
rtthread-realview.elf:     file format elf32-littlearm


Disassembly of section .text:

70000000 <system_vectors>:
.section .vectors, "ax"
.code 32

.globl system_vectors
system_vectors:
    ldr pc, _vector_reset
70000000:	e59ff018 	ldr	pc, [pc, #24]	; 70000020 <_vector_reset>
    ldr pc, _vector_undef
70000004:	e59ff018 	ldr	pc, [pc, #24]	; 70000024 <_vector_undef>
    ldr pc, _vector_swi
70000008:	e59ff018 	ldr	pc, [pc, #24]	; 70000028 <_vector_swi>
    ldr pc, _vector_pabt
7000000c:	e59ff018 	ldr	pc, [pc, #24]	; 7000002c <_vector_pabt>
    ldr pc, _vector_dabt
70000010:	e59ff018 	ldr	pc, [pc, #24]	; 70000030 <_vector_dabt>
    ldr pc, _vector_resv
70000014:	e59ff018 	ldr	pc, [pc, #24]	; 70000034 <_vector_resv>
    ldr pc, _vector_irq
70000018:	e59ff018 	ldr	pc, [pc, #24]	; 70000038 <_vector_irq>
    ldr pc, _vector_fiq
7000001c:	e59ff018 	ldr	pc, [pc, #24]	; 7000003c <_vector_fiq>

70000020 <_vector_reset>:
70000020:	7000e3a0 	.word	0x7000e3a0

70000024 <_vector_undef>:
70000024:	70023da0 	.word	0x70023da0

70000028 <_vector_swi>:
70000028:	70023d60 	.word	0x70023d60

7000002c <_vector_pabt>:
7000002c:	70023de0 	.word	0x70023de0

70000030 <_vector_dabt>:
70000030:	70023e20 	.word	0x70023e20

70000034 <_vector_resv>:
70000034:	70023e60 	.word	0x70023e60

70000038 <_vector_irq>:
70000038:	70023ce0 	.word	0x70023ce0

7000003c <_vector_fiq>:
7000003c:	70023cc0 	.word	0x70023cc0

70000040 <init_thread>:

#include <rtthread.h>
#include <components.h>

void init_thread(void* parameter)
{
70000040:	e92d4800 	push	{fp, lr}
70000044:	e28db004 	add	fp, sp, #4
70000048:	e24dd008 	sub	sp, sp, #8
7000004c:	e50b0008 	str	r0, [fp, #-8]
    rt_components_init();
70000050:	eb00020b 	bl	70000884 <rt_components_init>
}
70000054:	e24bd004 	sub	sp, fp, #4
70000058:	e8bd8800 	pop	{fp, pc}

7000005c <rt_application_init>:

int rt_application_init()
{
7000005c:	e92d4800 	push	{fp, lr}
70000060:	e28db004 	add	fp, sp, #4
70000064:	e24dd010 	sub	sp, sp, #16
    rt_thread_t tid;

    tid = rt_thread_create("init", init_thread, RT_NULL, 
70000068:	e3a0300a 	mov	r3, #10
7000006c:	e58d3000 	str	r3, [sp]
70000070:	e3a0300a 	mov	r3, #10
70000074:	e58d3004 	str	r3, [sp, #4]
70000078:	e30600f4 	movw	r0, #24820	; 0x60f4
7000007c:	e3470002 	movt	r0, #28674	; 0x7002
70000080:	e3001040 	movw	r1, #64	; 0x40
70000084:	e3471000 	movt	r1, #28672	; 0x7000
70000088:	e3a02000 	mov	r2, #0
7000008c:	e3a03b01 	mov	r3, #1024	; 0x400
70000090:	eb0029e1 	bl	7000a81c <rt_thread_create>
70000094:	e50b0008 	str	r0, [fp, #-8]
        1024, RT_THREAD_PRIORITY_MAX/3, 10);
    if (tid != RT_NULL) rt_thread_startup(tid);
70000098:	e51b3008 	ldr	r3, [fp, #-8]
7000009c:	e3530000 	cmp	r3, #0
700000a0:	0a000001 	beq	700000ac <rt_application_init+0x50>
700000a4:	e51b0008 	ldr	r0, [fp, #-8]
700000a8:	eb002939 	bl	7000a594 <rt_thread_startup>

    return 0;
700000ac:	e3a03000 	mov	r3, #0
}
700000b0:	e1a00003 	mov	r0, r3
700000b4:	e24bd004 	sub	sp, fp, #4
700000b8:	e8bd8800 	pop	{fp, pc}

700000bc <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
700000bc:	e92d4800 	push	{fp, lr}
700000c0:	e28db004 	add	fp, sp, #4
    /* initialzie hardware interrupt */
    rt_hw_interrupt_init();
700000c4:	eb003664 	bl	7000da5c <rt_hw_interrupt_init>

    /* initialize board */
    rt_hw_board_init();
700000c8:	eb000055 	bl	70000224 <rt_hw_board_init>

    /* show RT-Thread version */
    rt_show_version();
700000cc:	eb0019f3 	bl	700068a0 <rt_show_version>

    /* initialize memory system */
#ifdef RT_USING_HEAP
    rt_system_heap_init(HEAP_BEGIN, HEAP_END);
700000d0:	e30b087c 	movw	r0, #47228	; 0xb87c
700000d4:	e3470002 	movt	r0, #28674	; 0x7002
700000d8:	e3a01000 	mov	r1, #0
700000dc:	e3471080 	movt	r1, #28800	; 0x7080
700000e0:	eb001f5d 	bl	70007e5c <rt_system_heap_init>
#endif

    /* initialize scheduler system */
    rt_system_scheduler_init();
700000e4:	eb002688 	bl	70009b0c <rt_system_scheduler_init>

    /* initialize timer and soft timer thread */
    rt_system_timer_init();
700000e8:	eb002f5e 	bl	7000be68 <rt_system_timer_init>
    rt_system_timer_thread_init();
700000ec:	eb002f72 	bl	7000bebc <rt_system_timer_thread_init>

    /* initialize application */
    rt_application_init();
700000f0:	ebffffd9 	bl	7000005c <rt_application_init>

    /* initialize idle thread */
    rt_thread_idle_init();
700000f4:	eb000567 	bl	70001698 <rt_thread_idle_init>

    /* start scheduler */
    rt_system_scheduler_start();
700000f8:	eb0026a4 	bl	70009b90 <rt_system_scheduler_start>

    /* never reach here */
    return ;
700000fc:	e1a00000 	nop			; (mov r0, r0)
}
70000100:	e8bd8800 	pop	{fp, pc}

70000104 <main>:

int main(void)
{
70000104:	e92d4800 	push	{fp, lr}
70000108:	e28db004 	add	fp, sp, #4
    /* disable interrupt first */
    rt_hw_interrupt_disable();
7000010c:	eb00384d 	bl	7000e248 <rt_hw_interrupt_disable>

    /* invoke rtthread_startup */
    rtthread_startup();
70000110:	ebffffe9 	bl	700000bc <rtthread_startup>

    return 0;
70000114:	e3a03000 	mov	r3, #0
}
70000118:	e1a00003 	mov	r0, r3
7000011c:	e8bd8800 	pop	{fp, pc}

70000120 <rt_hw_timer_ack>:
#else
#define TIMER_HW_BASE                  REALVIEW_TIMER2_3_BASE
#endif

void rt_hw_timer_ack(void)
{
70000120:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70000124:	e28db000 	add	fp, sp, #0
    /* clear interrupt */
    TIMER_INTCLR(TIMER_HW_BASE) = 0x01;
70000128:	e302300c 	movw	r3, #8204	; 0x200c
7000012c:	e3413001 	movt	r3, #4097	; 0x1001
70000130:	e3a02001 	mov	r2, #1
70000134:	e5832000 	str	r2, [r3]
}
70000138:	e24bd000 	sub	sp, fp, #0
7000013c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70000140:	e12fff1e 	bx	lr

70000144 <rt_hw_timer_isr>:

static void rt_hw_timer_isr(int vector, void *param)
{
70000144:	e92d4800 	push	{fp, lr}
70000148:	e28db004 	add	fp, sp, #4
7000014c:	e24dd008 	sub	sp, sp, #8
70000150:	e50b0008 	str	r0, [fp, #-8]
70000154:	e50b100c 	str	r1, [fp, #-12]
    rt_tick_increase();
70000158:	eb000172 	bl	70000728 <rt_tick_increase>

    rt_hw_timer_ack();
7000015c:	ebffffef 	bl	70000120 <rt_hw_timer_ack>
}
70000160:	e24bd004 	sub	sp, fp, #4
70000164:	e8bd8800 	pop	{fp, pc}

70000168 <rt_hw_timer_init>:

int rt_hw_timer_init(void)
{
70000168:	e92d4800 	push	{fp, lr}
7000016c:	e28db004 	add	fp, sp, #4
70000170:	e24dd008 	sub	sp, sp, #8
        __REG32(sys_ctrl) |= REALVIEW_REFCLK;
    }

    timer_hw_base = vmm_find_iomap("TIMER");
#else
    SYS_CTRL |= REALVIEW_REFCLK;
70000174:	e3a03a0a 	mov	r3, #40960	; 0xa000
70000178:	e3413001 	movt	r3, #4097	; 0x1001
7000017c:	e3a02a0a 	mov	r2, #40960	; 0xa000
70000180:	e3412001 	movt	r2, #4097	; 0x1001
70000184:	e5922000 	ldr	r2, [r2]
70000188:	e5832000 	str	r2, [r3]
#endif

    /* Setup Timer0 for generating irq */
    val = TIMER_CTRL(TIMER_HW_BASE);
7000018c:	e3023008 	movw	r3, #8200	; 0x2008
70000190:	e3413001 	movt	r3, #4097	; 0x1001
70000194:	e5933000 	ldr	r3, [r3]
70000198:	e50b3008 	str	r3, [fp, #-8]
    val &= ~TIMER_CTRL_ENABLE;
7000019c:	e51b3008 	ldr	r3, [fp, #-8]
700001a0:	e3c33080 	bic	r3, r3, #128	; 0x80
700001a4:	e50b3008 	str	r3, [fp, #-8]
    val |= (TIMER_CTRL_32BIT | TIMER_CTRL_PERIODIC | TIMER_CTRL_IE);
700001a8:	e51b3008 	ldr	r3, [fp, #-8]
700001ac:	e3833062 	orr	r3, r3, #98	; 0x62
700001b0:	e50b3008 	str	r3, [fp, #-8]
    TIMER_CTRL(TIMER_HW_BASE) = val;
700001b4:	e3023008 	movw	r3, #8200	; 0x2008
700001b8:	e3413001 	movt	r3, #4097	; 0x1001
700001bc:	e51b2008 	ldr	r2, [fp, #-8]
700001c0:	e5832000 	str	r2, [r3]

    TIMER_LOAD(TIMER_HW_BASE) = 1000;
700001c4:	e3a03a02 	mov	r3, #8192	; 0x2000
700001c8:	e3413001 	movt	r3, #4097	; 0x1001
700001cc:	e3a02ffa 	mov	r2, #1000	; 0x3e8
700001d0:	e5832000 	str	r2, [r3]

    /* enable timer */
    TIMER_CTRL(TIMER_HW_BASE) |= TIMER_CTRL_ENABLE;
700001d4:	e3023008 	movw	r3, #8200	; 0x2008
700001d8:	e3413001 	movt	r3, #4097	; 0x1001
700001dc:	e3022008 	movw	r2, #8200	; 0x2008
700001e0:	e3412001 	movt	r2, #4097	; 0x1001
700001e4:	e5922000 	ldr	r2, [r2]
700001e8:	e3822080 	orr	r2, r2, #128	; 0x80
700001ec:	e5832000 	str	r2, [r3]

    rt_hw_interrupt_install(IRQ_PBA8_TIMER2_3, rt_hw_timer_isr, RT_NULL, "tick");
700001f0:	e3a00025 	mov	r0, #37	; 0x25
700001f4:	e3001144 	movw	r1, #324	; 0x144
700001f8:	e3471000 	movt	r1, #28672	; 0x7000
700001fc:	e3a02000 	mov	r2, #0
70000200:	e30630fc 	movw	r3, #24828	; 0x60fc
70000204:	e3473002 	movt	r3, #28674	; 0x7002
70000208:	eb00364c 	bl	7000db40 <rt_hw_interrupt_install>
    rt_hw_interrupt_umask(IRQ_PBA8_TIMER2_3);
7000020c:	e3a00025 	mov	r0, #37	; 0x25
70000210:	eb003641 	bl	7000db1c <rt_hw_interrupt_umask>

    return 0;
70000214:	e3a03000 	mov	r3, #0
}
70000218:	e1a00003 	mov	r0, r3
7000021c:	e24bd004 	sub	sp, fp, #4
70000220:	e8bd8800 	pop	{fp, pc}

70000224 <rt_hw_board_init>:

/**
 * This function will initialize beaglebone board
 */
void rt_hw_board_init(void)
{
70000224:	e92d4800 	push	{fp, lr}
70000228:	e28db004 	add	fp, sp, #4
    rt_components_board_init();
7000022c:	eb000180 	bl	70000834 <rt_components_board_init>
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
70000230:	e3060104 	movw	r0, #24836	; 0x6104
70000234:	e3470002 	movt	r0, #28674	; 0x7002
70000238:	eb001d40 	bl	70007740 <rt_console_set_device>
}
7000023c:	e8bd8800 	pop	{fp, pc}

70000240 <rt_hw_uart_isr>:
#define UARTIMSC_TXIM   0x20
#define UARTICR_RXIC    0x10
#define UARTICR_TXIC    0x20

static void rt_hw_uart_isr(int irqno, void *param)
{
70000240:	e92d4800 	push	{fp, lr}
70000244:	e28db004 	add	fp, sp, #4
70000248:	e24dd010 	sub	sp, sp, #16
7000024c:	e50b0010 	str	r0, [fp, #-16]
70000250:	e50b1014 	str	r1, [fp, #-20]
    struct rt_serial_device *serial = (struct rt_serial_device *)param;
70000254:	e51b3014 	ldr	r3, [fp, #-20]
70000258:	e50b3008 	str	r3, [fp, #-8]

    rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
7000025c:	e51b0008 	ldr	r0, [fp, #-8]
70000260:	e3a01001 	mov	r1, #1
70000264:	eb0089d5 	bl	700229c0 <rt_hw_serial_isr>
}
70000268:	e24bd004 	sub	sp, fp, #4
7000026c:	e8bd8800 	pop	{fp, pc}

70000270 <uart_configure>:

static rt_err_t uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
70000270:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70000274:	e28db000 	add	fp, sp, #0
70000278:	e24dd00c 	sub	sp, sp, #12
7000027c:	e50b0008 	str	r0, [fp, #-8]
70000280:	e50b100c 	str	r1, [fp, #-12]
    return RT_EOK;
70000284:	e3a03000 	mov	r3, #0
}
70000288:	e1a00003 	mov	r0, r3
7000028c:	e24bd000 	sub	sp, fp, #0
70000290:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70000294:	e12fff1e 	bx	lr

70000298 <uart_control>:

static rt_err_t uart_control(struct rt_serial_device *serial, int cmd, void *arg)
{
70000298:	e92d4800 	push	{fp, lr}
7000029c:	e28db004 	add	fp, sp, #4
700002a0:	e24dd018 	sub	sp, sp, #24
700002a4:	e50b0010 	str	r0, [fp, #-16]
700002a8:	e50b1014 	str	r1, [fp, #-20]
700002ac:	e50b2018 	str	r2, [fp, #-24]
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
700002b0:	e51b3010 	ldr	r3, [fp, #-16]
700002b4:	e3530000 	cmp	r3, #0
700002b8:	1a00001d 	bne	70000334 <uart_control+0x9c>
700002bc:	e3a03000 	mov	r3, #0
700002c0:	e54b3009 	strb	r3, [fp, #-9]
700002c4:	e30a3b74 	movw	r3, #43892	; 0xab74
700002c8:	e3473002 	movt	r3, #28674	; 0x7002
700002cc:	e5933000 	ldr	r3, [r3]
700002d0:	e3530000 	cmp	r3, #0
700002d4:	1a00000d 	bne	70000310 <uart_control+0x78>
700002d8:	e306010c 	movw	r0, #24844	; 0x610c
700002dc:	e3470002 	movt	r0, #28674	; 0x7002
700002e0:	e306112c 	movw	r1, #24876	; 0x612c
700002e4:	e3471002 	movt	r1, #28674	; 0x7002
700002e8:	e3062164 	movw	r2, #24932	; 0x6164
700002ec:	e3472002 	movt	r2, #28674	; 0x7002
700002f0:	e3a03049 	mov	r3, #73	; 0x49
700002f4:	eb001d3e 	bl	700077f4 <rt_kprintf>
700002f8:	e1a00000 	nop			; (mov r0, r0)
700002fc:	e55b3009 	ldrb	r3, [fp, #-9]
70000300:	e6ef3073 	uxtb	r3, r3
70000304:	e3530000 	cmp	r3, #0
70000308:	0afffffb 	beq	700002fc <uart_control+0x64>
7000030c:	ea000008 	b	70000334 <uart_control+0x9c>
70000310:	e30a3b74 	movw	r3, #43892	; 0xab74
70000314:	e3473002 	movt	r3, #28674	; 0x7002
70000318:	e5933000 	ldr	r3, [r3]
7000031c:	e306012c 	movw	r0, #24876	; 0x612c
70000320:	e3470002 	movt	r0, #28674	; 0x7002
70000324:	e3061164 	movw	r1, #24932	; 0x6164
70000328:	e3471002 	movt	r1, #28674	; 0x7002
7000032c:	e3a02049 	mov	r2, #73	; 0x49
70000330:	e12fff33 	blx	r3
    uart = (struct hw_uart_device *)serial->parent.user_data;
70000334:	e51b3010 	ldr	r3, [fp, #-16]
70000338:	e5933038 	ldr	r3, [r3, #56]	; 0x38
7000033c:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
70000340:	e51b3014 	ldr	r3, [fp, #-20]
70000344:	e3530010 	cmp	r3, #16
70000348:	0a00000b 	beq	7000037c <uart_control+0xe4>
7000034c:	e3530011 	cmp	r3, #17
70000350:	1a000020 	bne	700003d8 <uart_control+0x140>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        UART_IMSC(uart->hw_base) &= ~UARTIMSC_RXIM;
70000354:	e51b3008 	ldr	r3, [fp, #-8]
70000358:	e5933000 	ldr	r3, [r3]
7000035c:	e2833038 	add	r3, r3, #56	; 0x38
70000360:	e51b2008 	ldr	r2, [fp, #-8]
70000364:	e5922000 	ldr	r2, [r2]
70000368:	e2822038 	add	r2, r2, #56	; 0x38
7000036c:	e5922000 	ldr	r2, [r2]
70000370:	e3c22010 	bic	r2, r2, #16
70000374:	e5832000 	str	r2, [r3]
        break;
70000378:	ea000016 	b	700003d8 <uart_control+0x140>

    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        UART_IMSC(uart->hw_base) |= UARTIMSC_RXIM;
7000037c:	e51b3008 	ldr	r3, [fp, #-8]
70000380:	e5933000 	ldr	r3, [r3]
70000384:	e2833038 	add	r3, r3, #56	; 0x38
70000388:	e51b2008 	ldr	r2, [fp, #-8]
7000038c:	e5922000 	ldr	r2, [r2]
70000390:	e2822038 	add	r2, r2, #56	; 0x38
70000394:	e5922000 	ldr	r2, [r2]
70000398:	e3822010 	orr	r2, r2, #16
7000039c:	e5832000 	str	r2, [r3]
        rt_hw_interrupt_install(uart->irqno, rt_hw_uart_isr, serial, "uart");
700003a0:	e51b3008 	ldr	r3, [fp, #-8]
700003a4:	e5933004 	ldr	r3, [r3, #4]
700003a8:	e1a00003 	mov	r0, r3
700003ac:	e3001240 	movw	r1, #576	; 0x240
700003b0:	e3471000 	movt	r1, #28672	; 0x7000
700003b4:	e51b2010 	ldr	r2, [fp, #-16]
700003b8:	e3063140 	movw	r3, #24896	; 0x6140
700003bc:	e3473002 	movt	r3, #28674	; 0x7002
700003c0:	eb0035de 	bl	7000db40 <rt_hw_interrupt_install>
        rt_hw_interrupt_umask(uart->irqno);
700003c4:	e51b3008 	ldr	r3, [fp, #-8]
700003c8:	e5933004 	ldr	r3, [r3, #4]
700003cc:	e1a00003 	mov	r0, r3
700003d0:	eb0035d1 	bl	7000db1c <rt_hw_interrupt_umask>
        break;
700003d4:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
700003d8:	e3a03000 	mov	r3, #0
}
700003dc:	e1a00003 	mov	r0, r3
700003e0:	e24bd004 	sub	sp, fp, #4
700003e4:	e8bd8800 	pop	{fp, pc}

700003e8 <uart_putc>:

static int uart_putc(struct rt_serial_device *serial, char c)
{
700003e8:	e92d4800 	push	{fp, lr}
700003ec:	e28db004 	add	fp, sp, #4
700003f0:	e24dd010 	sub	sp, sp, #16
700003f4:	e50b0010 	str	r0, [fp, #-16]
700003f8:	e1a03001 	mov	r3, r1
700003fc:	e54b3011 	strb	r3, [fp, #-17]
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
70000400:	e51b3010 	ldr	r3, [fp, #-16]
70000404:	e3530000 	cmp	r3, #0
70000408:	1a00001d 	bne	70000484 <uart_putc+0x9c>
7000040c:	e3a03000 	mov	r3, #0
70000410:	e54b3009 	strb	r3, [fp, #-9]
70000414:	e30a3b74 	movw	r3, #43892	; 0xab74
70000418:	e3473002 	movt	r3, #28674	; 0x7002
7000041c:	e5933000 	ldr	r3, [r3]
70000420:	e3530000 	cmp	r3, #0
70000424:	1a00000d 	bne	70000460 <uart_putc+0x78>
70000428:	e306010c 	movw	r0, #24844	; 0x610c
7000042c:	e3470002 	movt	r0, #28674	; 0x7002
70000430:	e306112c 	movw	r1, #24876	; 0x612c
70000434:	e3471002 	movt	r1, #28674	; 0x7002
70000438:	e3062174 	movw	r2, #24948	; 0x6174
7000043c:	e3472002 	movt	r2, #28674	; 0x7002
70000440:	e3a03062 	mov	r3, #98	; 0x62
70000444:	eb001cea 	bl	700077f4 <rt_kprintf>
70000448:	e1a00000 	nop			; (mov r0, r0)
7000044c:	e55b3009 	ldrb	r3, [fp, #-9]
70000450:	e6ef3073 	uxtb	r3, r3
70000454:	e3530000 	cmp	r3, #0
70000458:	0afffffb 	beq	7000044c <uart_putc+0x64>
7000045c:	ea000008 	b	70000484 <uart_putc+0x9c>
70000460:	e30a3b74 	movw	r3, #43892	; 0xab74
70000464:	e3473002 	movt	r3, #28674	; 0x7002
70000468:	e5933000 	ldr	r3, [r3]
7000046c:	e306012c 	movw	r0, #24876	; 0x612c
70000470:	e3470002 	movt	r0, #28674	; 0x7002
70000474:	e3061174 	movw	r1, #24948	; 0x6174
70000478:	e3471002 	movt	r1, #28674	; 0x7002
7000047c:	e3a02062 	mov	r2, #98	; 0x62
70000480:	e12fff33 	blx	r3
    uart = (struct hw_uart_device *)serial->parent.user_data;
70000484:	e51b3010 	ldr	r3, [fp, #-16]
70000488:	e5933038 	ldr	r3, [r3, #56]	; 0x38
7000048c:	e50b3008 	str	r3, [fp, #-8]

    while (UART_FR(uart->hw_base) & UARTFR_TXFF);
70000490:	e1a00000 	nop			; (mov r0, r0)
70000494:	e51b3008 	ldr	r3, [fp, #-8]
70000498:	e5933000 	ldr	r3, [r3]
7000049c:	e2833018 	add	r3, r3, #24
700004a0:	e5933000 	ldr	r3, [r3]
700004a4:	e2033020 	and	r3, r3, #32
700004a8:	e3530000 	cmp	r3, #0
700004ac:	1afffff8 	bne	70000494 <uart_putc+0xac>
    UART_DR(uart->hw_base) = c;
700004b0:	e51b3008 	ldr	r3, [fp, #-8]
700004b4:	e5933000 	ldr	r3, [r3]
700004b8:	e55b2011 	ldrb	r2, [fp, #-17]
700004bc:	e5832000 	str	r2, [r3]

    return 1;
700004c0:	e3a03001 	mov	r3, #1
}
700004c4:	e1a00003 	mov	r0, r3
700004c8:	e24bd004 	sub	sp, fp, #4
700004cc:	e8bd8800 	pop	{fp, pc}

700004d0 <uart_getc>:

static int uart_getc(struct rt_serial_device *serial)
{
700004d0:	e92d4800 	push	{fp, lr}
700004d4:	e28db004 	add	fp, sp, #4
700004d8:	e24dd018 	sub	sp, sp, #24
700004dc:	e50b0018 	str	r0, [fp, #-24]
    int ch;
    struct hw_uart_device *uart;

    RT_ASSERT(serial != RT_NULL);
700004e0:	e51b3018 	ldr	r3, [fp, #-24]
700004e4:	e3530000 	cmp	r3, #0
700004e8:	1a00001d 	bne	70000564 <uart_getc+0x94>
700004ec:	e3a03000 	mov	r3, #0
700004f0:	e54b300d 	strb	r3, [fp, #-13]
700004f4:	e30a3b74 	movw	r3, #43892	; 0xab74
700004f8:	e3473002 	movt	r3, #28674	; 0x7002
700004fc:	e5933000 	ldr	r3, [r3]
70000500:	e3530000 	cmp	r3, #0
70000504:	1a00000d 	bne	70000540 <uart_getc+0x70>
70000508:	e306010c 	movw	r0, #24844	; 0x610c
7000050c:	e3470002 	movt	r0, #28674	; 0x7002
70000510:	e306112c 	movw	r1, #24876	; 0x612c
70000514:	e3471002 	movt	r1, #28674	; 0x7002
70000518:	e3062180 	movw	r2, #24960	; 0x6180
7000051c:	e3472002 	movt	r2, #28674	; 0x7002
70000520:	e3a03070 	mov	r3, #112	; 0x70
70000524:	eb001cb2 	bl	700077f4 <rt_kprintf>
70000528:	e1a00000 	nop			; (mov r0, r0)
7000052c:	e55b300d 	ldrb	r3, [fp, #-13]
70000530:	e6ef3073 	uxtb	r3, r3
70000534:	e3530000 	cmp	r3, #0
70000538:	0afffffb 	beq	7000052c <uart_getc+0x5c>
7000053c:	ea000008 	b	70000564 <uart_getc+0x94>
70000540:	e30a3b74 	movw	r3, #43892	; 0xab74
70000544:	e3473002 	movt	r3, #28674	; 0x7002
70000548:	e5933000 	ldr	r3, [r3]
7000054c:	e306012c 	movw	r0, #24876	; 0x612c
70000550:	e3470002 	movt	r0, #28674	; 0x7002
70000554:	e3061180 	movw	r1, #24960	; 0x6180
70000558:	e3471002 	movt	r1, #28674	; 0x7002
7000055c:	e3a02070 	mov	r2, #112	; 0x70
70000560:	e12fff33 	blx	r3
    uart = (struct hw_uart_device *)serial->parent.user_data;
70000564:	e51b3018 	ldr	r3, [fp, #-24]
70000568:	e5933038 	ldr	r3, [r3, #56]	; 0x38
7000056c:	e50b300c 	str	r3, [fp, #-12]

    ch = -1;
70000570:	e3e03000 	mvn	r3, #0
70000574:	e50b3008 	str	r3, [fp, #-8]
    if (!(UART_FR(uart->hw_base) & UARTFR_RXFE))
70000578:	e51b300c 	ldr	r3, [fp, #-12]
7000057c:	e5933000 	ldr	r3, [r3]
70000580:	e2833018 	add	r3, r3, #24
70000584:	e5933000 	ldr	r3, [r3]
70000588:	e2033010 	and	r3, r3, #16
7000058c:	e3530000 	cmp	r3, #0
70000590:	1a000004 	bne	700005a8 <uart_getc+0xd8>
    {
        ch = UART_DR(uart->hw_base) & 0xff;
70000594:	e51b300c 	ldr	r3, [fp, #-12]
70000598:	e5933000 	ldr	r3, [r3]
7000059c:	e5933000 	ldr	r3, [r3]
700005a0:	e6ef3073 	uxtb	r3, r3
700005a4:	e50b3008 	str	r3, [fp, #-8]
    }

    return ch;
700005a8:	e51b3008 	ldr	r3, [fp, #-8]
}
700005ac:	e1a00003 	mov	r0, r3
700005b0:	e24bd004 	sub	sp, fp, #4
700005b4:	e8bd8800 	pop	{fp, pc}

700005b8 <uart_isr_test>:
};
static struct rt_serial_device _serial1;
#endif

int uart_isr_test(void)
{
700005b8:	e92d4800 	push	{fp, lr}
700005bc:	e28db004 	add	fp, sp, #4
    return uart_getc(&_serial1);
700005c0:	e309054c 	movw	r0, #38220	; 0x954c
700005c4:	e3470002 	movt	r0, #28674	; 0x7002
700005c8:	ebffffc0 	bl	700004d0 <uart_getc>
700005cc:	e1a03000 	mov	r3, r0
}
700005d0:	e1a00003 	mov	r0, r3
700005d4:	e8bd8800 	pop	{fp, pc}

700005d8 <rt_hw_uart_init>:

int rt_hw_uart_init(void)
{
700005d8:	e92d4800 	push	{fp, lr}
700005dc:	e28db004 	add	fp, sp, #4
700005e0:	e24dd010 	sub	sp, sp, #16
    struct hw_uart_device *uart;
    struct serial_configure config;

    config.baud_rate = BAUD_RATE_115200;
700005e4:	e3a03cc2 	mov	r3, #49664	; 0xc200
700005e8:	e3403001 	movt	r3, #1
700005ec:	e50b3010 	str	r3, [fp, #-16]
    config.bit_order = BIT_ORDER_LSB;
700005f0:	e55b300b 	ldrb	r3, [fp, #-11]
700005f4:	e7c0301f 	bfc	r3, #0, #1
700005f8:	e54b300b 	strb	r3, [fp, #-11]
    config.data_bits = DATA_BITS_8;
700005fc:	e55b300c 	ldrb	r3, [fp, #-12]
70000600:	e3a02008 	mov	r2, #8
70000604:	e7c33012 	bfi	r3, r2, #0, #4
70000608:	e54b300c 	strb	r3, [fp, #-12]
    config.parity    = PARITY_NONE;
7000060c:	e55b300c 	ldrb	r3, [fp, #-12]
70000610:	e7c7331f 	bfc	r3, #6, #2
70000614:	e54b300c 	strb	r3, [fp, #-12]
    config.stop_bits = STOP_BITS_1;
70000618:	e55b300c 	ldrb	r3, [fp, #-12]
7000061c:	e7c5321f 	bfc	r3, #4, #2
70000620:	e54b300c 	strb	r3, [fp, #-12]
    config.invert    = NRZ_NORMAL;
70000624:	e55b300b 	ldrb	r3, [fp, #-11]
70000628:	e7c1309f 	bfc	r3, #1, #1
7000062c:	e54b300b 	strb	r3, [fp, #-11]
    config.bufsz     = RT_SERIAL_RB_BUFSZ;
70000630:	e51b300c 	ldr	r3, [fp, #-12]
70000634:	e3a02040 	mov	r2, #64	; 0x40
70000638:	e7d93512 	bfi	r3, r2, #10, #16
7000063c:	e50b300c 	str	r3, [fp, #-12]
    /* enable Rx and Tx of UART */
    UART_CR(uart->hw_base) = (1 << 0) | (1 << 8) | (1 << 9);
#endif

#ifdef RT_USING_UART1
    uart = &_uart1_device;
70000640:	e3083d80 	movw	r3, #36224	; 0x8d80
70000644:	e3473002 	movt	r3, #28674	; 0x7002
70000648:	e50b3008 	str	r3, [fp, #-8]
#ifdef RT_USING_VMM
    uart->hw_base = vmm_find_iomap("UART1");
#endif
    _serial1.ops = &_uart_ops;
7000064c:	e309354c 	movw	r3, #38220	; 0x954c
70000650:	e3473002 	movt	r3, #28674	; 0x7002
70000654:	e3062148 	movw	r2, #24904	; 0x6148
70000658:	e3472002 	movt	r2, #28674	; 0x7002
7000065c:	e583203c 	str	r2, [r3, #60]	; 0x3c
    _serial1.config = config;
70000660:	e309354c 	movw	r3, #38220	; 0x954c
70000664:	e3473002 	movt	r3, #28674	; 0x7002
70000668:	e2833040 	add	r3, r3, #64	; 0x40
7000066c:	e24b2010 	sub	r2, fp, #16
70000670:	e8920003 	ldm	r2, {r0, r1}
70000674:	e8830003 	stm	r3, {r0, r1}

    /* register UART1 device */
    rt_hw_serial_register(&_serial1, "uart1",
70000678:	e309054c 	movw	r0, #38220	; 0x954c
7000067c:	e3470002 	movt	r0, #28674	; 0x7002
70000680:	e306115c 	movw	r1, #24924	; 0x615c
70000684:	e3471002 	movt	r1, #28674	; 0x7002
70000688:	e3002103 	movw	r2, #259	; 0x103
7000068c:	e51b3008 	ldr	r3, [fp, #-8]
70000690:	eb008872 	bl	70022860 <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX, uart);
    /* enable Rx and Tx of UART */
    UART_CR(uart->hw_base) = (1 << 0) | (1 << 8) | (1 << 9);
70000694:	e51b3008 	ldr	r3, [fp, #-8]
70000698:	e5933000 	ldr	r3, [r3]
7000069c:	e2833030 	add	r3, r3, #48	; 0x30
700006a0:	e3002301 	movw	r2, #769	; 0x301
700006a4:	e5832000 	str	r2, [r3]
#endif

    return 0;
700006a8:	e3a03000 	mov	r3, #0
}
700006ac:	e1a00003 	mov	r0, r3
700006b0:	e24bd004 	sub	sp, fp, #4
700006b4:	e8bd8800 	pop	{fp, pc}

700006b8 <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
700006b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700006bc:	e28db000 	add	fp, sp, #0
}
700006c0:	e24bd000 	sub	sp, fp, #0
700006c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700006c8:	e12fff1e 	bx	lr

700006cc <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
700006cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700006d0:	e28db000 	add	fp, sp, #0
    /* return the global tick */
    return rt_tick;
700006d4:	e309359c 	movw	r3, #38300	; 0x959c
700006d8:	e3473002 	movt	r3, #28674	; 0x7002
700006dc:	e5933000 	ldr	r3, [r3]
}
700006e0:	e1a00003 	mov	r0, r3
700006e4:	e24bd000 	sub	sp, fp, #0
700006e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700006ec:	e12fff1e 	bx	lr

700006f0 <rt_tick_set>:

/**
 * This function will set current tick
 */
void rt_tick_set(rt_tick_t tick)
{
700006f0:	e92d4800 	push	{fp, lr}
700006f4:	e28db004 	add	fp, sp, #4
700006f8:	e24dd010 	sub	sp, sp, #16
700006fc:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
70000700:	eb0036d0 	bl	7000e248 <rt_hw_interrupt_disable>
70000704:	e50b0008 	str	r0, [fp, #-8]
    rt_tick = tick;
70000708:	e309359c 	movw	r3, #38300	; 0x959c
7000070c:	e3473002 	movt	r3, #28674	; 0x7002
70000710:	e51b2010 	ldr	r2, [fp, #-16]
70000714:	e5832000 	str	r2, [r3]
    rt_hw_interrupt_enable(level);
70000718:	e51b0008 	ldr	r0, [fp, #-8]
7000071c:	eb0036cc 	bl	7000e254 <rt_hw_interrupt_enable>
}
70000720:	e24bd004 	sub	sp, fp, #4
70000724:	e8bd8800 	pop	{fp, pc}

70000728 <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
70000728:	e92d4800 	push	{fp, lr}
7000072c:	e28db004 	add	fp, sp, #4
70000730:	e24dd008 	sub	sp, sp, #8
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
70000734:	e309359c 	movw	r3, #38300	; 0x959c
70000738:	e3473002 	movt	r3, #28674	; 0x7002
7000073c:	e5933000 	ldr	r3, [r3]
70000740:	e2832001 	add	r2, r3, #1
70000744:	e309359c 	movw	r3, #38300	; 0x959c
70000748:	e3473002 	movt	r3, #28674	; 0x7002
7000074c:	e5832000 	str	r2, [r3]

    /* check time slice */
    thread = rt_thread_self();
70000750:	eb002786 	bl	7000a570 <rt_thread_self>
70000754:	e50b0008 	str	r0, [fp, #-8]

    -- thread->remaining_tick;
70000758:	e51b3008 	ldr	r3, [fp, #-8]
7000075c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70000760:	e2432001 	sub	r2, r3, #1
70000764:	e51b3008 	ldr	r3, [fp, #-8]
70000768:	e5832044 	str	r2, [r3, #68]	; 0x44
    if (thread->remaining_tick == 0)
7000076c:	e51b3008 	ldr	r3, [fp, #-8]
70000770:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70000774:	e3530000 	cmp	r3, #0
70000778:	1a000004 	bne	70000790 <rt_tick_increase+0x68>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
7000077c:	e51b3008 	ldr	r3, [fp, #-8]
70000780:	e5932040 	ldr	r2, [r3, #64]	; 0x40
70000784:	e51b3008 	ldr	r3, [fp, #-8]
70000788:	e5832044 	str	r2, [r3, #68]	; 0x44

        /* yield */
        rt_thread_yield();
7000078c:	eb002889 	bl	7000a9b8 <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
70000790:	eb002d60 	bl	7000bd18 <rt_timer_check>
}
70000794:	e24bd004 	sub	sp, fp, #4
70000798:	e8bd8800 	pop	{fp, pc}

7000079c <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
7000079c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700007a0:	e28db000 	add	fp, sp, #0
700007a4:	e24dd00c 	sub	sp, sp, #12
700007a8:	e50b0008 	str	r0, [fp, #-8]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
700007ac:	e51b3008 	ldr	r3, [fp, #-8]
700007b0:	e3a02ffa 	mov	r2, #1000	; 0x3e8
700007b4:	e0030392 	mul	r3, r2, r3
700007b8:	e2832ff9 	add	r2, r3, #996	; 0x3e4
700007bc:	e2822003 	add	r2, r2, #3
700007c0:	e3043dd3 	movw	r3, #19923	; 0x4dd3
700007c4:	e3413062 	movt	r3, #4194	; 0x1062
700007c8:	e0831293 	umull	r1, r3, r3, r2
700007cc:	e1a03323 	lsr	r3, r3, #6
}
700007d0:	e1a00003 	mov	r0, r3
700007d4:	e24bd000 	sub	sp, fp, #0
700007d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700007dc:	e12fff1e 	bx	lr

700007e0 <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
700007e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700007e4:	e28db000 	add	fp, sp, #0
    return 0;
700007e8:	e3a03000 	mov	r3, #0
}
700007ec:	e1a00003 	mov	r0, r3
700007f0:	e24bd000 	sub	sp, fp, #0
700007f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700007f8:	e12fff1e 	bx	lr

700007fc <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
700007fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70000800:	e28db000 	add	fp, sp, #0
    return 0;
70000804:	e3a03000 	mov	r3, #0
}
70000808:	e1a00003 	mov	r0, r3
7000080c:	e24bd000 	sub	sp, fp, #0
70000810:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70000814:	e12fff1e 	bx	lr

70000818 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
70000818:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000081c:	e28db000 	add	fp, sp, #0
    return 0;
70000820:	e3a03000 	mov	r3, #0
}
70000824:	e1a00003 	mov	r0, r3
70000828:	e24bd000 	sub	sp, fp, #0
7000082c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70000830:	e12fff1e 	bx	lr

70000834 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
70000834:	e92d4800 	push	{fp, lr}
70000838:	e28db004 	add	fp, sp, #4
7000083c:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
70000840:	e30630d8 	movw	r3, #24792	; 0x60d8
70000844:	e3473002 	movt	r3, #28674	; 0x7002
70000848:	e50b3008 	str	r3, [fp, #-8]
7000084c:	ea000005 	b	70000868 <rt_components_board_init+0x34>
    {
        (*fn_ptr)();
70000850:	e51b3008 	ldr	r3, [fp, #-8]
70000854:	e5933000 	ldr	r3, [r3]
70000858:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
7000085c:	e51b3008 	ldr	r3, [fp, #-8]
70000860:	e2833004 	add	r3, r3, #4
70000864:	e50b3008 	str	r3, [fp, #-8]
70000868:	e51b2008 	ldr	r2, [fp, #-8]
7000086c:	e30630e4 	movw	r3, #24804	; 0x60e4
70000870:	e3473002 	movt	r3, #28674	; 0x7002
70000874:	e1520003 	cmp	r2, r3
70000878:	3afffff4 	bcc	70000850 <rt_components_board_init+0x1c>
    {
        (*fn_ptr)();
    }
#endif
}
7000087c:	e24bd004 	sub	sp, fp, #4
70000880:	e8bd8800 	pop	{fp, pc}

70000884 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
70000884:	e92d4800 	push	{fp, lr}
70000888:	e28db004 	add	fp, sp, #4
7000088c:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
70000890:	e30630e4 	movw	r3, #24804	; 0x60e4
70000894:	e3473002 	movt	r3, #28674	; 0x7002
70000898:	e50b3008 	str	r3, [fp, #-8]
7000089c:	ea000005 	b	700008b8 <rt_components_init+0x34>
    {
        (*fn_ptr)();
700008a0:	e51b3008 	ldr	r3, [fp, #-8]
700008a4:	e5933000 	ldr	r3, [r3]
700008a8:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
700008ac:	e51b3008 	ldr	r3, [fp, #-8]
700008b0:	e2833004 	add	r3, r3, #4
700008b4:	e50b3008 	str	r3, [fp, #-8]
700008b8:	e51b2008 	ldr	r2, [fp, #-8]
700008bc:	e30630f0 	movw	r3, #24816	; 0x60f0
700008c0:	e3473002 	movt	r3, #28674	; 0x7002
700008c4:	e1520003 	cmp	r2, r3
700008c8:	3afffff4 	bcc	700008a0 <rt_components_init+0x1c>
    {
        (*fn_ptr)();
    }
#endif
}
700008cc:	e24bd004 	sub	sp, fp, #4
700008d0:	e8bd8800 	pop	{fp, pc}

700008d4 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
700008d4:	e92d4800 	push	{fp, lr}
700008d8:	e28db004 	add	fp, sp, #4
700008dc:	e24dd010 	sub	sp, sp, #16
700008e0:	e50b0008 	str	r0, [fp, #-8]
700008e4:	e50b100c 	str	r1, [fp, #-12]
700008e8:	e1a03002 	mov	r3, r2
700008ec:	e14b30be 	strh	r3, [fp, #-14]
    if (dev == RT_NULL)
700008f0:	e51b3008 	ldr	r3, [fp, #-8]
700008f4:	e3530000 	cmp	r3, #0
700008f8:	1a000001 	bne	70000904 <rt_device_register+0x30>
        return -RT_ERROR;
700008fc:	e3e03000 	mvn	r3, #0
70000900:	ea000012 	b	70000950 <rt_device_register+0x7c>

    if (rt_device_find(name) != RT_NULL)
70000904:	e51b000c 	ldr	r0, [fp, #-12]
70000908:	eb000046 	bl	70000a28 <rt_device_find>
7000090c:	e1a03000 	mov	r3, r0
70000910:	e3530000 	cmp	r3, #0
70000914:	0a000001 	beq	70000920 <rt_device_register+0x4c>
        return -RT_ERROR;
70000918:	e3e03000 	mvn	r3, #0
7000091c:	ea00000b 	b	70000950 <rt_device_register+0x7c>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
70000920:	e51b3008 	ldr	r3, [fp, #-8]
70000924:	e1a00003 	mov	r0, r3
70000928:	e3a01007 	mov	r1, #7
7000092c:	e51b200c 	ldr	r2, [fp, #-12]
70000930:	eb00225e 	bl	700092b0 <rt_object_init>
    dev->flag = flags;
70000934:	e51b3008 	ldr	r3, [fp, #-8]
70000938:	e15b20be 	ldrh	r2, [fp, #-14]
7000093c:	e1c321b2 	strh	r2, [r3, #18]
    dev->ref_count = 0;
70000940:	e51b3008 	ldr	r3, [fp, #-8]
70000944:	e3a02000 	mov	r2, #0
70000948:	e5c32016 	strb	r2, [r3, #22]

    return RT_EOK;
7000094c:	e3a03000 	mov	r3, #0
}
70000950:	e1a00003 	mov	r0, r3
70000954:	e24bd004 	sub	sp, fp, #4
70000958:	e8bd8800 	pop	{fp, pc}

7000095c <rt_device_unregister>:
 * @param dev the pointer of device driver structure
 *
 * @return the error code, RT_EOK on successfully.
 */
rt_err_t rt_device_unregister(rt_device_t dev)
{
7000095c:	e92d4800 	push	{fp, lr}
70000960:	e28db004 	add	fp, sp, #4
70000964:	e24dd010 	sub	sp, sp, #16
70000968:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(dev != RT_NULL);
7000096c:	e51b3010 	ldr	r3, [fp, #-16]
70000970:	e3530000 	cmp	r3, #0
70000974:	1a00001d 	bne	700009f0 <rt_device_unregister+0x94>
70000978:	e3a03000 	mov	r3, #0
7000097c:	e54b3005 	strb	r3, [fp, #-5]
70000980:	e30a3b74 	movw	r3, #43892	; 0xab74
70000984:	e3473002 	movt	r3, #28674	; 0x7002
70000988:	e5933000 	ldr	r3, [r3]
7000098c:	e3530000 	cmp	r3, #0
70000990:	1a00000d 	bne	700009cc <rt_device_unregister+0x70>
70000994:	e306018c 	movw	r0, #24972	; 0x618c
70000998:	e3470002 	movt	r0, #28674	; 0x7002
7000099c:	e30611ac 	movw	r1, #25004	; 0x61ac
700009a0:	e3471002 	movt	r1, #28674	; 0x7002
700009a4:	e3062208 	movw	r2, #25096	; 0x6208
700009a8:	e3472002 	movt	r2, #28674	; 0x7002
700009ac:	e3a03046 	mov	r3, #70	; 0x46
700009b0:	eb001b8f 	bl	700077f4 <rt_kprintf>
700009b4:	e1a00000 	nop			; (mov r0, r0)
700009b8:	e55b3005 	ldrb	r3, [fp, #-5]
700009bc:	e6ef3073 	uxtb	r3, r3
700009c0:	e3530000 	cmp	r3, #0
700009c4:	0afffffb 	beq	700009b8 <rt_device_unregister+0x5c>
700009c8:	ea000008 	b	700009f0 <rt_device_unregister+0x94>
700009cc:	e30a3b74 	movw	r3, #43892	; 0xab74
700009d0:	e3473002 	movt	r3, #28674	; 0x7002
700009d4:	e5933000 	ldr	r3, [r3]
700009d8:	e30601ac 	movw	r0, #25004	; 0x61ac
700009dc:	e3470002 	movt	r0, #28674	; 0x7002
700009e0:	e3061208 	movw	r1, #25096	; 0x6208
700009e4:	e3471002 	movt	r1, #28674	; 0x7002
700009e8:	e3a02046 	mov	r2, #70	; 0x46
700009ec:	e12fff33 	blx	r3

    rt_object_detach(&(dev->parent));
700009f0:	e51b3010 	ldr	r3, [fp, #-16]
700009f4:	e1a00003 	mov	r0, r3
700009f8:	eb00225b 	bl	7000936c <rt_object_detach>

    return RT_EOK;
700009fc:	e3a03000 	mov	r3, #0
}
70000a00:	e1a00003 	mov	r0, r3
70000a04:	e24bd004 	sub	sp, fp, #4
70000a08:	e8bd8800 	pop	{fp, pc}

70000a0c <rt_device_init_all>:
 *
 * @deprecated since 1.2.x, this function is not needed because the initialization 
 *             of a device is performed when applicaiton opens it.
 */
rt_err_t rt_device_init_all(void)
{
70000a0c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70000a10:	e28db000 	add	fp, sp, #0
    return RT_EOK;
70000a14:	e3a03000 	mov	r3, #0
}
70000a18:	e1a00003 	mov	r0, r3
70000a1c:	e24bd000 	sub	sp, fp, #0
70000a20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70000a24:	e12fff1e 	bx	lr

70000a28 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
70000a28:	e92d4800 	push	{fp, lr}
70000a2c:	e28db004 	add	fp, sp, #4
70000a30:	e24dd018 	sub	sp, sp, #24
70000a34:	e50b0018 	str	r0, [fp, #-24]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
70000a38:	eb0026cc 	bl	7000a570 <rt_thread_self>
70000a3c:	e1a03000 	mov	r3, r0
70000a40:	e3530000 	cmp	r3, #0
70000a44:	0a000000 	beq	70000a4c <rt_device_find+0x24>
        rt_enter_critical();
70000a48:	eb00253a 	bl	70009f38 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
70000a4c:	e59f309c 	ldr	r3, [pc, #156]	; 70000af0 <rt_device_find+0xc8>
70000a50:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
70000a54:	e51b300c 	ldr	r3, [fp, #-12]
70000a58:	e5933004 	ldr	r3, [r3, #4]
70000a5c:	e50b3008 	str	r3, [fp, #-8]
70000a60:	ea000014 	b	70000ab8 <rt_device_find+0x90>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
70000a64:	e51b3008 	ldr	r3, [fp, #-8]
70000a68:	e2433008 	sub	r3, r3, #8
70000a6c:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
70000a70:	e51b3010 	ldr	r3, [fp, #-16]
70000a74:	e1a00003 	mov	r0, r3
70000a78:	e51b1018 	ldr	r1, [fp, #-24]
70000a7c:	e3a02006 	mov	r2, #6
70000a80:	eb001714 	bl	700066d8 <rt_strncmp>
70000a84:	e1a03000 	mov	r3, r0
70000a88:	e3530000 	cmp	r3, #0
70000a8c:	1a000006 	bne	70000aac <rt_device_find+0x84>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
70000a90:	eb0026b6 	bl	7000a570 <rt_thread_self>
70000a94:	e1a03000 	mov	r3, r0
70000a98:	e3530000 	cmp	r3, #0
70000a9c:	0a000000 	beq	70000aa4 <rt_device_find+0x7c>
                rt_exit_critical();
70000aa0:	eb002534 	bl	70009f78 <rt_exit_critical>

            return (rt_device_t)object;
70000aa4:	e51b3010 	ldr	r3, [fp, #-16]
70000aa8:	ea00000d 	b	70000ae4 <rt_device_find+0xbc>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
70000aac:	e51b3008 	ldr	r3, [fp, #-8]
70000ab0:	e5933000 	ldr	r3, [r3]
70000ab4:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
70000ab8:	e51b300c 	ldr	r3, [fp, #-12]
70000abc:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
70000ac0:	e51b3008 	ldr	r3, [fp, #-8]
70000ac4:	e1520003 	cmp	r2, r3
70000ac8:	1affffe5 	bne	70000a64 <rt_device_find+0x3c>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
70000acc:	eb0026a7 	bl	7000a570 <rt_thread_self>
70000ad0:	e1a03000 	mov	r3, r0
70000ad4:	e3530000 	cmp	r3, #0
70000ad8:	0a000000 	beq	70000ae0 <rt_device_find+0xb8>
        rt_exit_critical();
70000adc:	eb002525 	bl	70009f78 <rt_exit_critical>

    /* not found */
    return RT_NULL;
70000ae0:	e3a03000 	mov	r3, #0
}
70000ae4:	e1a00003 	mov	r0, r3
70000ae8:	e24bd004 	sub	sp, fp, #4
70000aec:	e8bd8800 	pop	{fp, pc}
70000af0:	70028df8 	.word	0x70028df8

70000af4 <rt_device_init>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_init(rt_device_t dev)
{
70000af4:	e92d4800 	push	{fp, lr}
70000af8:	e28db004 	add	fp, sp, #4
70000afc:	e24dd010 	sub	sp, sp, #16
70000b00:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
70000b04:	e3a03000 	mov	r3, #0
70000b08:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
70000b0c:	e51b3010 	ldr	r3, [fp, #-16]
70000b10:	e3530000 	cmp	r3, #0
70000b14:	1a00001d 	bne	70000b90 <rt_device_init+0x9c>
70000b18:	e3a03000 	mov	r3, #0
70000b1c:	e54b3009 	strb	r3, [fp, #-9]
70000b20:	e30a3b74 	movw	r3, #43892	; 0xab74
70000b24:	e3473002 	movt	r3, #28674	; 0x7002
70000b28:	e5933000 	ldr	r3, [r3]
70000b2c:	e3530000 	cmp	r3, #0
70000b30:	1a00000d 	bne	70000b6c <rt_device_init+0x78>
70000b34:	e306018c 	movw	r0, #24972	; 0x618c
70000b38:	e3470002 	movt	r0, #28674	; 0x7002
70000b3c:	e30611ac 	movw	r1, #25004	; 0x61ac
70000b40:	e3471002 	movt	r1, #28674	; 0x7002
70000b44:	e3062220 	movw	r2, #25120	; 0x6220
70000b48:	e3472002 	movt	r2, #28674	; 0x7002
70000b4c:	e3a03093 	mov	r3, #147	; 0x93
70000b50:	eb001b27 	bl	700077f4 <rt_kprintf>
70000b54:	e1a00000 	nop			; (mov r0, r0)
70000b58:	e55b3009 	ldrb	r3, [fp, #-9]
70000b5c:	e6ef3073 	uxtb	r3, r3
70000b60:	e3530000 	cmp	r3, #0
70000b64:	0afffffb 	beq	70000b58 <rt_device_init+0x64>
70000b68:	ea000008 	b	70000b90 <rt_device_init+0x9c>
70000b6c:	e30a3b74 	movw	r3, #43892	; 0xab74
70000b70:	e3473002 	movt	r3, #28674	; 0x7002
70000b74:	e5933000 	ldr	r3, [r3]
70000b78:	e30601ac 	movw	r0, #25004	; 0x61ac
70000b7c:	e3470002 	movt	r0, #28674	; 0x7002
70000b80:	e3061220 	movw	r1, #25120	; 0x6220
70000b84:	e3471002 	movt	r1, #28674	; 0x7002
70000b88:	e3a02093 	mov	r2, #147	; 0x93
70000b8c:	e12fff33 	blx	r3

    /* get device init handler */
    if (dev->init != RT_NULL)
70000b90:	e51b3010 	ldr	r3, [fp, #-16]
70000b94:	e5933020 	ldr	r3, [r3, #32]
70000b98:	e3530000 	cmp	r3, #0
70000b9c:	0a000019 	beq	70000c08 <rt_device_init+0x114>
    {
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
70000ba0:	e51b3010 	ldr	r3, [fp, #-16]
70000ba4:	e1d331b2 	ldrh	r3, [r3, #18]
70000ba8:	e2033010 	and	r3, r3, #16
70000bac:	e3530000 	cmp	r3, #0
70000bb0:	1a000014 	bne	70000c08 <rt_device_init+0x114>
        {
            result = dev->init(dev);
70000bb4:	e51b3010 	ldr	r3, [fp, #-16]
70000bb8:	e5933020 	ldr	r3, [r3, #32]
70000bbc:	e51b0010 	ldr	r0, [fp, #-16]
70000bc0:	e12fff33 	blx	r3
70000bc4:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
70000bc8:	e51b3008 	ldr	r3, [fp, #-8]
70000bcc:	e3530000 	cmp	r3, #0
70000bd0:	0a000006 	beq	70000bf0 <rt_device_init+0xfc>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
70000bd4:	e51b3010 	ldr	r3, [fp, #-16]
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
70000bd8:	e30601bc 	movw	r0, #25020	; 0x61bc
70000bdc:	e3470002 	movt	r0, #28674	; 0x7002
70000be0:	e1a01003 	mov	r1, r3
70000be4:	e51b2008 	ldr	r2, [fp, #-8]
70000be8:	eb001b01 	bl	700077f4 <rt_kprintf>
70000bec:	ea000005 	b	70000c08 <rt_device_init+0x114>
                           dev->parent.name, result);
            }
            else
            {
                dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
70000bf0:	e51b3010 	ldr	r3, [fp, #-16]
70000bf4:	e1d331b2 	ldrh	r3, [r3, #18]
70000bf8:	e3833010 	orr	r3, r3, #16
70000bfc:	e6ff2073 	uxth	r2, r3
70000c00:	e51b3010 	ldr	r3, [fp, #-16]
70000c04:	e1c321b2 	strh	r2, [r3, #18]
            }
        }
    }

    return result;
70000c08:	e51b3008 	ldr	r3, [fp, #-8]
}
70000c0c:	e1a00003 	mov	r0, r3
70000c10:	e24bd004 	sub	sp, fp, #4
70000c14:	e8bd8800 	pop	{fp, pc}

70000c18 <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
70000c18:	e92d4800 	push	{fp, lr}
70000c1c:	e28db004 	add	fp, sp, #4
70000c20:	e24dd010 	sub	sp, sp, #16
70000c24:	e50b0010 	str	r0, [fp, #-16]
70000c28:	e1a03001 	mov	r3, r1
70000c2c:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
70000c30:	e3a03000 	mov	r3, #0
70000c34:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
70000c38:	e51b3010 	ldr	r3, [fp, #-16]
70000c3c:	e3530000 	cmp	r3, #0
70000c40:	1a00001d 	bne	70000cbc <rt_device_open+0xa4>
70000c44:	e3a03000 	mov	r3, #0
70000c48:	e54b3009 	strb	r3, [fp, #-9]
70000c4c:	e30a3b74 	movw	r3, #43892	; 0xab74
70000c50:	e3473002 	movt	r3, #28674	; 0x7002
70000c54:	e5933000 	ldr	r3, [r3]
70000c58:	e3530000 	cmp	r3, #0
70000c5c:	1a00000d 	bne	70000c98 <rt_device_open+0x80>
70000c60:	e306018c 	movw	r0, #24972	; 0x618c
70000c64:	e3470002 	movt	r0, #28674	; 0x7002
70000c68:	e30611ac 	movw	r1, #25004	; 0x61ac
70000c6c:	e3471002 	movt	r1, #28674	; 0x7002
70000c70:	e3062230 	movw	r2, #25136	; 0x6230
70000c74:	e3472002 	movt	r2, #28674	; 0x7002
70000c78:	e3a030b6 	mov	r3, #182	; 0xb6
70000c7c:	eb001adc 	bl	700077f4 <rt_kprintf>
70000c80:	e1a00000 	nop			; (mov r0, r0)
70000c84:	e55b3009 	ldrb	r3, [fp, #-9]
70000c88:	e6ef3073 	uxtb	r3, r3
70000c8c:	e3530000 	cmp	r3, #0
70000c90:	0afffffb 	beq	70000c84 <rt_device_open+0x6c>
70000c94:	ea000008 	b	70000cbc <rt_device_open+0xa4>
70000c98:	e30a3b74 	movw	r3, #43892	; 0xab74
70000c9c:	e3473002 	movt	r3, #28674	; 0x7002
70000ca0:	e5933000 	ldr	r3, [r3]
70000ca4:	e30601ac 	movw	r0, #25004	; 0x61ac
70000ca8:	e3470002 	movt	r0, #28674	; 0x7002
70000cac:	e3061230 	movw	r1, #25136	; 0x6230
70000cb0:	e3471002 	movt	r1, #28674	; 0x7002
70000cb4:	e3a020b6 	mov	r2, #182	; 0xb6
70000cb8:	e12fff33 	blx	r3

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
70000cbc:	e51b3010 	ldr	r3, [fp, #-16]
70000cc0:	e1d331b2 	ldrh	r3, [r3, #18]
70000cc4:	e2033010 	and	r3, r3, #16
70000cc8:	e3530000 	cmp	r3, #0
70000ccc:	1a000019 	bne	70000d38 <rt_device_open+0x120>
    {
        if (dev->init != RT_NULL)
70000cd0:	e51b3010 	ldr	r3, [fp, #-16]
70000cd4:	e5933020 	ldr	r3, [r3, #32]
70000cd8:	e3530000 	cmp	r3, #0
70000cdc:	0a00000f 	beq	70000d20 <rt_device_open+0x108>
        {
            result = dev->init(dev);
70000ce0:	e51b3010 	ldr	r3, [fp, #-16]
70000ce4:	e5933020 	ldr	r3, [r3, #32]
70000ce8:	e51b0010 	ldr	r0, [fp, #-16]
70000cec:	e12fff33 	blx	r3
70000cf0:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
70000cf4:	e51b3008 	ldr	r3, [fp, #-8]
70000cf8:	e3530000 	cmp	r3, #0
70000cfc:	0a000007 	beq	70000d20 <rt_device_open+0x108>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
70000d00:	e51b3010 	ldr	r3, [fp, #-16]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
70000d04:	e30601bc 	movw	r0, #25020	; 0x61bc
70000d08:	e3470002 	movt	r0, #28674	; 0x7002
70000d0c:	e1a01003 	mov	r1, r3
70000d10:	e51b2008 	ldr	r2, [fp, #-8]
70000d14:	eb001ab6 	bl	700077f4 <rt_kprintf>
                           dev->parent.name, result);

                return result;
70000d18:	e51b3008 	ldr	r3, [fp, #-8]
70000d1c:	ea000050 	b	70000e64 <rt_device_open+0x24c>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
70000d20:	e51b3010 	ldr	r3, [fp, #-16]
70000d24:	e1d331b2 	ldrh	r3, [r3, #18]
70000d28:	e3833010 	orr	r3, r3, #16
70000d2c:	e6ff2073 	uxth	r2, r3
70000d30:	e51b3010 	ldr	r3, [fp, #-16]
70000d34:	e1c321b2 	strh	r2, [r3, #18]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
70000d38:	e51b3010 	ldr	r3, [fp, #-16]
70000d3c:	e1d331b2 	ldrh	r3, [r3, #18]
70000d40:	e2033008 	and	r3, r3, #8
70000d44:	e3530000 	cmp	r3, #0
70000d48:	0a000006 	beq	70000d68 <rt_device_open+0x150>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
70000d4c:	e51b3010 	ldr	r3, [fp, #-16]
70000d50:	e1d331b4 	ldrh	r3, [r3, #20]
70000d54:	e2033008 	and	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
70000d58:	e3530000 	cmp	r3, #0
70000d5c:	0a000001 	beq	70000d68 <rt_device_open+0x150>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
70000d60:	e3e03006 	mvn	r3, #6
70000d64:	ea00003e 	b	70000e64 <rt_device_open+0x24c>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
70000d68:	e51b3010 	ldr	r3, [fp, #-16]
70000d6c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70000d70:	e3530000 	cmp	r3, #0
70000d74:	0a000006 	beq	70000d94 <rt_device_open+0x17c>
    {
        result = dev->open(dev, oflag);
70000d78:	e51b3010 	ldr	r3, [fp, #-16]
70000d7c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70000d80:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
70000d84:	e51b0010 	ldr	r0, [fp, #-16]
70000d88:	e1a01002 	mov	r1, r2
70000d8c:	e12fff33 	blx	r3
70000d90:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
70000d94:	e51b3008 	ldr	r3, [fp, #-8]
70000d98:	e3530000 	cmp	r3, #0
70000d9c:	0a000002 	beq	70000dac <rt_device_open+0x194>
70000da0:	e51b3008 	ldr	r3, [fp, #-8]
70000da4:	e3730006 	cmn	r3, #6
70000da8:	1a00002c 	bne	70000e60 <rt_device_open+0x248>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
70000dac:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
70000db0:	e3833008 	orr	r3, r3, #8
70000db4:	e6ff2073 	uxth	r2, r3
70000db8:	e51b3010 	ldr	r3, [fp, #-16]
70000dbc:	e1c321b4 	strh	r2, [r3, #20]

        dev->ref_count++;
70000dc0:	e51b3010 	ldr	r3, [fp, #-16]
70000dc4:	e5d33016 	ldrb	r3, [r3, #22]
70000dc8:	e2833001 	add	r3, r3, #1
70000dcc:	e6ef2073 	uxtb	r2, r3
70000dd0:	e51b3010 	ldr	r3, [fp, #-16]
70000dd4:	e5c32016 	strb	r2, [r3, #22]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
70000dd8:	e51b3010 	ldr	r3, [fp, #-16]
70000ddc:	e5d33016 	ldrb	r3, [r3, #22]
70000de0:	e3530000 	cmp	r3, #0
70000de4:	1a00001d 	bne	70000e60 <rt_device_open+0x248>
70000de8:	e3a03000 	mov	r3, #0
70000dec:	e54b300a 	strb	r3, [fp, #-10]
70000df0:	e30a3b74 	movw	r3, #43892	; 0xab74
70000df4:	e3473002 	movt	r3, #28674	; 0x7002
70000df8:	e5933000 	ldr	r3, [r3]
70000dfc:	e3530000 	cmp	r3, #0
70000e00:	1a00000d 	bne	70000e3c <rt_device_open+0x224>
70000e04:	e306018c 	movw	r0, #24972	; 0x618c
70000e08:	e3470002 	movt	r0, #28674	; 0x7002
70000e0c:	e30611f4 	movw	r1, #25076	; 0x61f4
70000e10:	e3471002 	movt	r1, #28674	; 0x7002
70000e14:	e3062230 	movw	r2, #25136	; 0x6230
70000e18:	e3472002 	movt	r2, #28674	; 0x7002
70000e1c:	e3a030df 	mov	r3, #223	; 0xdf
70000e20:	eb001a73 	bl	700077f4 <rt_kprintf>
70000e24:	e1a00000 	nop			; (mov r0, r0)
70000e28:	e55b300a 	ldrb	r3, [fp, #-10]
70000e2c:	e6ef3073 	uxtb	r3, r3
70000e30:	e3530000 	cmp	r3, #0
70000e34:	0afffffb 	beq	70000e28 <rt_device_open+0x210>
70000e38:	ea000008 	b	70000e60 <rt_device_open+0x248>
70000e3c:	e30a3b74 	movw	r3, #43892	; 0xab74
70000e40:	e3473002 	movt	r3, #28674	; 0x7002
70000e44:	e5933000 	ldr	r3, [r3]
70000e48:	e30601f4 	movw	r0, #25076	; 0x61f4
70000e4c:	e3470002 	movt	r0, #28674	; 0x7002
70000e50:	e3061230 	movw	r1, #25136	; 0x6230
70000e54:	e3471002 	movt	r1, #28674	; 0x7002
70000e58:	e3a020df 	mov	r2, #223	; 0xdf
70000e5c:	e12fff33 	blx	r3
    }

    return result;
70000e60:	e51b3008 	ldr	r3, [fp, #-8]
}
70000e64:	e1a00003 	mov	r0, r3
70000e68:	e24bd004 	sub	sp, fp, #4
70000e6c:	e8bd8800 	pop	{fp, pc}

70000e70 <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
70000e70:	e92d4800 	push	{fp, lr}
70000e74:	e28db004 	add	fp, sp, #4
70000e78:	e24dd010 	sub	sp, sp, #16
70000e7c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
70000e80:	e3a03000 	mov	r3, #0
70000e84:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
70000e88:	e51b3010 	ldr	r3, [fp, #-16]
70000e8c:	e3530000 	cmp	r3, #0
70000e90:	1a00001d 	bne	70000f0c <rt_device_close+0x9c>
70000e94:	e3a03000 	mov	r3, #0
70000e98:	e54b3009 	strb	r3, [fp, #-9]
70000e9c:	e30a3b74 	movw	r3, #43892	; 0xab74
70000ea0:	e3473002 	movt	r3, #28674	; 0x7002
70000ea4:	e5933000 	ldr	r3, [r3]
70000ea8:	e3530000 	cmp	r3, #0
70000eac:	1a00000d 	bne	70000ee8 <rt_device_close+0x78>
70000eb0:	e306018c 	movw	r0, #24972	; 0x618c
70000eb4:	e3470002 	movt	r0, #28674	; 0x7002
70000eb8:	e30611ac 	movw	r1, #25004	; 0x61ac
70000ebc:	e3471002 	movt	r1, #28674	; 0x7002
70000ec0:	e3062240 	movw	r2, #25152	; 0x6240
70000ec4:	e3472002 	movt	r2, #28674	; 0x7002
70000ec8:	e3a030f1 	mov	r3, #241	; 0xf1
70000ecc:	eb001a48 	bl	700077f4 <rt_kprintf>
70000ed0:	e1a00000 	nop			; (mov r0, r0)
70000ed4:	e55b3009 	ldrb	r3, [fp, #-9]
70000ed8:	e6ef3073 	uxtb	r3, r3
70000edc:	e3530000 	cmp	r3, #0
70000ee0:	0afffffb 	beq	70000ed4 <rt_device_close+0x64>
70000ee4:	ea000008 	b	70000f0c <rt_device_close+0x9c>
70000ee8:	e30a3b74 	movw	r3, #43892	; 0xab74
70000eec:	e3473002 	movt	r3, #28674	; 0x7002
70000ef0:	e5933000 	ldr	r3, [r3]
70000ef4:	e30601ac 	movw	r0, #25004	; 0x61ac
70000ef8:	e3470002 	movt	r0, #28674	; 0x7002
70000efc:	e3061240 	movw	r1, #25152	; 0x6240
70000f00:	e3471002 	movt	r1, #28674	; 0x7002
70000f04:	e3a020f1 	mov	r2, #241	; 0xf1
70000f08:	e12fff33 	blx	r3

    if (dev->ref_count == 0)
70000f0c:	e51b3010 	ldr	r3, [fp, #-16]
70000f10:	e5d33016 	ldrb	r3, [r3, #22]
70000f14:	e3530000 	cmp	r3, #0
70000f18:	1a000001 	bne	70000f24 <rt_device_close+0xb4>
        return -RT_ERROR;
70000f1c:	e3e03000 	mvn	r3, #0
70000f20:	ea00001e 	b	70000fa0 <rt_device_close+0x130>

    dev->ref_count--;
70000f24:	e51b3010 	ldr	r3, [fp, #-16]
70000f28:	e5d33016 	ldrb	r3, [r3, #22]
70000f2c:	e2433001 	sub	r3, r3, #1
70000f30:	e6ef2073 	uxtb	r2, r3
70000f34:	e51b3010 	ldr	r3, [fp, #-16]
70000f38:	e5c32016 	strb	r2, [r3, #22]

    if (dev->ref_count != 0)
70000f3c:	e51b3010 	ldr	r3, [fp, #-16]
70000f40:	e5d33016 	ldrb	r3, [r3, #22]
70000f44:	e3530000 	cmp	r3, #0
70000f48:	0a000001 	beq	70000f54 <rt_device_close+0xe4>
        return RT_EOK;
70000f4c:	e3a03000 	mov	r3, #0
70000f50:	ea000012 	b	70000fa0 <rt_device_close+0x130>

    /* call device close interface */
    if (dev->close != RT_NULL)
70000f54:	e51b3010 	ldr	r3, [fp, #-16]
70000f58:	e5933028 	ldr	r3, [r3, #40]	; 0x28
70000f5c:	e3530000 	cmp	r3, #0
70000f60:	0a000004 	beq	70000f78 <rt_device_close+0x108>
    {
        result = dev->close(dev);
70000f64:	e51b3010 	ldr	r3, [fp, #-16]
70000f68:	e5933028 	ldr	r3, [r3, #40]	; 0x28
70000f6c:	e51b0010 	ldr	r0, [fp, #-16]
70000f70:	e12fff33 	blx	r3
70000f74:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
70000f78:	e51b3008 	ldr	r3, [fp, #-8]
70000f7c:	e3530000 	cmp	r3, #0
70000f80:	0a000002 	beq	70000f90 <rt_device_close+0x120>
70000f84:	e51b3008 	ldr	r3, [fp, #-8]
70000f88:	e3730006 	cmn	r3, #6
70000f8c:	1a000002 	bne	70000f9c <rt_device_close+0x12c>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
70000f90:	e51b3010 	ldr	r3, [fp, #-16]
70000f94:	e3a02000 	mov	r2, #0
70000f98:	e1c321b4 	strh	r2, [r3, #20]

    return result;
70000f9c:	e51b3008 	ldr	r3, [fp, #-8]
}
70000fa0:	e1a00003 	mov	r0, r3
70000fa4:	e24bd004 	sub	sp, fp, #4
70000fa8:	e8bd8800 	pop	{fp, pc}

70000fac <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
70000fac:	e92d4800 	push	{fp, lr}
70000fb0:	e28db004 	add	fp, sp, #4
70000fb4:	e24dd018 	sub	sp, sp, #24
70000fb8:	e50b0010 	str	r0, [fp, #-16]
70000fbc:	e50b1014 	str	r1, [fp, #-20]
70000fc0:	e50b2018 	str	r2, [fp, #-24]
70000fc4:	e50b301c 	str	r3, [fp, #-28]
    RT_ASSERT(dev != RT_NULL);
70000fc8:	e51b3010 	ldr	r3, [fp, #-16]
70000fcc:	e3530000 	cmp	r3, #0
70000fd0:	1a00001d 	bne	7000104c <rt_device_read+0xa0>
70000fd4:	e3a03000 	mov	r3, #0
70000fd8:	e54b3005 	strb	r3, [fp, #-5]
70000fdc:	e30a3b74 	movw	r3, #43892	; 0xab74
70000fe0:	e3473002 	movt	r3, #28674	; 0x7002
70000fe4:	e5933000 	ldr	r3, [r3]
70000fe8:	e3530000 	cmp	r3, #0
70000fec:	1a00000d 	bne	70001028 <rt_device_read+0x7c>
70000ff0:	e306018c 	movw	r0, #24972	; 0x618c
70000ff4:	e3470002 	movt	r0, #28674	; 0x7002
70000ff8:	e30611ac 	movw	r1, #25004	; 0x61ac
70000ffc:	e3471002 	movt	r1, #28674	; 0x7002
70001000:	e3062250 	movw	r2, #25168	; 0x6250
70001004:	e3472002 	movt	r2, #28674	; 0x7002
70001008:	e300311a 	movw	r3, #282	; 0x11a
7000100c:	eb0019f8 	bl	700077f4 <rt_kprintf>
70001010:	e1a00000 	nop			; (mov r0, r0)
70001014:	e55b3005 	ldrb	r3, [fp, #-5]
70001018:	e6ef3073 	uxtb	r3, r3
7000101c:	e3530000 	cmp	r3, #0
70001020:	0afffffb 	beq	70001014 <rt_device_read+0x68>
70001024:	ea000008 	b	7000104c <rt_device_read+0xa0>
70001028:	e30a3b74 	movw	r3, #43892	; 0xab74
7000102c:	e3473002 	movt	r3, #28674	; 0x7002
70001030:	e5933000 	ldr	r3, [r3]
70001034:	e30601ac 	movw	r0, #25004	; 0x61ac
70001038:	e3470002 	movt	r0, #28674	; 0x7002
7000103c:	e3061250 	movw	r1, #25168	; 0x6250
70001040:	e3471002 	movt	r1, #28674	; 0x7002
70001044:	e300211a 	movw	r2, #282	; 0x11a
70001048:	e12fff33 	blx	r3

    if (dev->ref_count == 0)
7000104c:	e51b3010 	ldr	r3, [fp, #-16]
70001050:	e5d33016 	ldrb	r3, [r3, #22]
70001054:	e3530000 	cmp	r3, #0
70001058:	1a000003 	bne	7000106c <rt_device_read+0xc0>
    {
        rt_set_errno(-RT_ERROR);
7000105c:	e3e00000 	mvn	r0, #0
70001060:	eb0013b6 	bl	70005f40 <rt_set_errno>
        return 0;
70001064:	e3a03000 	mov	r3, #0
70001068:	ea00000f 	b	700010ac <rt_device_read+0x100>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
7000106c:	e51b3010 	ldr	r3, [fp, #-16]
70001070:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70001074:	e3530000 	cmp	r3, #0
70001078:	0a000008 	beq	700010a0 <rt_device_read+0xf4>
    {
        return dev->read(dev, pos, buffer, size);
7000107c:	e51b3010 	ldr	r3, [fp, #-16]
70001080:	e593c02c 	ldr	ip, [r3, #44]	; 0x2c
70001084:	e51b0010 	ldr	r0, [fp, #-16]
70001088:	e51b1014 	ldr	r1, [fp, #-20]
7000108c:	e51b2018 	ldr	r2, [fp, #-24]
70001090:	e51b301c 	ldr	r3, [fp, #-28]
70001094:	e12fff3c 	blx	ip
70001098:	e1a03000 	mov	r3, r0
7000109c:	ea000002 	b	700010ac <rt_device_read+0x100>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
700010a0:	e3e00005 	mvn	r0, #5
700010a4:	eb0013a5 	bl	70005f40 <rt_set_errno>

    return 0;
700010a8:	e3a03000 	mov	r3, #0
}
700010ac:	e1a00003 	mov	r0, r3
700010b0:	e24bd004 	sub	sp, fp, #4
700010b4:	e8bd8800 	pop	{fp, pc}

700010b8 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
700010b8:	e92d4800 	push	{fp, lr}
700010bc:	e28db004 	add	fp, sp, #4
700010c0:	e24dd018 	sub	sp, sp, #24
700010c4:	e50b0010 	str	r0, [fp, #-16]
700010c8:	e50b1014 	str	r1, [fp, #-20]
700010cc:	e50b2018 	str	r2, [fp, #-24]
700010d0:	e50b301c 	str	r3, [fp, #-28]
    RT_ASSERT(dev != RT_NULL);
700010d4:	e51b3010 	ldr	r3, [fp, #-16]
700010d8:	e3530000 	cmp	r3, #0
700010dc:	1a00001d 	bne	70001158 <rt_device_write+0xa0>
700010e0:	e3a03000 	mov	r3, #0
700010e4:	e54b3005 	strb	r3, [fp, #-5]
700010e8:	e30a3b74 	movw	r3, #43892	; 0xab74
700010ec:	e3473002 	movt	r3, #28674	; 0x7002
700010f0:	e5933000 	ldr	r3, [r3]
700010f4:	e3530000 	cmp	r3, #0
700010f8:	1a00000d 	bne	70001134 <rt_device_write+0x7c>
700010fc:	e306018c 	movw	r0, #24972	; 0x618c
70001100:	e3470002 	movt	r0, #28674	; 0x7002
70001104:	e30611ac 	movw	r1, #25004	; 0x61ac
70001108:	e3471002 	movt	r1, #28674	; 0x7002
7000110c:	e3062260 	movw	r2, #25184	; 0x6260
70001110:	e3472002 	movt	r2, #28674	; 0x7002
70001114:	e3a03d05 	mov	r3, #320	; 0x140
70001118:	eb0019b5 	bl	700077f4 <rt_kprintf>
7000111c:	e1a00000 	nop			; (mov r0, r0)
70001120:	e55b3005 	ldrb	r3, [fp, #-5]
70001124:	e6ef3073 	uxtb	r3, r3
70001128:	e3530000 	cmp	r3, #0
7000112c:	0afffffb 	beq	70001120 <rt_device_write+0x68>
70001130:	ea000008 	b	70001158 <rt_device_write+0xa0>
70001134:	e30a3b74 	movw	r3, #43892	; 0xab74
70001138:	e3473002 	movt	r3, #28674	; 0x7002
7000113c:	e5933000 	ldr	r3, [r3]
70001140:	e30601ac 	movw	r0, #25004	; 0x61ac
70001144:	e3470002 	movt	r0, #28674	; 0x7002
70001148:	e3061260 	movw	r1, #25184	; 0x6260
7000114c:	e3471002 	movt	r1, #28674	; 0x7002
70001150:	e3a02d05 	mov	r2, #320	; 0x140
70001154:	e12fff33 	blx	r3

    if (dev->ref_count == 0)
70001158:	e51b3010 	ldr	r3, [fp, #-16]
7000115c:	e5d33016 	ldrb	r3, [r3, #22]
70001160:	e3530000 	cmp	r3, #0
70001164:	1a000003 	bne	70001178 <rt_device_write+0xc0>
    {
        rt_set_errno(-RT_ERROR);
70001168:	e3e00000 	mvn	r0, #0
7000116c:	eb001373 	bl	70005f40 <rt_set_errno>
        return 0;
70001170:	e3a03000 	mov	r3, #0
70001174:	ea00000f 	b	700011b8 <rt_device_write+0x100>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
70001178:	e51b3010 	ldr	r3, [fp, #-16]
7000117c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
70001180:	e3530000 	cmp	r3, #0
70001184:	0a000008 	beq	700011ac <rt_device_write+0xf4>
    {
        return dev->write(dev, pos, buffer, size);
70001188:	e51b3010 	ldr	r3, [fp, #-16]
7000118c:	e593c030 	ldr	ip, [r3, #48]	; 0x30
70001190:	e51b0010 	ldr	r0, [fp, #-16]
70001194:	e51b1014 	ldr	r1, [fp, #-20]
70001198:	e51b2018 	ldr	r2, [fp, #-24]
7000119c:	e51b301c 	ldr	r3, [fp, #-28]
700011a0:	e12fff3c 	blx	ip
700011a4:	e1a03000 	mov	r3, r0
700011a8:	ea000002 	b	700011b8 <rt_device_write+0x100>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
700011ac:	e3e00005 	mvn	r0, #5
700011b0:	eb001362 	bl	70005f40 <rt_set_errno>

    return 0;
700011b4:	e3a03000 	mov	r3, #0
}
700011b8:	e1a00003 	mov	r0, r3
700011bc:	e24bd004 	sub	sp, fp, #4
700011c0:	e8bd8800 	pop	{fp, pc}

700011c4 <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
700011c4:	e92d4800 	push	{fp, lr}
700011c8:	e28db004 	add	fp, sp, #4
700011cc:	e24dd018 	sub	sp, sp, #24
700011d0:	e50b0010 	str	r0, [fp, #-16]
700011d4:	e1a03001 	mov	r3, r1
700011d8:	e50b2018 	str	r2, [fp, #-24]
700011dc:	e54b3011 	strb	r3, [fp, #-17]
    RT_ASSERT(dev != RT_NULL);
700011e0:	e51b3010 	ldr	r3, [fp, #-16]
700011e4:	e3530000 	cmp	r3, #0
700011e8:	1a00001d 	bne	70001264 <rt_device_control+0xa0>
700011ec:	e3a03000 	mov	r3, #0
700011f0:	e54b3005 	strb	r3, [fp, #-5]
700011f4:	e30a3b74 	movw	r3, #43892	; 0xab74
700011f8:	e3473002 	movt	r3, #28674	; 0x7002
700011fc:	e5933000 	ldr	r3, [r3]
70001200:	e3530000 	cmp	r3, #0
70001204:	1a00000d 	bne	70001240 <rt_device_control+0x7c>
70001208:	e306018c 	movw	r0, #24972	; 0x618c
7000120c:	e3470002 	movt	r0, #28674	; 0x7002
70001210:	e30611ac 	movw	r1, #25004	; 0x61ac
70001214:	e3471002 	movt	r1, #28674	; 0x7002
70001218:	e3062270 	movw	r2, #25200	; 0x6270
7000121c:	e3472002 	movt	r2, #28674	; 0x7002
70001220:	e3a03e16 	mov	r3, #352	; 0x160
70001224:	eb001972 	bl	700077f4 <rt_kprintf>
70001228:	e1a00000 	nop			; (mov r0, r0)
7000122c:	e55b3005 	ldrb	r3, [fp, #-5]
70001230:	e6ef3073 	uxtb	r3, r3
70001234:	e3530000 	cmp	r3, #0
70001238:	0afffffb 	beq	7000122c <rt_device_control+0x68>
7000123c:	ea000008 	b	70001264 <rt_device_control+0xa0>
70001240:	e30a3b74 	movw	r3, #43892	; 0xab74
70001244:	e3473002 	movt	r3, #28674	; 0x7002
70001248:	e5933000 	ldr	r3, [r3]
7000124c:	e30601ac 	movw	r0, #25004	; 0x61ac
70001250:	e3470002 	movt	r0, #28674	; 0x7002
70001254:	e3061270 	movw	r1, #25200	; 0x6270
70001258:	e3471002 	movt	r1, #28674	; 0x7002
7000125c:	e3a02e16 	mov	r2, #352	; 0x160
70001260:	e12fff33 	blx	r3

    /* call device write interface */
    if (dev->control != RT_NULL)
70001264:	e51b3010 	ldr	r3, [fp, #-16]
70001268:	e5933034 	ldr	r3, [r3, #52]	; 0x34
7000126c:	e3530000 	cmp	r3, #0
70001270:	0a000008 	beq	70001298 <rt_device_control+0xd4>
    {
        return dev->control(dev, cmd, arg);
70001274:	e51b3010 	ldr	r3, [fp, #-16]
70001278:	e5933034 	ldr	r3, [r3, #52]	; 0x34
7000127c:	e55b2011 	ldrb	r2, [fp, #-17]
70001280:	e51b0010 	ldr	r0, [fp, #-16]
70001284:	e1a01002 	mov	r1, r2
70001288:	e51b2018 	ldr	r2, [fp, #-24]
7000128c:	e12fff33 	blx	r3
70001290:	e1a03000 	mov	r3, r0
70001294:	ea000000 	b	7000129c <rt_device_control+0xd8>
    }

    return RT_EOK;
70001298:	e3a03000 	mov	r3, #0
}
7000129c:	e1a00003 	mov	r0, r3
700012a0:	e24bd004 	sub	sp, fp, #4
700012a4:	e8bd8800 	pop	{fp, pc}

700012a8 <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
700012a8:	e92d4800 	push	{fp, lr}
700012ac:	e28db004 	add	fp, sp, #4
700012b0:	e24dd010 	sub	sp, sp, #16
700012b4:	e50b0010 	str	r0, [fp, #-16]
700012b8:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
700012bc:	e51b3010 	ldr	r3, [fp, #-16]
700012c0:	e3530000 	cmp	r3, #0
700012c4:	1a00001d 	bne	70001340 <rt_device_set_rx_indicate+0x98>
700012c8:	e3a03000 	mov	r3, #0
700012cc:	e54b3005 	strb	r3, [fp, #-5]
700012d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700012d4:	e3473002 	movt	r3, #28674	; 0x7002
700012d8:	e5933000 	ldr	r3, [r3]
700012dc:	e3530000 	cmp	r3, #0
700012e0:	1a00000d 	bne	7000131c <rt_device_set_rx_indicate+0x74>
700012e4:	e306018c 	movw	r0, #24972	; 0x618c
700012e8:	e3470002 	movt	r0, #28674	; 0x7002
700012ec:	e30611ac 	movw	r1, #25004	; 0x61ac
700012f0:	e3471002 	movt	r1, #28674	; 0x7002
700012f4:	e3062284 	movw	r2, #25220	; 0x6284
700012f8:	e3472002 	movt	r2, #28674	; 0x7002
700012fc:	e3003179 	movw	r3, #377	; 0x179
70001300:	eb00193b 	bl	700077f4 <rt_kprintf>
70001304:	e1a00000 	nop			; (mov r0, r0)
70001308:	e55b3005 	ldrb	r3, [fp, #-5]
7000130c:	e6ef3073 	uxtb	r3, r3
70001310:	e3530000 	cmp	r3, #0
70001314:	0afffffb 	beq	70001308 <rt_device_set_rx_indicate+0x60>
70001318:	ea000008 	b	70001340 <rt_device_set_rx_indicate+0x98>
7000131c:	e30a3b74 	movw	r3, #43892	; 0xab74
70001320:	e3473002 	movt	r3, #28674	; 0x7002
70001324:	e5933000 	ldr	r3, [r3]
70001328:	e30601ac 	movw	r0, #25004	; 0x61ac
7000132c:	e3470002 	movt	r0, #28674	; 0x7002
70001330:	e3061284 	movw	r1, #25220	; 0x6284
70001334:	e3471002 	movt	r1, #28674	; 0x7002
70001338:	e3002179 	movw	r2, #377	; 0x179
7000133c:	e12fff33 	blx	r3

    dev->rx_indicate = rx_ind;
70001340:	e51b3010 	ldr	r3, [fp, #-16]
70001344:	e51b2014 	ldr	r2, [fp, #-20]
70001348:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
7000134c:	e3a03000 	mov	r3, #0
}
70001350:	e1a00003 	mov	r0, r3
70001354:	e24bd004 	sub	sp, fp, #4
70001358:	e8bd8800 	pop	{fp, pc}

7000135c <rt_device_set_tx_complete>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_tx_complete(rt_device_t dev,
                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
{
7000135c:	e92d4800 	push	{fp, lr}
70001360:	e28db004 	add	fp, sp, #4
70001364:	e24dd010 	sub	sp, sp, #16
70001368:	e50b0010 	str	r0, [fp, #-16]
7000136c:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
70001370:	e51b3010 	ldr	r3, [fp, #-16]
70001374:	e3530000 	cmp	r3, #0
70001378:	1a00001d 	bne	700013f4 <rt_device_set_tx_complete+0x98>
7000137c:	e3a03000 	mov	r3, #0
70001380:	e54b3005 	strb	r3, [fp, #-5]
70001384:	e30a3b74 	movw	r3, #43892	; 0xab74
70001388:	e3473002 	movt	r3, #28674	; 0x7002
7000138c:	e5933000 	ldr	r3, [r3]
70001390:	e3530000 	cmp	r3, #0
70001394:	1a00000d 	bne	700013d0 <rt_device_set_tx_complete+0x74>
70001398:	e306018c 	movw	r0, #24972	; 0x618c
7000139c:	e3470002 	movt	r0, #28674	; 0x7002
700013a0:	e30611ac 	movw	r1, #25004	; 0x61ac
700013a4:	e3471002 	movt	r1, #28674	; 0x7002
700013a8:	e30622a0 	movw	r2, #25248	; 0x62a0
700013ac:	e3472002 	movt	r2, #28674	; 0x7002
700013b0:	e300318e 	movw	r3, #398	; 0x18e
700013b4:	eb00190e 	bl	700077f4 <rt_kprintf>
700013b8:	e1a00000 	nop			; (mov r0, r0)
700013bc:	e55b3005 	ldrb	r3, [fp, #-5]
700013c0:	e6ef3073 	uxtb	r3, r3
700013c4:	e3530000 	cmp	r3, #0
700013c8:	0afffffb 	beq	700013bc <rt_device_set_tx_complete+0x60>
700013cc:	ea000008 	b	700013f4 <rt_device_set_tx_complete+0x98>
700013d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700013d4:	e3473002 	movt	r3, #28674	; 0x7002
700013d8:	e5933000 	ldr	r3, [r3]
700013dc:	e30601ac 	movw	r0, #25004	; 0x61ac
700013e0:	e3470002 	movt	r0, #28674	; 0x7002
700013e4:	e30612a0 	movw	r1, #25248	; 0x62a0
700013e8:	e3471002 	movt	r1, #28674	; 0x7002
700013ec:	e300218e 	movw	r2, #398	; 0x18e
700013f0:	e12fff33 	blx	r3

    dev->tx_complete = tx_done;
700013f4:	e51b3010 	ldr	r3, [fp, #-16]
700013f8:	e51b2014 	ldr	r2, [fp, #-20]
700013fc:	e583201c 	str	r2, [r3, #28]

    return RT_EOK;
70001400:	e3a03000 	mov	r3, #0
}
70001404:	e1a00003 	mov	r0, r3
70001408:	e24bd004 	sub	sp, fp, #4
7000140c:	e8bd8800 	pop	{fp, pc}

70001410 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
70001410:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70001414:	e28db000 	add	fp, sp, #0
70001418:	e24dd00c 	sub	sp, sp, #12
7000141c:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
70001420:	e51b3008 	ldr	r3, [fp, #-8]
70001424:	e5933000 	ldr	r3, [r3]
70001428:	e51b2008 	ldr	r2, [fp, #-8]
7000142c:	e5922004 	ldr	r2, [r2, #4]
70001430:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
70001434:	e51b3008 	ldr	r3, [fp, #-8]
70001438:	e5933004 	ldr	r3, [r3, #4]
7000143c:	e51b2008 	ldr	r2, [fp, #-8]
70001440:	e5922000 	ldr	r2, [r2]
70001444:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
70001448:	e51b3008 	ldr	r3, [fp, #-8]
7000144c:	e51b2008 	ldr	r2, [fp, #-8]
70001450:	e5832004 	str	r2, [r3, #4]
70001454:	e51b3008 	ldr	r3, [fp, #-8]
70001458:	e5932004 	ldr	r2, [r3, #4]
7000145c:	e51b3008 	ldr	r3, [fp, #-8]
70001460:	e5832000 	str	r2, [r3]
}
70001464:	e24bd000 	sub	sp, fp, #0
70001468:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000146c:	e12fff1e 	bx	lr

70001470 <rt_thread_idle_sethook>:
 * @param hook the specified hook function
 *
 * @note the hook function must be simple and never be blocked or suspend.
 */
void rt_thread_idle_sethook(void (*hook)(void))
{
70001470:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70001474:	e28db000 	add	fp, sp, #0
70001478:	e24dd00c 	sub	sp, sp, #12
7000147c:	e50b0008 	str	r0, [fp, #-8]
    rt_thread_idle_hook = hook;
70001480:	e3093818 	movw	r3, #38936	; 0x9818
70001484:	e3473002 	movt	r3, #28674	; 0x7002
70001488:	e51b2008 	ldr	r2, [fp, #-8]
7000148c:	e5832000 	str	r2, [r3]
}
70001490:	e24bd000 	sub	sp, fp, #0
70001494:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70001498:	e12fff1e 	bx	lr

7000149c <_has_defunct_thread>:
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
7000149c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700014a0:	e28db000 	add	fp, sp, #0
700014a4:	e24dd00c 	sub	sp, sp, #12
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
700014a8:	e30a3c90 	movw	r3, #44176	; 0xac90
700014ac:	e3473002 	movt	r3, #28674	; 0x7002
700014b0:	e50b3008 	str	r3, [fp, #-8]

    return l->next != l;
700014b4:	e51b3008 	ldr	r3, [fp, #-8]
700014b8:	e5932000 	ldr	r2, [r3]
700014bc:	e51b3008 	ldr	r3, [fp, #-8]
700014c0:	e1520003 	cmp	r2, r3
700014c4:	03a03000 	moveq	r3, #0
700014c8:	13a03001 	movne	r3, #1
700014cc:	e6ef3073 	uxtb	r3, r3
}
700014d0:	e1a00003 	mov	r0, r3
700014d4:	e24bd000 	sub	sp, fp, #0
700014d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700014dc:	e12fff1e 	bx	lr

700014e0 <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
700014e0:	e92d4800 	push	{fp, lr}
700014e4:	e28db004 	add	fp, sp, #4
700014e8:	e24dd010 	sub	sp, sp, #16
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
700014ec:	ea000054 	b	70001644 <rt_thread_idle_excute+0x164>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
700014f0:	eb003354 	bl	7000e248 <rt_hw_interrupt_disable>
700014f4:	e50b0008 	str	r0, [fp, #-8]
700014f8:	eb00126d 	bl	70005eb4 <rt_interrupt_get_nest>
700014fc:	e1a03000 	mov	r3, r0
70001500:	e3530000 	cmp	r3, #0
70001504:	0a000022 	beq	70001594 <rt_thread_idle_excute+0xb4>
70001508:	e30602bc 	movw	r0, #25276	; 0x62bc
7000150c:	e3470002 	movt	r0, #28674	; 0x7002
70001510:	e306130c 	movw	r1, #25356	; 0x630c
70001514:	e3471002 	movt	r1, #28674	; 0x7002
70001518:	eb0018b5 	bl	700077f4 <rt_kprintf>
7000151c:	e3a03000 	mov	r3, #0
70001520:	e54b3011 	strb	r3, [fp, #-17]
70001524:	e30a3b74 	movw	r3, #43892	; 0xab74
70001528:	e3473002 	movt	r3, #28674	; 0x7002
7000152c:	e5933000 	ldr	r3, [r3]
70001530:	e3530000 	cmp	r3, #0
70001534:	1a00000d 	bne	70001570 <rt_thread_idle_excute+0x90>
70001538:	e30602e0 	movw	r0, #25312	; 0x62e0
7000153c:	e3470002 	movt	r0, #28674	; 0x7002
70001540:	e3061300 	movw	r1, #25344	; 0x6300
70001544:	e3471002 	movt	r1, #28674	; 0x7002
70001548:	e306230c 	movw	r2, #25356	; 0x630c
7000154c:	e3472002 	movt	r2, #28674	; 0x7002
70001550:	e3a0305e 	mov	r3, #94	; 0x5e
70001554:	eb0018a6 	bl	700077f4 <rt_kprintf>
70001558:	e1a00000 	nop			; (mov r0, r0)
7000155c:	e55b3011 	ldrb	r3, [fp, #-17]
70001560:	e6ef3073 	uxtb	r3, r3
70001564:	e3530000 	cmp	r3, #0
70001568:	0afffffb 	beq	7000155c <rt_thread_idle_excute+0x7c>
7000156c:	ea000008 	b	70001594 <rt_thread_idle_excute+0xb4>
70001570:	e30a3b74 	movw	r3, #43892	; 0xab74
70001574:	e3473002 	movt	r3, #28674	; 0x7002
70001578:	e5933000 	ldr	r3, [r3]
7000157c:	e3060300 	movw	r0, #25344	; 0x6300
70001580:	e3470002 	movt	r0, #28674	; 0x7002
70001584:	e306130c 	movw	r1, #25356	; 0x630c
70001588:	e3471002 	movt	r1, #28674	; 0x7002
7000158c:	e3a0205e 	mov	r2, #94	; 0x5e
70001590:	e12fff33 	blx	r3
70001594:	e51b0008 	ldr	r0, [fp, #-8]
70001598:	eb00332d 	bl	7000e254 <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
7000159c:	eb003329 	bl	7000e248 <rt_hw_interrupt_disable>
700015a0:	e50b000c 	str	r0, [fp, #-12]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
700015a4:	ebffffbc 	bl	7000149c <_has_defunct_thread>
700015a8:	e1a03000 	mov	r3, r0
700015ac:	e3530000 	cmp	r3, #0
700015b0:	0a000018 	beq	70001618 <rt_thread_idle_excute+0x138>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
700015b4:	e30a3c90 	movw	r3, #44176	; 0xac90
700015b8:	e3473002 	movt	r3, #28674	; 0x7002
700015bc:	e5933000 	ldr	r3, [r3]
700015c0:	e2433010 	sub	r3, r3, #16
700015c4:	e50b3010 	str	r3, [fp, #-16]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
700015c8:	e51b3010 	ldr	r3, [fp, #-16]
700015cc:	e2833010 	add	r3, r3, #16
700015d0:	e1a00003 	mov	r0, r3
700015d4:	ebffff8d 	bl	70001410 <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
700015d8:	e51b3010 	ldr	r3, [fp, #-16]
700015dc:	e5933070 	ldr	r3, [r3, #112]	; 0x70
700015e0:	e3530000 	cmp	r3, #0
700015e4:	0a000003 	beq	700015f8 <rt_thread_idle_excute+0x118>
                thread->cleanup(thread);
700015e8:	e51b3010 	ldr	r3, [fp, #-16]
700015ec:	e5933070 	ldr	r3, [r3, #112]	; 0x70
700015f0:	e51b0010 	ldr	r0, [fp, #-16]
700015f4:	e12fff33 	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
700015f8:	e51b0010 	ldr	r0, [fp, #-16]
700015fc:	eb002057 	bl	70009760 <rt_object_is_systemobject>
70001600:	e1a03000 	mov	r3, r0
70001604:	e3530001 	cmp	r3, #1
70001608:	1a000005 	bne	70001624 <rt_thread_idle_excute+0x144>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
7000160c:	e51b000c 	ldr	r0, [fp, #-12]
70001610:	eb00330f 	bl	7000e254 <rt_hw_interrupt_enable>

                return;
70001614:	ea00000e 	b	70001654 <rt_thread_idle_excute+0x174>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
70001618:	e51b000c 	ldr	r0, [fp, #-12]
7000161c:	eb00330c 	bl	7000e254 <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
70001620:	ea00000b 	b	70001654 <rt_thread_idle_excute+0x174>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
70001624:	e51b000c 	ldr	r0, [fp, #-12]
70001628:	eb003309 	bl	7000e254 <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
7000162c:	e51b3010 	ldr	r3, [fp, #-16]
70001630:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70001634:	e1a00003 	mov	r0, r3
70001638:	eb001d62 	bl	70008bc8 <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
7000163c:	e51b0010 	ldr	r0, [fp, #-16]
70001640:	eb001fe7 	bl	700095e4 <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
70001644:	ebffff94 	bl	7000149c <_has_defunct_thread>
70001648:	e1a03000 	mov	r3, r0
7000164c:	e3530000 	cmp	r3, #0
70001650:	1affffa6 	bne	700014f0 <rt_thread_idle_excute+0x10>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
70001654:	e24bd004 	sub	sp, fp, #4
70001658:	e8bd8800 	pop	{fp, pc}

7000165c <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
7000165c:	e92d4800 	push	{fp, lr}
70001660:	e28db004 	add	fp, sp, #4
70001664:	e24dd008 	sub	sp, sp, #8
70001668:	e50b0008 	str	r0, [fp, #-8]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
7000166c:	e3093818 	movw	r3, #38936	; 0x9818
70001670:	e3473002 	movt	r3, #28674	; 0x7002
70001674:	e5933000 	ldr	r3, [r3]
70001678:	e3530000 	cmp	r3, #0
7000167c:	0a000003 	beq	70001690 <rt_thread_idle_entry+0x34>
            rt_thread_idle_hook();
70001680:	e3093818 	movw	r3, #38936	; 0x9818
70001684:	e3473002 	movt	r3, #28674	; 0x7002
70001688:	e5933000 	ldr	r3, [r3]
7000168c:	e12fff33 	blx	r3
        #endif

        rt_thread_idle_excute();
70001690:	ebffff92 	bl	700014e0 <rt_thread_idle_excute>
    }
70001694:	eafffff4 	b	7000166c <rt_thread_idle_entry+0x10>

70001698 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
70001698:	e92d4800 	push	{fp, lr}
7000169c:	e28db004 	add	fp, sp, #4
700016a0:	e24dd010 	sub	sp, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
700016a4:	e3093618 	movw	r3, #38424	; 0x9618
700016a8:	e3473002 	movt	r3, #28674	; 0x7002
700016ac:	e58d3000 	str	r3, [sp]
700016b0:	e3a03c02 	mov	r3, #512	; 0x200
700016b4:	e58d3004 	str	r3, [sp, #4]
700016b8:	e3a0301f 	mov	r3, #31
700016bc:	e58d3008 	str	r3, [sp, #8]
700016c0:	e3a03020 	mov	r3, #32
700016c4:	e58d300c 	str	r3, [sp, #12]
700016c8:	e30905a0 	movw	r0, #38304	; 0x95a0
700016cc:	e3470002 	movt	r0, #28674	; 0x7002
700016d0:	e3061304 	movw	r1, #25348	; 0x6304
700016d4:	e3471002 	movt	r1, #28674	; 0x7002
700016d8:	e301265c 	movw	r2, #5724	; 0x165c
700016dc:	e3472000 	movt	r2, #28672	; 0x7000
700016e0:	e3a03000 	mov	r3, #0
700016e4:	eb002343 	bl	7000a3f8 <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
700016e8:	e30905a0 	movw	r0, #38304	; 0x95a0
700016ec:	e3470002 	movt	r0, #28674	; 0x7002
700016f0:	eb0023a7 	bl	7000a594 <rt_thread_startup>
}
700016f4:	e24bd004 	sub	sp, fp, #4
700016f8:	e8bd8800 	pop	{fp, pc}

700016fc <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
700016fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70001700:	e28db000 	add	fp, sp, #0
70001704:	e24dd00c 	sub	sp, sp, #12
70001708:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
7000170c:	e51b3008 	ldr	r3, [fp, #-8]
70001710:	e51b2008 	ldr	r2, [fp, #-8]
70001714:	e5832004 	str	r2, [r3, #4]
70001718:	e51b3008 	ldr	r3, [fp, #-8]
7000171c:	e5932004 	ldr	r2, [r3, #4]
70001720:	e51b3008 	ldr	r3, [fp, #-8]
70001724:	e5832000 	str	r2, [r3]
}
70001728:	e24bd000 	sub	sp, fp, #0
7000172c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70001730:	e12fff1e 	bx	lr

70001734 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
70001734:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70001738:	e28db000 	add	fp, sp, #0
7000173c:	e24dd00c 	sub	sp, sp, #12
70001740:	e50b0008 	str	r0, [fp, #-8]
70001744:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
70001748:	e51b3008 	ldr	r3, [fp, #-8]
7000174c:	e5933004 	ldr	r3, [r3, #4]
70001750:	e51b200c 	ldr	r2, [fp, #-12]
70001754:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
70001758:	e51b3008 	ldr	r3, [fp, #-8]
7000175c:	e5932004 	ldr	r2, [r3, #4]
70001760:	e51b300c 	ldr	r3, [fp, #-12]
70001764:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
70001768:	e51b3008 	ldr	r3, [fp, #-8]
7000176c:	e51b200c 	ldr	r2, [fp, #-12]
70001770:	e5832004 	str	r2, [r3, #4]
    n->next = l;
70001774:	e51b300c 	ldr	r3, [fp, #-12]
70001778:	e51b2008 	ldr	r2, [fp, #-8]
7000177c:	e5832000 	str	r2, [r3]
}
70001780:	e24bd000 	sub	sp, fp, #0
70001784:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70001788:	e12fff1e 	bx	lr

7000178c <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
7000178c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70001790:	e28db000 	add	fp, sp, #0
70001794:	e24dd00c 	sub	sp, sp, #12
70001798:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
7000179c:	e51b3008 	ldr	r3, [fp, #-8]
700017a0:	e5932000 	ldr	r2, [r3]
700017a4:	e51b3008 	ldr	r3, [fp, #-8]
700017a8:	e1520003 	cmp	r2, r3
700017ac:	13a03000 	movne	r3, #0
700017b0:	03a03001 	moveq	r3, #1
700017b4:	e6ef3073 	uxtb	r3, r3
}
700017b8:	e1a00003 	mov	r0, r3
700017bc:	e24bd000 	sub	sp, fp, #0
700017c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700017c4:	e12fff1e 	bx	lr

700017c8 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
700017c8:	e92d4800 	push	{fp, lr}
700017cc:	e28db004 	add	fp, sp, #4
700017d0:	e24dd008 	sub	sp, sp, #8
700017d4:	e50b0008 	str	r0, [fp, #-8]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
700017d8:	e51b3008 	ldr	r3, [fp, #-8]
700017dc:	e2833010 	add	r3, r3, #16
700017e0:	e1a00003 	mov	r0, r3
700017e4:	ebffffc4 	bl	700016fc <rt_list_init>

    return RT_EOK;
700017e8:	e3a03000 	mov	r3, #0
}
700017ec:	e1a00003 	mov	r0, r3
700017f0:	e24bd004 	sub	sp, fp, #4
700017f4:	e8bd8800 	pop	{fp, pc}

700017f8 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
700017f8:	e92d4800 	push	{fp, lr}
700017fc:	e28db004 	add	fp, sp, #4
70001800:	e24dd018 	sub	sp, sp, #24
70001804:	e50b0010 	str	r0, [fp, #-16]
70001808:	e50b1014 	str	r1, [fp, #-20]
7000180c:	e1a03002 	mov	r3, r2
70001810:	e54b3015 	strb	r3, [fp, #-21]
    /* suspend thread */
    rt_thread_suspend(thread);
70001814:	e51b0014 	ldr	r0, [fp, #-20]
70001818:	eb002543 	bl	7000ad2c <rt_thread_suspend>

    switch (flag)
7000181c:	e55b3015 	ldrb	r3, [fp, #-21]
70001820:	e3530000 	cmp	r3, #0
70001824:	0a000002 	beq	70001834 <rt_ipc_list_suspend+0x3c>
70001828:	e3530001 	cmp	r3, #1
7000182c:	0a000006 	beq	7000184c <rt_ipc_list_suspend+0x54>
70001830:	ea00002c 	b	700018e8 <rt_ipc_list_suspend+0xf0>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
70001834:	e51b3014 	ldr	r3, [fp, #-20]
70001838:	e2833010 	add	r3, r3, #16
7000183c:	e51b0010 	ldr	r0, [fp, #-16]
70001840:	e1a01003 	mov	r1, r3
70001844:	ebffffba 	bl	70001734 <rt_list_insert_before>
        break;
70001848:	ea000026 	b	700018e8 <rt_ipc_list_suspend+0xf0>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
7000184c:	e51b3010 	ldr	r3, [fp, #-16]
70001850:	e5933000 	ldr	r3, [r3]
70001854:	e50b3008 	str	r3, [fp, #-8]
70001858:	ea000013 	b	700018ac <rt_ipc_list_suspend+0xb4>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
7000185c:	e51b3008 	ldr	r3, [fp, #-8]
70001860:	e2433010 	sub	r3, r3, #16
70001864:	e50b300c 	str	r3, [fp, #-12]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
70001868:	e51b3014 	ldr	r3, [fp, #-20]
7000186c:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
70001870:	e51b300c 	ldr	r3, [fp, #-12]
70001874:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
70001878:	e1520003 	cmp	r2, r3
7000187c:	2a000007 	bcs	700018a0 <rt_ipc_list_suspend+0xa8>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
70001880:	e51b300c 	ldr	r3, [fp, #-12]
70001884:	e2832010 	add	r2, r3, #16
70001888:	e51b3014 	ldr	r3, [fp, #-20]
7000188c:	e2833010 	add	r3, r3, #16
70001890:	e1a00002 	mov	r0, r2
70001894:	e1a01003 	mov	r1, r3
70001898:	ebffffa5 	bl	70001734 <rt_list_insert_before>
                    break;
7000189c:	ea000006 	b	700018bc <rt_ipc_list_suspend+0xc4>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
700018a0:	e51b3008 	ldr	r3, [fp, #-8]
700018a4:	e5933000 	ldr	r3, [r3]
700018a8:	e50b3008 	str	r3, [fp, #-8]
700018ac:	e51b2008 	ldr	r2, [fp, #-8]
700018b0:	e51b3010 	ldr	r3, [fp, #-16]
700018b4:	e1520003 	cmp	r2, r3
700018b8:	1affffe7 	bne	7000185c <rt_ipc_list_suspend+0x64>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
700018bc:	e51b2008 	ldr	r2, [fp, #-8]
700018c0:	e51b3010 	ldr	r3, [fp, #-16]
700018c4:	e1520003 	cmp	r2, r3
700018c8:	1a000005 	bne	700018e4 <rt_ipc_list_suspend+0xec>
                rt_list_insert_before(list, &(thread->tlist));
700018cc:	e51b3014 	ldr	r3, [fp, #-20]
700018d0:	e2833010 	add	r3, r3, #16
700018d4:	e51b0010 	ldr	r0, [fp, #-16]
700018d8:	e1a01003 	mov	r1, r3
700018dc:	ebffff94 	bl	70001734 <rt_list_insert_before>
        }
        break;
700018e0:	eaffffff 	b	700018e4 <rt_ipc_list_suspend+0xec>
700018e4:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
700018e8:	e3a03000 	mov	r3, #0
}
700018ec:	e1a00003 	mov	r0, r3
700018f0:	e24bd004 	sub	sp, fp, #4
700018f4:	e8bd8800 	pop	{fp, pc}

700018f8 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
700018f8:	e92d4800 	push	{fp, lr}
700018fc:	e28db004 	add	fp, sp, #4
70001900:	e24dd010 	sub	sp, sp, #16
70001904:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
70001908:	e51b3010 	ldr	r3, [fp, #-16]
7000190c:	e5933000 	ldr	r3, [r3]
70001910:	e2433010 	sub	r3, r3, #16
70001914:	e50b3008 	str	r3, [fp, #-8]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
70001918:	e51b0008 	ldr	r0, [fp, #-8]
7000191c:	eb00253f 	bl	7000ae20 <rt_thread_resume>

    return RT_EOK;
70001920:	e3a03000 	mov	r3, #0
}
70001924:	e1a00003 	mov	r0, r3
70001928:	e24bd004 	sub	sp, fp, #4
7000192c:	e8bd8800 	pop	{fp, pc}

70001930 <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
70001930:	e92d4810 	push	{r4, fp, lr}
70001934:	e28db008 	add	fp, sp, #8
70001938:	e24dd014 	sub	sp, sp, #20
7000193c:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
70001940:	ea00000e 	b	70001980 <rt_ipc_list_resume_all+0x50>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70001944:	eb00323f 	bl	7000e248 <rt_hw_interrupt_disable>
70001948:	e1a03000 	mov	r3, r0
7000194c:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
70001950:	e51b3018 	ldr	r3, [fp, #-24]
70001954:	e5933000 	ldr	r3, [r3]
70001958:	e2433010 	sub	r3, r3, #16
7000195c:	e50b3010 	str	r3, [fp, #-16]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
70001960:	e51b3010 	ldr	r3, [fp, #-16]
70001964:	e3e02000 	mvn	r2, #0
70001968:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
7000196c:	e51b0010 	ldr	r0, [fp, #-16]
70001970:	eb00252a 	bl	7000ae20 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70001974:	e1a03004 	mov	r3, r4
70001978:	e1a00003 	mov	r0, r3
7000197c:	eb003234 	bl	7000e254 <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
70001980:	e51b0018 	ldr	r0, [fp, #-24]
70001984:	ebffff80 	bl	7000178c <rt_list_isempty>
70001988:	e1a03000 	mov	r3, r0
7000198c:	e3530000 	cmp	r3, #0
70001990:	0affffeb 	beq	70001944 <rt_ipc_list_resume_all+0x14>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
70001994:	e3a03000 	mov	r3, #0
}
70001998:	e1a00003 	mov	r0, r3
7000199c:	e24bd008 	sub	sp, fp, #8
700019a0:	e8bd8810 	pop	{r4, fp, pc}

700019a4 <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
700019a4:	e92d4800 	push	{fp, lr}
700019a8:	e28db004 	add	fp, sp, #4
700019ac:	e24dd018 	sub	sp, sp, #24
700019b0:	e50b0010 	str	r0, [fp, #-16]
700019b4:	e50b1014 	str	r1, [fp, #-20]
700019b8:	e50b2018 	str	r2, [fp, #-24]
700019bc:	e54b3019 	strb	r3, [fp, #-25]
    RT_ASSERT(sem != RT_NULL);
700019c0:	e51b3010 	ldr	r3, [fp, #-16]
700019c4:	e3530000 	cmp	r3, #0
700019c8:	1a00001d 	bne	70001a44 <rt_sem_init+0xa0>
700019cc:	e3a03000 	mov	r3, #0
700019d0:	e54b3005 	strb	r3, [fp, #-5]
700019d4:	e30a3b74 	movw	r3, #43892	; 0xab74
700019d8:	e3473002 	movt	r3, #28674	; 0x7002
700019dc:	e5933000 	ldr	r3, [r3]
700019e0:	e3530000 	cmp	r3, #0
700019e4:	1a00000d 	bne	70001a20 <rt_sem_init+0x7c>
700019e8:	e3060324 	movw	r0, #25380	; 0x6324
700019ec:	e3470002 	movt	r0, #28674	; 0x7002
700019f0:	e3061344 	movw	r1, #25412	; 0x6344
700019f4:	e3471002 	movt	r1, #28674	; 0x7002
700019f8:	e306241c 	movw	r2, #25628	; 0x641c
700019fc:	e3472002 	movt	r2, #28674	; 0x7002
70001a00:	e3a030d8 	mov	r3, #216	; 0xd8
70001a04:	eb00177a 	bl	700077f4 <rt_kprintf>
70001a08:	e1a00000 	nop			; (mov r0, r0)
70001a0c:	e55b3005 	ldrb	r3, [fp, #-5]
70001a10:	e6ef3073 	uxtb	r3, r3
70001a14:	e3530000 	cmp	r3, #0
70001a18:	0afffffb 	beq	70001a0c <rt_sem_init+0x68>
70001a1c:	ea000008 	b	70001a44 <rt_sem_init+0xa0>
70001a20:	e30a3b74 	movw	r3, #43892	; 0xab74
70001a24:	e3473002 	movt	r3, #28674	; 0x7002
70001a28:	e5933000 	ldr	r3, [r3]
70001a2c:	e3060344 	movw	r0, #25412	; 0x6344
70001a30:	e3470002 	movt	r0, #28674	; 0x7002
70001a34:	e306141c 	movw	r1, #25628	; 0x641c
70001a38:	e3471002 	movt	r1, #28674	; 0x7002
70001a3c:	e3a020d8 	mov	r2, #216	; 0xd8
70001a40:	e12fff33 	blx	r3

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
70001a44:	e51b3010 	ldr	r3, [fp, #-16]
70001a48:	e1a00003 	mov	r0, r3
70001a4c:	e3a01001 	mov	r1, #1
70001a50:	e51b2014 	ldr	r2, [fp, #-20]
70001a54:	eb001e15 	bl	700092b0 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
70001a58:	e51b3010 	ldr	r3, [fp, #-16]
70001a5c:	e1a00003 	mov	r0, r3
70001a60:	ebffff58 	bl	700017c8 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
70001a64:	e51b3018 	ldr	r3, [fp, #-24]
70001a68:	e6ff2073 	uxth	r2, r3
70001a6c:	e51b3010 	ldr	r3, [fp, #-16]
70001a70:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
70001a74:	e51b3010 	ldr	r3, [fp, #-16]
70001a78:	e55b2019 	ldrb	r2, [fp, #-25]
70001a7c:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
70001a80:	e3a03000 	mov	r3, #0
}
70001a84:	e1a00003 	mov	r0, r3
70001a88:	e24bd004 	sub	sp, fp, #4
70001a8c:	e8bd8800 	pop	{fp, pc}

70001a90 <rt_sem_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_sem_delete
 */
rt_err_t rt_sem_detach(rt_sem_t sem)
{
70001a90:	e92d4800 	push	{fp, lr}
70001a94:	e28db004 	add	fp, sp, #4
70001a98:	e24dd010 	sub	sp, sp, #16
70001a9c:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(sem != RT_NULL);
70001aa0:	e51b3010 	ldr	r3, [fp, #-16]
70001aa4:	e3530000 	cmp	r3, #0
70001aa8:	1a00001d 	bne	70001b24 <rt_sem_detach+0x94>
70001aac:	e3a03000 	mov	r3, #0
70001ab0:	e54b3005 	strb	r3, [fp, #-5]
70001ab4:	e30a3b74 	movw	r3, #43892	; 0xab74
70001ab8:	e3473002 	movt	r3, #28674	; 0x7002
70001abc:	e5933000 	ldr	r3, [r3]
70001ac0:	e3530000 	cmp	r3, #0
70001ac4:	1a00000d 	bne	70001b00 <rt_sem_detach+0x70>
70001ac8:	e3060324 	movw	r0, #25380	; 0x6324
70001acc:	e3470002 	movt	r0, #28674	; 0x7002
70001ad0:	e3061344 	movw	r1, #25412	; 0x6344
70001ad4:	e3471002 	movt	r1, #28674	; 0x7002
70001ad8:	e3062428 	movw	r2, #25640	; 0x6428
70001adc:	e3472002 	movt	r2, #28674	; 0x7002
70001ae0:	e3a030f5 	mov	r3, #245	; 0xf5
70001ae4:	eb001742 	bl	700077f4 <rt_kprintf>
70001ae8:	e1a00000 	nop			; (mov r0, r0)
70001aec:	e55b3005 	ldrb	r3, [fp, #-5]
70001af0:	e6ef3073 	uxtb	r3, r3
70001af4:	e3530000 	cmp	r3, #0
70001af8:	0afffffb 	beq	70001aec <rt_sem_detach+0x5c>
70001afc:	ea000008 	b	70001b24 <rt_sem_detach+0x94>
70001b00:	e30a3b74 	movw	r3, #43892	; 0xab74
70001b04:	e3473002 	movt	r3, #28674	; 0x7002
70001b08:	e5933000 	ldr	r3, [r3]
70001b0c:	e3060344 	movw	r0, #25412	; 0x6344
70001b10:	e3470002 	movt	r0, #28674	; 0x7002
70001b14:	e3061428 	movw	r1, #25640	; 0x6428
70001b18:	e3471002 	movt	r1, #28674	; 0x7002
70001b1c:	e3a020f5 	mov	r2, #245	; 0xf5
70001b20:	e12fff33 	blx	r3

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
70001b24:	e51b3010 	ldr	r3, [fp, #-16]
70001b28:	e2833010 	add	r3, r3, #16
70001b2c:	e1a00003 	mov	r0, r3
70001b30:	ebffff7e 	bl	70001930 <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(sem->parent.parent));
70001b34:	e51b3010 	ldr	r3, [fp, #-16]
70001b38:	e1a00003 	mov	r0, r3
70001b3c:	eb001e0a 	bl	7000936c <rt_object_detach>

    return RT_EOK;
70001b40:	e3a03000 	mov	r3, #0
}
70001b44:	e1a00003 	mov	r0, r3
70001b48:	e24bd004 	sub	sp, fp, #4
70001b4c:	e8bd8800 	pop	{fp, pc}

70001b50 <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
70001b50:	e92d4800 	push	{fp, lr}
70001b54:	e28db004 	add	fp, sp, #4
70001b58:	e24dd020 	sub	sp, sp, #32
70001b5c:	e50b0018 	str	r0, [fp, #-24]
70001b60:	e50b101c 	str	r1, [fp, #-28]
70001b64:	e1a03002 	mov	r3, r2
70001b68:	e54b301d 	strb	r3, [fp, #-29]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
70001b6c:	eb0031b5 	bl	7000e248 <rt_hw_interrupt_disable>
70001b70:	e50b0008 	str	r0, [fp, #-8]
70001b74:	eb0010ce 	bl	70005eb4 <rt_interrupt_get_nest>
70001b78:	e1a03000 	mov	r3, r0
70001b7c:	e3530000 	cmp	r3, #0
70001b80:	0a000022 	beq	70001c10 <rt_sem_create+0xc0>
70001b84:	e3060354 	movw	r0, #25428	; 0x6354
70001b88:	e3470002 	movt	r0, #28674	; 0x7002
70001b8c:	e3061438 	movw	r1, #25656	; 0x6438
70001b90:	e3471002 	movt	r1, #28674	; 0x7002
70001b94:	eb001716 	bl	700077f4 <rt_kprintf>
70001b98:	e3a03000 	mov	r3, #0
70001b9c:	e54b300d 	strb	r3, [fp, #-13]
70001ba0:	e30a3b74 	movw	r3, #43892	; 0xab74
70001ba4:	e3473002 	movt	r3, #28674	; 0x7002
70001ba8:	e5933000 	ldr	r3, [r3]
70001bac:	e3530000 	cmp	r3, #0
70001bb0:	1a00000d 	bne	70001bec <rt_sem_create+0x9c>
70001bb4:	e3060324 	movw	r0, #25380	; 0x6324
70001bb8:	e3470002 	movt	r0, #28674	; 0x7002
70001bbc:	e3061378 	movw	r1, #25464	; 0x6378
70001bc0:	e3471002 	movt	r1, #28674	; 0x7002
70001bc4:	e3062438 	movw	r2, #25656	; 0x6438
70001bc8:	e3472002 	movt	r2, #28674	; 0x7002
70001bcc:	e3003111 	movw	r3, #273	; 0x111
70001bd0:	eb001707 	bl	700077f4 <rt_kprintf>
70001bd4:	e1a00000 	nop			; (mov r0, r0)
70001bd8:	e55b300d 	ldrb	r3, [fp, #-13]
70001bdc:	e6ef3073 	uxtb	r3, r3
70001be0:	e3530000 	cmp	r3, #0
70001be4:	0afffffb 	beq	70001bd8 <rt_sem_create+0x88>
70001be8:	ea000008 	b	70001c10 <rt_sem_create+0xc0>
70001bec:	e30a3b74 	movw	r3, #43892	; 0xab74
70001bf0:	e3473002 	movt	r3, #28674	; 0x7002
70001bf4:	e5933000 	ldr	r3, [r3]
70001bf8:	e3060378 	movw	r0, #25464	; 0x6378
70001bfc:	e3470002 	movt	r0, #28674	; 0x7002
70001c00:	e3061438 	movw	r1, #25656	; 0x6438
70001c04:	e3471002 	movt	r1, #28674	; 0x7002
70001c08:	e3002111 	movw	r2, #273	; 0x111
70001c0c:	e12fff33 	blx	r3
70001c10:	e51b0008 	ldr	r0, [fp, #-8]
70001c14:	eb00318e 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
70001c18:	e3a00001 	mov	r0, #1
70001c1c:	e51b1018 	ldr	r1, [fp, #-24]
70001c20:	eb001e0a 	bl	70009450 <rt_object_allocate>
70001c24:	e50b000c 	str	r0, [fp, #-12]
    if (sem == RT_NULL)
70001c28:	e51b300c 	ldr	r3, [fp, #-12]
70001c2c:	e3530000 	cmp	r3, #0
70001c30:	1a000001 	bne	70001c3c <rt_sem_create+0xec>
        return sem;
70001c34:	e51b300c 	ldr	r3, [fp, #-12]
70001c38:	ea00000a 	b	70001c68 <rt_sem_create+0x118>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
70001c3c:	e51b300c 	ldr	r3, [fp, #-12]
70001c40:	e1a00003 	mov	r0, r3
70001c44:	ebfffedf 	bl	700017c8 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
70001c48:	e51b301c 	ldr	r3, [fp, #-28]
70001c4c:	e6ff2073 	uxth	r2, r3
70001c50:	e51b300c 	ldr	r3, [fp, #-12]
70001c54:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
70001c58:	e51b300c 	ldr	r3, [fp, #-12]
70001c5c:	e55b201d 	ldrb	r2, [fp, #-29]
70001c60:	e5c32007 	strb	r2, [r3, #7]

    return sem;
70001c64:	e51b300c 	ldr	r3, [fp, #-12]
}
70001c68:	e1a00003 	mov	r0, r3
70001c6c:	e24bd004 	sub	sp, fp, #4
70001c70:	e8bd8800 	pop	{fp, pc}

70001c74 <rt_sem_delete>:
 * @return the error code
 *
 * @see rt_sem_detach
 */
rt_err_t rt_sem_delete(rt_sem_t sem)
{
70001c74:	e92d4800 	push	{fp, lr}
70001c78:	e28db004 	add	fp, sp, #4
70001c7c:	e24dd010 	sub	sp, sp, #16
70001c80:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
70001c84:	eb00316f 	bl	7000e248 <rt_hw_interrupt_disable>
70001c88:	e50b0008 	str	r0, [fp, #-8]
70001c8c:	eb001088 	bl	70005eb4 <rt_interrupt_get_nest>
70001c90:	e1a03000 	mov	r3, r0
70001c94:	e3530000 	cmp	r3, #0
70001c98:	0a000022 	beq	70001d28 <rt_sem_delete+0xb4>
70001c9c:	e3060354 	movw	r0, #25428	; 0x6354
70001ca0:	e3470002 	movt	r0, #28674	; 0x7002
70001ca4:	e3061448 	movw	r1, #25672	; 0x6448
70001ca8:	e3471002 	movt	r1, #28674	; 0x7002
70001cac:	eb0016d0 	bl	700077f4 <rt_kprintf>
70001cb0:	e3a03000 	mov	r3, #0
70001cb4:	e54b3009 	strb	r3, [fp, #-9]
70001cb8:	e30a3b74 	movw	r3, #43892	; 0xab74
70001cbc:	e3473002 	movt	r3, #28674	; 0x7002
70001cc0:	e5933000 	ldr	r3, [r3]
70001cc4:	e3530000 	cmp	r3, #0
70001cc8:	1a00000d 	bne	70001d04 <rt_sem_delete+0x90>
70001ccc:	e3060324 	movw	r0, #25380	; 0x6324
70001cd0:	e3470002 	movt	r0, #28674	; 0x7002
70001cd4:	e3061378 	movw	r1, #25464	; 0x6378
70001cd8:	e3471002 	movt	r1, #28674	; 0x7002
70001cdc:	e3062448 	movw	r2, #25672	; 0x6448
70001ce0:	e3472002 	movt	r2, #28674	; 0x7002
70001ce4:	e3a03e13 	mov	r3, #304	; 0x130
70001ce8:	eb0016c1 	bl	700077f4 <rt_kprintf>
70001cec:	e1a00000 	nop			; (mov r0, r0)
70001cf0:	e55b3009 	ldrb	r3, [fp, #-9]
70001cf4:	e6ef3073 	uxtb	r3, r3
70001cf8:	e3530000 	cmp	r3, #0
70001cfc:	0afffffb 	beq	70001cf0 <rt_sem_delete+0x7c>
70001d00:	ea000008 	b	70001d28 <rt_sem_delete+0xb4>
70001d04:	e30a3b74 	movw	r3, #43892	; 0xab74
70001d08:	e3473002 	movt	r3, #28674	; 0x7002
70001d0c:	e5933000 	ldr	r3, [r3]
70001d10:	e3060378 	movw	r0, #25464	; 0x6378
70001d14:	e3470002 	movt	r0, #28674	; 0x7002
70001d18:	e3061448 	movw	r1, #25672	; 0x6448
70001d1c:	e3471002 	movt	r1, #28674	; 0x7002
70001d20:	e3a02e13 	mov	r2, #304	; 0x130
70001d24:	e12fff33 	blx	r3
70001d28:	e51b0008 	ldr	r0, [fp, #-8]
70001d2c:	eb003148 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_ASSERT(sem != RT_NULL);
70001d30:	e51b3010 	ldr	r3, [fp, #-16]
70001d34:	e3530000 	cmp	r3, #0
70001d38:	1a00001d 	bne	70001db4 <rt_sem_delete+0x140>
70001d3c:	e3a03000 	mov	r3, #0
70001d40:	e54b300a 	strb	r3, [fp, #-10]
70001d44:	e30a3b74 	movw	r3, #43892	; 0xab74
70001d48:	e3473002 	movt	r3, #28674	; 0x7002
70001d4c:	e5933000 	ldr	r3, [r3]
70001d50:	e3530000 	cmp	r3, #0
70001d54:	1a00000d 	bne	70001d90 <rt_sem_delete+0x11c>
70001d58:	e3060324 	movw	r0, #25380	; 0x6324
70001d5c:	e3470002 	movt	r0, #28674	; 0x7002
70001d60:	e3061344 	movw	r1, #25412	; 0x6344
70001d64:	e3471002 	movt	r1, #28674	; 0x7002
70001d68:	e3062448 	movw	r2, #25672	; 0x6448
70001d6c:	e3472002 	movt	r2, #28674	; 0x7002
70001d70:	e3003132 	movw	r3, #306	; 0x132
70001d74:	eb00169e 	bl	700077f4 <rt_kprintf>
70001d78:	e1a00000 	nop			; (mov r0, r0)
70001d7c:	e55b300a 	ldrb	r3, [fp, #-10]
70001d80:	e6ef3073 	uxtb	r3, r3
70001d84:	e3530000 	cmp	r3, #0
70001d88:	0afffffb 	beq	70001d7c <rt_sem_delete+0x108>
70001d8c:	ea000008 	b	70001db4 <rt_sem_delete+0x140>
70001d90:	e30a3b74 	movw	r3, #43892	; 0xab74
70001d94:	e3473002 	movt	r3, #28674	; 0x7002
70001d98:	e5933000 	ldr	r3, [r3]
70001d9c:	e3060344 	movw	r0, #25412	; 0x6344
70001da0:	e3470002 	movt	r0, #28674	; 0x7002
70001da4:	e3061448 	movw	r1, #25672	; 0x6448
70001da8:	e3471002 	movt	r1, #28674	; 0x7002
70001dac:	e3002132 	movw	r2, #306	; 0x132
70001db0:	e12fff33 	blx	r3

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
70001db4:	e51b3010 	ldr	r3, [fp, #-16]
70001db8:	e2833010 	add	r3, r3, #16
70001dbc:	e1a00003 	mov	r0, r3
70001dc0:	ebfffeda 	bl	70001930 <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(sem->parent.parent));
70001dc4:	e51b3010 	ldr	r3, [fp, #-16]
70001dc8:	e1a00003 	mov	r0, r3
70001dcc:	eb001e04 	bl	700095e4 <rt_object_delete>

    return RT_EOK;
70001dd0:	e3a03000 	mov	r3, #0
}
70001dd4:	e1a00003 	mov	r0, r3
70001dd8:	e24bd004 	sub	sp, fp, #4
70001ddc:	e8bd8800 	pop	{fp, pc}

70001de0 <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
70001de0:	e92d4810 	push	{r4, fp, lr}
70001de4:	e28db008 	add	fp, sp, #8
70001de8:	e24dd01c 	sub	sp, sp, #28
70001dec:	e50b0020 	str	r0, [fp, #-32]
70001df0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
70001df4:	e51b3020 	ldr	r3, [fp, #-32]
70001df8:	e3530000 	cmp	r3, #0
70001dfc:	1a00001d 	bne	70001e78 <rt_sem_take+0x98>
70001e00:	e3a03000 	mov	r3, #0
70001e04:	e54b3019 	strb	r3, [fp, #-25]
70001e08:	e30a3b74 	movw	r3, #43892	; 0xab74
70001e0c:	e3473002 	movt	r3, #28674	; 0x7002
70001e10:	e5933000 	ldr	r3, [r3]
70001e14:	e3530000 	cmp	r3, #0
70001e18:	1a00000d 	bne	70001e54 <rt_sem_take+0x74>
70001e1c:	e3060324 	movw	r0, #25380	; 0x6324
70001e20:	e3470002 	movt	r0, #28674	; 0x7002
70001e24:	e3061344 	movw	r1, #25412	; 0x6344
70001e28:	e3471002 	movt	r1, #28674	; 0x7002
70001e2c:	e3062458 	movw	r2, #25688	; 0x6458
70001e30:	e3472002 	movt	r2, #28674	; 0x7002
70001e34:	e300314d 	movw	r3, #333	; 0x14d
70001e38:	eb00166d 	bl	700077f4 <rt_kprintf>
70001e3c:	e1a00000 	nop			; (mov r0, r0)
70001e40:	e55b3019 	ldrb	r3, [fp, #-25]
70001e44:	e6ef3073 	uxtb	r3, r3
70001e48:	e3530000 	cmp	r3, #0
70001e4c:	0afffffb 	beq	70001e40 <rt_sem_take+0x60>
70001e50:	ea000008 	b	70001e78 <rt_sem_take+0x98>
70001e54:	e30a3b74 	movw	r3, #43892	; 0xab74
70001e58:	e3473002 	movt	r3, #28674	; 0x7002
70001e5c:	e5933000 	ldr	r3, [r3]
70001e60:	e3060344 	movw	r0, #25412	; 0x6344
70001e64:	e3470002 	movt	r0, #28674	; 0x7002
70001e68:	e3061458 	movw	r1, #25688	; 0x6458
70001e6c:	e3471002 	movt	r1, #28674	; 0x7002
70001e70:	e300214d 	movw	r2, #333	; 0x14d
70001e74:	e12fff33 	blx	r3

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
70001e78:	e30a3b80 	movw	r3, #43904	; 0xab80
70001e7c:	e3473002 	movt	r3, #28674	; 0x7002
70001e80:	e5933000 	ldr	r3, [r3]
70001e84:	e3530000 	cmp	r3, #0
70001e88:	0a000005 	beq	70001ea4 <rt_sem_take+0xc4>
70001e8c:	e30a3b80 	movw	r3, #43904	; 0xab80
70001e90:	e3473002 	movt	r3, #28674	; 0x7002
70001e94:	e5933000 	ldr	r3, [r3]
70001e98:	e51b2020 	ldr	r2, [fp, #-32]
70001e9c:	e1a00002 	mov	r0, r2
70001ea0:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70001ea4:	eb0030e7 	bl	7000e248 <rt_hw_interrupt_disable>
70001ea8:	e1a04000 	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
70001eac:	e51b3020 	ldr	r3, [fp, #-32]
70001eb0:	e1d331b8 	ldrh	r3, [r3, #24]
70001eb4:	e3530000 	cmp	r3, #0
70001eb8:	0a000008 	beq	70001ee0 <rt_sem_take+0x100>
    {
        /* semaphore is available */
        sem->value --;
70001ebc:	e51b3020 	ldr	r3, [fp, #-32]
70001ec0:	e1d331b8 	ldrh	r3, [r3, #24]
70001ec4:	e2433001 	sub	r3, r3, #1
70001ec8:	e6ff2073 	uxth	r2, r3
70001ecc:	e51b3020 	ldr	r3, [fp, #-32]
70001ed0:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70001ed4:	e1a00004 	mov	r0, r4
70001ed8:	eb0030dd 	bl	7000e254 <rt_hw_interrupt_enable>
70001edc:	ea000081 	b	700020e8 <rt_sem_take+0x308>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
70001ee0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70001ee4:	e3530000 	cmp	r3, #0
70001ee8:	1a000003 	bne	70001efc <rt_sem_take+0x11c>
        {
            rt_hw_interrupt_enable(temp);
70001eec:	e1a00004 	mov	r0, r4
70001ef0:	eb0030d7 	bl	7000e254 <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
70001ef4:	e3e03001 	mvn	r3, #1
70001ef8:	ea000086 	b	70002118 <rt_sem_take+0x338>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
70001efc:	eb0030d1 	bl	7000e248 <rt_hw_interrupt_disable>
70001f00:	e50b0010 	str	r0, [fp, #-16]
70001f04:	eb002199 	bl	7000a570 <rt_thread_self>
70001f08:	e1a03000 	mov	r3, r0
70001f0c:	e3530000 	cmp	r3, #0
70001f10:	1a000022 	bne	70001fa0 <rt_sem_take+0x1c0>
70001f14:	e306037c 	movw	r0, #25468	; 0x637c
70001f18:	e3470002 	movt	r0, #28674	; 0x7002
70001f1c:	e3061458 	movw	r1, #25688	; 0x6458
70001f20:	e3471002 	movt	r1, #28674	; 0x7002
70001f24:	eb001632 	bl	700077f4 <rt_kprintf>
70001f28:	e3a03000 	mov	r3, #0
70001f2c:	e54b301a 	strb	r3, [fp, #-26]
70001f30:	e30a3b74 	movw	r3, #43892	; 0xab74
70001f34:	e3473002 	movt	r3, #28674	; 0x7002
70001f38:	e5933000 	ldr	r3, [r3]
70001f3c:	e3530000 	cmp	r3, #0
70001f40:	1a00000d 	bne	70001f7c <rt_sem_take+0x19c>
70001f44:	e3060324 	movw	r0, #25380	; 0x6324
70001f48:	e3470002 	movt	r0, #28674	; 0x7002
70001f4c:	e3061378 	movw	r1, #25464	; 0x6378
70001f50:	e3471002 	movt	r1, #28674	; 0x7002
70001f54:	e3062458 	movw	r2, #25688	; 0x6458
70001f58:	e3472002 	movt	r2, #28674	; 0x7002
70001f5c:	e300316d 	movw	r3, #365	; 0x16d
70001f60:	eb001623 	bl	700077f4 <rt_kprintf>
70001f64:	e1a00000 	nop			; (mov r0, r0)
70001f68:	e55b301a 	ldrb	r3, [fp, #-26]
70001f6c:	e6ef3073 	uxtb	r3, r3
70001f70:	e3530000 	cmp	r3, #0
70001f74:	0afffffb 	beq	70001f68 <rt_sem_take+0x188>
70001f78:	ea000008 	b	70001fa0 <rt_sem_take+0x1c0>
70001f7c:	e30a3b74 	movw	r3, #43892	; 0xab74
70001f80:	e3473002 	movt	r3, #28674	; 0x7002
70001f84:	e5933000 	ldr	r3, [r3]
70001f88:	e3060378 	movw	r0, #25464	; 0x6378
70001f8c:	e3470002 	movt	r0, #28674	; 0x7002
70001f90:	e3061458 	movw	r1, #25688	; 0x6458
70001f94:	e3471002 	movt	r1, #28674	; 0x7002
70001f98:	e300216d 	movw	r2, #365	; 0x16d
70001f9c:	e12fff33 	blx	r3
70001fa0:	eb0030a8 	bl	7000e248 <rt_hw_interrupt_disable>
70001fa4:	e50b0014 	str	r0, [fp, #-20]
70001fa8:	eb000fc1 	bl	70005eb4 <rt_interrupt_get_nest>
70001fac:	e1a03000 	mov	r3, r0
70001fb0:	e3530000 	cmp	r3, #0
70001fb4:	0a000022 	beq	70002044 <rt_sem_take+0x264>
70001fb8:	e3060354 	movw	r0, #25428	; 0x6354
70001fbc:	e3470002 	movt	r0, #28674	; 0x7002
70001fc0:	e3061458 	movw	r1, #25688	; 0x6458
70001fc4:	e3471002 	movt	r1, #28674	; 0x7002
70001fc8:	eb001609 	bl	700077f4 <rt_kprintf>
70001fcc:	e3a03000 	mov	r3, #0
70001fd0:	e54b301b 	strb	r3, [fp, #-27]
70001fd4:	e30a3b74 	movw	r3, #43892	; 0xab74
70001fd8:	e3473002 	movt	r3, #28674	; 0x7002
70001fdc:	e5933000 	ldr	r3, [r3]
70001fe0:	e3530000 	cmp	r3, #0
70001fe4:	1a00000d 	bne	70002020 <rt_sem_take+0x240>
70001fe8:	e3060324 	movw	r0, #25380	; 0x6324
70001fec:	e3470002 	movt	r0, #28674	; 0x7002
70001ff0:	e3061378 	movw	r1, #25464	; 0x6378
70001ff4:	e3471002 	movt	r1, #28674	; 0x7002
70001ff8:	e3062458 	movw	r2, #25688	; 0x6458
70001ffc:	e3472002 	movt	r2, #28674	; 0x7002
70002000:	e300316d 	movw	r3, #365	; 0x16d
70002004:	eb0015fa 	bl	700077f4 <rt_kprintf>
70002008:	e1a00000 	nop			; (mov r0, r0)
7000200c:	e55b301b 	ldrb	r3, [fp, #-27]
70002010:	e6ef3073 	uxtb	r3, r3
70002014:	e3530000 	cmp	r3, #0
70002018:	0afffffb 	beq	7000200c <rt_sem_take+0x22c>
7000201c:	ea000008 	b	70002044 <rt_sem_take+0x264>
70002020:	e30a3b74 	movw	r3, #43892	; 0xab74
70002024:	e3473002 	movt	r3, #28674	; 0x7002
70002028:	e5933000 	ldr	r3, [r3]
7000202c:	e3060378 	movw	r0, #25464	; 0x6378
70002030:	e3470002 	movt	r0, #28674	; 0x7002
70002034:	e3061458 	movw	r1, #25688	; 0x6458
70002038:	e3471002 	movt	r1, #28674	; 0x7002
7000203c:	e300216d 	movw	r2, #365	; 0x16d
70002040:	e12fff33 	blx	r3
70002044:	e51b0014 	ldr	r0, [fp, #-20]
70002048:	eb003081 	bl	7000e254 <rt_hw_interrupt_enable>
7000204c:	e51b0010 	ldr	r0, [fp, #-16]
70002050:	eb00307f 	bl	7000e254 <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
70002054:	eb002145 	bl	7000a570 <rt_thread_self>
70002058:	e50b0018 	str	r0, [fp, #-24]

            /* reset thread error number */
            thread->error = RT_EOK;
7000205c:	e51b3018 	ldr	r3, [fp, #-24]
70002060:	e3a02000 	mov	r2, #0
70002064:	e583202c 	str	r2, [r3, #44]	; 0x2c

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
70002068:	e51b3020 	ldr	r3, [fp, #-32]
7000206c:	e2832010 	add	r2, r3, #16
70002070:	e51b3020 	ldr	r3, [fp, #-32]
70002074:	e5d33007 	ldrb	r3, [r3, #7]
70002078:	e1a00002 	mov	r0, r2
7000207c:	e51b1018 	ldr	r1, [fp, #-24]
70002080:	e1a02003 	mov	r2, r3
70002084:	ebfffddb 	bl	700017f8 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
70002088:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7000208c:	e3530000 	cmp	r3, #0
70002090:	da00000a 	ble	700020c0 <rt_sem_take+0x2e0>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
70002094:	e51b3018 	ldr	r3, [fp, #-24]
70002098:	e2832048 	add	r2, r3, #72	; 0x48
7000209c:	e24b3024 	sub	r3, fp, #36	; 0x24
700020a0:	e1a00002 	mov	r0, r2
700020a4:	e3a01000 	mov	r1, #0
700020a8:	e1a02003 	mov	r2, r3
700020ac:	eb0026cd 	bl	7000bbe8 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
700020b0:	e51b3018 	ldr	r3, [fp, #-24]
700020b4:	e2833048 	add	r3, r3, #72	; 0x48
700020b8:	e1a00003 	mov	r0, r3
700020bc:	eb00257d 	bl	7000b6b8 <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
700020c0:	e1a00004 	mov	r0, r4
700020c4:	eb003062 	bl	7000e254 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
700020c8:	eb001ec5 	bl	70009be4 <rt_schedule>

            if (thread->error != RT_EOK)
700020cc:	e51b3018 	ldr	r3, [fp, #-24]
700020d0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
700020d4:	e3530000 	cmp	r3, #0
700020d8:	0a000002 	beq	700020e8 <rt_sem_take+0x308>
            {
                return thread->error;
700020dc:	e51b3018 	ldr	r3, [fp, #-24]
700020e0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
700020e4:	ea00000b 	b	70002118 <rt_sem_take+0x338>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
700020e8:	e30a3b7c 	movw	r3, #43900	; 0xab7c
700020ec:	e3473002 	movt	r3, #28674	; 0x7002
700020f0:	e5933000 	ldr	r3, [r3]
700020f4:	e3530000 	cmp	r3, #0
700020f8:	0a000005 	beq	70002114 <rt_sem_take+0x334>
700020fc:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70002100:	e3473002 	movt	r3, #28674	; 0x7002
70002104:	e5933000 	ldr	r3, [r3]
70002108:	e51b2020 	ldr	r2, [fp, #-32]
7000210c:	e1a00002 	mov	r0, r2
70002110:	e12fff33 	blx	r3

    return RT_EOK;
70002114:	e3a03000 	mov	r3, #0
}
70002118:	e1a00003 	mov	r0, r3
7000211c:	e24bd008 	sub	sp, fp, #8
70002120:	e8bd8810 	pop	{r4, fp, pc}

70002124 <rt_sem_trytake>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_trytake(rt_sem_t sem)
{
70002124:	e92d4800 	push	{fp, lr}
70002128:	e28db004 	add	fp, sp, #4
7000212c:	e24dd008 	sub	sp, sp, #8
70002130:	e50b0008 	str	r0, [fp, #-8]
    return rt_sem_take(sem, 0);
70002134:	e51b0008 	ldr	r0, [fp, #-8]
70002138:	e3a01000 	mov	r1, #0
7000213c:	ebffff27 	bl	70001de0 <rt_sem_take>
70002140:	e1a03000 	mov	r3, r0
}
70002144:	e1a00003 	mov	r0, r3
70002148:	e24bd004 	sub	sp, fp, #4
7000214c:	e8bd8800 	pop	{fp, pc}

70002150 <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
70002150:	e92d4830 	push	{r4, r5, fp, lr}
70002154:	e28db00c 	add	fp, sp, #12
70002158:	e24dd008 	sub	sp, sp, #8
7000215c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
70002160:	e30a3b78 	movw	r3, #43896	; 0xab78
70002164:	e3473002 	movt	r3, #28674	; 0x7002
70002168:	e5933000 	ldr	r3, [r3]
7000216c:	e3530000 	cmp	r3, #0
70002170:	0a000005 	beq	7000218c <rt_sem_release+0x3c>
70002174:	e30a3b78 	movw	r3, #43896	; 0xab78
70002178:	e3473002 	movt	r3, #28674	; 0x7002
7000217c:	e5933000 	ldr	r3, [r3]
70002180:	e51b2010 	ldr	r2, [fp, #-16]
70002184:	e1a00002 	mov	r0, r2
70002188:	e12fff33 	blx	r3

    need_schedule = RT_FALSE;
7000218c:	e3a04000 	mov	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70002190:	eb00302c 	bl	7000e248 <rt_hw_interrupt_disable>
70002194:	e1a05000 	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
70002198:	e51b3010 	ldr	r3, [fp, #-16]
7000219c:	e2833010 	add	r3, r3, #16
700021a0:	e1a00003 	mov	r0, r3
700021a4:	ebfffd78 	bl	7000178c <rt_list_isempty>
700021a8:	e1a03000 	mov	r3, r0
700021ac:	e3530000 	cmp	r3, #0
700021b0:	1a000005 	bne	700021cc <rt_sem_release+0x7c>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
700021b4:	e51b3010 	ldr	r3, [fp, #-16]
700021b8:	e2833010 	add	r3, r3, #16
700021bc:	e1a00003 	mov	r0, r3
700021c0:	ebfffdcc 	bl	700018f8 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
700021c4:	e3a04001 	mov	r4, #1
700021c8:	ea000005 	b	700021e4 <rt_sem_release+0x94>
    }
    else
        sem->value ++; /* increase value */
700021cc:	e51b3010 	ldr	r3, [fp, #-16]
700021d0:	e1d331b8 	ldrh	r3, [r3, #24]
700021d4:	e2833001 	add	r3, r3, #1
700021d8:	e6ff2073 	uxth	r2, r3
700021dc:	e51b3010 	ldr	r3, [fp, #-16]
700021e0:	e1c321b8 	strh	r2, [r3, #24]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
700021e4:	e1a00005 	mov	r0, r5
700021e8:	eb003019 	bl	7000e254 <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
700021ec:	e3540001 	cmp	r4, #1
700021f0:	1a000000 	bne	700021f8 <rt_sem_release+0xa8>
        rt_schedule();
700021f4:	eb001e7a 	bl	70009be4 <rt_schedule>

    return RT_EOK;
700021f8:	e3a03000 	mov	r3, #0
}
700021fc:	e1a00003 	mov	r0, r3
70002200:	e24bd00c 	sub	sp, fp, #12
70002204:	e8bd8830 	pop	{r4, r5, fp, pc}

70002208 <rt_sem_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
{
70002208:	e92d4800 	push	{fp, lr}
7000220c:	e28db004 	add	fp, sp, #4
70002210:	e24dd020 	sub	sp, sp, #32
70002214:	e50b0018 	str	r0, [fp, #-24]
70002218:	e1a03001 	mov	r3, r1
7000221c:	e50b2020 	str	r2, [fp, #-32]
70002220:	e54b3019 	strb	r3, [fp, #-25]
    rt_ubase_t level;
    RT_ASSERT(sem != RT_NULL);
70002224:	e51b3018 	ldr	r3, [fp, #-24]
70002228:	e3530000 	cmp	r3, #0
7000222c:	1a00001d 	bne	700022a8 <rt_sem_control+0xa0>
70002230:	e3a03000 	mov	r3, #0
70002234:	e54b300d 	strb	r3, [fp, #-13]
70002238:	e30a3b74 	movw	r3, #43892	; 0xab74
7000223c:	e3473002 	movt	r3, #28674	; 0x7002
70002240:	e5933000 	ldr	r3, [r3]
70002244:	e3530000 	cmp	r3, #0
70002248:	1a00000d 	bne	70002284 <rt_sem_control+0x7c>
7000224c:	e3060324 	movw	r0, #25380	; 0x6324
70002250:	e3470002 	movt	r0, #28674	; 0x7002
70002254:	e3061344 	movw	r1, #25412	; 0x6344
70002258:	e3471002 	movt	r1, #28674	; 0x7002
7000225c:	e3062464 	movw	r2, #25700	; 0x6464
70002260:	e3472002 	movt	r2, #28674	; 0x7002
70002264:	e3a03f79 	mov	r3, #484	; 0x1e4
70002268:	eb001561 	bl	700077f4 <rt_kprintf>
7000226c:	e1a00000 	nop			; (mov r0, r0)
70002270:	e55b300d 	ldrb	r3, [fp, #-13]
70002274:	e6ef3073 	uxtb	r3, r3
70002278:	e3530000 	cmp	r3, #0
7000227c:	0afffffb 	beq	70002270 <rt_sem_control+0x68>
70002280:	ea000008 	b	700022a8 <rt_sem_control+0xa0>
70002284:	e30a3b74 	movw	r3, #43892	; 0xab74
70002288:	e3473002 	movt	r3, #28674	; 0x7002
7000228c:	e5933000 	ldr	r3, [r3]
70002290:	e3060344 	movw	r0, #25412	; 0x6344
70002294:	e3470002 	movt	r0, #28674	; 0x7002
70002298:	e3061464 	movw	r1, #25700	; 0x6464
7000229c:	e3471002 	movt	r1, #28674	; 0x7002
700022a0:	e3a02f79 	mov	r2, #484	; 0x1e4
700022a4:	e12fff33 	blx	r3

    if (cmd == RT_IPC_CMD_RESET)
700022a8:	e55b3019 	ldrb	r3, [fp, #-25]
700022ac:	e3530001 	cmp	r3, #1
700022b0:	1a000012 	bne	70002300 <rt_sem_control+0xf8>
    {
        rt_uint32_t value;

        /* get value */
        value = (rt_uint32_t)arg;
700022b4:	e51b3020 	ldr	r3, [fp, #-32]
700022b8:	e50b3008 	str	r3, [fp, #-8]
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
700022bc:	eb002fe1 	bl	7000e248 <rt_hw_interrupt_disable>
700022c0:	e1a03000 	mov	r3, r0
700022c4:	e50b300c 	str	r3, [fp, #-12]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&sem->parent.suspend_thread);
700022c8:	e51b3018 	ldr	r3, [fp, #-24]
700022cc:	e2833010 	add	r3, r3, #16
700022d0:	e1a00003 	mov	r0, r3
700022d4:	ebfffd95 	bl	70001930 <rt_ipc_list_resume_all>

        /* set new value */
        sem->value = (rt_uint16_t)value;
700022d8:	e51b3008 	ldr	r3, [fp, #-8]
700022dc:	e6ff2073 	uxth	r2, r3
700022e0:	e51b3018 	ldr	r3, [fp, #-24]
700022e4:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
700022e8:	e51b300c 	ldr	r3, [fp, #-12]
700022ec:	e1a00003 	mov	r0, r3
700022f0:	eb002fd7 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
700022f4:	eb001e3a 	bl	70009be4 <rt_schedule>

        return RT_EOK;
700022f8:	e3a03000 	mov	r3, #0
700022fc:	ea000000 	b	70002304 <rt_sem_control+0xfc>
    }

    return -RT_ERROR;
70002300:	e3e03000 	mvn	r3, #0
}
70002304:	e1a00003 	mov	r0, r3
70002308:	e24bd004 	sub	sp, fp, #4
7000230c:	e8bd8800 	pop	{fp, pc}

70002310 <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
70002310:	e92d4800 	push	{fp, lr}
70002314:	e28db004 	add	fp, sp, #4
70002318:	e24dd018 	sub	sp, sp, #24
7000231c:	e50b0010 	str	r0, [fp, #-16]
70002320:	e50b1014 	str	r1, [fp, #-20]
70002324:	e1a03002 	mov	r3, r2
70002328:	e54b3015 	strb	r3, [fp, #-21]
    RT_ASSERT(mutex != RT_NULL);
7000232c:	e51b3010 	ldr	r3, [fp, #-16]
70002330:	e3530000 	cmp	r3, #0
70002334:	1a00001d 	bne	700023b0 <rt_mutex_init+0xa0>
70002338:	e3a03000 	mov	r3, #0
7000233c:	e54b3005 	strb	r3, [fp, #-5]
70002340:	e30a3b74 	movw	r3, #43892	; 0xab74
70002344:	e3473002 	movt	r3, #28674	; 0x7002
70002348:	e5933000 	ldr	r3, [r3]
7000234c:	e3530000 	cmp	r3, #0
70002350:	1a00000d 	bne	7000238c <rt_mutex_init+0x7c>
70002354:	e3060324 	movw	r0, #25380	; 0x6324
70002358:	e3470002 	movt	r0, #28674	; 0x7002
7000235c:	e30613b4 	movw	r1, #25524	; 0x63b4
70002360:	e3471002 	movt	r1, #28674	; 0x7002
70002364:	e3062474 	movw	r2, #25716	; 0x6474
70002368:	e3472002 	movt	r2, #28674	; 0x7002
7000236c:	e300320f 	movw	r3, #527	; 0x20f
70002370:	eb00151f 	bl	700077f4 <rt_kprintf>
70002374:	e1a00000 	nop			; (mov r0, r0)
70002378:	e55b3005 	ldrb	r3, [fp, #-5]
7000237c:	e6ef3073 	uxtb	r3, r3
70002380:	e3530000 	cmp	r3, #0
70002384:	0afffffb 	beq	70002378 <rt_mutex_init+0x68>
70002388:	ea000008 	b	700023b0 <rt_mutex_init+0xa0>
7000238c:	e30a3b74 	movw	r3, #43892	; 0xab74
70002390:	e3473002 	movt	r3, #28674	; 0x7002
70002394:	e5933000 	ldr	r3, [r3]
70002398:	e30603b4 	movw	r0, #25524	; 0x63b4
7000239c:	e3470002 	movt	r0, #28674	; 0x7002
700023a0:	e3061474 	movw	r1, #25716	; 0x6474
700023a4:	e3471002 	movt	r1, #28674	; 0x7002
700023a8:	e300220f 	movw	r2, #527	; 0x20f
700023ac:	e12fff33 	blx	r3

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
700023b0:	e51b3010 	ldr	r3, [fp, #-16]
700023b4:	e1a00003 	mov	r0, r3
700023b8:	e3a01002 	mov	r1, #2
700023bc:	e51b2014 	ldr	r2, [fp, #-20]
700023c0:	eb001bba 	bl	700092b0 <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
700023c4:	e51b3010 	ldr	r3, [fp, #-16]
700023c8:	e1a00003 	mov	r0, r3
700023cc:	ebfffcfd 	bl	700017c8 <rt_ipc_object_init>

    mutex->value = 1;
700023d0:	e51b3010 	ldr	r3, [fp, #-16]
700023d4:	e3a02001 	mov	r2, #1
700023d8:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner = RT_NULL;
700023dc:	e51b3010 	ldr	r3, [fp, #-16]
700023e0:	e3a02000 	mov	r2, #0
700023e4:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority = 0xFF;
700023e8:	e51b3010 	ldr	r3, [fp, #-16]
700023ec:	e3e02000 	mvn	r2, #0
700023f0:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold  = 0;
700023f4:	e51b3010 	ldr	r3, [fp, #-16]
700023f8:	e3a02000 	mov	r2, #0
700023fc:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
70002400:	e51b3010 	ldr	r3, [fp, #-16]
70002404:	e55b2015 	ldrb	r2, [fp, #-21]
70002408:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
7000240c:	e3a03000 	mov	r3, #0
}
70002410:	e1a00003 	mov	r0, r3
70002414:	e24bd004 	sub	sp, fp, #4
70002418:	e8bd8800 	pop	{fp, pc}

7000241c <rt_mutex_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_mutex_delete
 */
rt_err_t rt_mutex_detach(rt_mutex_t mutex)
{
7000241c:	e92d4800 	push	{fp, lr}
70002420:	e28db004 	add	fp, sp, #4
70002424:	e24dd010 	sub	sp, sp, #16
70002428:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(mutex != RT_NULL);
7000242c:	e51b3010 	ldr	r3, [fp, #-16]
70002430:	e3530000 	cmp	r3, #0
70002434:	1a00001d 	bne	700024b0 <rt_mutex_detach+0x94>
70002438:	e3a03000 	mov	r3, #0
7000243c:	e54b3005 	strb	r3, [fp, #-5]
70002440:	e30a3b74 	movw	r3, #43892	; 0xab74
70002444:	e3473002 	movt	r3, #28674	; 0x7002
70002448:	e5933000 	ldr	r3, [r3]
7000244c:	e3530000 	cmp	r3, #0
70002450:	1a00000d 	bne	7000248c <rt_mutex_detach+0x70>
70002454:	e3060324 	movw	r0, #25380	; 0x6324
70002458:	e3470002 	movt	r0, #28674	; 0x7002
7000245c:	e30613b4 	movw	r1, #25524	; 0x63b4
70002460:	e3471002 	movt	r1, #28674	; 0x7002
70002464:	e3062484 	movw	r2, #25732	; 0x6484
70002468:	e3472002 	movt	r2, #28674	; 0x7002
7000246c:	e300322e 	movw	r3, #558	; 0x22e
70002470:	eb0014df 	bl	700077f4 <rt_kprintf>
70002474:	e1a00000 	nop			; (mov r0, r0)
70002478:	e55b3005 	ldrb	r3, [fp, #-5]
7000247c:	e6ef3073 	uxtb	r3, r3
70002480:	e3530000 	cmp	r3, #0
70002484:	0afffffb 	beq	70002478 <rt_mutex_detach+0x5c>
70002488:	ea000008 	b	700024b0 <rt_mutex_detach+0x94>
7000248c:	e30a3b74 	movw	r3, #43892	; 0xab74
70002490:	e3473002 	movt	r3, #28674	; 0x7002
70002494:	e5933000 	ldr	r3, [r3]
70002498:	e30603b4 	movw	r0, #25524	; 0x63b4
7000249c:	e3470002 	movt	r0, #28674	; 0x7002
700024a0:	e3061484 	movw	r1, #25732	; 0x6484
700024a4:	e3471002 	movt	r1, #28674	; 0x7002
700024a8:	e300222e 	movw	r2, #558	; 0x22e
700024ac:	e12fff33 	blx	r3

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
700024b0:	e51b3010 	ldr	r3, [fp, #-16]
700024b4:	e2833010 	add	r3, r3, #16
700024b8:	e1a00003 	mov	r0, r3
700024bc:	ebfffd1b 	bl	70001930 <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(mutex->parent.parent));
700024c0:	e51b3010 	ldr	r3, [fp, #-16]
700024c4:	e1a00003 	mov	r0, r3
700024c8:	eb001ba7 	bl	7000936c <rt_object_detach>

    return RT_EOK;
700024cc:	e3a03000 	mov	r3, #0
}
700024d0:	e1a00003 	mov	r0, r3
700024d4:	e24bd004 	sub	sp, fp, #4
700024d8:	e8bd8800 	pop	{fp, pc}

700024dc <rt_mutex_create>:
 * @return the created mutex, RT_NULL on error happen
 *
 * @see rt_mutex_init
 */
rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
{
700024dc:	e92d4800 	push	{fp, lr}
700024e0:	e28db004 	add	fp, sp, #4
700024e4:	e24dd018 	sub	sp, sp, #24
700024e8:	e50b0018 	str	r0, [fp, #-24]
700024ec:	e1a03001 	mov	r3, r1
700024f0:	e54b3019 	strb	r3, [fp, #-25]
    struct rt_mutex *mutex;

    RT_DEBUG_NOT_IN_INTERRUPT;
700024f4:	eb002f53 	bl	7000e248 <rt_hw_interrupt_disable>
700024f8:	e50b0008 	str	r0, [fp, #-8]
700024fc:	eb000e6c 	bl	70005eb4 <rt_interrupt_get_nest>
70002500:	e1a03000 	mov	r3, r0
70002504:	e3530000 	cmp	r3, #0
70002508:	0a000022 	beq	70002598 <rt_mutex_create+0xbc>
7000250c:	e3060354 	movw	r0, #25428	; 0x6354
70002510:	e3470002 	movt	r0, #28674	; 0x7002
70002514:	e3061494 	movw	r1, #25748	; 0x6494
70002518:	e3471002 	movt	r1, #28674	; 0x7002
7000251c:	eb0014b4 	bl	700077f4 <rt_kprintf>
70002520:	e3a03000 	mov	r3, #0
70002524:	e54b300d 	strb	r3, [fp, #-13]
70002528:	e30a3b74 	movw	r3, #43892	; 0xab74
7000252c:	e3473002 	movt	r3, #28674	; 0x7002
70002530:	e5933000 	ldr	r3, [r3]
70002534:	e3530000 	cmp	r3, #0
70002538:	1a00000d 	bne	70002574 <rt_mutex_create+0x98>
7000253c:	e3060324 	movw	r0, #25380	; 0x6324
70002540:	e3470002 	movt	r0, #28674	; 0x7002
70002544:	e3061378 	movw	r1, #25464	; 0x6378
70002548:	e3471002 	movt	r1, #28674	; 0x7002
7000254c:	e3062494 	movw	r2, #25748	; 0x6494
70002550:	e3472002 	movt	r2, #28674	; 0x7002
70002554:	e3003249 	movw	r3, #585	; 0x249
70002558:	eb0014a5 	bl	700077f4 <rt_kprintf>
7000255c:	e1a00000 	nop			; (mov r0, r0)
70002560:	e55b300d 	ldrb	r3, [fp, #-13]
70002564:	e6ef3073 	uxtb	r3, r3
70002568:	e3530000 	cmp	r3, #0
7000256c:	0afffffb 	beq	70002560 <rt_mutex_create+0x84>
70002570:	ea000008 	b	70002598 <rt_mutex_create+0xbc>
70002574:	e30a3b74 	movw	r3, #43892	; 0xab74
70002578:	e3473002 	movt	r3, #28674	; 0x7002
7000257c:	e5933000 	ldr	r3, [r3]
70002580:	e3060378 	movw	r0, #25464	; 0x6378
70002584:	e3470002 	movt	r0, #28674	; 0x7002
70002588:	e3061494 	movw	r1, #25748	; 0x6494
7000258c:	e3471002 	movt	r1, #28674	; 0x7002
70002590:	e3002249 	movw	r2, #585	; 0x249
70002594:	e12fff33 	blx	r3
70002598:	e51b0008 	ldr	r0, [fp, #-8]
7000259c:	eb002f2c 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate object */
    mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
700025a0:	e3a00002 	mov	r0, #2
700025a4:	e51b1018 	ldr	r1, [fp, #-24]
700025a8:	eb001ba8 	bl	70009450 <rt_object_allocate>
700025ac:	e50b000c 	str	r0, [fp, #-12]
    if (mutex == RT_NULL)
700025b0:	e51b300c 	ldr	r3, [fp, #-12]
700025b4:	e3530000 	cmp	r3, #0
700025b8:	1a000001 	bne	700025c4 <rt_mutex_create+0xe8>
        return mutex;
700025bc:	e51b300c 	ldr	r3, [fp, #-12]
700025c0:	ea000012 	b	70002610 <rt_mutex_create+0x134>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
700025c4:	e51b300c 	ldr	r3, [fp, #-12]
700025c8:	e1a00003 	mov	r0, r3
700025cc:	ebfffc7d 	bl	700017c8 <rt_ipc_object_init>

    mutex->value              = 1;
700025d0:	e51b300c 	ldr	r3, [fp, #-12]
700025d4:	e3a02001 	mov	r2, #1
700025d8:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner              = RT_NULL;
700025dc:	e51b300c 	ldr	r3, [fp, #-12]
700025e0:	e3a02000 	mov	r2, #0
700025e4:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority  = 0xFF;
700025e8:	e51b300c 	ldr	r3, [fp, #-12]
700025ec:	e3e02000 	mvn	r2, #0
700025f0:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold               = 0;
700025f4:	e51b300c 	ldr	r3, [fp, #-12]
700025f8:	e3a02000 	mov	r2, #0
700025fc:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
70002600:	e51b300c 	ldr	r3, [fp, #-12]
70002604:	e55b2019 	ldrb	r2, [fp, #-25]
70002608:	e5c32007 	strb	r2, [r3, #7]

    return mutex;
7000260c:	e51b300c 	ldr	r3, [fp, #-12]
}
70002610:	e1a00003 	mov	r0, r3
70002614:	e24bd004 	sub	sp, fp, #4
70002618:	e8bd8800 	pop	{fp, pc}

7000261c <rt_mutex_delete>:
 * @return the error code
 *
 * @see rt_mutex_detach
 */
rt_err_t rt_mutex_delete(rt_mutex_t mutex)
{
7000261c:	e92d4800 	push	{fp, lr}
70002620:	e28db004 	add	fp, sp, #4
70002624:	e24dd010 	sub	sp, sp, #16
70002628:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
7000262c:	eb002f05 	bl	7000e248 <rt_hw_interrupt_disable>
70002630:	e50b0008 	str	r0, [fp, #-8]
70002634:	eb000e1e 	bl	70005eb4 <rt_interrupt_get_nest>
70002638:	e1a03000 	mov	r3, r0
7000263c:	e3530000 	cmp	r3, #0
70002640:	0a000022 	beq	700026d0 <rt_mutex_delete+0xb4>
70002644:	e3060354 	movw	r0, #25428	; 0x6354
70002648:	e3470002 	movt	r0, #28674	; 0x7002
7000264c:	e30614a4 	movw	r1, #25764	; 0x64a4
70002650:	e3471002 	movt	r1, #28674	; 0x7002
70002654:	eb001466 	bl	700077f4 <rt_kprintf>
70002658:	e3a03000 	mov	r3, #0
7000265c:	e54b3009 	strb	r3, [fp, #-9]
70002660:	e30a3b74 	movw	r3, #43892	; 0xab74
70002664:	e3473002 	movt	r3, #28674	; 0x7002
70002668:	e5933000 	ldr	r3, [r3]
7000266c:	e3530000 	cmp	r3, #0
70002670:	1a00000d 	bne	700026ac <rt_mutex_delete+0x90>
70002674:	e3060324 	movw	r0, #25380	; 0x6324
70002678:	e3470002 	movt	r0, #28674	; 0x7002
7000267c:	e3061378 	movw	r1, #25464	; 0x6378
70002680:	e3471002 	movt	r1, #28674	; 0x7002
70002684:	e30624a4 	movw	r2, #25764	; 0x64a4
70002688:	e3472002 	movt	r2, #28674	; 0x7002
7000268c:	e300326a 	movw	r3, #618	; 0x26a
70002690:	eb001457 	bl	700077f4 <rt_kprintf>
70002694:	e1a00000 	nop			; (mov r0, r0)
70002698:	e55b3009 	ldrb	r3, [fp, #-9]
7000269c:	e6ef3073 	uxtb	r3, r3
700026a0:	e3530000 	cmp	r3, #0
700026a4:	0afffffb 	beq	70002698 <rt_mutex_delete+0x7c>
700026a8:	ea000008 	b	700026d0 <rt_mutex_delete+0xb4>
700026ac:	e30a3b74 	movw	r3, #43892	; 0xab74
700026b0:	e3473002 	movt	r3, #28674	; 0x7002
700026b4:	e5933000 	ldr	r3, [r3]
700026b8:	e3060378 	movw	r0, #25464	; 0x6378
700026bc:	e3470002 	movt	r0, #28674	; 0x7002
700026c0:	e30614a4 	movw	r1, #25764	; 0x64a4
700026c4:	e3471002 	movt	r1, #28674	; 0x7002
700026c8:	e300226a 	movw	r2, #618	; 0x26a
700026cc:	e12fff33 	blx	r3
700026d0:	e51b0008 	ldr	r0, [fp, #-8]
700026d4:	eb002ede 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
700026d8:	e51b3010 	ldr	r3, [fp, #-16]
700026dc:	e3530000 	cmp	r3, #0
700026e0:	1a00001d 	bne	7000275c <rt_mutex_delete+0x140>
700026e4:	e3a03000 	mov	r3, #0
700026e8:	e54b300a 	strb	r3, [fp, #-10]
700026ec:	e30a3b74 	movw	r3, #43892	; 0xab74
700026f0:	e3473002 	movt	r3, #28674	; 0x7002
700026f4:	e5933000 	ldr	r3, [r3]
700026f8:	e3530000 	cmp	r3, #0
700026fc:	1a00000d 	bne	70002738 <rt_mutex_delete+0x11c>
70002700:	e3060324 	movw	r0, #25380	; 0x6324
70002704:	e3470002 	movt	r0, #28674	; 0x7002
70002708:	e30613b4 	movw	r1, #25524	; 0x63b4
7000270c:	e3471002 	movt	r1, #28674	; 0x7002
70002710:	e30624a4 	movw	r2, #25764	; 0x64a4
70002714:	e3472002 	movt	r2, #28674	; 0x7002
70002718:	e3a03f9b 	mov	r3, #620	; 0x26c
7000271c:	eb001434 	bl	700077f4 <rt_kprintf>
70002720:	e1a00000 	nop			; (mov r0, r0)
70002724:	e55b300a 	ldrb	r3, [fp, #-10]
70002728:	e6ef3073 	uxtb	r3, r3
7000272c:	e3530000 	cmp	r3, #0
70002730:	0afffffb 	beq	70002724 <rt_mutex_delete+0x108>
70002734:	ea000008 	b	7000275c <rt_mutex_delete+0x140>
70002738:	e30a3b74 	movw	r3, #43892	; 0xab74
7000273c:	e3473002 	movt	r3, #28674	; 0x7002
70002740:	e5933000 	ldr	r3, [r3]
70002744:	e30603b4 	movw	r0, #25524	; 0x63b4
70002748:	e3470002 	movt	r0, #28674	; 0x7002
7000274c:	e30614a4 	movw	r1, #25764	; 0x64a4
70002750:	e3471002 	movt	r1, #28674	; 0x7002
70002754:	e3a02f9b 	mov	r2, #620	; 0x26c
70002758:	e12fff33 	blx	r3

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
7000275c:	e51b3010 	ldr	r3, [fp, #-16]
70002760:	e2833010 	add	r3, r3, #16
70002764:	e1a00003 	mov	r0, r3
70002768:	ebfffc70 	bl	70001930 <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(mutex->parent.parent));
7000276c:	e51b3010 	ldr	r3, [fp, #-16]
70002770:	e1a00003 	mov	r0, r3
70002774:	eb001b9a 	bl	700095e4 <rt_object_delete>

    return RT_EOK;
70002778:	e3a03000 	mov	r3, #0
}
7000277c:	e1a00003 	mov	r0, r3
70002780:	e24bd004 	sub	sp, fp, #4
70002784:	e8bd8800 	pop	{fp, pc}

70002788 <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
70002788:	e92d4810 	push	{r4, fp, lr}
7000278c:	e28db008 	add	fp, sp, #8
70002790:	e24dd01c 	sub	sp, sp, #28
70002794:	e50b0020 	str	r0, [fp, #-32]
70002798:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
7000279c:	eb002ea9 	bl	7000e248 <rt_hw_interrupt_disable>
700027a0:	e50b0010 	str	r0, [fp, #-16]
700027a4:	eb001f71 	bl	7000a570 <rt_thread_self>
700027a8:	e1a03000 	mov	r3, r0
700027ac:	e3530000 	cmp	r3, #0
700027b0:	1a000022 	bne	70002840 <rt_mutex_take+0xb8>
700027b4:	e306037c 	movw	r0, #25468	; 0x637c
700027b8:	e3470002 	movt	r0, #28674	; 0x7002
700027bc:	e30614b4 	movw	r1, #25780	; 0x64b4
700027c0:	e3471002 	movt	r1, #28674	; 0x7002
700027c4:	eb00140a 	bl	700077f4 <rt_kprintf>
700027c8:	e3a03000 	mov	r3, #0
700027cc:	e54b3019 	strb	r3, [fp, #-25]
700027d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700027d4:	e3473002 	movt	r3, #28674	; 0x7002
700027d8:	e5933000 	ldr	r3, [r3]
700027dc:	e3530000 	cmp	r3, #0
700027e0:	1a00000d 	bne	7000281c <rt_mutex_take+0x94>
700027e4:	e3060324 	movw	r0, #25380	; 0x6324
700027e8:	e3470002 	movt	r0, #28674	; 0x7002
700027ec:	e3061378 	movw	r1, #25464	; 0x6378
700027f0:	e3471002 	movt	r1, #28674	; 0x7002
700027f4:	e30624b4 	movw	r2, #25780	; 0x64b4
700027f8:	e3472002 	movt	r2, #28674	; 0x7002
700027fc:	e3a03fa2 	mov	r3, #648	; 0x288
70002800:	eb0013fb 	bl	700077f4 <rt_kprintf>
70002804:	e1a00000 	nop			; (mov r0, r0)
70002808:	e55b3019 	ldrb	r3, [fp, #-25]
7000280c:	e6ef3073 	uxtb	r3, r3
70002810:	e3530000 	cmp	r3, #0
70002814:	0afffffb 	beq	70002808 <rt_mutex_take+0x80>
70002818:	ea000008 	b	70002840 <rt_mutex_take+0xb8>
7000281c:	e30a3b74 	movw	r3, #43892	; 0xab74
70002820:	e3473002 	movt	r3, #28674	; 0x7002
70002824:	e5933000 	ldr	r3, [r3]
70002828:	e3060378 	movw	r0, #25464	; 0x6378
7000282c:	e3470002 	movt	r0, #28674	; 0x7002
70002830:	e30614b4 	movw	r1, #25780	; 0x64b4
70002834:	e3471002 	movt	r1, #28674	; 0x7002
70002838:	e3a02fa2 	mov	r2, #648	; 0x288
7000283c:	e12fff33 	blx	r3
70002840:	eb002e80 	bl	7000e248 <rt_hw_interrupt_disable>
70002844:	e50b0014 	str	r0, [fp, #-20]
70002848:	eb000d99 	bl	70005eb4 <rt_interrupt_get_nest>
7000284c:	e1a03000 	mov	r3, r0
70002850:	e3530000 	cmp	r3, #0
70002854:	0a000022 	beq	700028e4 <rt_mutex_take+0x15c>
70002858:	e3060354 	movw	r0, #25428	; 0x6354
7000285c:	e3470002 	movt	r0, #28674	; 0x7002
70002860:	e30614b4 	movw	r1, #25780	; 0x64b4
70002864:	e3471002 	movt	r1, #28674	; 0x7002
70002868:	eb0013e1 	bl	700077f4 <rt_kprintf>
7000286c:	e3a03000 	mov	r3, #0
70002870:	e54b301a 	strb	r3, [fp, #-26]
70002874:	e30a3b74 	movw	r3, #43892	; 0xab74
70002878:	e3473002 	movt	r3, #28674	; 0x7002
7000287c:	e5933000 	ldr	r3, [r3]
70002880:	e3530000 	cmp	r3, #0
70002884:	1a00000d 	bne	700028c0 <rt_mutex_take+0x138>
70002888:	e3060324 	movw	r0, #25380	; 0x6324
7000288c:	e3470002 	movt	r0, #28674	; 0x7002
70002890:	e3061378 	movw	r1, #25464	; 0x6378
70002894:	e3471002 	movt	r1, #28674	; 0x7002
70002898:	e30624b4 	movw	r2, #25780	; 0x64b4
7000289c:	e3472002 	movt	r2, #28674	; 0x7002
700028a0:	e3a03fa2 	mov	r3, #648	; 0x288
700028a4:	eb0013d2 	bl	700077f4 <rt_kprintf>
700028a8:	e1a00000 	nop			; (mov r0, r0)
700028ac:	e55b301a 	ldrb	r3, [fp, #-26]
700028b0:	e6ef3073 	uxtb	r3, r3
700028b4:	e3530000 	cmp	r3, #0
700028b8:	0afffffb 	beq	700028ac <rt_mutex_take+0x124>
700028bc:	ea000008 	b	700028e4 <rt_mutex_take+0x15c>
700028c0:	e30a3b74 	movw	r3, #43892	; 0xab74
700028c4:	e3473002 	movt	r3, #28674	; 0x7002
700028c8:	e5933000 	ldr	r3, [r3]
700028cc:	e3060378 	movw	r0, #25464	; 0x6378
700028d0:	e3470002 	movt	r0, #28674	; 0x7002
700028d4:	e30614b4 	movw	r1, #25780	; 0x64b4
700028d8:	e3471002 	movt	r1, #28674	; 0x7002
700028dc:	e3a02fa2 	mov	r2, #648	; 0x288
700028e0:	e12fff33 	blx	r3
700028e4:	e51b0014 	ldr	r0, [fp, #-20]
700028e8:	eb002e59 	bl	7000e254 <rt_hw_interrupt_enable>
700028ec:	e51b0010 	ldr	r0, [fp, #-16]
700028f0:	eb002e57 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
700028f4:	e51b3020 	ldr	r3, [fp, #-32]
700028f8:	e3530000 	cmp	r3, #0
700028fc:	1a00001d 	bne	70002978 <rt_mutex_take+0x1f0>
70002900:	e3a03000 	mov	r3, #0
70002904:	e54b301b 	strb	r3, [fp, #-27]
70002908:	e30a3b74 	movw	r3, #43892	; 0xab74
7000290c:	e3473002 	movt	r3, #28674	; 0x7002
70002910:	e5933000 	ldr	r3, [r3]
70002914:	e3530000 	cmp	r3, #0
70002918:	1a00000d 	bne	70002954 <rt_mutex_take+0x1cc>
7000291c:	e3060324 	movw	r0, #25380	; 0x6324
70002920:	e3470002 	movt	r0, #28674	; 0x7002
70002924:	e30613b4 	movw	r1, #25524	; 0x63b4
70002928:	e3471002 	movt	r1, #28674	; 0x7002
7000292c:	e30624b4 	movw	r2, #25780	; 0x64b4
70002930:	e3472002 	movt	r2, #28674	; 0x7002
70002934:	e300328a 	movw	r3, #650	; 0x28a
70002938:	eb0013ad 	bl	700077f4 <rt_kprintf>
7000293c:	e1a00000 	nop			; (mov r0, r0)
70002940:	e55b301b 	ldrb	r3, [fp, #-27]
70002944:	e6ef3073 	uxtb	r3, r3
70002948:	e3530000 	cmp	r3, #0
7000294c:	0afffffb 	beq	70002940 <rt_mutex_take+0x1b8>
70002950:	ea000008 	b	70002978 <rt_mutex_take+0x1f0>
70002954:	e30a3b74 	movw	r3, #43892	; 0xab74
70002958:	e3473002 	movt	r3, #28674	; 0x7002
7000295c:	e5933000 	ldr	r3, [r3]
70002960:	e30603b4 	movw	r0, #25524	; 0x63b4
70002964:	e3470002 	movt	r0, #28674	; 0x7002
70002968:	e30614b4 	movw	r1, #25780	; 0x64b4
7000296c:	e3471002 	movt	r1, #28674	; 0x7002
70002970:	e300228a 	movw	r2, #650	; 0x28a
70002974:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70002978:	eb002e32 	bl	7000e248 <rt_hw_interrupt_disable>
7000297c:	e1a04000 	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
70002980:	eb001efa 	bl	7000a570 <rt_thread_self>
70002984:	e50b0018 	str	r0, [fp, #-24]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
70002988:	e30a3b80 	movw	r3, #43904	; 0xab80
7000298c:	e3473002 	movt	r3, #28674	; 0x7002
70002990:	e5933000 	ldr	r3, [r3]
70002994:	e3530000 	cmp	r3, #0
70002998:	0a000005 	beq	700029b4 <rt_mutex_take+0x22c>
7000299c:	e30a3b80 	movw	r3, #43904	; 0xab80
700029a0:	e3473002 	movt	r3, #28674	; 0x7002
700029a4:	e5933000 	ldr	r3, [r3]
700029a8:	e51b2020 	ldr	r2, [fp, #-32]
700029ac:	e1a00002 	mov	r0, r2
700029b0:	e12fff33 	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
700029b4:	e51b3018 	ldr	r3, [fp, #-24]
700029b8:	e3a02000 	mov	r2, #0
700029bc:	e583202c 	str	r2, [r3, #44]	; 0x2c

    if (mutex->owner == thread)
700029c0:	e51b3020 	ldr	r3, [fp, #-32]
700029c4:	e593201c 	ldr	r2, [r3, #28]
700029c8:	e51b3018 	ldr	r3, [fp, #-24]
700029cc:	e1520003 	cmp	r2, r3
700029d0:	1a000006 	bne	700029f0 <rt_mutex_take+0x268>
    {
        /* it's the same thread */
        mutex->hold ++;
700029d4:	e51b3020 	ldr	r3, [fp, #-32]
700029d8:	e5d3301b 	ldrb	r3, [r3, #27]
700029dc:	e2833001 	add	r3, r3, #1
700029e0:	e6ef2073 	uxtb	r2, r3
700029e4:	e51b3020 	ldr	r3, [fp, #-32]
700029e8:	e5c3201b 	strb	r2, [r3, #27]
700029ec:	ea000052 	b	70002b3c <rt_mutex_take+0x3b4>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
700029f0:	e51b3020 	ldr	r3, [fp, #-32]
700029f4:	e1d331b8 	ldrh	r3, [r3, #24]
700029f8:	e3530000 	cmp	r3, #0
700029fc:	0a000013 	beq	70002a50 <rt_mutex_take+0x2c8>
        {
            /* mutex is available */
            mutex->value --;
70002a00:	e51b3020 	ldr	r3, [fp, #-32]
70002a04:	e1d331b8 	ldrh	r3, [r3, #24]
70002a08:	e2433001 	sub	r3, r3, #1
70002a0c:	e6ff2073 	uxth	r2, r3
70002a10:	e51b3020 	ldr	r3, [fp, #-32]
70002a14:	e1c321b8 	strh	r2, [r3, #24]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
70002a18:	e51b3020 	ldr	r3, [fp, #-32]
70002a1c:	e51b2018 	ldr	r2, [fp, #-24]
70002a20:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
70002a24:	e51b3018 	ldr	r3, [fp, #-24]
70002a28:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
70002a2c:	e51b3020 	ldr	r3, [fp, #-32]
70002a30:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
70002a34:	e51b3020 	ldr	r3, [fp, #-32]
70002a38:	e5d3301b 	ldrb	r3, [r3, #27]
70002a3c:	e2833001 	add	r3, r3, #1
70002a40:	e6ef2073 	uxtb	r2, r3
70002a44:	e51b3020 	ldr	r3, [fp, #-32]
70002a48:	e5c3201b 	strb	r2, [r3, #27]
70002a4c:	ea00003a 	b	70002b3c <rt_mutex_take+0x3b4>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
70002a50:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70002a54:	e3530000 	cmp	r3, #0
70002a58:	1a000006 	bne	70002a78 <rt_mutex_take+0x2f0>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
70002a5c:	e51b3018 	ldr	r3, [fp, #-24]
70002a60:	e3e02001 	mvn	r2, #1
70002a64:	e583202c 	str	r2, [r3, #44]	; 0x2c

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
70002a68:	e1a00004 	mov	r0, r4
70002a6c:	eb002df8 	bl	7000e254 <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
70002a70:	e3e03001 	mvn	r3, #1
70002a74:	ea00003e 	b	70002b74 <rt_mutex_take+0x3ec>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
70002a78:	e51b3018 	ldr	r3, [fp, #-24]
70002a7c:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
70002a80:	e51b3020 	ldr	r3, [fp, #-32]
70002a84:	e593301c 	ldr	r3, [r3, #28]
70002a88:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
70002a8c:	e1520003 	cmp	r2, r3
70002a90:	2a000007 	bcs	70002ab4 <rt_mutex_take+0x32c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
70002a94:	e51b3020 	ldr	r3, [fp, #-32]
70002a98:	e593201c 	ldr	r2, [r3, #28]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
70002a9c:	e51b3018 	ldr	r3, [fp, #-24]
70002aa0:	e2833031 	add	r3, r3, #49	; 0x31

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
70002aa4:	e1a00002 	mov	r0, r2
70002aa8:	e3a01002 	mov	r1, #2
70002aac:	e1a02003 	mov	r2, r3
70002ab0:	eb00203d 	bl	7000abac <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
70002ab4:	e51b3020 	ldr	r3, [fp, #-32]
70002ab8:	e2832010 	add	r2, r3, #16
70002abc:	e51b3020 	ldr	r3, [fp, #-32]
70002ac0:	e5d33007 	ldrb	r3, [r3, #7]
70002ac4:	e1a00002 	mov	r0, r2
70002ac8:	e51b1018 	ldr	r1, [fp, #-24]
70002acc:	e1a02003 	mov	r2, r3
70002ad0:	ebfffb48 	bl	700017f8 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
70002ad4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70002ad8:	e3530000 	cmp	r3, #0
70002adc:	da00000a 	ble	70002b0c <rt_mutex_take+0x384>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
70002ae0:	e51b3018 	ldr	r3, [fp, #-24]
70002ae4:	e2832048 	add	r2, r3, #72	; 0x48
70002ae8:	e24b3024 	sub	r3, fp, #36	; 0x24
70002aec:	e1a00002 	mov	r0, r2
70002af0:	e3a01000 	mov	r1, #0
70002af4:	e1a02003 	mov	r2, r3
70002af8:	eb00243a 	bl	7000bbe8 <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
70002afc:	e51b3018 	ldr	r3, [fp, #-24]
70002b00:	e2833048 	add	r3, r3, #72	; 0x48
70002b04:	e1a00003 	mov	r0, r3
70002b08:	eb0022ea 	bl	7000b6b8 <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
70002b0c:	e1a00004 	mov	r0, r4
70002b10:	eb002dcf 	bl	7000e254 <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
70002b14:	eb001c32 	bl	70009be4 <rt_schedule>

                if (thread->error != RT_EOK)
70002b18:	e51b3018 	ldr	r3, [fp, #-24]
70002b1c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70002b20:	e3530000 	cmp	r3, #0
70002b24:	0a000002 	beq	70002b34 <rt_mutex_take+0x3ac>
                {
                    /* return error */
                    return thread->error;
70002b28:	e51b3018 	ldr	r3, [fp, #-24]
70002b2c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70002b30:	ea00000f 	b	70002b74 <rt_mutex_take+0x3ec>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
70002b34:	eb002dc3 	bl	7000e248 <rt_hw_interrupt_disable>
70002b38:	e1a04000 	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70002b3c:	e1a00004 	mov	r0, r4
70002b40:	eb002dc3 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
70002b44:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70002b48:	e3473002 	movt	r3, #28674	; 0x7002
70002b4c:	e5933000 	ldr	r3, [r3]
70002b50:	e3530000 	cmp	r3, #0
70002b54:	0a000005 	beq	70002b70 <rt_mutex_take+0x3e8>
70002b58:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70002b5c:	e3473002 	movt	r3, #28674	; 0x7002
70002b60:	e5933000 	ldr	r3, [r3]
70002b64:	e51b2020 	ldr	r2, [fp, #-32]
70002b68:	e1a00002 	mov	r0, r2
70002b6c:	e12fff33 	blx	r3

    return RT_EOK;
70002b70:	e3a03000 	mov	r3, #0
}
70002b74:	e1a00003 	mov	r0, r3
70002b78:	e24bd008 	sub	sp, fp, #8
70002b7c:	e8bd8810 	pop	{r4, fp, pc}

70002b80 <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
70002b80:	e92d4810 	push	{r4, fp, lr}
70002b84:	e28db008 	add	fp, sp, #8
70002b88:	e24dd024 	sub	sp, sp, #36	; 0x24
70002b8c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
70002b90:	e3a03000 	mov	r3, #0
70002b94:	e50b3010 	str	r3, [fp, #-16]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
70002b98:	eb002daa 	bl	7000e248 <rt_hw_interrupt_disable>
70002b9c:	e50b0014 	str	r0, [fp, #-20]
70002ba0:	eb001e72 	bl	7000a570 <rt_thread_self>
70002ba4:	e1a03000 	mov	r3, r0
70002ba8:	e3530000 	cmp	r3, #0
70002bac:	1a000022 	bne	70002c3c <rt_mutex_release+0xbc>
70002bb0:	e306037c 	movw	r0, #25468	; 0x637c
70002bb4:	e3470002 	movt	r0, #28674	; 0x7002
70002bb8:	e30614c4 	movw	r1, #25796	; 0x64c4
70002bbc:	e3471002 	movt	r1, #28674	; 0x7002
70002bc0:	eb00130b 	bl	700077f4 <rt_kprintf>
70002bc4:	e3a03000 	mov	r3, #0
70002bc8:	e54b301d 	strb	r3, [fp, #-29]
70002bcc:	e30a3b74 	movw	r3, #43892	; 0xab74
70002bd0:	e3473002 	movt	r3, #28674	; 0x7002
70002bd4:	e5933000 	ldr	r3, [r3]
70002bd8:	e3530000 	cmp	r3, #0
70002bdc:	1a00000d 	bne	70002c18 <rt_mutex_release+0x98>
70002be0:	e3060324 	movw	r0, #25380	; 0x6324
70002be4:	e3470002 	movt	r0, #28674	; 0x7002
70002be8:	e3061378 	movw	r1, #25464	; 0x6378
70002bec:	e3471002 	movt	r1, #28674	; 0x7002
70002bf0:	e30624c4 	movw	r2, #25796	; 0x64c4
70002bf4:	e3472002 	movt	r2, #28674	; 0x7002
70002bf8:	e300330d 	movw	r3, #781	; 0x30d
70002bfc:	eb0012fc 	bl	700077f4 <rt_kprintf>
70002c00:	e1a00000 	nop			; (mov r0, r0)
70002c04:	e55b301d 	ldrb	r3, [fp, #-29]
70002c08:	e6ef3073 	uxtb	r3, r3
70002c0c:	e3530000 	cmp	r3, #0
70002c10:	0afffffb 	beq	70002c04 <rt_mutex_release+0x84>
70002c14:	ea000008 	b	70002c3c <rt_mutex_release+0xbc>
70002c18:	e30a3b74 	movw	r3, #43892	; 0xab74
70002c1c:	e3473002 	movt	r3, #28674	; 0x7002
70002c20:	e5933000 	ldr	r3, [r3]
70002c24:	e3060378 	movw	r0, #25464	; 0x6378
70002c28:	e3470002 	movt	r0, #28674	; 0x7002
70002c2c:	e30614c4 	movw	r1, #25796	; 0x64c4
70002c30:	e3471002 	movt	r1, #28674	; 0x7002
70002c34:	e300230d 	movw	r2, #781	; 0x30d
70002c38:	e12fff33 	blx	r3
70002c3c:	eb002d81 	bl	7000e248 <rt_hw_interrupt_disable>
70002c40:	e50b0018 	str	r0, [fp, #-24]
70002c44:	eb000c9a 	bl	70005eb4 <rt_interrupt_get_nest>
70002c48:	e1a03000 	mov	r3, r0
70002c4c:	e3530000 	cmp	r3, #0
70002c50:	0a000022 	beq	70002ce0 <rt_mutex_release+0x160>
70002c54:	e3060354 	movw	r0, #25428	; 0x6354
70002c58:	e3470002 	movt	r0, #28674	; 0x7002
70002c5c:	e30614c4 	movw	r1, #25796	; 0x64c4
70002c60:	e3471002 	movt	r1, #28674	; 0x7002
70002c64:	eb0012e2 	bl	700077f4 <rt_kprintf>
70002c68:	e3a03000 	mov	r3, #0
70002c6c:	e54b301e 	strb	r3, [fp, #-30]
70002c70:	e30a3b74 	movw	r3, #43892	; 0xab74
70002c74:	e3473002 	movt	r3, #28674	; 0x7002
70002c78:	e5933000 	ldr	r3, [r3]
70002c7c:	e3530000 	cmp	r3, #0
70002c80:	1a00000d 	bne	70002cbc <rt_mutex_release+0x13c>
70002c84:	e3060324 	movw	r0, #25380	; 0x6324
70002c88:	e3470002 	movt	r0, #28674	; 0x7002
70002c8c:	e3061378 	movw	r1, #25464	; 0x6378
70002c90:	e3471002 	movt	r1, #28674	; 0x7002
70002c94:	e30624c4 	movw	r2, #25796	; 0x64c4
70002c98:	e3472002 	movt	r2, #28674	; 0x7002
70002c9c:	e300330d 	movw	r3, #781	; 0x30d
70002ca0:	eb0012d3 	bl	700077f4 <rt_kprintf>
70002ca4:	e1a00000 	nop			; (mov r0, r0)
70002ca8:	e55b301e 	ldrb	r3, [fp, #-30]
70002cac:	e6ef3073 	uxtb	r3, r3
70002cb0:	e3530000 	cmp	r3, #0
70002cb4:	0afffffb 	beq	70002ca8 <rt_mutex_release+0x128>
70002cb8:	ea000008 	b	70002ce0 <rt_mutex_release+0x160>
70002cbc:	e30a3b74 	movw	r3, #43892	; 0xab74
70002cc0:	e3473002 	movt	r3, #28674	; 0x7002
70002cc4:	e5933000 	ldr	r3, [r3]
70002cc8:	e3060378 	movw	r0, #25464	; 0x6378
70002ccc:	e3470002 	movt	r0, #28674	; 0x7002
70002cd0:	e30614c4 	movw	r1, #25796	; 0x64c4
70002cd4:	e3471002 	movt	r1, #28674	; 0x7002
70002cd8:	e300230d 	movw	r2, #781	; 0x30d
70002cdc:	e12fff33 	blx	r3
70002ce0:	e51b0018 	ldr	r0, [fp, #-24]
70002ce4:	eb002d5a 	bl	7000e254 <rt_hw_interrupt_enable>
70002ce8:	e51b0014 	ldr	r0, [fp, #-20]
70002cec:	eb002d58 	bl	7000e254 <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
70002cf0:	eb001e1e 	bl	7000a570 <rt_thread_self>
70002cf4:	e50b001c 	str	r0, [fp, #-28]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70002cf8:	eb002d52 	bl	7000e248 <rt_hw_interrupt_disable>
70002cfc:	e1a04000 	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
70002d00:	e30a3b78 	movw	r3, #43896	; 0xab78
70002d04:	e3473002 	movt	r3, #28674	; 0x7002
70002d08:	e5933000 	ldr	r3, [r3]
70002d0c:	e3530000 	cmp	r3, #0
70002d10:	0a000005 	beq	70002d2c <rt_mutex_release+0x1ac>
70002d14:	e30a3b78 	movw	r3, #43896	; 0xab78
70002d18:	e3473002 	movt	r3, #28674	; 0x7002
70002d1c:	e5933000 	ldr	r3, [r3]
70002d20:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70002d24:	e1a00002 	mov	r0, r2
70002d28:	e12fff33 	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
70002d2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d30:	e593201c 	ldr	r2, [r3, #28]
70002d34:	e51b301c 	ldr	r3, [fp, #-28]
70002d38:	e1520003 	cmp	r2, r3
70002d3c:	0a000006 	beq	70002d5c <rt_mutex_release+0x1dc>
    {
        thread->error = -RT_ERROR;
70002d40:	e51b301c 	ldr	r3, [fp, #-28]
70002d44:	e3e02000 	mvn	r2, #0
70002d48:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70002d4c:	e1a00004 	mov	r0, r4
70002d50:	eb002d3f 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_ERROR;
70002d54:	e3e03000 	mvn	r3, #0
70002d58:	ea00004a 	b	70002e88 <rt_mutex_release+0x308>
    }

    /* decrease hold */
    mutex->hold --;
70002d5c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d60:	e5d3301b 	ldrb	r3, [r3, #27]
70002d64:	e2433001 	sub	r3, r3, #1
70002d68:	e6ef2073 	uxtb	r2, r3
70002d6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d70:	e5c3201b 	strb	r2, [r3, #27]
    /* if no hold */
    if (mutex->hold == 0)
70002d74:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d78:	e5d3301b 	ldrb	r3, [r3, #27]
70002d7c:	e3530000 	cmp	r3, #0
70002d80:	1a000039 	bne	70002e6c <rt_mutex_release+0x2ec>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
70002d84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d88:	e5d3201a 	ldrb	r2, [r3, #26]
70002d8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002d90:	e593301c 	ldr	r3, [r3, #28]
70002d94:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
70002d98:	e1520003 	cmp	r2, r3
70002d9c:	0a000007 	beq	70002dc0 <rt_mutex_release+0x240>
        {
            rt_thread_control(mutex->owner,
70002da0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002da4:	e593201c 	ldr	r2, [r3, #28]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
70002da8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002dac:	e283301a 	add	r3, r3, #26
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
70002db0:	e1a00002 	mov	r0, r2
70002db4:	e3a01002 	mov	r1, #2
70002db8:	e1a02003 	mov	r2, r3
70002dbc:	eb001f7a 	bl	7000abac <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
70002dc0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002dc4:	e2833010 	add	r3, r3, #16
70002dc8:	e1a00003 	mov	r0, r3
70002dcc:	ebfffa6e 	bl	7000178c <rt_list_isempty>
70002dd0:	e1a03000 	mov	r3, r0
70002dd4:	e3530000 	cmp	r3, #0
70002dd8:	1a000017 	bne	70002e3c <rt_mutex_release+0x2bc>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
70002ddc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002de0:	e5933010 	ldr	r3, [r3, #16]
70002de4:	e2433010 	sub	r3, r3, #16
70002de8:	e50b301c 	str	r3, [fp, #-28]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
70002dec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002df0:	e51b201c 	ldr	r2, [fp, #-28]
70002df4:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
70002df8:	e51b301c 	ldr	r3, [fp, #-28]
70002dfc:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
70002e00:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e04:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
70002e08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e0c:	e5d3301b 	ldrb	r3, [r3, #27]
70002e10:	e2833001 	add	r3, r3, #1
70002e14:	e6ef2073 	uxtb	r2, r3
70002e18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e1c:	e5c3201b 	strb	r2, [r3, #27]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
70002e20:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e24:	e2833010 	add	r3, r3, #16
70002e28:	e1a00003 	mov	r0, r3
70002e2c:	ebfffab1 	bl	700018f8 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
70002e30:	e3a03001 	mov	r3, #1
70002e34:	e50b3010 	str	r3, [fp, #-16]
70002e38:	ea00000b 	b	70002e6c <rt_mutex_release+0x2ec>
        }
        else
        {
            /* increase value */
            mutex->value ++;
70002e3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e40:	e1d331b8 	ldrh	r3, [r3, #24]
70002e44:	e2833001 	add	r3, r3, #1
70002e48:	e6ff2073 	uxth	r2, r3
70002e4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e50:	e1c321b8 	strh	r2, [r3, #24]

            /* clear owner */
            mutex->owner             = RT_NULL;
70002e54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e58:	e3a02000 	mov	r2, #0
70002e5c:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = 0xff;
70002e60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70002e64:	e3e02000 	mvn	r2, #0
70002e68:	e5c3201a 	strb	r2, [r3, #26]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70002e6c:	e1a00004 	mov	r0, r4
70002e70:	eb002cf7 	bl	7000e254 <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
70002e74:	e51b3010 	ldr	r3, [fp, #-16]
70002e78:	e3530001 	cmp	r3, #1
70002e7c:	1a000000 	bne	70002e84 <rt_mutex_release+0x304>
        rt_schedule();
70002e80:	eb001b57 	bl	70009be4 <rt_schedule>

    return RT_EOK;
70002e84:	e3a03000 	mov	r3, #0
}
70002e88:	e1a00003 	mov	r0, r3
70002e8c:	e24bd008 	sub	sp, fp, #8
70002e90:	e8bd8810 	pop	{r4, fp, pc}

70002e94 <rt_mutex_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
{
70002e94:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70002e98:	e28db000 	add	fp, sp, #0
70002e9c:	e24dd014 	sub	sp, sp, #20
70002ea0:	e50b0008 	str	r0, [fp, #-8]
70002ea4:	e1a03001 	mov	r3, r1
70002ea8:	e50b2010 	str	r2, [fp, #-16]
70002eac:	e54b3009 	strb	r3, [fp, #-9]
    return -RT_ERROR;
70002eb0:	e3e03000 	mvn	r3, #0
}
70002eb4:	e1a00003 	mov	r0, r3
70002eb8:	e24bd000 	sub	sp, fp, #0
70002ebc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70002ec0:	e12fff1e 	bx	lr

70002ec4 <rt_event_init>:
 * @param flag the flag of event
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
{
70002ec4:	e92d4800 	push	{fp, lr}
70002ec8:	e28db004 	add	fp, sp, #4
70002ecc:	e24dd018 	sub	sp, sp, #24
70002ed0:	e50b0010 	str	r0, [fp, #-16]
70002ed4:	e50b1014 	str	r1, [fp, #-20]
70002ed8:	e1a03002 	mov	r3, r2
70002edc:	e54b3015 	strb	r3, [fp, #-21]
    RT_ASSERT(event != RT_NULL);
70002ee0:	e51b3010 	ldr	r3, [fp, #-16]
70002ee4:	e3530000 	cmp	r3, #0
70002ee8:	1a00001d 	bne	70002f64 <rt_event_init+0xa0>
70002eec:	e3a03000 	mov	r3, #0
70002ef0:	e54b3005 	strb	r3, [fp, #-5]
70002ef4:	e30a3b74 	movw	r3, #43892	; 0xab74
70002ef8:	e3473002 	movt	r3, #28674	; 0x7002
70002efc:	e5933000 	ldr	r3, [r3]
70002f00:	e3530000 	cmp	r3, #0
70002f04:	1a00000d 	bne	70002f40 <rt_event_init+0x7c>
70002f08:	e3060324 	movw	r0, #25380	; 0x6324
70002f0c:	e3470002 	movt	r0, #28674	; 0x7002
70002f10:	e30613c8 	movw	r1, #25544	; 0x63c8
70002f14:	e3471002 	movt	r1, #28674	; 0x7002
70002f18:	e30624d8 	movw	r2, #25816	; 0x64d8
70002f1c:	e3472002 	movt	r2, #28674	; 0x7002
70002f20:	e300337b 	movw	r3, #891	; 0x37b
70002f24:	eb001232 	bl	700077f4 <rt_kprintf>
70002f28:	e1a00000 	nop			; (mov r0, r0)
70002f2c:	e55b3005 	ldrb	r3, [fp, #-5]
70002f30:	e6ef3073 	uxtb	r3, r3
70002f34:	e3530000 	cmp	r3, #0
70002f38:	0afffffb 	beq	70002f2c <rt_event_init+0x68>
70002f3c:	ea000008 	b	70002f64 <rt_event_init+0xa0>
70002f40:	e30a3b74 	movw	r3, #43892	; 0xab74
70002f44:	e3473002 	movt	r3, #28674	; 0x7002
70002f48:	e5933000 	ldr	r3, [r3]
70002f4c:	e30603c8 	movw	r0, #25544	; 0x63c8
70002f50:	e3470002 	movt	r0, #28674	; 0x7002
70002f54:	e30614d8 	movw	r1, #25816	; 0x64d8
70002f58:	e3471002 	movt	r1, #28674	; 0x7002
70002f5c:	e300237b 	movw	r2, #891	; 0x37b
70002f60:	e12fff33 	blx	r3

    /* init object */
    rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
70002f64:	e51b3010 	ldr	r3, [fp, #-16]
70002f68:	e1a00003 	mov	r0, r3
70002f6c:	e3a01003 	mov	r1, #3
70002f70:	e51b2014 	ldr	r2, [fp, #-20]
70002f74:	eb0018cd 	bl	700092b0 <rt_object_init>

    /* set parent flag */
    event->parent.parent.flag = flag;
70002f78:	e51b3010 	ldr	r3, [fp, #-16]
70002f7c:	e55b2015 	ldrb	r2, [fp, #-21]
70002f80:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
70002f84:	e51b3010 	ldr	r3, [fp, #-16]
70002f88:	e1a00003 	mov	r0, r3
70002f8c:	ebfffa0d 	bl	700017c8 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
70002f90:	e51b3010 	ldr	r3, [fp, #-16]
70002f94:	e3a02000 	mov	r2, #0
70002f98:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
70002f9c:	e3a03000 	mov	r3, #0
}
70002fa0:	e1a00003 	mov	r0, r3
70002fa4:	e24bd004 	sub	sp, fp, #4
70002fa8:	e8bd8800 	pop	{fp, pc}

70002fac <rt_event_detach>:
 * @param event the event object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_detach(rt_event_t event)
{
70002fac:	e92d4800 	push	{fp, lr}
70002fb0:	e28db004 	add	fp, sp, #4
70002fb4:	e24dd010 	sub	sp, sp, #16
70002fb8:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
70002fbc:	e51b3010 	ldr	r3, [fp, #-16]
70002fc0:	e3530000 	cmp	r3, #0
70002fc4:	1a00001d 	bne	70003040 <rt_event_detach+0x94>
70002fc8:	e3a03000 	mov	r3, #0
70002fcc:	e54b3005 	strb	r3, [fp, #-5]
70002fd0:	e30a3b74 	movw	r3, #43892	; 0xab74
70002fd4:	e3473002 	movt	r3, #28674	; 0x7002
70002fd8:	e5933000 	ldr	r3, [r3]
70002fdc:	e3530000 	cmp	r3, #0
70002fe0:	1a00000d 	bne	7000301c <rt_event_detach+0x70>
70002fe4:	e3060324 	movw	r0, #25380	; 0x6324
70002fe8:	e3470002 	movt	r0, #28674	; 0x7002
70002fec:	e30613c8 	movw	r1, #25544	; 0x63c8
70002ff0:	e3471002 	movt	r1, #28674	; 0x7002
70002ff4:	e30624e8 	movw	r2, #25832	; 0x64e8
70002ff8:	e3472002 	movt	r2, #28674	; 0x7002
70002ffc:	e3003397 	movw	r3, #919	; 0x397
70003000:	eb0011fb 	bl	700077f4 <rt_kprintf>
70003004:	e1a00000 	nop			; (mov r0, r0)
70003008:	e55b3005 	ldrb	r3, [fp, #-5]
7000300c:	e6ef3073 	uxtb	r3, r3
70003010:	e3530000 	cmp	r3, #0
70003014:	0afffffb 	beq	70003008 <rt_event_detach+0x5c>
70003018:	ea000008 	b	70003040 <rt_event_detach+0x94>
7000301c:	e30a3b74 	movw	r3, #43892	; 0xab74
70003020:	e3473002 	movt	r3, #28674	; 0x7002
70003024:	e5933000 	ldr	r3, [r3]
70003028:	e30603c8 	movw	r0, #25544	; 0x63c8
7000302c:	e3470002 	movt	r0, #28674	; 0x7002
70003030:	e30614e8 	movw	r1, #25832	; 0x64e8
70003034:	e3471002 	movt	r1, #28674	; 0x7002
70003038:	e3002397 	movw	r2, #919	; 0x397
7000303c:	e12fff33 	blx	r3

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
70003040:	e51b3010 	ldr	r3, [fp, #-16]
70003044:	e2833010 	add	r3, r3, #16
70003048:	e1a00003 	mov	r0, r3
7000304c:	ebfffa37 	bl	70001930 <rt_ipc_list_resume_all>

    /* detach event object */
    rt_object_detach(&(event->parent.parent));
70003050:	e51b3010 	ldr	r3, [fp, #-16]
70003054:	e1a00003 	mov	r0, r3
70003058:	eb0018c3 	bl	7000936c <rt_object_detach>

    return RT_EOK;
7000305c:	e3a03000 	mov	r3, #0
}
70003060:	e1a00003 	mov	r0, r3
70003064:	e24bd004 	sub	sp, fp, #4
70003068:	e8bd8800 	pop	{fp, pc}

7000306c <rt_event_create>:
 * @param flag the flag of event
 *
 * @return the created event, RT_NULL on error happen
 */
rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
{
7000306c:	e92d4800 	push	{fp, lr}
70003070:	e28db004 	add	fp, sp, #4
70003074:	e24dd018 	sub	sp, sp, #24
70003078:	e50b0018 	str	r0, [fp, #-24]
7000307c:	e1a03001 	mov	r3, r1
70003080:	e54b3019 	strb	r3, [fp, #-25]
    rt_event_t event;

    RT_DEBUG_NOT_IN_INTERRUPT;
70003084:	eb002c6f 	bl	7000e248 <rt_hw_interrupt_disable>
70003088:	e50b0008 	str	r0, [fp, #-8]
7000308c:	eb000b88 	bl	70005eb4 <rt_interrupt_get_nest>
70003090:	e1a03000 	mov	r3, r0
70003094:	e3530000 	cmp	r3, #0
70003098:	0a000022 	beq	70003128 <rt_event_create+0xbc>
7000309c:	e3060354 	movw	r0, #25428	; 0x6354
700030a0:	e3470002 	movt	r0, #28674	; 0x7002
700030a4:	e30614f8 	movw	r1, #25848	; 0x64f8
700030a8:	e3471002 	movt	r1, #28674	; 0x7002
700030ac:	eb0011d0 	bl	700077f4 <rt_kprintf>
700030b0:	e3a03000 	mov	r3, #0
700030b4:	e54b300d 	strb	r3, [fp, #-13]
700030b8:	e30a3b74 	movw	r3, #43892	; 0xab74
700030bc:	e3473002 	movt	r3, #28674	; 0x7002
700030c0:	e5933000 	ldr	r3, [r3]
700030c4:	e3530000 	cmp	r3, #0
700030c8:	1a00000d 	bne	70003104 <rt_event_create+0x98>
700030cc:	e3060324 	movw	r0, #25380	; 0x6324
700030d0:	e3470002 	movt	r0, #28674	; 0x7002
700030d4:	e3061378 	movw	r1, #25464	; 0x6378
700030d8:	e3471002 	movt	r1, #28674	; 0x7002
700030dc:	e30624f8 	movw	r2, #25848	; 0x64f8
700030e0:	e3472002 	movt	r2, #28674	; 0x7002
700030e4:	e3a03e3b 	mov	r3, #944	; 0x3b0
700030e8:	eb0011c1 	bl	700077f4 <rt_kprintf>
700030ec:	e1a00000 	nop			; (mov r0, r0)
700030f0:	e55b300d 	ldrb	r3, [fp, #-13]
700030f4:	e6ef3073 	uxtb	r3, r3
700030f8:	e3530000 	cmp	r3, #0
700030fc:	0afffffb 	beq	700030f0 <rt_event_create+0x84>
70003100:	ea000008 	b	70003128 <rt_event_create+0xbc>
70003104:	e30a3b74 	movw	r3, #43892	; 0xab74
70003108:	e3473002 	movt	r3, #28674	; 0x7002
7000310c:	e5933000 	ldr	r3, [r3]
70003110:	e3060378 	movw	r0, #25464	; 0x6378
70003114:	e3470002 	movt	r0, #28674	; 0x7002
70003118:	e30614f8 	movw	r1, #25848	; 0x64f8
7000311c:	e3471002 	movt	r1, #28674	; 0x7002
70003120:	e3a02e3b 	mov	r2, #944	; 0x3b0
70003124:	e12fff33 	blx	r3
70003128:	e51b0008 	ldr	r0, [fp, #-8]
7000312c:	eb002c48 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate object */
    event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
70003130:	e3a00003 	mov	r0, #3
70003134:	e51b1018 	ldr	r1, [fp, #-24]
70003138:	eb0018c4 	bl	70009450 <rt_object_allocate>
7000313c:	e50b000c 	str	r0, [fp, #-12]
    if (event == RT_NULL)
70003140:	e51b300c 	ldr	r3, [fp, #-12]
70003144:	e3530000 	cmp	r3, #0
70003148:	1a000001 	bne	70003154 <rt_event_create+0xe8>
        return event;
7000314c:	e51b300c 	ldr	r3, [fp, #-12]
70003150:	ea000009 	b	7000317c <rt_event_create+0x110>

    /* set parent */
    event->parent.parent.flag = flag;
70003154:	e51b300c 	ldr	r3, [fp, #-12]
70003158:	e55b2019 	ldrb	r2, [fp, #-25]
7000315c:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
70003160:	e51b300c 	ldr	r3, [fp, #-12]
70003164:	e1a00003 	mov	r0, r3
70003168:	ebfff996 	bl	700017c8 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
7000316c:	e51b300c 	ldr	r3, [fp, #-12]
70003170:	e3a02000 	mov	r2, #0
70003174:	e5832018 	str	r2, [r3, #24]

    return event;
70003178:	e51b300c 	ldr	r3, [fp, #-12]
}
7000317c:	e1a00003 	mov	r0, r3
70003180:	e24bd004 	sub	sp, fp, #4
70003184:	e8bd8800 	pop	{fp, pc}

70003188 <rt_event_delete>:
 * @param event the event object
 *
 * @return the error code
 */
rt_err_t rt_event_delete(rt_event_t event)
{
70003188:	e92d4800 	push	{fp, lr}
7000318c:	e28db004 	add	fp, sp, #4
70003190:	e24dd010 	sub	sp, sp, #16
70003194:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
70003198:	e51b3010 	ldr	r3, [fp, #-16]
7000319c:	e3530000 	cmp	r3, #0
700031a0:	1a00001d 	bne	7000321c <rt_event_delete+0x94>
700031a4:	e3a03000 	mov	r3, #0
700031a8:	e54b3009 	strb	r3, [fp, #-9]
700031ac:	e30a3b74 	movw	r3, #43892	; 0xab74
700031b0:	e3473002 	movt	r3, #28674	; 0x7002
700031b4:	e5933000 	ldr	r3, [r3]
700031b8:	e3530000 	cmp	r3, #0
700031bc:	1a00000d 	bne	700031f8 <rt_event_delete+0x70>
700031c0:	e3060324 	movw	r0, #25380	; 0x6324
700031c4:	e3470002 	movt	r0, #28674	; 0x7002
700031c8:	e30613c8 	movw	r1, #25544	; 0x63c8
700031cc:	e3471002 	movt	r1, #28674	; 0x7002
700031d0:	e3062508 	movw	r2, #25864	; 0x6508
700031d4:	e3472002 	movt	r2, #28674	; 0x7002
700031d8:	e30033ce 	movw	r3, #974	; 0x3ce
700031dc:	eb001184 	bl	700077f4 <rt_kprintf>
700031e0:	e1a00000 	nop			; (mov r0, r0)
700031e4:	e55b3009 	ldrb	r3, [fp, #-9]
700031e8:	e6ef3073 	uxtb	r3, r3
700031ec:	e3530000 	cmp	r3, #0
700031f0:	0afffffb 	beq	700031e4 <rt_event_delete+0x5c>
700031f4:	ea000008 	b	7000321c <rt_event_delete+0x94>
700031f8:	e30a3b74 	movw	r3, #43892	; 0xab74
700031fc:	e3473002 	movt	r3, #28674	; 0x7002
70003200:	e5933000 	ldr	r3, [r3]
70003204:	e30603c8 	movw	r0, #25544	; 0x63c8
70003208:	e3470002 	movt	r0, #28674	; 0x7002
7000320c:	e3061508 	movw	r1, #25864	; 0x6508
70003210:	e3471002 	movt	r1, #28674	; 0x7002
70003214:	e30023ce 	movw	r2, #974	; 0x3ce
70003218:	e12fff33 	blx	r3

    RT_DEBUG_NOT_IN_INTERRUPT;
7000321c:	eb002c09 	bl	7000e248 <rt_hw_interrupt_disable>
70003220:	e50b0008 	str	r0, [fp, #-8]
70003224:	eb000b22 	bl	70005eb4 <rt_interrupt_get_nest>
70003228:	e1a03000 	mov	r3, r0
7000322c:	e3530000 	cmp	r3, #0
70003230:	0a000022 	beq	700032c0 <rt_event_delete+0x138>
70003234:	e3060354 	movw	r0, #25428	; 0x6354
70003238:	e3470002 	movt	r0, #28674	; 0x7002
7000323c:	e3061508 	movw	r1, #25864	; 0x6508
70003240:	e3471002 	movt	r1, #28674	; 0x7002
70003244:	eb00116a 	bl	700077f4 <rt_kprintf>
70003248:	e3a03000 	mov	r3, #0
7000324c:	e54b300a 	strb	r3, [fp, #-10]
70003250:	e30a3b74 	movw	r3, #43892	; 0xab74
70003254:	e3473002 	movt	r3, #28674	; 0x7002
70003258:	e5933000 	ldr	r3, [r3]
7000325c:	e3530000 	cmp	r3, #0
70003260:	1a00000d 	bne	7000329c <rt_event_delete+0x114>
70003264:	e3060324 	movw	r0, #25380	; 0x6324
70003268:	e3470002 	movt	r0, #28674	; 0x7002
7000326c:	e3061378 	movw	r1, #25464	; 0x6378
70003270:	e3471002 	movt	r1, #28674	; 0x7002
70003274:	e3062508 	movw	r2, #25864	; 0x6508
70003278:	e3472002 	movt	r2, #28674	; 0x7002
7000327c:	e3a03e3d 	mov	r3, #976	; 0x3d0
70003280:	eb00115b 	bl	700077f4 <rt_kprintf>
70003284:	e1a00000 	nop			; (mov r0, r0)
70003288:	e55b300a 	ldrb	r3, [fp, #-10]
7000328c:	e6ef3073 	uxtb	r3, r3
70003290:	e3530000 	cmp	r3, #0
70003294:	0afffffb 	beq	70003288 <rt_event_delete+0x100>
70003298:	ea000008 	b	700032c0 <rt_event_delete+0x138>
7000329c:	e30a3b74 	movw	r3, #43892	; 0xab74
700032a0:	e3473002 	movt	r3, #28674	; 0x7002
700032a4:	e5933000 	ldr	r3, [r3]
700032a8:	e3060378 	movw	r0, #25464	; 0x6378
700032ac:	e3470002 	movt	r0, #28674	; 0x7002
700032b0:	e3061508 	movw	r1, #25864	; 0x6508
700032b4:	e3471002 	movt	r1, #28674	; 0x7002
700032b8:	e3a02e3d 	mov	r2, #976	; 0x3d0
700032bc:	e12fff33 	blx	r3
700032c0:	e51b0008 	ldr	r0, [fp, #-8]
700032c4:	eb002be2 	bl	7000e254 <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
700032c8:	e51b3010 	ldr	r3, [fp, #-16]
700032cc:	e2833010 	add	r3, r3, #16
700032d0:	e1a00003 	mov	r0, r3
700032d4:	ebfff995 	bl	70001930 <rt_ipc_list_resume_all>

    /* delete event object */
    rt_object_delete(&(event->parent.parent));
700032d8:	e51b3010 	ldr	r3, [fp, #-16]
700032dc:	e1a00003 	mov	r0, r3
700032e0:	eb0018bf 	bl	700095e4 <rt_object_delete>

    return RT_EOK;
700032e4:	e3a03000 	mov	r3, #0
}
700032e8:	e1a00003 	mov	r0, r3
700032ec:	e24bd004 	sub	sp, fp, #4
700032f0:	e8bd8800 	pop	{fp, pc}

700032f4 <rt_event_send>:
 * @param set the event set
 *
 * @return the error code
 */
rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
{
700032f4:	e92d4830 	push	{r4, r5, fp, lr}
700032f8:	e28db00c 	add	fp, sp, #12
700032fc:	e24dd018 	sub	sp, sp, #24
70003300:	e50b0020 	str	r0, [fp, #-32]
70003304:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_ubase_t level;
    register rt_base_t status;
    rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
70003308:	e51b3020 	ldr	r3, [fp, #-32]
7000330c:	e3530000 	cmp	r3, #0
70003310:	1a00001d 	bne	7000338c <rt_event_send+0x98>
70003314:	e3a03000 	mov	r3, #0
70003318:	e54b3019 	strb	r3, [fp, #-25]
7000331c:	e30a3b74 	movw	r3, #43892	; 0xab74
70003320:	e3473002 	movt	r3, #28674	; 0x7002
70003324:	e5933000 	ldr	r3, [r3]
70003328:	e3530000 	cmp	r3, #0
7000332c:	1a00000d 	bne	70003368 <rt_event_send+0x74>
70003330:	e3060324 	movw	r0, #25380	; 0x6324
70003334:	e3470002 	movt	r0, #28674	; 0x7002
70003338:	e30613c8 	movw	r1, #25544	; 0x63c8
7000333c:	e3471002 	movt	r1, #28674	; 0x7002
70003340:	e3062518 	movw	r2, #25880	; 0x6518
70003344:	e3472002 	movt	r2, #28674	; 0x7002
70003348:	e30033ef 	movw	r3, #1007	; 0x3ef
7000334c:	eb001128 	bl	700077f4 <rt_kprintf>
70003350:	e1a00000 	nop			; (mov r0, r0)
70003354:	e55b3019 	ldrb	r3, [fp, #-25]
70003358:	e6ef3073 	uxtb	r3, r3
7000335c:	e3530000 	cmp	r3, #0
70003360:	0afffffb 	beq	70003354 <rt_event_send+0x60>
70003364:	ea000008 	b	7000338c <rt_event_send+0x98>
70003368:	e30a3b74 	movw	r3, #43892	; 0xab74
7000336c:	e3473002 	movt	r3, #28674	; 0x7002
70003370:	e5933000 	ldr	r3, [r3]
70003374:	e30603c8 	movw	r0, #25544	; 0x63c8
70003378:	e3470002 	movt	r0, #28674	; 0x7002
7000337c:	e3061518 	movw	r1, #25880	; 0x6518
70003380:	e3471002 	movt	r1, #28674	; 0x7002
70003384:	e30023ef 	movw	r2, #1007	; 0x3ef
70003388:	e12fff33 	blx	r3
    if (set == 0)
7000338c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70003390:	e3530000 	cmp	r3, #0
70003394:	1a000001 	bne	700033a0 <rt_event_send+0xac>
        return -RT_ERROR;
70003398:	e3e03000 	mvn	r3, #0
7000339c:	ea00006b 	b	70003550 <rt_event_send+0x25c>

    need_schedule = RT_FALSE;
700033a0:	e3a03000 	mov	r3, #0
700033a4:	e50b3014 	str	r3, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
700033a8:	e30a3b78 	movw	r3, #43896	; 0xab78
700033ac:	e3473002 	movt	r3, #28674	; 0x7002
700033b0:	e5933000 	ldr	r3, [r3]
700033b4:	e3530000 	cmp	r3, #0
700033b8:	0a000005 	beq	700033d4 <rt_event_send+0xe0>
700033bc:	e30a3b78 	movw	r3, #43896	; 0xab78
700033c0:	e3473002 	movt	r3, #28674	; 0x7002
700033c4:	e5933000 	ldr	r3, [r3]
700033c8:	e51b2020 	ldr	r2, [fp, #-32]
700033cc:	e1a00002 	mov	r0, r2
700033d0:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
700033d4:	eb002b9b 	bl	7000e248 <rt_hw_interrupt_disable>
700033d8:	e1a03000 	mov	r3, r0
700033dc:	e1a05003 	mov	r5, r3

    /* set event */
    event->set |= set;
700033e0:	e51b3020 	ldr	r3, [fp, #-32]
700033e4:	e5932018 	ldr	r2, [r3, #24]
700033e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700033ec:	e1822003 	orr	r2, r2, r3
700033f0:	e51b3020 	ldr	r3, [fp, #-32]
700033f4:	e5832018 	str	r2, [r3, #24]

    if (!rt_list_isempty(&event->parent.suspend_thread))
700033f8:	e51b3020 	ldr	r3, [fp, #-32]
700033fc:	e2833010 	add	r3, r3, #16
70003400:	e1a00003 	mov	r0, r3
70003404:	ebfff8e0 	bl	7000178c <rt_list_isempty>
70003408:	e1a03000 	mov	r3, r0
7000340c:	e3530000 	cmp	r3, #0
70003410:	1a000046 	bne	70003530 <rt_event_send+0x23c>
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
70003414:	e51b3020 	ldr	r3, [fp, #-32]
70003418:	e5933010 	ldr	r3, [r3, #16]
7000341c:	e50b3010 	str	r3, [fp, #-16]
        while (n != &(event->parent.suspend_thread))
70003420:	ea00003d 	b	7000351c <rt_event_send+0x228>
        {
            /* get thread */
            thread = rt_list_entry(n, struct rt_thread, tlist);
70003424:	e51b3010 	ldr	r3, [fp, #-16]
70003428:	e2433010 	sub	r3, r3, #16
7000342c:	e50b3018 	str	r3, [fp, #-24]

            status = -RT_ERROR;
70003430:	e3e04000 	mvn	r4, #0
            if (thread->event_info & RT_EVENT_FLAG_AND)
70003434:	e51b3018 	ldr	r3, [fp, #-24]
70003438:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
7000343c:	e2033001 	and	r3, r3, #1
70003440:	e3530000 	cmp	r3, #0
70003444:	0a00000a 	beq	70003474 <rt_event_send+0x180>
            {
                if ((thread->event_set & event->set) == thread->event_set)
70003448:	e51b3018 	ldr	r3, [fp, #-24]
7000344c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
70003450:	e51b3020 	ldr	r3, [fp, #-32]
70003454:	e5933018 	ldr	r3, [r3, #24]
70003458:	e0022003 	and	r2, r2, r3
7000345c:	e51b3018 	ldr	r3, [fp, #-24]
70003460:	e5933038 	ldr	r3, [r3, #56]	; 0x38
70003464:	e1520003 	cmp	r2, r3
70003468:	1a000015 	bne	700034c4 <rt_event_send+0x1d0>
                {
                    /* received an AND event */
                    status = RT_EOK;
7000346c:	e3a04000 	mov	r4, #0
70003470:	ea000013 	b	700034c4 <rt_event_send+0x1d0>
                }
            }
            else if (thread->event_info & RT_EVENT_FLAG_OR)
70003474:	e51b3018 	ldr	r3, [fp, #-24]
70003478:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
7000347c:	e2033002 	and	r3, r3, #2
70003480:	e3530000 	cmp	r3, #0
70003484:	0a00000e 	beq	700034c4 <rt_event_send+0x1d0>
            {
                if (thread->event_set & event->set)
70003488:	e51b3018 	ldr	r3, [fp, #-24]
7000348c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
70003490:	e51b3020 	ldr	r3, [fp, #-32]
70003494:	e5933018 	ldr	r3, [r3, #24]
70003498:	e0023003 	and	r3, r2, r3
7000349c:	e3530000 	cmp	r3, #0
700034a0:	0a000007 	beq	700034c4 <rt_event_send+0x1d0>
                {
                    /* save recieved event set */
                    thread->event_set = thread->event_set & event->set;
700034a4:	e51b3018 	ldr	r3, [fp, #-24]
700034a8:	e5932038 	ldr	r2, [r3, #56]	; 0x38
700034ac:	e51b3020 	ldr	r3, [fp, #-32]
700034b0:	e5933018 	ldr	r3, [r3, #24]
700034b4:	e0022003 	and	r2, r2, r3
700034b8:	e51b3018 	ldr	r3, [fp, #-24]
700034bc:	e5832038 	str	r2, [r3, #56]	; 0x38

                    /* received an OR event */
                    status = RT_EOK;
700034c0:	e3a04000 	mov	r4, #0
                }
            }

            /* move node to the next */
            n = n->next;
700034c4:	e51b3010 	ldr	r3, [fp, #-16]
700034c8:	e5933000 	ldr	r3, [r3]
700034cc:	e50b3010 	str	r3, [fp, #-16]

            /* condition is satisfied, resume thread */
            if (status == RT_EOK)
700034d0:	e3540000 	cmp	r4, #0
700034d4:	1a000010 	bne	7000351c <rt_event_send+0x228>
            {
                /* clear event */
                if (thread->event_info & RT_EVENT_FLAG_CLEAR)
700034d8:	e51b3018 	ldr	r3, [fp, #-24]
700034dc:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
700034e0:	e2033004 	and	r3, r3, #4
700034e4:	e3530000 	cmp	r3, #0
700034e8:	0a000007 	beq	7000350c <rt_event_send+0x218>
                    event->set &= ~thread->event_set;
700034ec:	e51b3020 	ldr	r3, [fp, #-32]
700034f0:	e5932018 	ldr	r2, [r3, #24]
700034f4:	e51b3018 	ldr	r3, [fp, #-24]
700034f8:	e5933038 	ldr	r3, [r3, #56]	; 0x38
700034fc:	e1e03003 	mvn	r3, r3
70003500:	e0022003 	and	r2, r2, r3
70003504:	e51b3020 	ldr	r3, [fp, #-32]
70003508:	e5832018 	str	r2, [r3, #24]

                /* resume thread, and thread list breaks out */
                rt_thread_resume(thread);
7000350c:	e51b0018 	ldr	r0, [fp, #-24]
70003510:	eb001e42 	bl	7000ae20 <rt_thread_resume>

                /* need do a scheduling */
                need_schedule = RT_TRUE;
70003514:	e3a03001 	mov	r3, #1
70003518:	e50b3014 	str	r3, [fp, #-20]

    if (!rt_list_isempty(&event->parent.suspend_thread))
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
        while (n != &(event->parent.suspend_thread))
7000351c:	e51b3020 	ldr	r3, [fp, #-32]
70003520:	e2832010 	add	r2, r3, #16
70003524:	e51b3010 	ldr	r3, [fp, #-16]
70003528:	e1520003 	cmp	r2, r3
7000352c:	1affffbc 	bne	70003424 <rt_event_send+0x130>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
70003530:	e1a03005 	mov	r3, r5
70003534:	e1a00003 	mov	r0, r3
70003538:	eb002b45 	bl	7000e254 <rt_hw_interrupt_enable>

    /* do a schedule */
    if (need_schedule == RT_TRUE)
7000353c:	e51b3014 	ldr	r3, [fp, #-20]
70003540:	e3530001 	cmp	r3, #1
70003544:	1a000000 	bne	7000354c <rt_event_send+0x258>
        rt_schedule();
70003548:	eb0019a5 	bl	70009be4 <rt_schedule>

    return RT_EOK;
7000354c:	e3a03000 	mov	r3, #0
}
70003550:	e1a00003 	mov	r0, r3
70003554:	e24bd00c 	sub	sp, fp, #12
70003558:	e8bd8830 	pop	{r4, r5, fp, pc}

7000355c <rt_event_recv>:
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   option,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
{
7000355c:	e92d4830 	push	{r4, r5, fp, lr}
70003560:	e28db00c 	add	fp, sp, #12
70003564:	e24dd020 	sub	sp, sp, #32
70003568:	e50b0020 	str	r0, [fp, #-32]
7000356c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
70003570:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
70003574:	e1a03002 	mov	r3, r2
70003578:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
    struct rt_thread *thread;
    register rt_ubase_t level;
    register rt_base_t status;

    RT_DEBUG_IN_THREAD_CONTEXT;
7000357c:	eb002b31 	bl	7000e248 <rt_hw_interrupt_disable>
70003580:	e50b0010 	str	r0, [fp, #-16]
70003584:	eb001bf9 	bl	7000a570 <rt_thread_self>
70003588:	e1a03000 	mov	r3, r0
7000358c:	e3530000 	cmp	r3, #0
70003590:	1a000022 	bne	70003620 <rt_event_recv+0xc4>
70003594:	e306037c 	movw	r0, #25468	; 0x637c
70003598:	e3470002 	movt	r0, #28674	; 0x7002
7000359c:	e3061528 	movw	r1, #25896	; 0x6528
700035a0:	e3471002 	movt	r1, #28674	; 0x7002
700035a4:	eb001092 	bl	700077f4 <rt_kprintf>
700035a8:	e3a03000 	mov	r3, #0
700035ac:	e54b3019 	strb	r3, [fp, #-25]
700035b0:	e30a3b74 	movw	r3, #43892	; 0xab74
700035b4:	e3473002 	movt	r3, #28674	; 0x7002
700035b8:	e5933000 	ldr	r3, [r3]
700035bc:	e3530000 	cmp	r3, #0
700035c0:	1a00000d 	bne	700035fc <rt_event_recv+0xa0>
700035c4:	e3060324 	movw	r0, #25380	; 0x6324
700035c8:	e3470002 	movt	r0, #28674	; 0x7002
700035cc:	e3061378 	movw	r1, #25464	; 0x6378
700035d0:	e3471002 	movt	r1, #28674	; 0x7002
700035d4:	e3062528 	movw	r2, #25896	; 0x6528
700035d8:	e3472002 	movt	r2, #28674	; 0x7002
700035dc:	e300344f 	movw	r3, #1103	; 0x44f
700035e0:	eb001083 	bl	700077f4 <rt_kprintf>
700035e4:	e1a00000 	nop			; (mov r0, r0)
700035e8:	e55b3019 	ldrb	r3, [fp, #-25]
700035ec:	e6ef3073 	uxtb	r3, r3
700035f0:	e3530000 	cmp	r3, #0
700035f4:	0afffffb 	beq	700035e8 <rt_event_recv+0x8c>
700035f8:	ea000008 	b	70003620 <rt_event_recv+0xc4>
700035fc:	e30a3b74 	movw	r3, #43892	; 0xab74
70003600:	e3473002 	movt	r3, #28674	; 0x7002
70003604:	e5933000 	ldr	r3, [r3]
70003608:	e3060378 	movw	r0, #25464	; 0x6378
7000360c:	e3470002 	movt	r0, #28674	; 0x7002
70003610:	e3061528 	movw	r1, #25896	; 0x6528
70003614:	e3471002 	movt	r1, #28674	; 0x7002
70003618:	e300244f 	movw	r2, #1103	; 0x44f
7000361c:	e12fff33 	blx	r3
70003620:	eb002b08 	bl	7000e248 <rt_hw_interrupt_disable>
70003624:	e50b0014 	str	r0, [fp, #-20]
70003628:	eb000a21 	bl	70005eb4 <rt_interrupt_get_nest>
7000362c:	e1a03000 	mov	r3, r0
70003630:	e3530000 	cmp	r3, #0
70003634:	0a000022 	beq	700036c4 <rt_event_recv+0x168>
70003638:	e3060354 	movw	r0, #25428	; 0x6354
7000363c:	e3470002 	movt	r0, #28674	; 0x7002
70003640:	e3061528 	movw	r1, #25896	; 0x6528
70003644:	e3471002 	movt	r1, #28674	; 0x7002
70003648:	eb001069 	bl	700077f4 <rt_kprintf>
7000364c:	e3a03000 	mov	r3, #0
70003650:	e54b301a 	strb	r3, [fp, #-26]
70003654:	e30a3b74 	movw	r3, #43892	; 0xab74
70003658:	e3473002 	movt	r3, #28674	; 0x7002
7000365c:	e5933000 	ldr	r3, [r3]
70003660:	e3530000 	cmp	r3, #0
70003664:	1a00000d 	bne	700036a0 <rt_event_recv+0x144>
70003668:	e3060324 	movw	r0, #25380	; 0x6324
7000366c:	e3470002 	movt	r0, #28674	; 0x7002
70003670:	e3061378 	movw	r1, #25464	; 0x6378
70003674:	e3471002 	movt	r1, #28674	; 0x7002
70003678:	e3062528 	movw	r2, #25896	; 0x6528
7000367c:	e3472002 	movt	r2, #28674	; 0x7002
70003680:	e300344f 	movw	r3, #1103	; 0x44f
70003684:	eb00105a 	bl	700077f4 <rt_kprintf>
70003688:	e1a00000 	nop			; (mov r0, r0)
7000368c:	e55b301a 	ldrb	r3, [fp, #-26]
70003690:	e6ef3073 	uxtb	r3, r3
70003694:	e3530000 	cmp	r3, #0
70003698:	0afffffb 	beq	7000368c <rt_event_recv+0x130>
7000369c:	ea000008 	b	700036c4 <rt_event_recv+0x168>
700036a0:	e30a3b74 	movw	r3, #43892	; 0xab74
700036a4:	e3473002 	movt	r3, #28674	; 0x7002
700036a8:	e5933000 	ldr	r3, [r3]
700036ac:	e3060378 	movw	r0, #25464	; 0x6378
700036b0:	e3470002 	movt	r0, #28674	; 0x7002
700036b4:	e3061528 	movw	r1, #25896	; 0x6528
700036b8:	e3471002 	movt	r1, #28674	; 0x7002
700036bc:	e300244f 	movw	r2, #1103	; 0x44f
700036c0:	e12fff33 	blx	r3
700036c4:	e51b0014 	ldr	r0, [fp, #-20]
700036c8:	eb002ae1 	bl	7000e254 <rt_hw_interrupt_enable>
700036cc:	e51b0010 	ldr	r0, [fp, #-16]
700036d0:	eb002adf 	bl	7000e254 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
700036d4:	e51b3020 	ldr	r3, [fp, #-32]
700036d8:	e3530000 	cmp	r3, #0
700036dc:	1a00001d 	bne	70003758 <rt_event_recv+0x1fc>
700036e0:	e3a03000 	mov	r3, #0
700036e4:	e54b301b 	strb	r3, [fp, #-27]
700036e8:	e30a3b74 	movw	r3, #43892	; 0xab74
700036ec:	e3473002 	movt	r3, #28674	; 0x7002
700036f0:	e5933000 	ldr	r3, [r3]
700036f4:	e3530000 	cmp	r3, #0
700036f8:	1a00000d 	bne	70003734 <rt_event_recv+0x1d8>
700036fc:	e3060324 	movw	r0, #25380	; 0x6324
70003700:	e3470002 	movt	r0, #28674	; 0x7002
70003704:	e30613c8 	movw	r1, #25544	; 0x63c8
70003708:	e3471002 	movt	r1, #28674	; 0x7002
7000370c:	e3062528 	movw	r2, #25896	; 0x6528
70003710:	e3472002 	movt	r2, #28674	; 0x7002
70003714:	e3003452 	movw	r3, #1106	; 0x452
70003718:	eb001035 	bl	700077f4 <rt_kprintf>
7000371c:	e1a00000 	nop			; (mov r0, r0)
70003720:	e55b301b 	ldrb	r3, [fp, #-27]
70003724:	e6ef3073 	uxtb	r3, r3
70003728:	e3530000 	cmp	r3, #0
7000372c:	0afffffb 	beq	70003720 <rt_event_recv+0x1c4>
70003730:	ea000008 	b	70003758 <rt_event_recv+0x1fc>
70003734:	e30a3b74 	movw	r3, #43892	; 0xab74
70003738:	e3473002 	movt	r3, #28674	; 0x7002
7000373c:	e5933000 	ldr	r3, [r3]
70003740:	e30603c8 	movw	r0, #25544	; 0x63c8
70003744:	e3470002 	movt	r0, #28674	; 0x7002
70003748:	e3061528 	movw	r1, #25896	; 0x6528
7000374c:	e3471002 	movt	r1, #28674	; 0x7002
70003750:	e3002452 	movw	r2, #1106	; 0x452
70003754:	e12fff33 	blx	r3
    if (set == 0)
70003758:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7000375c:	e3530000 	cmp	r3, #0
70003760:	1a000001 	bne	7000376c <rt_event_recv+0x210>
        return -RT_ERROR;
70003764:	e3e03000 	mvn	r3, #0
70003768:	ea0000a3 	b	700039fc <rt_event_recv+0x4a0>

    /* init status */
    status = -RT_ERROR;
7000376c:	e3e05000 	mvn	r5, #0
    /* get current thread */
    thread = rt_thread_self();
70003770:	eb001b7e 	bl	7000a570 <rt_thread_self>
70003774:	e50b0018 	str	r0, [fp, #-24]
    /* reset thread error */
    thread->error = RT_EOK;
70003778:	e51b3018 	ldr	r3, [fp, #-24]
7000377c:	e3a02000 	mov	r2, #0
70003780:	e583202c 	str	r2, [r3, #44]	; 0x2c

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
70003784:	e30a3b80 	movw	r3, #43904	; 0xab80
70003788:	e3473002 	movt	r3, #28674	; 0x7002
7000378c:	e5933000 	ldr	r3, [r3]
70003790:	e3530000 	cmp	r3, #0
70003794:	0a000005 	beq	700037b0 <rt_event_recv+0x254>
70003798:	e30a3b80 	movw	r3, #43904	; 0xab80
7000379c:	e3473002 	movt	r3, #28674	; 0x7002
700037a0:	e5933000 	ldr	r3, [r3]
700037a4:	e51b2020 	ldr	r2, [fp, #-32]
700037a8:	e1a00002 	mov	r0, r2
700037ac:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
700037b0:	eb002aa4 	bl	7000e248 <rt_hw_interrupt_disable>
700037b4:	e1a03000 	mov	r3, r0
700037b8:	e1a04003 	mov	r4, r3

    /* check event set */
    if (option & RT_EVENT_FLAG_AND)
700037bc:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
700037c0:	e2033001 	and	r3, r3, #1
700037c4:	e3530000 	cmp	r3, #0
700037c8:	0a000008 	beq	700037f0 <rt_event_recv+0x294>
    {
        if ((event->set & set) == set)
700037cc:	e51b3020 	ldr	r3, [fp, #-32]
700037d0:	e5932018 	ldr	r2, [r3, #24]
700037d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700037d8:	e0022003 	and	r2, r2, r3
700037dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700037e0:	e1520003 	cmp	r2, r3
700037e4:	1a00002b 	bne	70003898 <rt_event_recv+0x33c>
            status = RT_EOK;
700037e8:	e3a05000 	mov	r5, #0
700037ec:	ea000029 	b	70003898 <rt_event_recv+0x33c>
    }
    else if (option & RT_EVENT_FLAG_OR)
700037f0:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
700037f4:	e2033002 	and	r3, r3, #2
700037f8:	e3530000 	cmp	r3, #0
700037fc:	0a000007 	beq	70003820 <rt_event_recv+0x2c4>
    {
        if (event->set & set)
70003800:	e51b3020 	ldr	r3, [fp, #-32]
70003804:	e5932018 	ldr	r2, [r3, #24]
70003808:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7000380c:	e0023003 	and	r3, r2, r3
70003810:	e3530000 	cmp	r3, #0
70003814:	0a00001f 	beq	70003898 <rt_event_recv+0x33c>
            status = RT_EOK;
70003818:	e3a05000 	mov	r5, #0
7000381c:	ea00001d 	b	70003898 <rt_event_recv+0x33c>
    }
    else
    {
        /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
        RT_ASSERT(0);
70003820:	e3a03000 	mov	r3, #0
70003824:	e54b301c 	strb	r3, [fp, #-28]
70003828:	e30a3b74 	movw	r3, #43892	; 0xab74
7000382c:	e3473002 	movt	r3, #28674	; 0x7002
70003830:	e5933000 	ldr	r3, [r3]
70003834:	e3530000 	cmp	r3, #0
70003838:	1a00000d 	bne	70003874 <rt_event_recv+0x318>
7000383c:	e3060324 	movw	r0, #25380	; 0x6324
70003840:	e3470002 	movt	r0, #28674	; 0x7002
70003844:	e3061378 	movw	r1, #25464	; 0x6378
70003848:	e3471002 	movt	r1, #28674	; 0x7002
7000384c:	e3062528 	movw	r2, #25896	; 0x6528
70003850:	e3472002 	movt	r2, #28674	; 0x7002
70003854:	e3a03e47 	mov	r3, #1136	; 0x470
70003858:	eb000fe5 	bl	700077f4 <rt_kprintf>
7000385c:	e1a00000 	nop			; (mov r0, r0)
70003860:	e55b301c 	ldrb	r3, [fp, #-28]
70003864:	e6ef3073 	uxtb	r3, r3
70003868:	e3530000 	cmp	r3, #0
7000386c:	0afffffb 	beq	70003860 <rt_event_recv+0x304>
70003870:	ea000008 	b	70003898 <rt_event_recv+0x33c>
70003874:	e30a3b74 	movw	r3, #43892	; 0xab74
70003878:	e3473002 	movt	r3, #28674	; 0x7002
7000387c:	e5933000 	ldr	r3, [r3]
70003880:	e3060378 	movw	r0, #25464	; 0x6378
70003884:	e3470002 	movt	r0, #28674	; 0x7002
70003888:	e3061528 	movw	r1, #25896	; 0x6528
7000388c:	e3471002 	movt	r1, #28674	; 0x7002
70003890:	e3a02e47 	mov	r2, #1136	; 0x470
70003894:	e12fff33 	blx	r3
    }

    if (status == RT_EOK)
70003898:	e3550000 	cmp	r5, #0
7000389c:	1a000011 	bne	700038e8 <rt_event_recv+0x38c>
    {
        /* set received event */
        *recved = (event->set & set);
700038a0:	e51b3020 	ldr	r3, [fp, #-32]
700038a4:	e5932018 	ldr	r2, [r3, #24]
700038a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700038ac:	e0022003 	and	r2, r2, r3
700038b0:	e59b3004 	ldr	r3, [fp, #4]
700038b4:	e5832000 	str	r2, [r3]

        /* received event */
        if (option & RT_EVENT_FLAG_CLEAR)
700038b8:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
700038bc:	e2033004 	and	r3, r3, #4
700038c0:	e3530000 	cmp	r3, #0
700038c4:	0a00003c 	beq	700039bc <rt_event_recv+0x460>
            event->set &= ~set;
700038c8:	e51b3020 	ldr	r3, [fp, #-32]
700038cc:	e5932018 	ldr	r2, [r3, #24]
700038d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700038d4:	e1e03003 	mvn	r3, r3
700038d8:	e0022003 	and	r2, r2, r3
700038dc:	e51b3020 	ldr	r3, [fp, #-32]
700038e0:	e5832018 	str	r2, [r3, #24]
700038e4:	ea000034 	b	700039bc <rt_event_recv+0x460>
    }
    else if (timeout == 0)
700038e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
700038ec:	e3530000 	cmp	r3, #0
700038f0:	1a000003 	bne	70003904 <rt_event_recv+0x3a8>
    {
        /* no waiting */
        thread->error = -RT_ETIMEOUT;
700038f4:	e51b3018 	ldr	r3, [fp, #-24]
700038f8:	e3e02001 	mvn	r2, #1
700038fc:	e583202c 	str	r2, [r3, #44]	; 0x2c
70003900:	ea00002d 	b	700039bc <rt_event_recv+0x460>
    }
    else
    {
        /* fill thread event info */
        thread->event_set  = set;
70003904:	e51b3018 	ldr	r3, [fp, #-24]
70003908:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
7000390c:	e5832038 	str	r2, [r3, #56]	; 0x38
        thread->event_info = option;
70003910:	e51b3018 	ldr	r3, [fp, #-24]
70003914:	e55b2025 	ldrb	r2, [fp, #-37]	; 0x25
70003918:	e5c3203c 	strb	r2, [r3, #60]	; 0x3c

        /* put thread to suspended thread list */
        rt_ipc_list_suspend(&(event->parent.suspend_thread),
7000391c:	e51b3020 	ldr	r3, [fp, #-32]
70003920:	e2832010 	add	r2, r3, #16
70003924:	e51b3020 	ldr	r3, [fp, #-32]
70003928:	e5d33007 	ldrb	r3, [r3, #7]
7000392c:	e1a00002 	mov	r0, r2
70003930:	e51b1018 	ldr	r1, [fp, #-24]
70003934:	e1a02003 	mov	r2, r3
70003938:	ebfff7ae 	bl	700017f8 <rt_ipc_list_suspend>
                            thread,
                            event->parent.parent.flag);

        /* if there is a waiting timeout, active thread timer */
        if (timeout > 0)
7000393c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70003940:	e3530000 	cmp	r3, #0
70003944:	da00000a 	ble	70003974 <rt_event_recv+0x418>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
70003948:	e51b3018 	ldr	r3, [fp, #-24]
7000394c:	e2832048 	add	r2, r3, #72	; 0x48
70003950:	e24b302c 	sub	r3, fp, #44	; 0x2c
70003954:	e1a00002 	mov	r0, r2
70003958:	e3a01000 	mov	r1, #0
7000395c:	e1a02003 	mov	r2, r3
70003960:	eb0020a0 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
70003964:	e51b3018 	ldr	r3, [fp, #-24]
70003968:	e2833048 	add	r3, r3, #72	; 0x48
7000396c:	e1a00003 	mov	r0, r3
70003970:	eb001f50 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70003974:	e1a03004 	mov	r3, r4
70003978:	e1a00003 	mov	r0, r3
7000397c:	eb002a34 	bl	7000e254 <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
70003980:	eb001897 	bl	70009be4 <rt_schedule>

        if (thread->error != RT_EOK)
70003984:	e51b3018 	ldr	r3, [fp, #-24]
70003988:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7000398c:	e3530000 	cmp	r3, #0
70003990:	0a000002 	beq	700039a0 <rt_event_recv+0x444>
        {
            /* return error */
            return thread->error;
70003994:	e51b3018 	ldr	r3, [fp, #-24]
70003998:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7000399c:	ea000016 	b	700039fc <rt_event_recv+0x4a0>
        }

        /* received an event, disable interrupt to protect */
        level = rt_hw_interrupt_disable();
700039a0:	eb002a28 	bl	7000e248 <rt_hw_interrupt_disable>
700039a4:	e1a03000 	mov	r3, r0
700039a8:	e1a04003 	mov	r4, r3

        /* set received event */
        *recved = thread->event_set;
700039ac:	e51b3018 	ldr	r3, [fp, #-24]
700039b0:	e5932038 	ldr	r2, [r3, #56]	; 0x38
700039b4:	e59b3004 	ldr	r3, [fp, #4]
700039b8:	e5832000 	str	r2, [r3]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
700039bc:	e1a03004 	mov	r3, r4
700039c0:	e1a00003 	mov	r0, r3
700039c4:	eb002a22 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
700039c8:	e30a3b7c 	movw	r3, #43900	; 0xab7c
700039cc:	e3473002 	movt	r3, #28674	; 0x7002
700039d0:	e5933000 	ldr	r3, [r3]
700039d4:	e3530000 	cmp	r3, #0
700039d8:	0a000005 	beq	700039f4 <rt_event_recv+0x498>
700039dc:	e30a3b7c 	movw	r3, #43900	; 0xab7c
700039e0:	e3473002 	movt	r3, #28674	; 0x7002
700039e4:	e5933000 	ldr	r3, [r3]
700039e8:	e51b2020 	ldr	r2, [fp, #-32]
700039ec:	e1a00002 	mov	r0, r2
700039f0:	e12fff33 	blx	r3

    return thread->error;
700039f4:	e51b3018 	ldr	r3, [fp, #-24]
700039f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
700039fc:	e1a00003 	mov	r0, r3
70003a00:	e24bd00c 	sub	sp, fp, #12
70003a04:	e8bd8830 	pop	{r4, r5, fp, pc}

70003a08 <rt_event_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
{
70003a08:	e92d4800 	push	{fp, lr}
70003a0c:	e28db004 	add	fp, sp, #4
70003a10:	e24dd018 	sub	sp, sp, #24
70003a14:	e50b0010 	str	r0, [fp, #-16]
70003a18:	e1a03001 	mov	r3, r1
70003a1c:	e50b2018 	str	r2, [fp, #-24]
70003a20:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(event != RT_NULL);
70003a24:	e51b3010 	ldr	r3, [fp, #-16]
70003a28:	e3530000 	cmp	r3, #0
70003a2c:	1a00001d 	bne	70003aa8 <rt_event_control+0xa0>
70003a30:	e3a03000 	mov	r3, #0
70003a34:	e54b3009 	strb	r3, [fp, #-9]
70003a38:	e30a3b74 	movw	r3, #43892	; 0xab74
70003a3c:	e3473002 	movt	r3, #28674	; 0x7002
70003a40:	e5933000 	ldr	r3, [r3]
70003a44:	e3530000 	cmp	r3, #0
70003a48:	1a00000d 	bne	70003a84 <rt_event_control+0x7c>
70003a4c:	e3060324 	movw	r0, #25380	; 0x6324
70003a50:	e3470002 	movt	r0, #28674	; 0x7002
70003a54:	e30613c8 	movw	r1, #25544	; 0x63c8
70003a58:	e3471002 	movt	r1, #28674	; 0x7002
70003a5c:	e3062538 	movw	r2, #25912	; 0x6538
70003a60:	e3472002 	movt	r2, #28674	; 0x7002
70003a64:	e30034be 	movw	r3, #1214	; 0x4be
70003a68:	eb000f61 	bl	700077f4 <rt_kprintf>
70003a6c:	e1a00000 	nop			; (mov r0, r0)
70003a70:	e55b3009 	ldrb	r3, [fp, #-9]
70003a74:	e6ef3073 	uxtb	r3, r3
70003a78:	e3530000 	cmp	r3, #0
70003a7c:	0afffffb 	beq	70003a70 <rt_event_control+0x68>
70003a80:	ea000008 	b	70003aa8 <rt_event_control+0xa0>
70003a84:	e30a3b74 	movw	r3, #43892	; 0xab74
70003a88:	e3473002 	movt	r3, #28674	; 0x7002
70003a8c:	e5933000 	ldr	r3, [r3]
70003a90:	e30603c8 	movw	r0, #25544	; 0x63c8
70003a94:	e3470002 	movt	r0, #28674	; 0x7002
70003a98:	e3061538 	movw	r1, #25912	; 0x6538
70003a9c:	e3471002 	movt	r1, #28674	; 0x7002
70003aa0:	e30024be 	movw	r2, #1214	; 0x4be
70003aa4:	e12fff33 	blx	r3

    if (cmd == RT_IPC_CMD_RESET)
70003aa8:	e55b3011 	ldrb	r3, [fp, #-17]
70003aac:	e3530001 	cmp	r3, #1
70003ab0:	1a00000f 	bne	70003af4 <rt_event_control+0xec>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
70003ab4:	eb0029e3 	bl	7000e248 <rt_hw_interrupt_disable>
70003ab8:	e1a03000 	mov	r3, r0
70003abc:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&event->parent.suspend_thread);
70003ac0:	e51b3010 	ldr	r3, [fp, #-16]
70003ac4:	e2833010 	add	r3, r3, #16
70003ac8:	e1a00003 	mov	r0, r3
70003acc:	ebfff797 	bl	70001930 <rt_ipc_list_resume_all>

        /* init event set */
        event->set = 0;
70003ad0:	e51b3010 	ldr	r3, [fp, #-16]
70003ad4:	e3a02000 	mov	r2, #0
70003ad8:	e5832018 	str	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70003adc:	e51b3008 	ldr	r3, [fp, #-8]
70003ae0:	e1a00003 	mov	r0, r3
70003ae4:	eb0029da 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
70003ae8:	eb00183d 	bl	70009be4 <rt_schedule>

        return RT_EOK;
70003aec:	e3a03000 	mov	r3, #0
70003af0:	ea000000 	b	70003af8 <rt_event_control+0xf0>
    }

    return -RT_ERROR;
70003af4:	e3e03000 	mvn	r3, #0
}
70003af8:	e1a00003 	mov	r0, r3
70003afc:	e24bd004 	sub	sp, fp, #4
70003b00:	e8bd8800 	pop	{fp, pc}

70003b04 <rt_mb_init>:
rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char  *name,
                    void        *msgpool,
                    rt_size_t    size,
                    rt_uint8_t   flag)
{
70003b04:	e92d4800 	push	{fp, lr}
70003b08:	e28db004 	add	fp, sp, #4
70003b0c:	e24dd018 	sub	sp, sp, #24
70003b10:	e50b0010 	str	r0, [fp, #-16]
70003b14:	e50b1014 	str	r1, [fp, #-20]
70003b18:	e50b2018 	str	r2, [fp, #-24]
70003b1c:	e50b301c 	str	r3, [fp, #-28]
    RT_ASSERT(mb != RT_NULL);
70003b20:	e51b3010 	ldr	r3, [fp, #-16]
70003b24:	e3530000 	cmp	r3, #0
70003b28:	1a00001d 	bne	70003ba4 <rt_mb_init+0xa0>
70003b2c:	e3a03000 	mov	r3, #0
70003b30:	e54b3005 	strb	r3, [fp, #-5]
70003b34:	e30a3b74 	movw	r3, #43892	; 0xab74
70003b38:	e3473002 	movt	r3, #28674	; 0x7002
70003b3c:	e5933000 	ldr	r3, [r3]
70003b40:	e3530000 	cmp	r3, #0
70003b44:	1a00000d 	bne	70003b80 <rt_mb_init+0x7c>
70003b48:	e3060324 	movw	r0, #25380	; 0x6324
70003b4c:	e3470002 	movt	r0, #28674	; 0x7002
70003b50:	e30613dc 	movw	r1, #25564	; 0x63dc
70003b54:	e3471002 	movt	r1, #28674	; 0x7002
70003b58:	e306254c 	movw	r2, #25932	; 0x654c
70003b5c:	e3472002 	movt	r2, #28674	; 0x7002
70003b60:	e30034eb 	movw	r3, #1259	; 0x4eb
70003b64:	eb000f22 	bl	700077f4 <rt_kprintf>
70003b68:	e1a00000 	nop			; (mov r0, r0)
70003b6c:	e55b3005 	ldrb	r3, [fp, #-5]
70003b70:	e6ef3073 	uxtb	r3, r3
70003b74:	e3530000 	cmp	r3, #0
70003b78:	0afffffb 	beq	70003b6c <rt_mb_init+0x68>
70003b7c:	ea000008 	b	70003ba4 <rt_mb_init+0xa0>
70003b80:	e30a3b74 	movw	r3, #43892	; 0xab74
70003b84:	e3473002 	movt	r3, #28674	; 0x7002
70003b88:	e5933000 	ldr	r3, [r3]
70003b8c:	e30603dc 	movw	r0, #25564	; 0x63dc
70003b90:	e3470002 	movt	r0, #28674	; 0x7002
70003b94:	e306154c 	movw	r1, #25932	; 0x654c
70003b98:	e3471002 	movt	r1, #28674	; 0x7002
70003b9c:	e30024eb 	movw	r2, #1259	; 0x4eb
70003ba0:	e12fff33 	blx	r3

    /* init object */
    rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
70003ba4:	e51b3010 	ldr	r3, [fp, #-16]
70003ba8:	e1a00003 	mov	r0, r3
70003bac:	e3a01004 	mov	r1, #4
70003bb0:	e51b2014 	ldr	r2, [fp, #-20]
70003bb4:	eb0015bd 	bl	700092b0 <rt_object_init>

    /* set parent flag */
    mb->parent.parent.flag = flag;
70003bb8:	e51b3010 	ldr	r3, [fp, #-16]
70003bbc:	e5db2004 	ldrb	r2, [fp, #4]
70003bc0:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
70003bc4:	e51b3010 	ldr	r3, [fp, #-16]
70003bc8:	e1a00003 	mov	r0, r3
70003bcc:	ebfff6fd 	bl	700017c8 <rt_ipc_object_init>

    /* init mailbox */
    mb->msg_pool   = msgpool;
70003bd0:	e51b3010 	ldr	r3, [fp, #-16]
70003bd4:	e51b2018 	ldr	r2, [fp, #-24]
70003bd8:	e5832018 	str	r2, [r3, #24]
    mb->size       = size;
70003bdc:	e51b301c 	ldr	r3, [fp, #-28]
70003be0:	e6ff2073 	uxth	r2, r3
70003be4:	e51b3010 	ldr	r3, [fp, #-16]
70003be8:	e1c321bc 	strh	r2, [r3, #28]
    mb->entry      = 0;
70003bec:	e51b3010 	ldr	r3, [fp, #-16]
70003bf0:	e3a02000 	mov	r2, #0
70003bf4:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
70003bf8:	e51b3010 	ldr	r3, [fp, #-16]
70003bfc:	e3a02000 	mov	r2, #0
70003c00:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
70003c04:	e51b3010 	ldr	r3, [fp, #-16]
70003c08:	e3a02000 	mov	r2, #0
70003c0c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
70003c10:	e51b3010 	ldr	r3, [fp, #-16]
70003c14:	e2833024 	add	r3, r3, #36	; 0x24
70003c18:	e1a00003 	mov	r0, r3
70003c1c:	ebfff6b6 	bl	700016fc <rt_list_init>

    return RT_EOK;
70003c20:	e3a03000 	mov	r3, #0
}
70003c24:	e1a00003 	mov	r0, r3
70003c28:	e24bd004 	sub	sp, fp, #4
70003c2c:	e8bd8800 	pop	{fp, pc}

70003c30 <rt_mb_detach>:
 * @param mb the mailbox object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mb_detach(rt_mailbox_t mb)
{
70003c30:	e92d4800 	push	{fp, lr}
70003c34:	e28db004 	add	fp, sp, #4
70003c38:	e24dd010 	sub	sp, sp, #16
70003c3c:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
70003c40:	e51b3010 	ldr	r3, [fp, #-16]
70003c44:	e3530000 	cmp	r3, #0
70003c48:	1a00001d 	bne	70003cc4 <rt_mb_detach+0x94>
70003c4c:	e3a03000 	mov	r3, #0
70003c50:	e54b3005 	strb	r3, [fp, #-5]
70003c54:	e30a3b74 	movw	r3, #43892	; 0xab74
70003c58:	e3473002 	movt	r3, #28674	; 0x7002
70003c5c:	e5933000 	ldr	r3, [r3]
70003c60:	e3530000 	cmp	r3, #0
70003c64:	1a00000d 	bne	70003ca0 <rt_mb_detach+0x70>
70003c68:	e3060324 	movw	r0, #25380	; 0x6324
70003c6c:	e3470002 	movt	r0, #28674	; 0x7002
70003c70:	e30613dc 	movw	r1, #25564	; 0x63dc
70003c74:	e3471002 	movt	r1, #28674	; 0x7002
70003c78:	e3062558 	movw	r2, #25944	; 0x6558
70003c7c:	e3472002 	movt	r2, #28674	; 0x7002
70003c80:	e300350e 	movw	r3, #1294	; 0x50e
70003c84:	eb000eda 	bl	700077f4 <rt_kprintf>
70003c88:	e1a00000 	nop			; (mov r0, r0)
70003c8c:	e55b3005 	ldrb	r3, [fp, #-5]
70003c90:	e6ef3073 	uxtb	r3, r3
70003c94:	e3530000 	cmp	r3, #0
70003c98:	0afffffb 	beq	70003c8c <rt_mb_detach+0x5c>
70003c9c:	ea000008 	b	70003cc4 <rt_mb_detach+0x94>
70003ca0:	e30a3b74 	movw	r3, #43892	; 0xab74
70003ca4:	e3473002 	movt	r3, #28674	; 0x7002
70003ca8:	e5933000 	ldr	r3, [r3]
70003cac:	e30603dc 	movw	r0, #25564	; 0x63dc
70003cb0:	e3470002 	movt	r0, #28674	; 0x7002
70003cb4:	e3061558 	movw	r1, #25944	; 0x6558
70003cb8:	e3471002 	movt	r1, #28674	; 0x7002
70003cbc:	e300250e 	movw	r2, #1294	; 0x50e
70003cc0:	e12fff33 	blx	r3

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
70003cc4:	e51b3010 	ldr	r3, [fp, #-16]
70003cc8:	e2833010 	add	r3, r3, #16
70003ccc:	e1a00003 	mov	r0, r3
70003cd0:	ebfff716 	bl	70001930 <rt_ipc_list_resume_all>
    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
70003cd4:	e51b3010 	ldr	r3, [fp, #-16]
70003cd8:	e2833024 	add	r3, r3, #36	; 0x24
70003cdc:	e1a00003 	mov	r0, r3
70003ce0:	ebfff712 	bl	70001930 <rt_ipc_list_resume_all>

    /* detach mailbox object */
    rt_object_detach(&(mb->parent.parent));
70003ce4:	e51b3010 	ldr	r3, [fp, #-16]
70003ce8:	e1a00003 	mov	r0, r3
70003cec:	eb00159e 	bl	7000936c <rt_object_detach>

    return RT_EOK;
70003cf0:	e3a03000 	mov	r3, #0
}
70003cf4:	e1a00003 	mov	r0, r3
70003cf8:	e24bd004 	sub	sp, fp, #4
70003cfc:	e8bd8800 	pop	{fp, pc}

70003d00 <rt_mb_create>:
 * @param flag the flag of mailbox
 *
 * @return the created mailbox, RT_NULL on error happen
 */
rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
{
70003d00:	e92d4800 	push	{fp, lr}
70003d04:	e28db004 	add	fp, sp, #4
70003d08:	e24dd020 	sub	sp, sp, #32
70003d0c:	e50b0018 	str	r0, [fp, #-24]
70003d10:	e50b101c 	str	r1, [fp, #-28]
70003d14:	e1a03002 	mov	r3, r2
70003d18:	e54b301d 	strb	r3, [fp, #-29]
    rt_mailbox_t mb;

    RT_DEBUG_NOT_IN_INTERRUPT;
70003d1c:	eb002949 	bl	7000e248 <rt_hw_interrupt_disable>
70003d20:	e50b0008 	str	r0, [fp, #-8]
70003d24:	eb000862 	bl	70005eb4 <rt_interrupt_get_nest>
70003d28:	e1a03000 	mov	r3, r0
70003d2c:	e3530000 	cmp	r3, #0
70003d30:	0a000022 	beq	70003dc0 <rt_mb_create+0xc0>
70003d34:	e3060354 	movw	r0, #25428	; 0x6354
70003d38:	e3470002 	movt	r0, #28674	; 0x7002
70003d3c:	e3061568 	movw	r1, #25960	; 0x6568
70003d40:	e3471002 	movt	r1, #28674	; 0x7002
70003d44:	eb000eaa 	bl	700077f4 <rt_kprintf>
70003d48:	e3a03000 	mov	r3, #0
70003d4c:	e54b300d 	strb	r3, [fp, #-13]
70003d50:	e30a3b74 	movw	r3, #43892	; 0xab74
70003d54:	e3473002 	movt	r3, #28674	; 0x7002
70003d58:	e5933000 	ldr	r3, [r3]
70003d5c:	e3530000 	cmp	r3, #0
70003d60:	1a00000d 	bne	70003d9c <rt_mb_create+0x9c>
70003d64:	e3060324 	movw	r0, #25380	; 0x6324
70003d68:	e3470002 	movt	r0, #28674	; 0x7002
70003d6c:	e3061378 	movw	r1, #25464	; 0x6378
70003d70:	e3471002 	movt	r1, #28674	; 0x7002
70003d74:	e3062568 	movw	r2, #25960	; 0x6568
70003d78:	e3472002 	movt	r2, #28674	; 0x7002
70003d7c:	e300352a 	movw	r3, #1322	; 0x52a
70003d80:	eb000e9b 	bl	700077f4 <rt_kprintf>
70003d84:	e1a00000 	nop			; (mov r0, r0)
70003d88:	e55b300d 	ldrb	r3, [fp, #-13]
70003d8c:	e6ef3073 	uxtb	r3, r3
70003d90:	e3530000 	cmp	r3, #0
70003d94:	0afffffb 	beq	70003d88 <rt_mb_create+0x88>
70003d98:	ea000008 	b	70003dc0 <rt_mb_create+0xc0>
70003d9c:	e30a3b74 	movw	r3, #43892	; 0xab74
70003da0:	e3473002 	movt	r3, #28674	; 0x7002
70003da4:	e5933000 	ldr	r3, [r3]
70003da8:	e3060378 	movw	r0, #25464	; 0x6378
70003dac:	e3470002 	movt	r0, #28674	; 0x7002
70003db0:	e3061568 	movw	r1, #25960	; 0x6568
70003db4:	e3471002 	movt	r1, #28674	; 0x7002
70003db8:	e300252a 	movw	r2, #1322	; 0x52a
70003dbc:	e12fff33 	blx	r3
70003dc0:	e51b0008 	ldr	r0, [fp, #-8]
70003dc4:	eb002922 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate object */
    mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
70003dc8:	e3a00004 	mov	r0, #4
70003dcc:	e51b1018 	ldr	r1, [fp, #-24]
70003dd0:	eb00159e 	bl	70009450 <rt_object_allocate>
70003dd4:	e50b000c 	str	r0, [fp, #-12]
    if (mb == RT_NULL)
70003dd8:	e51b300c 	ldr	r3, [fp, #-12]
70003ddc:	e3530000 	cmp	r3, #0
70003de0:	1a000001 	bne	70003dec <rt_mb_create+0xec>
        return mb;
70003de4:	e51b300c 	ldr	r3, [fp, #-12]
70003de8:	ea000028 	b	70003e90 <rt_mb_create+0x190>

    /* set parent */
    mb->parent.parent.flag = flag;
70003dec:	e51b300c 	ldr	r3, [fp, #-12]
70003df0:	e55b201d 	ldrb	r2, [fp, #-29]
70003df4:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
70003df8:	e51b300c 	ldr	r3, [fp, #-12]
70003dfc:	e1a00003 	mov	r0, r3
70003e00:	ebfff670 	bl	700017c8 <rt_ipc_object_init>

    /* init mailbox */
    mb->size     = size;
70003e04:	e51b301c 	ldr	r3, [fp, #-28]
70003e08:	e6ff2073 	uxth	r2, r3
70003e0c:	e51b300c 	ldr	r3, [fp, #-12]
70003e10:	e1c321bc 	strh	r2, [r3, #28]
    mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
70003e14:	e51b300c 	ldr	r3, [fp, #-12]
70003e18:	e1d331bc 	ldrh	r3, [r3, #28]
70003e1c:	e1a03103 	lsl	r3, r3, #2
70003e20:	e1a00003 	mov	r0, r3
70003e24:	eb0010a4 	bl	700080bc <rt_malloc>
70003e28:	e1a02000 	mov	r2, r0
70003e2c:	e51b300c 	ldr	r3, [fp, #-12]
70003e30:	e5832018 	str	r2, [r3, #24]
    if (mb->msg_pool == RT_NULL)
70003e34:	e51b300c 	ldr	r3, [fp, #-12]
70003e38:	e5933018 	ldr	r3, [r3, #24]
70003e3c:	e3530000 	cmp	r3, #0
70003e40:	1a000004 	bne	70003e58 <rt_mb_create+0x158>
    {
        /* delete mailbox object */
        rt_object_delete(&(mb->parent.parent));
70003e44:	e51b300c 	ldr	r3, [fp, #-12]
70003e48:	e1a00003 	mov	r0, r3
70003e4c:	eb0015e4 	bl	700095e4 <rt_object_delete>

        return RT_NULL;
70003e50:	e3a03000 	mov	r3, #0
70003e54:	ea00000d 	b	70003e90 <rt_mb_create+0x190>
    }
    mb->entry      = 0;
70003e58:	e51b300c 	ldr	r3, [fp, #-12]
70003e5c:	e3a02000 	mov	r2, #0
70003e60:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
70003e64:	e51b300c 	ldr	r3, [fp, #-12]
70003e68:	e3a02000 	mov	r2, #0
70003e6c:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
70003e70:	e51b300c 	ldr	r3, [fp, #-12]
70003e74:	e3a02000 	mov	r2, #0
70003e78:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
70003e7c:	e51b300c 	ldr	r3, [fp, #-12]
70003e80:	e2833024 	add	r3, r3, #36	; 0x24
70003e84:	e1a00003 	mov	r0, r3
70003e88:	ebfff61b 	bl	700016fc <rt_list_init>

    return mb;
70003e8c:	e51b300c 	ldr	r3, [fp, #-12]
}
70003e90:	e1a00003 	mov	r0, r3
70003e94:	e24bd004 	sub	sp, fp, #4
70003e98:	e8bd8800 	pop	{fp, pc}

70003e9c <rt_mb_delete>:
 * @param mb the mailbox object
 *
 * @return the error code
 */
rt_err_t rt_mb_delete(rt_mailbox_t mb)
{
70003e9c:	e92d4800 	push	{fp, lr}
70003ea0:	e28db004 	add	fp, sp, #4
70003ea4:	e24dd010 	sub	sp, sp, #16
70003ea8:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
70003eac:	eb0028e5 	bl	7000e248 <rt_hw_interrupt_disable>
70003eb0:	e50b0008 	str	r0, [fp, #-8]
70003eb4:	eb0007fe 	bl	70005eb4 <rt_interrupt_get_nest>
70003eb8:	e1a03000 	mov	r3, r0
70003ebc:	e3530000 	cmp	r3, #0
70003ec0:	0a000022 	beq	70003f50 <rt_mb_delete+0xb4>
70003ec4:	e3060354 	movw	r0, #25428	; 0x6354
70003ec8:	e3470002 	movt	r0, #28674	; 0x7002
70003ecc:	e3061578 	movw	r1, #25976	; 0x6578
70003ed0:	e3471002 	movt	r1, #28674	; 0x7002
70003ed4:	eb000e46 	bl	700077f4 <rt_kprintf>
70003ed8:	e3a03000 	mov	r3, #0
70003edc:	e54b3009 	strb	r3, [fp, #-9]
70003ee0:	e30a3b74 	movw	r3, #43892	; 0xab74
70003ee4:	e3473002 	movt	r3, #28674	; 0x7002
70003ee8:	e5933000 	ldr	r3, [r3]
70003eec:	e3530000 	cmp	r3, #0
70003ef0:	1a00000d 	bne	70003f2c <rt_mb_delete+0x90>
70003ef4:	e3060324 	movw	r0, #25380	; 0x6324
70003ef8:	e3470002 	movt	r0, #28674	; 0x7002
70003efc:	e3061378 	movw	r1, #25464	; 0x6378
70003f00:	e3471002 	movt	r1, #28674	; 0x7002
70003f04:	e3062578 	movw	r2, #25976	; 0x6578
70003f08:	e3472002 	movt	r2, #28674	; 0x7002
70003f0c:	e3003555 	movw	r3, #1365	; 0x555
70003f10:	eb000e37 	bl	700077f4 <rt_kprintf>
70003f14:	e1a00000 	nop			; (mov r0, r0)
70003f18:	e55b3009 	ldrb	r3, [fp, #-9]
70003f1c:	e6ef3073 	uxtb	r3, r3
70003f20:	e3530000 	cmp	r3, #0
70003f24:	0afffffb 	beq	70003f18 <rt_mb_delete+0x7c>
70003f28:	ea000008 	b	70003f50 <rt_mb_delete+0xb4>
70003f2c:	e30a3b74 	movw	r3, #43892	; 0xab74
70003f30:	e3473002 	movt	r3, #28674	; 0x7002
70003f34:	e5933000 	ldr	r3, [r3]
70003f38:	e3060378 	movw	r0, #25464	; 0x6378
70003f3c:	e3470002 	movt	r0, #28674	; 0x7002
70003f40:	e3061578 	movw	r1, #25976	; 0x6578
70003f44:	e3471002 	movt	r1, #28674	; 0x7002
70003f48:	e3002555 	movw	r2, #1365	; 0x555
70003f4c:	e12fff33 	blx	r3
70003f50:	e51b0008 	ldr	r0, [fp, #-8]
70003f54:	eb0028be 	bl	7000e254 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
70003f58:	e51b3010 	ldr	r3, [fp, #-16]
70003f5c:	e3530000 	cmp	r3, #0
70003f60:	1a00001d 	bne	70003fdc <rt_mb_delete+0x140>
70003f64:	e3a03000 	mov	r3, #0
70003f68:	e54b300a 	strb	r3, [fp, #-10]
70003f6c:	e30a3b74 	movw	r3, #43892	; 0xab74
70003f70:	e3473002 	movt	r3, #28674	; 0x7002
70003f74:	e5933000 	ldr	r3, [r3]
70003f78:	e3530000 	cmp	r3, #0
70003f7c:	1a00000d 	bne	70003fb8 <rt_mb_delete+0x11c>
70003f80:	e3060324 	movw	r0, #25380	; 0x6324
70003f84:	e3470002 	movt	r0, #28674	; 0x7002
70003f88:	e30613dc 	movw	r1, #25564	; 0x63dc
70003f8c:	e3471002 	movt	r1, #28674	; 0x7002
70003f90:	e3062578 	movw	r2, #25976	; 0x6578
70003f94:	e3472002 	movt	r2, #28674	; 0x7002
70003f98:	e3003558 	movw	r3, #1368	; 0x558
70003f9c:	eb000e14 	bl	700077f4 <rt_kprintf>
70003fa0:	e1a00000 	nop			; (mov r0, r0)
70003fa4:	e55b300a 	ldrb	r3, [fp, #-10]
70003fa8:	e6ef3073 	uxtb	r3, r3
70003fac:	e3530000 	cmp	r3, #0
70003fb0:	0afffffb 	beq	70003fa4 <rt_mb_delete+0x108>
70003fb4:	ea000008 	b	70003fdc <rt_mb_delete+0x140>
70003fb8:	e30a3b74 	movw	r3, #43892	; 0xab74
70003fbc:	e3473002 	movt	r3, #28674	; 0x7002
70003fc0:	e5933000 	ldr	r3, [r3]
70003fc4:	e30603dc 	movw	r0, #25564	; 0x63dc
70003fc8:	e3470002 	movt	r0, #28674	; 0x7002
70003fcc:	e3061578 	movw	r1, #25976	; 0x6578
70003fd0:	e3471002 	movt	r1, #28674	; 0x7002
70003fd4:	e3002558 	movw	r2, #1368	; 0x558
70003fd8:	e12fff33 	blx	r3

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
70003fdc:	e51b3010 	ldr	r3, [fp, #-16]
70003fe0:	e2833010 	add	r3, r3, #16
70003fe4:	e1a00003 	mov	r0, r3
70003fe8:	ebfff650 	bl	70001930 <rt_ipc_list_resume_all>

    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
70003fec:	e51b3010 	ldr	r3, [fp, #-16]
70003ff0:	e2833024 	add	r3, r3, #36	; 0x24
70003ff4:	e1a00003 	mov	r0, r3
70003ff8:	ebfff64c 	bl	70001930 <rt_ipc_list_resume_all>
        rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
    else
#endif

    /* free mailbox pool */
    RT_KERNEL_FREE(mb->msg_pool);
70003ffc:	e51b3010 	ldr	r3, [fp, #-16]
70004000:	e5933018 	ldr	r3, [r3, #24]
70004004:	e1a00003 	mov	r0, r3
70004008:	eb0012ee 	bl	70008bc8 <rt_free>

    /* delete mailbox object */
    rt_object_delete(&(mb->parent.parent));
7000400c:	e51b3010 	ldr	r3, [fp, #-16]
70004010:	e1a00003 	mov	r0, r3
70004014:	eb001572 	bl	700095e4 <rt_object_delete>

    return RT_EOK;
70004018:	e3a03000 	mov	r3, #0
}
7000401c:	e1a00003 	mov	r0, r3
70004020:	e24bd004 	sub	sp, fp, #4
70004024:	e8bd8800 	pop	{fp, pc}

70004028 <rt_mb_send_wait>:
 * @return the error code
 */
rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
                         rt_uint32_t  value,
                         rt_int32_t   timeout)
{
70004028:	e92d4810 	push	{r4, fp, lr}
7000402c:	e28db008 	add	fp, sp, #8
70004030:	e24dd02c 	sub	sp, sp, #44	; 0x2c
70004034:	e50b0028 	str	r0, [fp, #-40]	; 0x28
70004038:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
7000403c:	e50b2030 	str	r2, [fp, #-48]	; 0x30
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
70004040:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004044:	e3530000 	cmp	r3, #0
70004048:	1a00001d 	bne	700040c4 <rt_mb_send_wait+0x9c>
7000404c:	e3a03000 	mov	r3, #0
70004050:	e54b301d 	strb	r3, [fp, #-29]
70004054:	e30a3b74 	movw	r3, #43892	; 0xab74
70004058:	e3473002 	movt	r3, #28674	; 0x7002
7000405c:	e5933000 	ldr	r3, [r3]
70004060:	e3530000 	cmp	r3, #0
70004064:	1a00000d 	bne	700040a0 <rt_mb_send_wait+0x78>
70004068:	e3060324 	movw	r0, #25380	; 0x6324
7000406c:	e3470002 	movt	r0, #28674	; 0x7002
70004070:	e30613dc 	movw	r1, #25564	; 0x63dc
70004074:	e3471002 	movt	r1, #28674	; 0x7002
70004078:	e3062588 	movw	r2, #25992	; 0x6588
7000407c:	e3472002 	movt	r2, #28674	; 0x7002
70004080:	e3003585 	movw	r3, #1413	; 0x585
70004084:	eb000dda 	bl	700077f4 <rt_kprintf>
70004088:	e1a00000 	nop			; (mov r0, r0)
7000408c:	e55b301d 	ldrb	r3, [fp, #-29]
70004090:	e6ef3073 	uxtb	r3, r3
70004094:	e3530000 	cmp	r3, #0
70004098:	0afffffb 	beq	7000408c <rt_mb_send_wait+0x64>
7000409c:	ea000008 	b	700040c4 <rt_mb_send_wait+0x9c>
700040a0:	e30a3b74 	movw	r3, #43892	; 0xab74
700040a4:	e3473002 	movt	r3, #28674	; 0x7002
700040a8:	e5933000 	ldr	r3, [r3]
700040ac:	e30603dc 	movw	r0, #25564	; 0x63dc
700040b0:	e3470002 	movt	r0, #28674	; 0x7002
700040b4:	e3061588 	movw	r1, #25992	; 0x6588
700040b8:	e3471002 	movt	r1, #28674	; 0x7002
700040bc:	e3002585 	movw	r2, #1413	; 0x585
700040c0:	e12fff33 	blx	r3

    /* initialize delta tick */
    tick_delta = 0;
700040c4:	e3a03000 	mov	r3, #0
700040c8:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
700040cc:	eb001927 	bl	7000a570 <rt_thread_self>
700040d0:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
700040d4:	e30a3b78 	movw	r3, #43896	; 0xab78
700040d8:	e3473002 	movt	r3, #28674	; 0x7002
700040dc:	e5933000 	ldr	r3, [r3]
700040e0:	e3530000 	cmp	r3, #0
700040e4:	0a000005 	beq	70004100 <rt_mb_send_wait+0xd8>
700040e8:	e30a3b78 	movw	r3, #43896	; 0xab78
700040ec:	e3473002 	movt	r3, #28674	; 0x7002
700040f0:	e5933000 	ldr	r3, [r3]
700040f4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700040f8:	e1a00002 	mov	r0, r2
700040fc:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70004100:	eb002850 	bl	7000e248 <rt_hw_interrupt_disable>
70004104:	e1a03000 	mov	r3, r0
70004108:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == mb->size && timeout == 0)
7000410c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004110:	e1d321be 	ldrh	r2, [r3, #30]
70004114:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004118:	e1d331bc 	ldrh	r3, [r3, #28]
7000411c:	e1520003 	cmp	r2, r3
70004120:	1a000007 	bne	70004144 <rt_mb_send_wait+0x11c>
70004124:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004128:	e3530000 	cmp	r3, #0
7000412c:	1a000004 	bne	70004144 <rt_mb_send_wait+0x11c>
    {
        rt_hw_interrupt_enable(temp);
70004130:	e1a03004 	mov	r3, r4
70004134:	e1a00003 	mov	r0, r3
70004138:	eb002845 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_EFULL;
7000413c:	e3e03002 	mvn	r3, #2
70004140:	ea0000d1 	b	7000448c <rt_mb_send_wait+0x464>
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
70004144:	ea000098 	b	700043ac <rt_mb_send_wait+0x384>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
70004148:	e51b3014 	ldr	r3, [fp, #-20]
7000414c:	e3a02000 	mov	r2, #0
70004150:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
70004154:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004158:	e3530000 	cmp	r3, #0
7000415c:	1a000004 	bne	70004174 <rt_mb_send_wait+0x14c>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
70004160:	e1a03004 	mov	r3, r4
70004164:	e1a00003 	mov	r0, r3
70004168:	eb002839 	bl	7000e254 <rt_hw_interrupt_enable>

            return -RT_EFULL;
7000416c:	e3e03002 	mvn	r3, #2
70004170:	ea0000c5 	b	7000448c <rt_mb_send_wait+0x464>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
70004174:	eb002833 	bl	7000e248 <rt_hw_interrupt_disable>
70004178:	e50b0018 	str	r0, [fp, #-24]
7000417c:	eb0018fb 	bl	7000a570 <rt_thread_self>
70004180:	e1a03000 	mov	r3, r0
70004184:	e3530000 	cmp	r3, #0
70004188:	1a000022 	bne	70004218 <rt_mb_send_wait+0x1f0>
7000418c:	e306037c 	movw	r0, #25468	; 0x637c
70004190:	e3470002 	movt	r0, #28674	; 0x7002
70004194:	e3061588 	movw	r1, #25992	; 0x6588
70004198:	e3471002 	movt	r1, #28674	; 0x7002
7000419c:	eb000d94 	bl	700077f4 <rt_kprintf>
700041a0:	e3a03000 	mov	r3, #0
700041a4:	e54b301e 	strb	r3, [fp, #-30]
700041a8:	e30a3b74 	movw	r3, #43892	; 0xab74
700041ac:	e3473002 	movt	r3, #28674	; 0x7002
700041b0:	e5933000 	ldr	r3, [r3]
700041b4:	e3530000 	cmp	r3, #0
700041b8:	1a00000d 	bne	700041f4 <rt_mb_send_wait+0x1cc>
700041bc:	e3060324 	movw	r0, #25380	; 0x6324
700041c0:	e3470002 	movt	r0, #28674	; 0x7002
700041c4:	e3061378 	movw	r1, #25464	; 0x6378
700041c8:	e3471002 	movt	r1, #28674	; 0x7002
700041cc:	e3062588 	movw	r2, #25992	; 0x6588
700041d0:	e3472002 	movt	r2, #28674	; 0x7002
700041d4:	e30035a8 	movw	r3, #1448	; 0x5a8
700041d8:	eb000d85 	bl	700077f4 <rt_kprintf>
700041dc:	e1a00000 	nop			; (mov r0, r0)
700041e0:	e55b301e 	ldrb	r3, [fp, #-30]
700041e4:	e6ef3073 	uxtb	r3, r3
700041e8:	e3530000 	cmp	r3, #0
700041ec:	0afffffb 	beq	700041e0 <rt_mb_send_wait+0x1b8>
700041f0:	ea000008 	b	70004218 <rt_mb_send_wait+0x1f0>
700041f4:	e30a3b74 	movw	r3, #43892	; 0xab74
700041f8:	e3473002 	movt	r3, #28674	; 0x7002
700041fc:	e5933000 	ldr	r3, [r3]
70004200:	e3060378 	movw	r0, #25464	; 0x6378
70004204:	e3470002 	movt	r0, #28674	; 0x7002
70004208:	e3061588 	movw	r1, #25992	; 0x6588
7000420c:	e3471002 	movt	r1, #28674	; 0x7002
70004210:	e30025a8 	movw	r2, #1448	; 0x5a8
70004214:	e12fff33 	blx	r3
70004218:	eb00280a 	bl	7000e248 <rt_hw_interrupt_disable>
7000421c:	e50b001c 	str	r0, [fp, #-28]
70004220:	eb000723 	bl	70005eb4 <rt_interrupt_get_nest>
70004224:	e1a03000 	mov	r3, r0
70004228:	e3530000 	cmp	r3, #0
7000422c:	0a000022 	beq	700042bc <rt_mb_send_wait+0x294>
70004230:	e3060354 	movw	r0, #25428	; 0x6354
70004234:	e3470002 	movt	r0, #28674	; 0x7002
70004238:	e3061588 	movw	r1, #25992	; 0x6588
7000423c:	e3471002 	movt	r1, #28674	; 0x7002
70004240:	eb000d6b 	bl	700077f4 <rt_kprintf>
70004244:	e3a03000 	mov	r3, #0
70004248:	e54b301f 	strb	r3, [fp, #-31]
7000424c:	e30a3b74 	movw	r3, #43892	; 0xab74
70004250:	e3473002 	movt	r3, #28674	; 0x7002
70004254:	e5933000 	ldr	r3, [r3]
70004258:	e3530000 	cmp	r3, #0
7000425c:	1a00000d 	bne	70004298 <rt_mb_send_wait+0x270>
70004260:	e3060324 	movw	r0, #25380	; 0x6324
70004264:	e3470002 	movt	r0, #28674	; 0x7002
70004268:	e3061378 	movw	r1, #25464	; 0x6378
7000426c:	e3471002 	movt	r1, #28674	; 0x7002
70004270:	e3062588 	movw	r2, #25992	; 0x6588
70004274:	e3472002 	movt	r2, #28674	; 0x7002
70004278:	e30035a8 	movw	r3, #1448	; 0x5a8
7000427c:	eb000d5c 	bl	700077f4 <rt_kprintf>
70004280:	e1a00000 	nop			; (mov r0, r0)
70004284:	e55b301f 	ldrb	r3, [fp, #-31]
70004288:	e6ef3073 	uxtb	r3, r3
7000428c:	e3530000 	cmp	r3, #0
70004290:	0afffffb 	beq	70004284 <rt_mb_send_wait+0x25c>
70004294:	ea000008 	b	700042bc <rt_mb_send_wait+0x294>
70004298:	e30a3b74 	movw	r3, #43892	; 0xab74
7000429c:	e3473002 	movt	r3, #28674	; 0x7002
700042a0:	e5933000 	ldr	r3, [r3]
700042a4:	e3060378 	movw	r0, #25464	; 0x6378
700042a8:	e3470002 	movt	r0, #28674	; 0x7002
700042ac:	e3061588 	movw	r1, #25992	; 0x6588
700042b0:	e3471002 	movt	r1, #28674	; 0x7002
700042b4:	e30025a8 	movw	r2, #1448	; 0x5a8
700042b8:	e12fff33 	blx	r3
700042bc:	e51b001c 	ldr	r0, [fp, #-28]
700042c0:	eb0027e3 	bl	7000e254 <rt_hw_interrupt_enable>
700042c4:	e51b0018 	ldr	r0, [fp, #-24]
700042c8:	eb0027e1 	bl	7000e254 <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->suspend_sender_thread),
700042cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700042d0:	e2832024 	add	r2, r3, #36	; 0x24
700042d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700042d8:	e5d33007 	ldrb	r3, [r3, #7]
700042dc:	e1a00002 	mov	r0, r2
700042e0:	e51b1014 	ldr	r1, [fp, #-20]
700042e4:	e1a02003 	mov	r2, r3
700042e8:	ebfff542 	bl	700017f8 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
700042ec:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
700042f0:	e3530000 	cmp	r3, #0
700042f4:	da00000c 	ble	7000432c <rt_mb_send_wait+0x304>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
700042f8:	ebfff0f3 	bl	700006cc <rt_tick_get>
700042fc:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
70004300:	e51b3014 	ldr	r3, [fp, #-20]
70004304:	e2832048 	add	r2, r3, #72	; 0x48
70004308:	e24b3030 	sub	r3, fp, #48	; 0x30
7000430c:	e1a00002 	mov	r0, r2
70004310:	e3a01000 	mov	r1, #0
70004314:	e1a02003 	mov	r2, r3
70004318:	eb001e32 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
7000431c:	e51b3014 	ldr	r3, [fp, #-20]
70004320:	e2833048 	add	r3, r3, #72	; 0x48
70004324:	e1a00003 	mov	r0, r3
70004328:	eb001ce2 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
7000432c:	e1a03004 	mov	r3, r4
70004330:	e1a00003 	mov	r0, r3
70004334:	eb0027c6 	bl	7000e254 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
70004338:	eb001629 	bl	70009be4 <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
7000433c:	e51b3014 	ldr	r3, [fp, #-20]
70004340:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70004344:	e3530000 	cmp	r3, #0
70004348:	0a000002 	beq	70004358 <rt_mb_send_wait+0x330>
        {
            /* return error */
            return thread->error;
7000434c:	e51b3014 	ldr	r3, [fp, #-20]
70004350:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70004354:	ea00004c 	b	7000448c <rt_mb_send_wait+0x464>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70004358:	eb0027ba 	bl	7000e248 <rt_hw_interrupt_disable>
7000435c:	e1a03000 	mov	r3, r0
70004360:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
70004364:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004368:	e3530000 	cmp	r3, #0
7000436c:	da00000e 	ble	700043ac <rt_mb_send_wait+0x384>
        {
            tick_delta = rt_tick_get() - tick_delta;
70004370:	ebfff0d5 	bl	700006cc <rt_tick_get>
70004374:	e1a02000 	mov	r2, r0
70004378:	e51b3010 	ldr	r3, [fp, #-16]
7000437c:	e0633002 	rsb	r3, r3, r2
70004380:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
70004384:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004388:	e1a02003 	mov	r2, r3
7000438c:	e51b3010 	ldr	r3, [fp, #-16]
70004390:	e0633002 	rsb	r3, r3, r2
70004394:	e50b3030 	str	r3, [fp, #-48]	; 0x30
            if (timeout < 0)
70004398:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000439c:	e3530000 	cmp	r3, #0
700043a0:	aa000001 	bge	700043ac <rt_mb_send_wait+0x384>
                timeout = 0;
700043a4:	e3a03000 	mov	r3, #0
700043a8:	e50b3030 	str	r3, [fp, #-48]	; 0x30

        return -RT_EFULL;
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
700043ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043b0:	e1d321be 	ldrh	r2, [r3, #30]
700043b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043b8:	e1d331bc 	ldrh	r3, [r3, #28]
700043bc:	e1520003 	cmp	r2, r3
700043c0:	0affff60 	beq	70004148 <rt_mb_send_wait+0x120>
                timeout = 0;
        }
    }

    /* set ptr */
    mb->msg_pool[mb->in_offset] = value;
700043c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043c8:	e5932018 	ldr	r2, [r3, #24]
700043cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043d0:	e1d332b0 	ldrh	r3, [r3, #32]
700043d4:	e1a03103 	lsl	r3, r3, #2
700043d8:	e0823003 	add	r3, r2, r3
700043dc:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
700043e0:	e5832000 	str	r2, [r3]
    /* increase input offset */
    ++ mb->in_offset;
700043e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043e8:	e1d332b0 	ldrh	r3, [r3, #32]
700043ec:	e2833001 	add	r3, r3, #1
700043f0:	e6ff2073 	uxth	r2, r3
700043f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700043f8:	e1c322b0 	strh	r2, [r3, #32]
    if (mb->in_offset >= mb->size)
700043fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004400:	e1d322b0 	ldrh	r2, [r3, #32]
70004404:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004408:	e1d331bc 	ldrh	r3, [r3, #28]
7000440c:	e1520003 	cmp	r2, r3
70004410:	3a000002 	bcc	70004420 <rt_mb_send_wait+0x3f8>
        mb->in_offset = 0;
70004414:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004418:	e3a02000 	mov	r2, #0
7000441c:	e1c322b0 	strh	r2, [r3, #32]
    /* increase message entry */
    mb->entry ++;
70004420:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004424:	e1d331be 	ldrh	r3, [r3, #30]
70004428:	e2833001 	add	r3, r3, #1
7000442c:	e6ff2073 	uxth	r2, r3
70004430:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004434:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&mb->parent.suspend_thread))
70004438:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000443c:	e2833010 	add	r3, r3, #16
70004440:	e1a00003 	mov	r0, r3
70004444:	ebfff4d0 	bl	7000178c <rt_list_isempty>
70004448:	e1a03000 	mov	r3, r0
7000444c:	e3530000 	cmp	r3, #0
70004450:	1a000009 	bne	7000447c <rt_mb_send_wait+0x454>
    {
        rt_ipc_list_resume(&(mb->parent.suspend_thread));
70004454:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004458:	e2833010 	add	r3, r3, #16
7000445c:	e1a00003 	mov	r0, r3
70004460:	ebfff524 	bl	700018f8 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70004464:	e1a03004 	mov	r3, r4
70004468:	e1a00003 	mov	r0, r3
7000446c:	eb002778 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
70004470:	eb0015db 	bl	70009be4 <rt_schedule>

        return RT_EOK;
70004474:	e3a03000 	mov	r3, #0
70004478:	ea000003 	b	7000448c <rt_mb_send_wait+0x464>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
7000447c:	e1a03004 	mov	r3, r4
70004480:	e1a00003 	mov	r0, r3
70004484:	eb002772 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
70004488:	e3a03000 	mov	r3, #0
}
7000448c:	e1a00003 	mov	r0, r3
70004490:	e24bd008 	sub	sp, fp, #8
70004494:	e8bd8810 	pop	{r4, fp, pc}

70004498 <rt_mb_send>:
 * @param value the mail
 *
 * @return the error code
 */
rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
{
70004498:	e92d4800 	push	{fp, lr}
7000449c:	e28db004 	add	fp, sp, #4
700044a0:	e24dd008 	sub	sp, sp, #8
700044a4:	e50b0008 	str	r0, [fp, #-8]
700044a8:	e50b100c 	str	r1, [fp, #-12]
    return rt_mb_send_wait(mb, value, 0);
700044ac:	e51b0008 	ldr	r0, [fp, #-8]
700044b0:	e51b100c 	ldr	r1, [fp, #-12]
700044b4:	e3a02000 	mov	r2, #0
700044b8:	ebfffeda 	bl	70004028 <rt_mb_send_wait>
700044bc:	e1a03000 	mov	r3, r0
}
700044c0:	e1a00003 	mov	r0, r3
700044c4:	e24bd004 	sub	sp, fp, #4
700044c8:	e8bd8800 	pop	{fp, pc}

700044cc <rt_mb_recv>:
 * @param timeout the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
{
700044cc:	e92d4810 	push	{r4, fp, lr}
700044d0:	e28db008 	add	fp, sp, #8
700044d4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
700044d8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
700044dc:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
700044e0:	e50b2030 	str	r2, [fp, #-48]	; 0x30
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
700044e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700044e8:	e3530000 	cmp	r3, #0
700044ec:	1a00001d 	bne	70004568 <rt_mb_recv+0x9c>
700044f0:	e3a03000 	mov	r3, #0
700044f4:	e54b301d 	strb	r3, [fp, #-29]
700044f8:	e30a3b74 	movw	r3, #43892	; 0xab74
700044fc:	e3473002 	movt	r3, #28674	; 0x7002
70004500:	e5933000 	ldr	r3, [r3]
70004504:	e3530000 	cmp	r3, #0
70004508:	1a00000d 	bne	70004544 <rt_mb_recv+0x78>
7000450c:	e3060324 	movw	r0, #25380	; 0x6324
70004510:	e3470002 	movt	r0, #28674	; 0x7002
70004514:	e30613dc 	movw	r1, #25564	; 0x63dc
70004518:	e3471002 	movt	r1, #28674	; 0x7002
7000451c:	e3062598 	movw	r2, #26008	; 0x6598
70004520:	e3472002 	movt	r2, #28674	; 0x7002
70004524:	e3003616 	movw	r3, #1558	; 0x616
70004528:	eb000cb1 	bl	700077f4 <rt_kprintf>
7000452c:	e1a00000 	nop			; (mov r0, r0)
70004530:	e55b301d 	ldrb	r3, [fp, #-29]
70004534:	e6ef3073 	uxtb	r3, r3
70004538:	e3530000 	cmp	r3, #0
7000453c:	0afffffb 	beq	70004530 <rt_mb_recv+0x64>
70004540:	ea000008 	b	70004568 <rt_mb_recv+0x9c>
70004544:	e30a3b74 	movw	r3, #43892	; 0xab74
70004548:	e3473002 	movt	r3, #28674	; 0x7002
7000454c:	e5933000 	ldr	r3, [r3]
70004550:	e30603dc 	movw	r0, #25564	; 0x63dc
70004554:	e3470002 	movt	r0, #28674	; 0x7002
70004558:	e3061598 	movw	r1, #26008	; 0x6598
7000455c:	e3471002 	movt	r1, #28674	; 0x7002
70004560:	e3002616 	movw	r2, #1558	; 0x616
70004564:	e12fff33 	blx	r3

    /* initialize delta tick */
    tick_delta = 0;
70004568:	e3a03000 	mov	r3, #0
7000456c:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
70004570:	eb0017fe 	bl	7000a570 <rt_thread_self>
70004574:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
70004578:	e30a3b80 	movw	r3, #43904	; 0xab80
7000457c:	e3473002 	movt	r3, #28674	; 0x7002
70004580:	e5933000 	ldr	r3, [r3]
70004584:	e3530000 	cmp	r3, #0
70004588:	0a000005 	beq	700045a4 <rt_mb_recv+0xd8>
7000458c:	e30a3b80 	movw	r3, #43904	; 0xab80
70004590:	e3473002 	movt	r3, #28674	; 0x7002
70004594:	e5933000 	ldr	r3, [r3]
70004598:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
7000459c:	e1a00002 	mov	r0, r2
700045a0:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
700045a4:	eb002727 	bl	7000e248 <rt_hw_interrupt_disable>
700045a8:	e1a03000 	mov	r3, r0
700045ac:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == 0 && timeout == 0)
700045b0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700045b4:	e1d331be 	ldrh	r3, [r3, #30]
700045b8:	e3530000 	cmp	r3, #0
700045bc:	1a000007 	bne	700045e0 <rt_mb_recv+0x114>
700045c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
700045c4:	e3530000 	cmp	r3, #0
700045c8:	1a000004 	bne	700045e0 <rt_mb_recv+0x114>
    {
        rt_hw_interrupt_enable(temp);
700045cc:	e1a03004 	mov	r3, r4
700045d0:	e1a00003 	mov	r0, r3
700045d4:	eb00271e 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
700045d8:	e3e03001 	mvn	r3, #1
700045dc:	ea0000e9 	b	70004988 <rt_mb_recv+0x4bc>
    }

    /* mailbox is empty */
    while (mb->entry == 0)
700045e0:	ea00009b 	b	70004854 <rt_mb_recv+0x388>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
700045e4:	e51b3014 	ldr	r3, [fp, #-20]
700045e8:	e3a02000 	mov	r2, #0
700045ec:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
700045f0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
700045f4:	e3530000 	cmp	r3, #0
700045f8:	1a000007 	bne	7000461c <rt_mb_recv+0x150>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
700045fc:	e1a03004 	mov	r3, r4
70004600:	e1a00003 	mov	r0, r3
70004604:	eb002712 	bl	7000e254 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
70004608:	e51b3014 	ldr	r3, [fp, #-20]
7000460c:	e3e02001 	mvn	r2, #1
70004610:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
70004614:	e3e03001 	mvn	r3, #1
70004618:	ea0000da 	b	70004988 <rt_mb_recv+0x4bc>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
7000461c:	eb002709 	bl	7000e248 <rt_hw_interrupt_disable>
70004620:	e50b0018 	str	r0, [fp, #-24]
70004624:	eb0017d1 	bl	7000a570 <rt_thread_self>
70004628:	e1a03000 	mov	r3, r0
7000462c:	e3530000 	cmp	r3, #0
70004630:	1a000022 	bne	700046c0 <rt_mb_recv+0x1f4>
70004634:	e306037c 	movw	r0, #25468	; 0x637c
70004638:	e3470002 	movt	r0, #28674	; 0x7002
7000463c:	e3061598 	movw	r1, #26008	; 0x6598
70004640:	e3471002 	movt	r1, #28674	; 0x7002
70004644:	eb000c6a 	bl	700077f4 <rt_kprintf>
70004648:	e3a03000 	mov	r3, #0
7000464c:	e54b301e 	strb	r3, [fp, #-30]
70004650:	e30a3b74 	movw	r3, #43892	; 0xab74
70004654:	e3473002 	movt	r3, #28674	; 0x7002
70004658:	e5933000 	ldr	r3, [r3]
7000465c:	e3530000 	cmp	r3, #0
70004660:	1a00000d 	bne	7000469c <rt_mb_recv+0x1d0>
70004664:	e3060324 	movw	r0, #25380	; 0x6324
70004668:	e3470002 	movt	r0, #28674	; 0x7002
7000466c:	e3061378 	movw	r1, #25464	; 0x6378
70004670:	e3471002 	movt	r1, #28674	; 0x7002
70004674:	e3062598 	movw	r2, #26008	; 0x6598
70004678:	e3472002 	movt	r2, #28674	; 0x7002
7000467c:	e300363b 	movw	r3, #1595	; 0x63b
70004680:	eb000c5b 	bl	700077f4 <rt_kprintf>
70004684:	e1a00000 	nop			; (mov r0, r0)
70004688:	e55b301e 	ldrb	r3, [fp, #-30]
7000468c:	e6ef3073 	uxtb	r3, r3
70004690:	e3530000 	cmp	r3, #0
70004694:	0afffffb 	beq	70004688 <rt_mb_recv+0x1bc>
70004698:	ea000008 	b	700046c0 <rt_mb_recv+0x1f4>
7000469c:	e30a3b74 	movw	r3, #43892	; 0xab74
700046a0:	e3473002 	movt	r3, #28674	; 0x7002
700046a4:	e5933000 	ldr	r3, [r3]
700046a8:	e3060378 	movw	r0, #25464	; 0x6378
700046ac:	e3470002 	movt	r0, #28674	; 0x7002
700046b0:	e3061598 	movw	r1, #26008	; 0x6598
700046b4:	e3471002 	movt	r1, #28674	; 0x7002
700046b8:	e300263b 	movw	r2, #1595	; 0x63b
700046bc:	e12fff33 	blx	r3
700046c0:	eb0026e0 	bl	7000e248 <rt_hw_interrupt_disable>
700046c4:	e50b001c 	str	r0, [fp, #-28]
700046c8:	eb0005f9 	bl	70005eb4 <rt_interrupt_get_nest>
700046cc:	e1a03000 	mov	r3, r0
700046d0:	e3530000 	cmp	r3, #0
700046d4:	0a000022 	beq	70004764 <rt_mb_recv+0x298>
700046d8:	e3060354 	movw	r0, #25428	; 0x6354
700046dc:	e3470002 	movt	r0, #28674	; 0x7002
700046e0:	e3061598 	movw	r1, #26008	; 0x6598
700046e4:	e3471002 	movt	r1, #28674	; 0x7002
700046e8:	eb000c41 	bl	700077f4 <rt_kprintf>
700046ec:	e3a03000 	mov	r3, #0
700046f0:	e54b301f 	strb	r3, [fp, #-31]
700046f4:	e30a3b74 	movw	r3, #43892	; 0xab74
700046f8:	e3473002 	movt	r3, #28674	; 0x7002
700046fc:	e5933000 	ldr	r3, [r3]
70004700:	e3530000 	cmp	r3, #0
70004704:	1a00000d 	bne	70004740 <rt_mb_recv+0x274>
70004708:	e3060324 	movw	r0, #25380	; 0x6324
7000470c:	e3470002 	movt	r0, #28674	; 0x7002
70004710:	e3061378 	movw	r1, #25464	; 0x6378
70004714:	e3471002 	movt	r1, #28674	; 0x7002
70004718:	e3062598 	movw	r2, #26008	; 0x6598
7000471c:	e3472002 	movt	r2, #28674	; 0x7002
70004720:	e300363b 	movw	r3, #1595	; 0x63b
70004724:	eb000c32 	bl	700077f4 <rt_kprintf>
70004728:	e1a00000 	nop			; (mov r0, r0)
7000472c:	e55b301f 	ldrb	r3, [fp, #-31]
70004730:	e6ef3073 	uxtb	r3, r3
70004734:	e3530000 	cmp	r3, #0
70004738:	0afffffb 	beq	7000472c <rt_mb_recv+0x260>
7000473c:	ea000008 	b	70004764 <rt_mb_recv+0x298>
70004740:	e30a3b74 	movw	r3, #43892	; 0xab74
70004744:	e3473002 	movt	r3, #28674	; 0x7002
70004748:	e5933000 	ldr	r3, [r3]
7000474c:	e3060378 	movw	r0, #25464	; 0x6378
70004750:	e3470002 	movt	r0, #28674	; 0x7002
70004754:	e3061598 	movw	r1, #26008	; 0x6598
70004758:	e3471002 	movt	r1, #28674	; 0x7002
7000475c:	e300263b 	movw	r2, #1595	; 0x63b
70004760:	e12fff33 	blx	r3
70004764:	e51b001c 	ldr	r0, [fp, #-28]
70004768:	eb0026b9 	bl	7000e254 <rt_hw_interrupt_enable>
7000476c:	e51b0018 	ldr	r0, [fp, #-24]
70004770:	eb0026b7 	bl	7000e254 <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->parent.suspend_thread),
70004774:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004778:	e2832010 	add	r2, r3, #16
7000477c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004780:	e5d33007 	ldrb	r3, [r3, #7]
70004784:	e1a00002 	mov	r0, r2
70004788:	e51b1014 	ldr	r1, [fp, #-20]
7000478c:	e1a02003 	mov	r2, r3
70004790:	ebfff418 	bl	700017f8 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
70004794:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004798:	e3530000 	cmp	r3, #0
7000479c:	da00000c 	ble	700047d4 <rt_mb_recv+0x308>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
700047a0:	ebffefc9 	bl	700006cc <rt_tick_get>
700047a4:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
700047a8:	e51b3014 	ldr	r3, [fp, #-20]
700047ac:	e2832048 	add	r2, r3, #72	; 0x48
700047b0:	e24b3030 	sub	r3, fp, #48	; 0x30
700047b4:	e1a00002 	mov	r0, r2
700047b8:	e3a01000 	mov	r1, #0
700047bc:	e1a02003 	mov	r2, r3
700047c0:	eb001d08 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
700047c4:	e51b3014 	ldr	r3, [fp, #-20]
700047c8:	e2833048 	add	r3, r3, #72	; 0x48
700047cc:	e1a00003 	mov	r0, r3
700047d0:	eb001bb8 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
700047d4:	e1a03004 	mov	r3, r4
700047d8:	e1a00003 	mov	r0, r3
700047dc:	eb00269c 	bl	7000e254 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
700047e0:	eb0014ff 	bl	70009be4 <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
700047e4:	e51b3014 	ldr	r3, [fp, #-20]
700047e8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
700047ec:	e3530000 	cmp	r3, #0
700047f0:	0a000002 	beq	70004800 <rt_mb_recv+0x334>
        {
            /* return error */
            return thread->error;
700047f4:	e51b3014 	ldr	r3, [fp, #-20]
700047f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
700047fc:	ea000061 	b	70004988 <rt_mb_recv+0x4bc>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70004800:	eb002690 	bl	7000e248 <rt_hw_interrupt_disable>
70004804:	e1a03000 	mov	r3, r0
70004808:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
7000480c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004810:	e3530000 	cmp	r3, #0
70004814:	da00000e 	ble	70004854 <rt_mb_recv+0x388>
        {
            tick_delta = rt_tick_get() - tick_delta;
70004818:	ebffefab 	bl	700006cc <rt_tick_get>
7000481c:	e1a02000 	mov	r2, r0
70004820:	e51b3010 	ldr	r3, [fp, #-16]
70004824:	e0633002 	rsb	r3, r3, r2
70004828:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
7000482c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004830:	e1a02003 	mov	r2, r3
70004834:	e51b3010 	ldr	r3, [fp, #-16]
70004838:	e0633002 	rsb	r3, r3, r2
7000483c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
            if (timeout < 0)
70004840:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70004844:	e3530000 	cmp	r3, #0
70004848:	aa000001 	bge	70004854 <rt_mb_recv+0x388>
                timeout = 0;
7000484c:	e3a03000 	mov	r3, #0
70004850:	e50b3030 	str	r3, [fp, #-48]	; 0x30

        return -RT_ETIMEOUT;
    }

    /* mailbox is empty */
    while (mb->entry == 0)
70004854:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004858:	e1d331be 	ldrh	r3, [r3, #30]
7000485c:	e3530000 	cmp	r3, #0
70004860:	0affff5f 	beq	700045e4 <rt_mb_recv+0x118>
                timeout = 0;
        }
    }

    /* fill ptr */
    *value = mb->msg_pool[mb->out_offset];
70004864:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004868:	e5932018 	ldr	r2, [r3, #24]
7000486c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004870:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
70004874:	e1a03103 	lsl	r3, r3, #2
70004878:	e0823003 	add	r3, r2, r3
7000487c:	e5932000 	ldr	r2, [r3]
70004880:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70004884:	e5832000 	str	r2, [r3]

    /* increase output offset */
    ++ mb->out_offset;
70004888:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000488c:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
70004890:	e2833001 	add	r3, r3, #1
70004894:	e6ff2073 	uxth	r2, r3
70004898:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000489c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    if (mb->out_offset >= mb->size)
700048a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048a4:	e1d322b2 	ldrh	r2, [r3, #34]	; 0x22
700048a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048ac:	e1d331bc 	ldrh	r3, [r3, #28]
700048b0:	e1520003 	cmp	r2, r3
700048b4:	3a000002 	bcc	700048c4 <rt_mb_recv+0x3f8>
        mb->out_offset = 0;
700048b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048bc:	e3a02000 	mov	r2, #0
700048c0:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    /* decrease message entry */
    mb->entry --;
700048c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048c8:	e1d331be 	ldrh	r3, [r3, #30]
700048cc:	e2433001 	sub	r3, r3, #1
700048d0:	e6ff2073 	uxth	r2, r3
700048d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048d8:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&(mb->suspend_sender_thread)))
700048dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048e0:	e2833024 	add	r3, r3, #36	; 0x24
700048e4:	e1a00003 	mov	r0, r3
700048e8:	ebfff3a7 	bl	7000178c <rt_list_isempty>
700048ec:	e1a03000 	mov	r3, r0
700048f0:	e3530000 	cmp	r3, #0
700048f4:	1a000014 	bne	7000494c <rt_mb_recv+0x480>
    {
        rt_ipc_list_resume(&(mb->suspend_sender_thread));
700048f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700048fc:	e2833024 	add	r3, r3, #36	; 0x24
70004900:	e1a00003 	mov	r0, r3
70004904:	ebfff3fb 	bl	700018f8 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70004908:	e1a03004 	mov	r3, r4
7000490c:	e1a00003 	mov	r0, r3
70004910:	eb00264f 	bl	7000e254 <rt_hw_interrupt_enable>

        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
70004914:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70004918:	e3473002 	movt	r3, #28674	; 0x7002
7000491c:	e5933000 	ldr	r3, [r3]
70004920:	e3530000 	cmp	r3, #0
70004924:	0a000005 	beq	70004940 <rt_mb_recv+0x474>
70004928:	e30a3b7c 	movw	r3, #43900	; 0xab7c
7000492c:	e3473002 	movt	r3, #28674	; 0x7002
70004930:	e5933000 	ldr	r3, [r3]
70004934:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70004938:	e1a00002 	mov	r0, r2
7000493c:	e12fff33 	blx	r3

        rt_schedule();
70004940:	eb0014a7 	bl	70009be4 <rt_schedule>

        return RT_EOK;
70004944:	e3a03000 	mov	r3, #0
70004948:	ea00000e 	b	70004988 <rt_mb_recv+0x4bc>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
7000494c:	e1a03004 	mov	r3, r4
70004950:	e1a00003 	mov	r0, r3
70004954:	eb00263e 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
70004958:	e30a3b7c 	movw	r3, #43900	; 0xab7c
7000495c:	e3473002 	movt	r3, #28674	; 0x7002
70004960:	e5933000 	ldr	r3, [r3]
70004964:	e3530000 	cmp	r3, #0
70004968:	0a000005 	beq	70004984 <rt_mb_recv+0x4b8>
7000496c:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70004970:	e3473002 	movt	r3, #28674	; 0x7002
70004974:	e5933000 	ldr	r3, [r3]
70004978:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
7000497c:	e1a00002 	mov	r0, r2
70004980:	e12fff33 	blx	r3

    return RT_EOK;
70004984:	e3a03000 	mov	r3, #0
}
70004988:	e1a00003 	mov	r0, r3
7000498c:	e24bd008 	sub	sp, fp, #8
70004990:	e8bd8810 	pop	{r4, fp, pc}

70004994 <rt_mb_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
{
70004994:	e92d4800 	push	{fp, lr}
70004998:	e28db004 	add	fp, sp, #4
7000499c:	e24dd018 	sub	sp, sp, #24
700049a0:	e50b0010 	str	r0, [fp, #-16]
700049a4:	e1a03001 	mov	r3, r1
700049a8:	e50b2018 	str	r2, [fp, #-24]
700049ac:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(mb != RT_NULL);
700049b0:	e51b3010 	ldr	r3, [fp, #-16]
700049b4:	e3530000 	cmp	r3, #0
700049b8:	1a00001d 	bne	70004a34 <rt_mb_control+0xa0>
700049bc:	e3a03000 	mov	r3, #0
700049c0:	e54b3009 	strb	r3, [fp, #-9]
700049c4:	e30a3b74 	movw	r3, #43892	; 0xab74
700049c8:	e3473002 	movt	r3, #28674	; 0x7002
700049cc:	e5933000 	ldr	r3, [r3]
700049d0:	e3530000 	cmp	r3, #0
700049d4:	1a00000d 	bne	70004a10 <rt_mb_control+0x7c>
700049d8:	e3060324 	movw	r0, #25380	; 0x6324
700049dc:	e3470002 	movt	r0, #28674	; 0x7002
700049e0:	e30613dc 	movw	r1, #25564	; 0x63dc
700049e4:	e3471002 	movt	r1, #28674	; 0x7002
700049e8:	e30625a4 	movw	r2, #26020	; 0x65a4
700049ec:	e3472002 	movt	r2, #28674	; 0x7002
700049f0:	e3003699 	movw	r3, #1689	; 0x699
700049f4:	eb000b7e 	bl	700077f4 <rt_kprintf>
700049f8:	e1a00000 	nop			; (mov r0, r0)
700049fc:	e55b3009 	ldrb	r3, [fp, #-9]
70004a00:	e6ef3073 	uxtb	r3, r3
70004a04:	e3530000 	cmp	r3, #0
70004a08:	0afffffb 	beq	700049fc <rt_mb_control+0x68>
70004a0c:	ea000008 	b	70004a34 <rt_mb_control+0xa0>
70004a10:	e30a3b74 	movw	r3, #43892	; 0xab74
70004a14:	e3473002 	movt	r3, #28674	; 0x7002
70004a18:	e5933000 	ldr	r3, [r3]
70004a1c:	e30603dc 	movw	r0, #25564	; 0x63dc
70004a20:	e3470002 	movt	r0, #28674	; 0x7002
70004a24:	e30615a4 	movw	r1, #26020	; 0x65a4
70004a28:	e3471002 	movt	r1, #28674	; 0x7002
70004a2c:	e3002699 	movw	r2, #1689	; 0x699
70004a30:	e12fff33 	blx	r3

    if (cmd == RT_IPC_CMD_RESET)
70004a34:	e55b3011 	ldrb	r3, [fp, #-17]
70004a38:	e3530001 	cmp	r3, #1
70004a3c:	1a000019 	bne	70004aa8 <rt_mb_control+0x114>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
70004a40:	eb002600 	bl	7000e248 <rt_hw_interrupt_disable>
70004a44:	e1a03000 	mov	r3, r0
70004a48:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
70004a4c:	e51b3010 	ldr	r3, [fp, #-16]
70004a50:	e2833010 	add	r3, r3, #16
70004a54:	e1a00003 	mov	r0, r3
70004a58:	ebfff3b4 	bl	70001930 <rt_ipc_list_resume_all>
        /* also resume all mailbox private suspended thread */
        rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
70004a5c:	e51b3010 	ldr	r3, [fp, #-16]
70004a60:	e2833024 	add	r3, r3, #36	; 0x24
70004a64:	e1a00003 	mov	r0, r3
70004a68:	ebfff3b0 	bl	70001930 <rt_ipc_list_resume_all>

        /* re-init mailbox */
        mb->entry      = 0;
70004a6c:	e51b3010 	ldr	r3, [fp, #-16]
70004a70:	e3a02000 	mov	r2, #0
70004a74:	e1c321be 	strh	r2, [r3, #30]
        mb->in_offset  = 0;
70004a78:	e51b3010 	ldr	r3, [fp, #-16]
70004a7c:	e3a02000 	mov	r2, #0
70004a80:	e1c322b0 	strh	r2, [r3, #32]
        mb->out_offset = 0;
70004a84:	e51b3010 	ldr	r3, [fp, #-16]
70004a88:	e3a02000 	mov	r2, #0
70004a8c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70004a90:	e51b3008 	ldr	r3, [fp, #-8]
70004a94:	e1a00003 	mov	r0, r3
70004a98:	eb0025ed 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
70004a9c:	eb001450 	bl	70009be4 <rt_schedule>

        return RT_EOK;
70004aa0:	e3a03000 	mov	r3, #0
70004aa4:	ea000000 	b	70004aac <rt_mb_control+0x118>
    }

    return -RT_ERROR;
70004aa8:	e3e03000 	mvn	r3, #0
}
70004aac:	e1a00003 	mov	r0, r3
70004ab0:	e24bd004 	sub	sp, fp, #4
70004ab4:	e8bd8800 	pop	{fp, pc}

70004ab8 <rt_mq_init>:
                    const char *name,
                    void       *msgpool,
                    rt_size_t   msg_size,
                    rt_size_t   pool_size,
                    rt_uint8_t  flag)
{
70004ab8:	e92d4810 	push	{r4, fp, lr}
70004abc:	e28db008 	add	fp, sp, #8
70004ac0:	e24dd01c 	sub	sp, sp, #28
70004ac4:	e50b0018 	str	r0, [fp, #-24]
70004ac8:	e50b101c 	str	r1, [fp, #-28]
70004acc:	e50b2020 	str	r2, [fp, #-32]
70004ad0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    struct rt_mq_message *head;
    register rt_base_t temp;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
70004ad4:	e51b3018 	ldr	r3, [fp, #-24]
70004ad8:	e3530000 	cmp	r3, #0
70004adc:	1a00001d 	bne	70004b58 <rt_mq_init+0xa0>
70004ae0:	e3a03000 	mov	r3, #0
70004ae4:	e54b3011 	strb	r3, [fp, #-17]
70004ae8:	e30a3b74 	movw	r3, #43892	; 0xab74
70004aec:	e3473002 	movt	r3, #28674	; 0x7002
70004af0:	e5933000 	ldr	r3, [r3]
70004af4:	e3530000 	cmp	r3, #0
70004af8:	1a00000d 	bne	70004b34 <rt_mq_init+0x7c>
70004afc:	e3060324 	movw	r0, #25380	; 0x6324
70004b00:	e3470002 	movt	r0, #28674	; 0x7002
70004b04:	e30613ec 	movw	r1, #25580	; 0x63ec
70004b08:	e3471002 	movt	r1, #28674	; 0x7002
70004b0c:	e30625b4 	movw	r2, #26036	; 0x65b4
70004b10:	e3472002 	movt	r2, #28674	; 0x7002
70004b14:	e30036d5 	movw	r3, #1749	; 0x6d5
70004b18:	eb000b35 	bl	700077f4 <rt_kprintf>
70004b1c:	e1a00000 	nop			; (mov r0, r0)
70004b20:	e55b3011 	ldrb	r3, [fp, #-17]
70004b24:	e6ef3073 	uxtb	r3, r3
70004b28:	e3530000 	cmp	r3, #0
70004b2c:	0afffffb 	beq	70004b20 <rt_mq_init+0x68>
70004b30:	ea000008 	b	70004b58 <rt_mq_init+0xa0>
70004b34:	e30a3b74 	movw	r3, #43892	; 0xab74
70004b38:	e3473002 	movt	r3, #28674	; 0x7002
70004b3c:	e5933000 	ldr	r3, [r3]
70004b40:	e30603ec 	movw	r0, #25580	; 0x63ec
70004b44:	e3470002 	movt	r0, #28674	; 0x7002
70004b48:	e30615b4 	movw	r1, #26036	; 0x65b4
70004b4c:	e3471002 	movt	r1, #28674	; 0x7002
70004b50:	e30026d5 	movw	r2, #1749	; 0x6d5
70004b54:	e12fff33 	blx	r3

    /* init object */
    rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
70004b58:	e51b3018 	ldr	r3, [fp, #-24]
70004b5c:	e1a00003 	mov	r0, r3
70004b60:	e3a01005 	mov	r1, #5
70004b64:	e51b201c 	ldr	r2, [fp, #-28]
70004b68:	eb0011d0 	bl	700092b0 <rt_object_init>

    /* set parent flag */
    mq->parent.parent.flag = flag;
70004b6c:	e51b3018 	ldr	r3, [fp, #-24]
70004b70:	e5db2008 	ldrb	r2, [fp, #8]
70004b74:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
70004b78:	e51b3018 	ldr	r3, [fp, #-24]
70004b7c:	e1a00003 	mov	r0, r3
70004b80:	ebfff310 	bl	700017c8 <rt_ipc_object_init>

    /* set messasge pool */
    mq->msg_pool = msgpool;
70004b84:	e51b3018 	ldr	r3, [fp, #-24]
70004b88:	e51b2020 	ldr	r2, [fp, #-32]
70004b8c:	e5832018 	str	r2, [r3, #24]

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
70004b90:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70004b94:	e6ff3073 	uxth	r3, r3
70004b98:	e2833003 	add	r3, r3, #3
70004b9c:	e6ff3073 	uxth	r3, r3
70004ba0:	e3c33003 	bic	r3, r3, #3
70004ba4:	e6ff2073 	uxth	r2, r3
70004ba8:	e51b3018 	ldr	r3, [fp, #-24]
70004bac:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
70004bb0:	e51b3018 	ldr	r3, [fp, #-24]
70004bb4:	e1d331bc 	ldrh	r3, [r3, #28]
70004bb8:	e2833004 	add	r3, r3, #4
70004bbc:	e59b0004 	ldr	r0, [fp, #4]
70004bc0:	e1a01003 	mov	r1, r3
70004bc4:	fa00791d 	blx	70023040 <__aeabi_uidiv>
70004bc8:	e1a03000 	mov	r3, r0
70004bcc:	e6ff2073 	uxth	r2, r3
70004bd0:	e51b3018 	ldr	r3, [fp, #-24]
70004bd4:	e1c321be 	strh	r2, [r3, #30]

    /* init message list */
    mq->msg_queue_head = RT_NULL;
70004bd8:	e51b3018 	ldr	r3, [fp, #-24]
70004bdc:	e3a02000 	mov	r2, #0
70004be0:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
70004be4:	e51b3018 	ldr	r3, [fp, #-24]
70004be8:	e3a02000 	mov	r2, #0
70004bec:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
70004bf0:	e51b3018 	ldr	r3, [fp, #-24]
70004bf4:	e3a02000 	mov	r2, #0
70004bf8:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
70004bfc:	e3a04000 	mov	r4, #0
70004c00:	ea000010 	b	70004c48 <rt_mq_init+0x190>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
70004c04:	e51b3018 	ldr	r3, [fp, #-24]
70004c08:	e5932018 	ldr	r2, [r3, #24]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
70004c0c:	e51b3018 	ldr	r3, [fp, #-24]
70004c10:	e1d331bc 	ldrh	r3, [r3, #28]
70004c14:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
70004c18:	e1a01004 	mov	r1, r4
70004c1c:	e0030391 	mul	r3, r1, r3
70004c20:	e0823003 	add	r3, r2, r3
70004c24:	e50b3010 	str	r3, [fp, #-16]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
70004c28:	e51b3018 	ldr	r3, [fp, #-24]
70004c2c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
70004c30:	e51b3010 	ldr	r3, [fp, #-16]
70004c34:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
70004c38:	e51b3018 	ldr	r3, [fp, #-24]
70004c3c:	e51b2010 	ldr	r2, [fp, #-16]
70004c40:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
70004c44:	e2844001 	add	r4, r4, #1
70004c48:	e51b3018 	ldr	r3, [fp, #-24]
70004c4c:	e1d331be 	ldrh	r3, [r3, #30]
70004c50:	e1530004 	cmp	r3, r4
70004c54:	caffffea 	bgt	70004c04 <rt_mq_init+0x14c>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
70004c58:	e51b3018 	ldr	r3, [fp, #-24]
70004c5c:	e3a02000 	mov	r2, #0
70004c60:	e1c322b0 	strh	r2, [r3, #32]

    return RT_EOK;
70004c64:	e3a03000 	mov	r3, #0
}
70004c68:	e1a00003 	mov	r0, r3
70004c6c:	e24bd008 	sub	sp, fp, #8
70004c70:	e8bd8810 	pop	{r4, fp, pc}

70004c74 <rt_mq_detach>:
 * @param mq the message queue object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mq_detach(rt_mq_t mq)
{
70004c74:	e92d4800 	push	{fp, lr}
70004c78:	e28db004 	add	fp, sp, #4
70004c7c:	e24dd010 	sub	sp, sp, #16
70004c80:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
70004c84:	e51b3010 	ldr	r3, [fp, #-16]
70004c88:	e3530000 	cmp	r3, #0
70004c8c:	1a00001d 	bne	70004d08 <rt_mq_detach+0x94>
70004c90:	e3a03000 	mov	r3, #0
70004c94:	e54b3005 	strb	r3, [fp, #-5]
70004c98:	e30a3b74 	movw	r3, #43892	; 0xab74
70004c9c:	e3473002 	movt	r3, #28674	; 0x7002
70004ca0:	e5933000 	ldr	r3, [r3]
70004ca4:	e3530000 	cmp	r3, #0
70004ca8:	1a00000d 	bne	70004ce4 <rt_mq_detach+0x70>
70004cac:	e3060324 	movw	r0, #25380	; 0x6324
70004cb0:	e3470002 	movt	r0, #28674	; 0x7002
70004cb4:	e30613ec 	movw	r1, #25580	; 0x63ec
70004cb8:	e3471002 	movt	r1, #28674	; 0x7002
70004cbc:	e30625c0 	movw	r2, #26048	; 0x65c0
70004cc0:	e3472002 	movt	r2, #28674	; 0x7002
70004cc4:	e3003706 	movw	r3, #1798	; 0x706
70004cc8:	eb000ac9 	bl	700077f4 <rt_kprintf>
70004ccc:	e1a00000 	nop			; (mov r0, r0)
70004cd0:	e55b3005 	ldrb	r3, [fp, #-5]
70004cd4:	e6ef3073 	uxtb	r3, r3
70004cd8:	e3530000 	cmp	r3, #0
70004cdc:	0afffffb 	beq	70004cd0 <rt_mq_detach+0x5c>
70004ce0:	ea000008 	b	70004d08 <rt_mq_detach+0x94>
70004ce4:	e30a3b74 	movw	r3, #43892	; 0xab74
70004ce8:	e3473002 	movt	r3, #28674	; 0x7002
70004cec:	e5933000 	ldr	r3, [r3]
70004cf0:	e30603ec 	movw	r0, #25580	; 0x63ec
70004cf4:	e3470002 	movt	r0, #28674	; 0x7002
70004cf8:	e30615c0 	movw	r1, #26048	; 0x65c0
70004cfc:	e3471002 	movt	r1, #28674	; 0x7002
70004d00:	e3002706 	movw	r2, #1798	; 0x706
70004d04:	e12fff33 	blx	r3

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&mq->parent.suspend_thread);
70004d08:	e51b3010 	ldr	r3, [fp, #-16]
70004d0c:	e2833010 	add	r3, r3, #16
70004d10:	e1a00003 	mov	r0, r3
70004d14:	ebfff305 	bl	70001930 <rt_ipc_list_resume_all>

    /* detach message queue object */
    rt_object_detach(&(mq->parent.parent));
70004d18:	e51b3010 	ldr	r3, [fp, #-16]
70004d1c:	e1a00003 	mov	r0, r3
70004d20:	eb001191 	bl	7000936c <rt_object_detach>

    return RT_EOK;
70004d24:	e3a03000 	mov	r3, #0
}
70004d28:	e1a00003 	mov	r0, r3
70004d2c:	e24bd004 	sub	sp, fp, #4
70004d30:	e8bd8800 	pop	{fp, pc}

70004d34 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
70004d34:	e92d4810 	push	{r4, fp, lr}
70004d38:	e28db008 	add	fp, sp, #8
70004d3c:	e24dd024 	sub	sp, sp, #36	; 0x24
70004d40:	e50b0020 	str	r0, [fp, #-32]
70004d44:	e50b1024 	str	r1, [fp, #-36]	; 0x24
70004d48:	e50b2028 	str	r2, [fp, #-40]	; 0x28
70004d4c:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
70004d50:	eb00253c 	bl	7000e248 <rt_hw_interrupt_disable>
70004d54:	e50b0010 	str	r0, [fp, #-16]
70004d58:	eb000455 	bl	70005eb4 <rt_interrupt_get_nest>
70004d5c:	e1a03000 	mov	r3, r0
70004d60:	e3530000 	cmp	r3, #0
70004d64:	0a000022 	beq	70004df4 <rt_mq_create+0xc0>
70004d68:	e3060354 	movw	r0, #25428	; 0x6354
70004d6c:	e3470002 	movt	r0, #28674	; 0x7002
70004d70:	e30615d0 	movw	r1, #26064	; 0x65d0
70004d74:	e3471002 	movt	r1, #28674	; 0x7002
70004d78:	eb000a9d 	bl	700077f4 <rt_kprintf>
70004d7c:	e3a03000 	mov	r3, #0
70004d80:	e54b3019 	strb	r3, [fp, #-25]
70004d84:	e30a3b74 	movw	r3, #43892	; 0xab74
70004d88:	e3473002 	movt	r3, #28674	; 0x7002
70004d8c:	e5933000 	ldr	r3, [r3]
70004d90:	e3530000 	cmp	r3, #0
70004d94:	1a00000d 	bne	70004dd0 <rt_mq_create+0x9c>
70004d98:	e3060324 	movw	r0, #25380	; 0x6324
70004d9c:	e3470002 	movt	r0, #28674	; 0x7002
70004da0:	e3061378 	movw	r1, #25464	; 0x6378
70004da4:	e3471002 	movt	r1, #28674	; 0x7002
70004da8:	e30625d0 	movw	r2, #26064	; 0x65d0
70004dac:	e3472002 	movt	r2, #28674	; 0x7002
70004db0:	e3003726 	movw	r3, #1830	; 0x726
70004db4:	eb000a8e 	bl	700077f4 <rt_kprintf>
70004db8:	e1a00000 	nop			; (mov r0, r0)
70004dbc:	e55b3019 	ldrb	r3, [fp, #-25]
70004dc0:	e6ef3073 	uxtb	r3, r3
70004dc4:	e3530000 	cmp	r3, #0
70004dc8:	0afffffb 	beq	70004dbc <rt_mq_create+0x88>
70004dcc:	ea000008 	b	70004df4 <rt_mq_create+0xc0>
70004dd0:	e30a3b74 	movw	r3, #43892	; 0xab74
70004dd4:	e3473002 	movt	r3, #28674	; 0x7002
70004dd8:	e5933000 	ldr	r3, [r3]
70004ddc:	e3060378 	movw	r0, #25464	; 0x6378
70004de0:	e3470002 	movt	r0, #28674	; 0x7002
70004de4:	e30615d0 	movw	r1, #26064	; 0x65d0
70004de8:	e3471002 	movt	r1, #28674	; 0x7002
70004dec:	e3002726 	movw	r2, #1830	; 0x726
70004df0:	e12fff33 	blx	r3
70004df4:	e51b0010 	ldr	r0, [fp, #-16]
70004df8:	eb002515 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
70004dfc:	e3a00005 	mov	r0, #5
70004e00:	e51b1020 	ldr	r1, [fp, #-32]
70004e04:	eb001191 	bl	70009450 <rt_object_allocate>
70004e08:	e50b0014 	str	r0, [fp, #-20]
    if (mq == RT_NULL)
70004e0c:	e51b3014 	ldr	r3, [fp, #-20]
70004e10:	e3530000 	cmp	r3, #0
70004e14:	1a000001 	bne	70004e20 <rt_mq_create+0xec>
        return mq;
70004e18:	e51b3014 	ldr	r3, [fp, #-20]
70004e1c:	ea000048 	b	70004f44 <rt_mq_create+0x210>

    /* set parent */
    mq->parent.parent.flag = flag;
70004e20:	e51b3014 	ldr	r3, [fp, #-20]
70004e24:	e55b2029 	ldrb	r2, [fp, #-41]	; 0x29
70004e28:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
70004e2c:	e51b3014 	ldr	r3, [fp, #-20]
70004e30:	e1a00003 	mov	r0, r3
70004e34:	ebfff263 	bl	700017c8 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
70004e38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70004e3c:	e6ff3073 	uxth	r3, r3
70004e40:	e2833003 	add	r3, r3, #3
70004e44:	e6ff3073 	uxth	r3, r3
70004e48:	e3c33003 	bic	r3, r3, #3
70004e4c:	e6ff2073 	uxth	r2, r3
70004e50:	e51b3014 	ldr	r3, [fp, #-20]
70004e54:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = max_msgs;
70004e58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70004e5c:	e6ff2073 	uxth	r2, r3
70004e60:	e51b3014 	ldr	r3, [fp, #-20]
70004e64:	e1c321be 	strh	r2, [r3, #30]

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
70004e68:	e51b3014 	ldr	r3, [fp, #-20]
70004e6c:	e1d331bc 	ldrh	r3, [r3, #28]
70004e70:	e2833004 	add	r3, r3, #4
70004e74:	e51b2014 	ldr	r2, [fp, #-20]
70004e78:	e1d221be 	ldrh	r2, [r2, #30]
70004e7c:	e0030392 	mul	r3, r2, r3
70004e80:	e1a00003 	mov	r0, r3
70004e84:	eb000c8c 	bl	700080bc <rt_malloc>
70004e88:	e1a02000 	mov	r2, r0
70004e8c:	e51b3014 	ldr	r3, [fp, #-20]
70004e90:	e5832018 	str	r2, [r3, #24]
    if (mq->msg_pool == RT_NULL)
70004e94:	e51b3014 	ldr	r3, [fp, #-20]
70004e98:	e5933018 	ldr	r3, [r3, #24]
70004e9c:	e3530000 	cmp	r3, #0
70004ea0:	1a000003 	bne	70004eb4 <rt_mq_create+0x180>
    {
        rt_mq_delete(mq);
70004ea4:	e51b0014 	ldr	r0, [fp, #-20]
70004ea8:	eb000028 	bl	70004f50 <rt_mq_delete>

        return RT_NULL;
70004eac:	e3a03000 	mov	r3, #0
70004eb0:	ea000023 	b	70004f44 <rt_mq_create+0x210>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
70004eb4:	e51b3014 	ldr	r3, [fp, #-20]
70004eb8:	e3a02000 	mov	r2, #0
70004ebc:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
70004ec0:	e51b3014 	ldr	r3, [fp, #-20]
70004ec4:	e3a02000 	mov	r2, #0
70004ec8:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
70004ecc:	e51b3014 	ldr	r3, [fp, #-20]
70004ed0:	e3a02000 	mov	r2, #0
70004ed4:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
70004ed8:	e3a04000 	mov	r4, #0
70004edc:	ea000010 	b	70004f24 <rt_mq_create+0x1f0>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
70004ee0:	e51b3014 	ldr	r3, [fp, #-20]
70004ee4:	e5932018 	ldr	r2, [r3, #24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
70004ee8:	e51b3014 	ldr	r3, [fp, #-20]
70004eec:	e1d331bc 	ldrh	r3, [r3, #28]
70004ef0:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
70004ef4:	e1a01004 	mov	r1, r4
70004ef8:	e0030391 	mul	r3, r1, r3
70004efc:	e0823003 	add	r3, r2, r3
70004f00:	e50b3018 	str	r3, [fp, #-24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
70004f04:	e51b3014 	ldr	r3, [fp, #-20]
70004f08:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
70004f0c:	e51b3018 	ldr	r3, [fp, #-24]
70004f10:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
70004f14:	e51b3014 	ldr	r3, [fp, #-20]
70004f18:	e51b2018 	ldr	r2, [fp, #-24]
70004f1c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
70004f20:	e2844001 	add	r4, r4, #1
70004f24:	e51b3014 	ldr	r3, [fp, #-20]
70004f28:	e1d331be 	ldrh	r3, [r3, #30]
70004f2c:	e1530004 	cmp	r3, r4
70004f30:	caffffea 	bgt	70004ee0 <rt_mq_create+0x1ac>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
70004f34:	e51b3014 	ldr	r3, [fp, #-20]
70004f38:	e3a02000 	mov	r2, #0
70004f3c:	e1c322b0 	strh	r2, [r3, #32]

    return mq;
70004f40:	e51b3014 	ldr	r3, [fp, #-20]
}
70004f44:	e1a00003 	mov	r0, r3
70004f48:	e24bd008 	sub	sp, fp, #8
70004f4c:	e8bd8810 	pop	{r4, fp, pc}

70004f50 <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
70004f50:	e92d4800 	push	{fp, lr}
70004f54:	e28db004 	add	fp, sp, #4
70004f58:	e24dd010 	sub	sp, sp, #16
70004f5c:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
70004f60:	eb0024b8 	bl	7000e248 <rt_hw_interrupt_disable>
70004f64:	e50b0008 	str	r0, [fp, #-8]
70004f68:	eb0003d1 	bl	70005eb4 <rt_interrupt_get_nest>
70004f6c:	e1a03000 	mov	r3, r0
70004f70:	e3530000 	cmp	r3, #0
70004f74:	0a000022 	beq	70005004 <rt_mq_delete+0xb4>
70004f78:	e3060354 	movw	r0, #25428	; 0x6354
70004f7c:	e3470002 	movt	r0, #28674	; 0x7002
70004f80:	e30615e0 	movw	r1, #26080	; 0x65e0
70004f84:	e3471002 	movt	r1, #28674	; 0x7002
70004f88:	eb000a19 	bl	700077f4 <rt_kprintf>
70004f8c:	e3a03000 	mov	r3, #0
70004f90:	e54b3009 	strb	r3, [fp, #-9]
70004f94:	e30a3b74 	movw	r3, #43892	; 0xab74
70004f98:	e3473002 	movt	r3, #28674	; 0x7002
70004f9c:	e5933000 	ldr	r3, [r3]
70004fa0:	e3530000 	cmp	r3, #0
70004fa4:	1a00000d 	bne	70004fe0 <rt_mq_delete+0x90>
70004fa8:	e3060324 	movw	r0, #25380	; 0x6324
70004fac:	e3470002 	movt	r0, #28674	; 0x7002
70004fb0:	e3061378 	movw	r1, #25464	; 0x6378
70004fb4:	e3471002 	movt	r1, #28674	; 0x7002
70004fb8:	e30625e0 	movw	r2, #26080	; 0x65e0
70004fbc:	e3472002 	movt	r2, #28674	; 0x7002
70004fc0:	e3a03e76 	mov	r3, #1888	; 0x760
70004fc4:	eb000a0a 	bl	700077f4 <rt_kprintf>
70004fc8:	e1a00000 	nop			; (mov r0, r0)
70004fcc:	e55b3009 	ldrb	r3, [fp, #-9]
70004fd0:	e6ef3073 	uxtb	r3, r3
70004fd4:	e3530000 	cmp	r3, #0
70004fd8:	0afffffb 	beq	70004fcc <rt_mq_delete+0x7c>
70004fdc:	ea000008 	b	70005004 <rt_mq_delete+0xb4>
70004fe0:	e30a3b74 	movw	r3, #43892	; 0xab74
70004fe4:	e3473002 	movt	r3, #28674	; 0x7002
70004fe8:	e5933000 	ldr	r3, [r3]
70004fec:	e3060378 	movw	r0, #25464	; 0x6378
70004ff0:	e3470002 	movt	r0, #28674	; 0x7002
70004ff4:	e30615e0 	movw	r1, #26080	; 0x65e0
70004ff8:	e3471002 	movt	r1, #28674	; 0x7002
70004ffc:	e3a02e76 	mov	r2, #1888	; 0x760
70005000:	e12fff33 	blx	r3
70005004:	e51b0008 	ldr	r0, [fp, #-8]
70005008:	eb002491 	bl	7000e254 <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
7000500c:	e51b3010 	ldr	r3, [fp, #-16]
70005010:	e3530000 	cmp	r3, #0
70005014:	1a00001d 	bne	70005090 <rt_mq_delete+0x140>
70005018:	e3a03000 	mov	r3, #0
7000501c:	e54b300a 	strb	r3, [fp, #-10]
70005020:	e30a3b74 	movw	r3, #43892	; 0xab74
70005024:	e3473002 	movt	r3, #28674	; 0x7002
70005028:	e5933000 	ldr	r3, [r3]
7000502c:	e3530000 	cmp	r3, #0
70005030:	1a00000d 	bne	7000506c <rt_mq_delete+0x11c>
70005034:	e3060324 	movw	r0, #25380	; 0x6324
70005038:	e3470002 	movt	r0, #28674	; 0x7002
7000503c:	e30613ec 	movw	r1, #25580	; 0x63ec
70005040:	e3471002 	movt	r1, #28674	; 0x7002
70005044:	e30625e0 	movw	r2, #26080	; 0x65e0
70005048:	e3472002 	movt	r2, #28674	; 0x7002
7000504c:	e3003763 	movw	r3, #1891	; 0x763
70005050:	eb0009e7 	bl	700077f4 <rt_kprintf>
70005054:	e1a00000 	nop			; (mov r0, r0)
70005058:	e55b300a 	ldrb	r3, [fp, #-10]
7000505c:	e6ef3073 	uxtb	r3, r3
70005060:	e3530000 	cmp	r3, #0
70005064:	0afffffb 	beq	70005058 <rt_mq_delete+0x108>
70005068:	ea000008 	b	70005090 <rt_mq_delete+0x140>
7000506c:	e30a3b74 	movw	r3, #43892	; 0xab74
70005070:	e3473002 	movt	r3, #28674	; 0x7002
70005074:	e5933000 	ldr	r3, [r3]
70005078:	e30603ec 	movw	r0, #25580	; 0x63ec
7000507c:	e3470002 	movt	r0, #28674	; 0x7002
70005080:	e30615e0 	movw	r1, #26080	; 0x65e0
70005084:	e3471002 	movt	r1, #28674	; 0x7002
70005088:	e3002763 	movw	r2, #1891	; 0x763
7000508c:	e12fff33 	blx	r3

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
70005090:	e51b3010 	ldr	r3, [fp, #-16]
70005094:	e2833010 	add	r3, r3, #16
70005098:	e1a00003 	mov	r0, r3
7000509c:	ebfff223 	bl	70001930 <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
700050a0:	e51b3010 	ldr	r3, [fp, #-16]
700050a4:	e5933018 	ldr	r3, [r3, #24]
700050a8:	e1a00003 	mov	r0, r3
700050ac:	eb000ec5 	bl	70008bc8 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
700050b0:	e51b3010 	ldr	r3, [fp, #-16]
700050b4:	e1a00003 	mov	r0, r3
700050b8:	eb001149 	bl	700095e4 <rt_object_delete>

    return RT_EOK;
700050bc:	e3a03000 	mov	r3, #0
}
700050c0:	e1a00003 	mov	r0, r3
700050c4:	e24bd004 	sub	sp, fp, #4
700050c8:	e8bd8800 	pop	{fp, pc}

700050cc <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
700050cc:	e92d4810 	push	{r4, fp, lr}
700050d0:	e28db008 	add	fp, sp, #8
700050d4:	e24dd01c 	sub	sp, sp, #28
700050d8:	e50b0018 	str	r0, [fp, #-24]
700050dc:	e50b101c 	str	r1, [fp, #-28]
700050e0:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
700050e4:	e51b3018 	ldr	r3, [fp, #-24]
700050e8:	e3530000 	cmp	r3, #0
700050ec:	1a00001d 	bne	70005168 <rt_mq_send+0x9c>
700050f0:	e3a03000 	mov	r3, #0
700050f4:	e54b3011 	strb	r3, [fp, #-17]
700050f8:	e30a3b74 	movw	r3, #43892	; 0xab74
700050fc:	e3473002 	movt	r3, #28674	; 0x7002
70005100:	e5933000 	ldr	r3, [r3]
70005104:	e3530000 	cmp	r3, #0
70005108:	1a00000d 	bne	70005144 <rt_mq_send+0x78>
7000510c:	e3060324 	movw	r0, #25380	; 0x6324
70005110:	e3470002 	movt	r0, #28674	; 0x7002
70005114:	e30613ec 	movw	r1, #25580	; 0x63ec
70005118:	e3471002 	movt	r1, #28674	; 0x7002
7000511c:	e30625f0 	movw	r2, #26096	; 0x65f0
70005120:	e3472002 	movt	r2, #28674	; 0x7002
70005124:	e3003789 	movw	r3, #1929	; 0x789
70005128:	eb0009b1 	bl	700077f4 <rt_kprintf>
7000512c:	e1a00000 	nop			; (mov r0, r0)
70005130:	e55b3011 	ldrb	r3, [fp, #-17]
70005134:	e6ef3073 	uxtb	r3, r3
70005138:	e3530000 	cmp	r3, #0
7000513c:	0afffffb 	beq	70005130 <rt_mq_send+0x64>
70005140:	ea000008 	b	70005168 <rt_mq_send+0x9c>
70005144:	e30a3b74 	movw	r3, #43892	; 0xab74
70005148:	e3473002 	movt	r3, #28674	; 0x7002
7000514c:	e5933000 	ldr	r3, [r3]
70005150:	e30603ec 	movw	r0, #25580	; 0x63ec
70005154:	e3470002 	movt	r0, #28674	; 0x7002
70005158:	e30615f0 	movw	r1, #26096	; 0x65f0
7000515c:	e3471002 	movt	r1, #28674	; 0x7002
70005160:	e3002789 	movw	r2, #1929	; 0x789
70005164:	e12fff33 	blx	r3
    RT_ASSERT(buffer != RT_NULL);
70005168:	e51b301c 	ldr	r3, [fp, #-28]
7000516c:	e3530000 	cmp	r3, #0
70005170:	1a00001d 	bne	700051ec <rt_mq_send+0x120>
70005174:	e3a03000 	mov	r3, #0
70005178:	e54b3012 	strb	r3, [fp, #-18]
7000517c:	e30a3b74 	movw	r3, #43892	; 0xab74
70005180:	e3473002 	movt	r3, #28674	; 0x7002
70005184:	e5933000 	ldr	r3, [r3]
70005188:	e3530000 	cmp	r3, #0
7000518c:	1a00000d 	bne	700051c8 <rt_mq_send+0xfc>
70005190:	e3060324 	movw	r0, #25380	; 0x6324
70005194:	e3470002 	movt	r0, #28674	; 0x7002
70005198:	e30613fc 	movw	r1, #25596	; 0x63fc
7000519c:	e3471002 	movt	r1, #28674	; 0x7002
700051a0:	e30625f0 	movw	r2, #26096	; 0x65f0
700051a4:	e3472002 	movt	r2, #28674	; 0x7002
700051a8:	e300378a 	movw	r3, #1930	; 0x78a
700051ac:	eb000990 	bl	700077f4 <rt_kprintf>
700051b0:	e1a00000 	nop			; (mov r0, r0)
700051b4:	e55b3012 	ldrb	r3, [fp, #-18]
700051b8:	e6ef3073 	uxtb	r3, r3
700051bc:	e3530000 	cmp	r3, #0
700051c0:	0afffffb 	beq	700051b4 <rt_mq_send+0xe8>
700051c4:	ea000008 	b	700051ec <rt_mq_send+0x120>
700051c8:	e30a3b74 	movw	r3, #43892	; 0xab74
700051cc:	e3473002 	movt	r3, #28674	; 0x7002
700051d0:	e5933000 	ldr	r3, [r3]
700051d4:	e30603fc 	movw	r0, #25596	; 0x63fc
700051d8:	e3470002 	movt	r0, #28674	; 0x7002
700051dc:	e30615f0 	movw	r1, #26096	; 0x65f0
700051e0:	e3471002 	movt	r1, #28674	; 0x7002
700051e4:	e300278a 	movw	r2, #1930	; 0x78a
700051e8:	e12fff33 	blx	r3
    RT_ASSERT(size != 0);
700051ec:	e51b3020 	ldr	r3, [fp, #-32]
700051f0:	e3530000 	cmp	r3, #0
700051f4:	1a00001d 	bne	70005270 <rt_mq_send+0x1a4>
700051f8:	e3a03000 	mov	r3, #0
700051fc:	e54b3013 	strb	r3, [fp, #-19]
70005200:	e30a3b74 	movw	r3, #43892	; 0xab74
70005204:	e3473002 	movt	r3, #28674	; 0x7002
70005208:	e5933000 	ldr	r3, [r3]
7000520c:	e3530000 	cmp	r3, #0
70005210:	1a00000d 	bne	7000524c <rt_mq_send+0x180>
70005214:	e3060324 	movw	r0, #25380	; 0x6324
70005218:	e3470002 	movt	r0, #28674	; 0x7002
7000521c:	e3061410 	movw	r1, #25616	; 0x6410
70005220:	e3471002 	movt	r1, #28674	; 0x7002
70005224:	e30625f0 	movw	r2, #26096	; 0x65f0
70005228:	e3472002 	movt	r2, #28674	; 0x7002
7000522c:	e300378b 	movw	r3, #1931	; 0x78b
70005230:	eb00096f 	bl	700077f4 <rt_kprintf>
70005234:	e1a00000 	nop			; (mov r0, r0)
70005238:	e55b3013 	ldrb	r3, [fp, #-19]
7000523c:	e6ef3073 	uxtb	r3, r3
70005240:	e3530000 	cmp	r3, #0
70005244:	0afffffb 	beq	70005238 <rt_mq_send+0x16c>
70005248:	ea000008 	b	70005270 <rt_mq_send+0x1a4>
7000524c:	e30a3b74 	movw	r3, #43892	; 0xab74
70005250:	e3473002 	movt	r3, #28674	; 0x7002
70005254:	e5933000 	ldr	r3, [r3]
70005258:	e3060410 	movw	r0, #25616	; 0x6410
7000525c:	e3470002 	movt	r0, #28674	; 0x7002
70005260:	e30615f0 	movw	r1, #26096	; 0x65f0
70005264:	e3471002 	movt	r1, #28674	; 0x7002
70005268:	e300278b 	movw	r2, #1931	; 0x78b
7000526c:	e12fff33 	blx	r3

    /* greater than one message size */
    if (size > mq->msg_size)
70005270:	e51b3018 	ldr	r3, [fp, #-24]
70005274:	e1d331bc 	ldrh	r3, [r3, #28]
70005278:	e1a02003 	mov	r2, r3
7000527c:	e51b3020 	ldr	r3, [fp, #-32]
70005280:	e1520003 	cmp	r2, r3
70005284:	2a000001 	bcs	70005290 <rt_mq_send+0x1c4>
        return -RT_ERROR;
70005288:	e3e03000 	mvn	r3, #0
7000528c:	ea000058 	b	700053f4 <rt_mq_send+0x328>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
70005290:	e30a3b78 	movw	r3, #43896	; 0xab78
70005294:	e3473002 	movt	r3, #28674	; 0x7002
70005298:	e5933000 	ldr	r3, [r3]
7000529c:	e3530000 	cmp	r3, #0
700052a0:	0a000005 	beq	700052bc <rt_mq_send+0x1f0>
700052a4:	e30a3b78 	movw	r3, #43896	; 0xab78
700052a8:	e3473002 	movt	r3, #28674	; 0x7002
700052ac:	e5933000 	ldr	r3, [r3]
700052b0:	e51b2018 	ldr	r2, [fp, #-24]
700052b4:	e1a00002 	mov	r0, r2
700052b8:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
700052bc:	eb0023e1 	bl	7000e248 <rt_hw_interrupt_disable>
700052c0:	e1a03000 	mov	r3, r0
700052c4:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
700052c8:	e51b3018 	ldr	r3, [fp, #-24]
700052cc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
700052d0:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
700052d4:	e51b3010 	ldr	r3, [fp, #-16]
700052d8:	e3530000 	cmp	r3, #0
700052dc:	1a000004 	bne	700052f4 <rt_mq_send+0x228>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
700052e0:	e1a03004 	mov	r3, r4
700052e4:	e1a00003 	mov	r0, r3
700052e8:	eb0023d9 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_EFULL;
700052ec:	e3e03002 	mvn	r3, #2
700052f0:	ea00003f 	b	700053f4 <rt_mq_send+0x328>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
700052f4:	e51b3010 	ldr	r3, [fp, #-16]
700052f8:	e5932000 	ldr	r2, [r3]
700052fc:	e51b3018 	ldr	r3, [fp, #-24]
70005300:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70005304:	e1a03004 	mov	r3, r4
70005308:	e1a00003 	mov	r0, r3
7000530c:	eb0023d0 	bl	7000e254 <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
70005310:	e51b3010 	ldr	r3, [fp, #-16]
70005314:	e3a02000 	mov	r2, #0
70005318:	e5832000 	str	r2, [r3]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
7000531c:	e51b3010 	ldr	r3, [fp, #-16]
70005320:	e2833004 	add	r3, r3, #4
70005324:	e1a00003 	mov	r0, r3
70005328:	e51b101c 	ldr	r1, [fp, #-28]
7000532c:	e51b2020 	ldr	r2, [fp, #-32]
70005330:	eb00038e 	bl	70006170 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70005334:	eb0023c3 	bl	7000e248 <rt_hw_interrupt_disable>
70005338:	e1a03000 	mov	r3, r0
7000533c:	e1a04003 	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
70005340:	e51b3018 	ldr	r3, [fp, #-24]
70005344:	e5933028 	ldr	r3, [r3, #40]	; 0x28
70005348:	e3530000 	cmp	r3, #0
7000534c:	0a000003 	beq	70005360 <rt_mq_send+0x294>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
70005350:	e51b3018 	ldr	r3, [fp, #-24]
70005354:	e5933028 	ldr	r3, [r3, #40]	; 0x28
70005358:	e51b2010 	ldr	r2, [fp, #-16]
7000535c:	e5832000 	str	r2, [r3]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
70005360:	e51b3018 	ldr	r3, [fp, #-24]
70005364:	e51b2010 	ldr	r2, [fp, #-16]
70005368:	e5832028 	str	r2, [r3, #40]	; 0x28
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
7000536c:	e51b3018 	ldr	r3, [fp, #-24]
70005370:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70005374:	e3530000 	cmp	r3, #0
70005378:	1a000002 	bne	70005388 <rt_mq_send+0x2bc>
        mq->msg_queue_head = msg;
7000537c:	e51b3018 	ldr	r3, [fp, #-24]
70005380:	e51b2010 	ldr	r2, [fp, #-16]
70005384:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* increase message entry */
    mq->entry ++;
70005388:	e51b3018 	ldr	r3, [fp, #-24]
7000538c:	e1d332b0 	ldrh	r3, [r3, #32]
70005390:	e2833001 	add	r3, r3, #1
70005394:	e6ff2073 	uxth	r2, r3
70005398:	e51b3018 	ldr	r3, [fp, #-24]
7000539c:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
700053a0:	e51b3018 	ldr	r3, [fp, #-24]
700053a4:	e2833010 	add	r3, r3, #16
700053a8:	e1a00003 	mov	r0, r3
700053ac:	ebfff0f6 	bl	7000178c <rt_list_isempty>
700053b0:	e1a03000 	mov	r3, r0
700053b4:	e3530000 	cmp	r3, #0
700053b8:	1a000009 	bne	700053e4 <rt_mq_send+0x318>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
700053bc:	e51b3018 	ldr	r3, [fp, #-24]
700053c0:	e2833010 	add	r3, r3, #16
700053c4:	e1a00003 	mov	r0, r3
700053c8:	ebfff14a 	bl	700018f8 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
700053cc:	e1a03004 	mov	r3, r4
700053d0:	e1a00003 	mov	r0, r3
700053d4:	eb00239e 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
700053d8:	eb001201 	bl	70009be4 <rt_schedule>

        return RT_EOK;
700053dc:	e3a03000 	mov	r3, #0
700053e0:	ea000003 	b	700053f4 <rt_mq_send+0x328>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
700053e4:	e1a03004 	mov	r3, r4
700053e8:	e1a00003 	mov	r0, r3
700053ec:	eb002398 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
700053f0:	e3a03000 	mov	r3, #0
}
700053f4:	e1a00003 	mov	r0, r3
700053f8:	e24bd008 	sub	sp, fp, #8
700053fc:	e8bd8810 	pop	{r4, fp, pc}

70005400 <rt_mq_urgent>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
{
70005400:	e92d4810 	push	{r4, fp, lr}
70005404:	e28db008 	add	fp, sp, #8
70005408:	e24dd01c 	sub	sp, sp, #28
7000540c:	e50b0018 	str	r0, [fp, #-24]
70005410:	e50b101c 	str	r1, [fp, #-28]
70005414:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
70005418:	e51b3018 	ldr	r3, [fp, #-24]
7000541c:	e3530000 	cmp	r3, #0
70005420:	1a00001d 	bne	7000549c <rt_mq_urgent+0x9c>
70005424:	e3a03000 	mov	r3, #0
70005428:	e54b3011 	strb	r3, [fp, #-17]
7000542c:	e30a3b74 	movw	r3, #43892	; 0xab74
70005430:	e3473002 	movt	r3, #28674	; 0x7002
70005434:	e5933000 	ldr	r3, [r3]
70005438:	e3530000 	cmp	r3, #0
7000543c:	1a00000d 	bne	70005478 <rt_mq_urgent+0x78>
70005440:	e3060324 	movw	r0, #25380	; 0x6324
70005444:	e3470002 	movt	r0, #28674	; 0x7002
70005448:	e30613ec 	movw	r1, #25580	; 0x63ec
7000544c:	e3471002 	movt	r1, #28674	; 0x7002
70005450:	e30625fc 	movw	r2, #26108	; 0x65fc
70005454:	e3472002 	movt	r2, #28674	; 0x7002
70005458:	e30037e1 	movw	r3, #2017	; 0x7e1
7000545c:	eb0008e4 	bl	700077f4 <rt_kprintf>
70005460:	e1a00000 	nop			; (mov r0, r0)
70005464:	e55b3011 	ldrb	r3, [fp, #-17]
70005468:	e6ef3073 	uxtb	r3, r3
7000546c:	e3530000 	cmp	r3, #0
70005470:	0afffffb 	beq	70005464 <rt_mq_urgent+0x64>
70005474:	ea000008 	b	7000549c <rt_mq_urgent+0x9c>
70005478:	e30a3b74 	movw	r3, #43892	; 0xab74
7000547c:	e3473002 	movt	r3, #28674	; 0x7002
70005480:	e5933000 	ldr	r3, [r3]
70005484:	e30603ec 	movw	r0, #25580	; 0x63ec
70005488:	e3470002 	movt	r0, #28674	; 0x7002
7000548c:	e30615fc 	movw	r1, #26108	; 0x65fc
70005490:	e3471002 	movt	r1, #28674	; 0x7002
70005494:	e30027e1 	movw	r2, #2017	; 0x7e1
70005498:	e12fff33 	blx	r3
    RT_ASSERT(buffer != RT_NULL);
7000549c:	e51b301c 	ldr	r3, [fp, #-28]
700054a0:	e3530000 	cmp	r3, #0
700054a4:	1a00001d 	bne	70005520 <rt_mq_urgent+0x120>
700054a8:	e3a03000 	mov	r3, #0
700054ac:	e54b3012 	strb	r3, [fp, #-18]
700054b0:	e30a3b74 	movw	r3, #43892	; 0xab74
700054b4:	e3473002 	movt	r3, #28674	; 0x7002
700054b8:	e5933000 	ldr	r3, [r3]
700054bc:	e3530000 	cmp	r3, #0
700054c0:	1a00000d 	bne	700054fc <rt_mq_urgent+0xfc>
700054c4:	e3060324 	movw	r0, #25380	; 0x6324
700054c8:	e3470002 	movt	r0, #28674	; 0x7002
700054cc:	e30613fc 	movw	r1, #25596	; 0x63fc
700054d0:	e3471002 	movt	r1, #28674	; 0x7002
700054d4:	e30625fc 	movw	r2, #26108	; 0x65fc
700054d8:	e3472002 	movt	r2, #28674	; 0x7002
700054dc:	e30037e2 	movw	r3, #2018	; 0x7e2
700054e0:	eb0008c3 	bl	700077f4 <rt_kprintf>
700054e4:	e1a00000 	nop			; (mov r0, r0)
700054e8:	e55b3012 	ldrb	r3, [fp, #-18]
700054ec:	e6ef3073 	uxtb	r3, r3
700054f0:	e3530000 	cmp	r3, #0
700054f4:	0afffffb 	beq	700054e8 <rt_mq_urgent+0xe8>
700054f8:	ea000008 	b	70005520 <rt_mq_urgent+0x120>
700054fc:	e30a3b74 	movw	r3, #43892	; 0xab74
70005500:	e3473002 	movt	r3, #28674	; 0x7002
70005504:	e5933000 	ldr	r3, [r3]
70005508:	e30603fc 	movw	r0, #25596	; 0x63fc
7000550c:	e3470002 	movt	r0, #28674	; 0x7002
70005510:	e30615fc 	movw	r1, #26108	; 0x65fc
70005514:	e3471002 	movt	r1, #28674	; 0x7002
70005518:	e30027e2 	movw	r2, #2018	; 0x7e2
7000551c:	e12fff33 	blx	r3
    RT_ASSERT(size != 0);
70005520:	e51b3020 	ldr	r3, [fp, #-32]
70005524:	e3530000 	cmp	r3, #0
70005528:	1a00001d 	bne	700055a4 <rt_mq_urgent+0x1a4>
7000552c:	e3a03000 	mov	r3, #0
70005530:	e54b3013 	strb	r3, [fp, #-19]
70005534:	e30a3b74 	movw	r3, #43892	; 0xab74
70005538:	e3473002 	movt	r3, #28674	; 0x7002
7000553c:	e5933000 	ldr	r3, [r3]
70005540:	e3530000 	cmp	r3, #0
70005544:	1a00000d 	bne	70005580 <rt_mq_urgent+0x180>
70005548:	e3060324 	movw	r0, #25380	; 0x6324
7000554c:	e3470002 	movt	r0, #28674	; 0x7002
70005550:	e3061410 	movw	r1, #25616	; 0x6410
70005554:	e3471002 	movt	r1, #28674	; 0x7002
70005558:	e30625fc 	movw	r2, #26108	; 0x65fc
7000555c:	e3472002 	movt	r2, #28674	; 0x7002
70005560:	e30037e3 	movw	r3, #2019	; 0x7e3
70005564:	eb0008a2 	bl	700077f4 <rt_kprintf>
70005568:	e1a00000 	nop			; (mov r0, r0)
7000556c:	e55b3013 	ldrb	r3, [fp, #-19]
70005570:	e6ef3073 	uxtb	r3, r3
70005574:	e3530000 	cmp	r3, #0
70005578:	0afffffb 	beq	7000556c <rt_mq_urgent+0x16c>
7000557c:	ea000008 	b	700055a4 <rt_mq_urgent+0x1a4>
70005580:	e30a3b74 	movw	r3, #43892	; 0xab74
70005584:	e3473002 	movt	r3, #28674	; 0x7002
70005588:	e5933000 	ldr	r3, [r3]
7000558c:	e3060410 	movw	r0, #25616	; 0x6410
70005590:	e3470002 	movt	r0, #28674	; 0x7002
70005594:	e30615fc 	movw	r1, #26108	; 0x65fc
70005598:	e3471002 	movt	r1, #28674	; 0x7002
7000559c:	e30027e3 	movw	r2, #2019	; 0x7e3
700055a0:	e12fff33 	blx	r3

    /* greater than one message size */
    if (size > mq->msg_size)
700055a4:	e51b3018 	ldr	r3, [fp, #-24]
700055a8:	e1d331bc 	ldrh	r3, [r3, #28]
700055ac:	e1a02003 	mov	r2, r3
700055b0:	e51b3020 	ldr	r3, [fp, #-32]
700055b4:	e1520003 	cmp	r2, r3
700055b8:	2a000001 	bcs	700055c4 <rt_mq_urgent+0x1c4>
        return -RT_ERROR;
700055bc:	e3e03000 	mvn	r3, #0
700055c0:	ea000051 	b	7000570c <rt_mq_urgent+0x30c>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
700055c4:	e30a3b78 	movw	r3, #43896	; 0xab78
700055c8:	e3473002 	movt	r3, #28674	; 0x7002
700055cc:	e5933000 	ldr	r3, [r3]
700055d0:	e3530000 	cmp	r3, #0
700055d4:	0a000005 	beq	700055f0 <rt_mq_urgent+0x1f0>
700055d8:	e30a3b78 	movw	r3, #43896	; 0xab78
700055dc:	e3473002 	movt	r3, #28674	; 0x7002
700055e0:	e5933000 	ldr	r3, [r3]
700055e4:	e51b2018 	ldr	r2, [fp, #-24]
700055e8:	e1a00002 	mov	r0, r2
700055ec:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
700055f0:	eb002314 	bl	7000e248 <rt_hw_interrupt_disable>
700055f4:	e1a03000 	mov	r3, r0
700055f8:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message *)mq->msg_queue_free;
700055fc:	e51b3018 	ldr	r3, [fp, #-24]
70005600:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70005604:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
70005608:	e51b3010 	ldr	r3, [fp, #-16]
7000560c:	e3530000 	cmp	r3, #0
70005610:	1a000004 	bne	70005628 <rt_mq_urgent+0x228>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70005614:	e1a03004 	mov	r3, r4
70005618:	e1a00003 	mov	r0, r3
7000561c:	eb00230c 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_EFULL;
70005620:	e3e03002 	mvn	r3, #2
70005624:	ea000038 	b	7000570c <rt_mq_urgent+0x30c>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
70005628:	e51b3010 	ldr	r3, [fp, #-16]
7000562c:	e5932000 	ldr	r2, [r3]
70005630:	e51b3018 	ldr	r3, [fp, #-24]
70005634:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70005638:	e1a03004 	mov	r3, r4
7000563c:	e1a00003 	mov	r0, r3
70005640:	eb002303 	bl	7000e254 <rt_hw_interrupt_enable>

    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
70005644:	e51b3010 	ldr	r3, [fp, #-16]
70005648:	e2833004 	add	r3, r3, #4
7000564c:	e1a00003 	mov	r0, r3
70005650:	e51b101c 	ldr	r1, [fp, #-28]
70005654:	e51b2020 	ldr	r2, [fp, #-32]
70005658:	eb0002c4 	bl	70006170 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
7000565c:	eb0022f9 	bl	7000e248 <rt_hw_interrupt_disable>
70005660:	e1a03000 	mov	r3, r0
70005664:	e1a04003 	mov	r4, r3

    /* link msg to the beginning of message queue */
    msg->next = mq->msg_queue_head;
70005668:	e51b3018 	ldr	r3, [fp, #-24]
7000566c:	e5932024 	ldr	r2, [r3, #36]	; 0x24
70005670:	e51b3010 	ldr	r3, [fp, #-16]
70005674:	e5832000 	str	r2, [r3]
    mq->msg_queue_head = msg;
70005678:	e51b3018 	ldr	r3, [fp, #-24]
7000567c:	e51b2010 	ldr	r2, [fp, #-16]
70005680:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* if there is no tail */
    if (mq->msg_queue_tail == RT_NULL)
70005684:	e51b3018 	ldr	r3, [fp, #-24]
70005688:	e5933028 	ldr	r3, [r3, #40]	; 0x28
7000568c:	e3530000 	cmp	r3, #0
70005690:	1a000002 	bne	700056a0 <rt_mq_urgent+0x2a0>
        mq->msg_queue_tail = msg;
70005694:	e51b3018 	ldr	r3, [fp, #-24]
70005698:	e51b2010 	ldr	r2, [fp, #-16]
7000569c:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
700056a0:	e51b3018 	ldr	r3, [fp, #-24]
700056a4:	e1d332b0 	ldrh	r3, [r3, #32]
700056a8:	e2833001 	add	r3, r3, #1
700056ac:	e6ff2073 	uxth	r2, r3
700056b0:	e51b3018 	ldr	r3, [fp, #-24]
700056b4:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
700056b8:	e51b3018 	ldr	r3, [fp, #-24]
700056bc:	e2833010 	add	r3, r3, #16
700056c0:	e1a00003 	mov	r0, r3
700056c4:	ebfff030 	bl	7000178c <rt_list_isempty>
700056c8:	e1a03000 	mov	r3, r0
700056cc:	e3530000 	cmp	r3, #0
700056d0:	1a000009 	bne	700056fc <rt_mq_urgent+0x2fc>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
700056d4:	e51b3018 	ldr	r3, [fp, #-24]
700056d8:	e2833010 	add	r3, r3, #16
700056dc:	e1a00003 	mov	r0, r3
700056e0:	ebfff084 	bl	700018f8 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
700056e4:	e1a03004 	mov	r3, r4
700056e8:	e1a00003 	mov	r0, r3
700056ec:	eb0022d8 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
700056f0:	eb00113b 	bl	70009be4 <rt_schedule>

        return RT_EOK;
700056f4:	e3a03000 	mov	r3, #0
700056f8:	ea000003 	b	7000570c <rt_mq_urgent+0x30c>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
700056fc:	e1a03004 	mov	r3, r4
70005700:	e1a00003 	mov	r0, r3
70005704:	eb0022d2 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
70005708:	e3a03000 	mov	r3, #0
}
7000570c:	e1a00003 	mov	r0, r3
70005710:	e24bd008 	sub	sp, fp, #8
70005714:	e8bd8810 	pop	{r4, fp, pc}

70005718 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
70005718:	e92d4810 	push	{r4, fp, lr}
7000571c:	e28db008 	add	fp, sp, #8
70005720:	e24dd034 	sub	sp, sp, #52	; 0x34
70005724:	e50b0030 	str	r0, [fp, #-48]	; 0x30
70005728:	e50b1034 	str	r1, [fp, #-52]	; 0x34
7000572c:	e50b2038 	str	r2, [fp, #-56]	; 0x38
70005730:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
70005734:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005738:	e3530000 	cmp	r3, #0
7000573c:	1a00001d 	bne	700057b8 <rt_mq_recv+0xa0>
70005740:	e3a03000 	mov	r3, #0
70005744:	e54b3021 	strb	r3, [fp, #-33]	; 0x21
70005748:	e30a3b74 	movw	r3, #43892	; 0xab74
7000574c:	e3473002 	movt	r3, #28674	; 0x7002
70005750:	e5933000 	ldr	r3, [r3]
70005754:	e3530000 	cmp	r3, #0
70005758:	1a00000d 	bne	70005794 <rt_mq_recv+0x7c>
7000575c:	e3060324 	movw	r0, #25380	; 0x6324
70005760:	e3470002 	movt	r0, #28674	; 0x7002
70005764:	e30613ec 	movw	r1, #25580	; 0x63ec
70005768:	e3471002 	movt	r1, #28674	; 0x7002
7000576c:	e306260c 	movw	r2, #26124	; 0x660c
70005770:	e3472002 	movt	r2, #28674	; 0x7002
70005774:	e3003839 	movw	r3, #2105	; 0x839
70005778:	eb00081d 	bl	700077f4 <rt_kprintf>
7000577c:	e1a00000 	nop			; (mov r0, r0)
70005780:	e55b3021 	ldrb	r3, [fp, #-33]	; 0x21
70005784:	e6ef3073 	uxtb	r3, r3
70005788:	e3530000 	cmp	r3, #0
7000578c:	0afffffb 	beq	70005780 <rt_mq_recv+0x68>
70005790:	ea000008 	b	700057b8 <rt_mq_recv+0xa0>
70005794:	e30a3b74 	movw	r3, #43892	; 0xab74
70005798:	e3473002 	movt	r3, #28674	; 0x7002
7000579c:	e5933000 	ldr	r3, [r3]
700057a0:	e30603ec 	movw	r0, #25580	; 0x63ec
700057a4:	e3470002 	movt	r0, #28674	; 0x7002
700057a8:	e306160c 	movw	r1, #26124	; 0x660c
700057ac:	e3471002 	movt	r1, #28674	; 0x7002
700057b0:	e3002839 	movw	r2, #2105	; 0x839
700057b4:	e12fff33 	blx	r3
    RT_ASSERT(buffer != RT_NULL);
700057b8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
700057bc:	e3530000 	cmp	r3, #0
700057c0:	1a00001d 	bne	7000583c <rt_mq_recv+0x124>
700057c4:	e3a03000 	mov	r3, #0
700057c8:	e54b3022 	strb	r3, [fp, #-34]	; 0x22
700057cc:	e30a3b74 	movw	r3, #43892	; 0xab74
700057d0:	e3473002 	movt	r3, #28674	; 0x7002
700057d4:	e5933000 	ldr	r3, [r3]
700057d8:	e3530000 	cmp	r3, #0
700057dc:	1a00000d 	bne	70005818 <rt_mq_recv+0x100>
700057e0:	e3060324 	movw	r0, #25380	; 0x6324
700057e4:	e3470002 	movt	r0, #28674	; 0x7002
700057e8:	e30613fc 	movw	r1, #25596	; 0x63fc
700057ec:	e3471002 	movt	r1, #28674	; 0x7002
700057f0:	e306260c 	movw	r2, #26124	; 0x660c
700057f4:	e3472002 	movt	r2, #28674	; 0x7002
700057f8:	e300383a 	movw	r3, #2106	; 0x83a
700057fc:	eb0007fc 	bl	700077f4 <rt_kprintf>
70005800:	e1a00000 	nop			; (mov r0, r0)
70005804:	e55b3022 	ldrb	r3, [fp, #-34]	; 0x22
70005808:	e6ef3073 	uxtb	r3, r3
7000580c:	e3530000 	cmp	r3, #0
70005810:	0afffffb 	beq	70005804 <rt_mq_recv+0xec>
70005814:	ea000008 	b	7000583c <rt_mq_recv+0x124>
70005818:	e30a3b74 	movw	r3, #43892	; 0xab74
7000581c:	e3473002 	movt	r3, #28674	; 0x7002
70005820:	e5933000 	ldr	r3, [r3]
70005824:	e30603fc 	movw	r0, #25596	; 0x63fc
70005828:	e3470002 	movt	r0, #28674	; 0x7002
7000582c:	e306160c 	movw	r1, #26124	; 0x660c
70005830:	e3471002 	movt	r1, #28674	; 0x7002
70005834:	e300283a 	movw	r2, #2106	; 0x83a
70005838:	e12fff33 	blx	r3
    RT_ASSERT(size != 0);
7000583c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70005840:	e3530000 	cmp	r3, #0
70005844:	1a00001d 	bne	700058c0 <rt_mq_recv+0x1a8>
70005848:	e3a03000 	mov	r3, #0
7000584c:	e54b3023 	strb	r3, [fp, #-35]	; 0x23
70005850:	e30a3b74 	movw	r3, #43892	; 0xab74
70005854:	e3473002 	movt	r3, #28674	; 0x7002
70005858:	e5933000 	ldr	r3, [r3]
7000585c:	e3530000 	cmp	r3, #0
70005860:	1a00000d 	bne	7000589c <rt_mq_recv+0x184>
70005864:	e3060324 	movw	r0, #25380	; 0x6324
70005868:	e3470002 	movt	r0, #28674	; 0x7002
7000586c:	e3061410 	movw	r1, #25616	; 0x6410
70005870:	e3471002 	movt	r1, #28674	; 0x7002
70005874:	e306260c 	movw	r2, #26124	; 0x660c
70005878:	e3472002 	movt	r2, #28674	; 0x7002
7000587c:	e300383b 	movw	r3, #2107	; 0x83b
70005880:	eb0007db 	bl	700077f4 <rt_kprintf>
70005884:	e1a00000 	nop			; (mov r0, r0)
70005888:	e55b3023 	ldrb	r3, [fp, #-35]	; 0x23
7000588c:	e6ef3073 	uxtb	r3, r3
70005890:	e3530000 	cmp	r3, #0
70005894:	0afffffb 	beq	70005888 <rt_mq_recv+0x170>
70005898:	ea000008 	b	700058c0 <rt_mq_recv+0x1a8>
7000589c:	e30a3b74 	movw	r3, #43892	; 0xab74
700058a0:	e3473002 	movt	r3, #28674	; 0x7002
700058a4:	e5933000 	ldr	r3, [r3]
700058a8:	e3060410 	movw	r0, #25616	; 0x6410
700058ac:	e3470002 	movt	r0, #28674	; 0x7002
700058b0:	e306160c 	movw	r1, #26124	; 0x660c
700058b4:	e3471002 	movt	r1, #28674	; 0x7002
700058b8:	e300283b 	movw	r2, #2107	; 0x83b
700058bc:	e12fff33 	blx	r3

    /* initialize delta tick */
    tick_delta = 0;
700058c0:	e3a03000 	mov	r3, #0
700058c4:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
700058c8:	eb001328 	bl	7000a570 <rt_thread_self>
700058cc:	e50b0014 	str	r0, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
700058d0:	e30a3b80 	movw	r3, #43904	; 0xab80
700058d4:	e3473002 	movt	r3, #28674	; 0x7002
700058d8:	e5933000 	ldr	r3, [r3]
700058dc:	e3530000 	cmp	r3, #0
700058e0:	0a000005 	beq	700058fc <rt_mq_recv+0x1e4>
700058e4:	e30a3b80 	movw	r3, #43904	; 0xab80
700058e8:	e3473002 	movt	r3, #28674	; 0x7002
700058ec:	e5933000 	ldr	r3, [r3]
700058f0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
700058f4:	e1a00002 	mov	r0, r2
700058f8:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
700058fc:	eb002251 	bl	7000e248 <rt_hw_interrupt_disable>
70005900:	e1a03000 	mov	r3, r0
70005904:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
70005908:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000590c:	e1d332b0 	ldrh	r3, [r3, #32]
70005910:	e3530000 	cmp	r3, #0
70005914:	1a000007 	bne	70005938 <rt_mq_recv+0x220>
70005918:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
7000591c:	e3530000 	cmp	r3, #0
70005920:	1a000004 	bne	70005938 <rt_mq_recv+0x220>
    {
        rt_hw_interrupt_enable(temp);
70005924:	e1a03004 	mov	r3, r4
70005928:	e1a00003 	mov	r0, r3
7000592c:	eb002248 	bl	7000e254 <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
70005930:	e3e03001 	mvn	r3, #1
70005934:	ea0000dd 	b	70005cb0 <rt_mq_recv+0x598>
    }

    /* message queue is empty */
    while (mq->entry == 0)
70005938:	ea00009b 	b	70005bac <rt_mq_recv+0x494>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
7000593c:	eb002241 	bl	7000e248 <rt_hw_interrupt_disable>
70005940:	e50b0018 	str	r0, [fp, #-24]
70005944:	eb001309 	bl	7000a570 <rt_thread_self>
70005948:	e1a03000 	mov	r3, r0
7000594c:	e3530000 	cmp	r3, #0
70005950:	1a000022 	bne	700059e0 <rt_mq_recv+0x2c8>
70005954:	e306037c 	movw	r0, #25468	; 0x637c
70005958:	e3470002 	movt	r0, #28674	; 0x7002
7000595c:	e306160c 	movw	r1, #26124	; 0x660c
70005960:	e3471002 	movt	r1, #28674	; 0x7002
70005964:	eb0007a2 	bl	700077f4 <rt_kprintf>
70005968:	e3a03000 	mov	r3, #0
7000596c:	e54b3024 	strb	r3, [fp, #-36]	; 0x24
70005970:	e30a3b74 	movw	r3, #43892	; 0xab74
70005974:	e3473002 	movt	r3, #28674	; 0x7002
70005978:	e5933000 	ldr	r3, [r3]
7000597c:	e3530000 	cmp	r3, #0
70005980:	1a00000d 	bne	700059bc <rt_mq_recv+0x2a4>
70005984:	e3060324 	movw	r0, #25380	; 0x6324
70005988:	e3470002 	movt	r0, #28674	; 0x7002
7000598c:	e3061378 	movw	r1, #25464	; 0x6378
70005990:	e3471002 	movt	r1, #28674	; 0x7002
70005994:	e306260c 	movw	r2, #26124	; 0x660c
70005998:	e3472002 	movt	r2, #28674	; 0x7002
7000599c:	e3003851 	movw	r3, #2129	; 0x851
700059a0:	eb000793 	bl	700077f4 <rt_kprintf>
700059a4:	e1a00000 	nop			; (mov r0, r0)
700059a8:	e55b3024 	ldrb	r3, [fp, #-36]	; 0x24
700059ac:	e6ef3073 	uxtb	r3, r3
700059b0:	e3530000 	cmp	r3, #0
700059b4:	0afffffb 	beq	700059a8 <rt_mq_recv+0x290>
700059b8:	ea000008 	b	700059e0 <rt_mq_recv+0x2c8>
700059bc:	e30a3b74 	movw	r3, #43892	; 0xab74
700059c0:	e3473002 	movt	r3, #28674	; 0x7002
700059c4:	e5933000 	ldr	r3, [r3]
700059c8:	e3060378 	movw	r0, #25464	; 0x6378
700059cc:	e3470002 	movt	r0, #28674	; 0x7002
700059d0:	e306160c 	movw	r1, #26124	; 0x660c
700059d4:	e3471002 	movt	r1, #28674	; 0x7002
700059d8:	e3002851 	movw	r2, #2129	; 0x851
700059dc:	e12fff33 	blx	r3
700059e0:	eb002218 	bl	7000e248 <rt_hw_interrupt_disable>
700059e4:	e50b001c 	str	r0, [fp, #-28]
700059e8:	eb000131 	bl	70005eb4 <rt_interrupt_get_nest>
700059ec:	e1a03000 	mov	r3, r0
700059f0:	e3530000 	cmp	r3, #0
700059f4:	0a000022 	beq	70005a84 <rt_mq_recv+0x36c>
700059f8:	e3060354 	movw	r0, #25428	; 0x6354
700059fc:	e3470002 	movt	r0, #28674	; 0x7002
70005a00:	e306160c 	movw	r1, #26124	; 0x660c
70005a04:	e3471002 	movt	r1, #28674	; 0x7002
70005a08:	eb000779 	bl	700077f4 <rt_kprintf>
70005a0c:	e3a03000 	mov	r3, #0
70005a10:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
70005a14:	e30a3b74 	movw	r3, #43892	; 0xab74
70005a18:	e3473002 	movt	r3, #28674	; 0x7002
70005a1c:	e5933000 	ldr	r3, [r3]
70005a20:	e3530000 	cmp	r3, #0
70005a24:	1a00000d 	bne	70005a60 <rt_mq_recv+0x348>
70005a28:	e3060324 	movw	r0, #25380	; 0x6324
70005a2c:	e3470002 	movt	r0, #28674	; 0x7002
70005a30:	e3061378 	movw	r1, #25464	; 0x6378
70005a34:	e3471002 	movt	r1, #28674	; 0x7002
70005a38:	e306260c 	movw	r2, #26124	; 0x660c
70005a3c:	e3472002 	movt	r2, #28674	; 0x7002
70005a40:	e3003851 	movw	r3, #2129	; 0x851
70005a44:	eb00076a 	bl	700077f4 <rt_kprintf>
70005a48:	e1a00000 	nop			; (mov r0, r0)
70005a4c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
70005a50:	e6ef3073 	uxtb	r3, r3
70005a54:	e3530000 	cmp	r3, #0
70005a58:	0afffffb 	beq	70005a4c <rt_mq_recv+0x334>
70005a5c:	ea000008 	b	70005a84 <rt_mq_recv+0x36c>
70005a60:	e30a3b74 	movw	r3, #43892	; 0xab74
70005a64:	e3473002 	movt	r3, #28674	; 0x7002
70005a68:	e5933000 	ldr	r3, [r3]
70005a6c:	e3060378 	movw	r0, #25464	; 0x6378
70005a70:	e3470002 	movt	r0, #28674	; 0x7002
70005a74:	e306160c 	movw	r1, #26124	; 0x660c
70005a78:	e3471002 	movt	r1, #28674	; 0x7002
70005a7c:	e3002851 	movw	r2, #2129	; 0x851
70005a80:	e12fff33 	blx	r3
70005a84:	e51b001c 	ldr	r0, [fp, #-28]
70005a88:	eb0021f1 	bl	7000e254 <rt_hw_interrupt_enable>
70005a8c:	e51b0018 	ldr	r0, [fp, #-24]
70005a90:	eb0021ef 	bl	7000e254 <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
70005a94:	e51b3014 	ldr	r3, [fp, #-20]
70005a98:	e3a02000 	mov	r2, #0
70005a9c:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
70005aa0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70005aa4:	e3530000 	cmp	r3, #0
70005aa8:	1a000007 	bne	70005acc <rt_mq_recv+0x3b4>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
70005aac:	e1a03004 	mov	r3, r4
70005ab0:	e1a00003 	mov	r0, r3
70005ab4:	eb0021e6 	bl	7000e254 <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
70005ab8:	e51b3014 	ldr	r3, [fp, #-20]
70005abc:	e3e02001 	mvn	r2, #1
70005ac0:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
70005ac4:	e3e03001 	mvn	r3, #1
70005ac8:	ea000078 	b	70005cb0 <rt_mq_recv+0x598>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
70005acc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005ad0:	e2832010 	add	r2, r3, #16
70005ad4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005ad8:	e5d33007 	ldrb	r3, [r3, #7]
70005adc:	e1a00002 	mov	r0, r2
70005ae0:	e51b1014 	ldr	r1, [fp, #-20]
70005ae4:	e1a02003 	mov	r2, r3
70005ae8:	ebffef42 	bl	700017f8 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
70005aec:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70005af0:	e3530000 	cmp	r3, #0
70005af4:	da00000c 	ble	70005b2c <rt_mq_recv+0x414>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
70005af8:	ebffeaf3 	bl	700006cc <rt_tick_get>
70005afc:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
70005b00:	e51b3014 	ldr	r3, [fp, #-20]
70005b04:	e2832048 	add	r2, r3, #72	; 0x48
70005b08:	e24b303c 	sub	r3, fp, #60	; 0x3c
70005b0c:	e1a00002 	mov	r0, r2
70005b10:	e3a01000 	mov	r1, #0
70005b14:	e1a02003 	mov	r2, r3
70005b18:	eb001832 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
70005b1c:	e51b3014 	ldr	r3, [fp, #-20]
70005b20:	e2833048 	add	r3, r3, #72	; 0x48
70005b24:	e1a00003 	mov	r0, r3
70005b28:	eb0016e2 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70005b2c:	e1a03004 	mov	r3, r4
70005b30:	e1a00003 	mov	r0, r3
70005b34:	eb0021c6 	bl	7000e254 <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
70005b38:	eb001029 	bl	70009be4 <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
70005b3c:	e51b3014 	ldr	r3, [fp, #-20]
70005b40:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70005b44:	e3530000 	cmp	r3, #0
70005b48:	0a000002 	beq	70005b58 <rt_mq_recv+0x440>
        {
            /* return error */
            return thread->error;
70005b4c:	e51b3014 	ldr	r3, [fp, #-20]
70005b50:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70005b54:	ea000055 	b	70005cb0 <rt_mq_recv+0x598>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70005b58:	eb0021ba 	bl	7000e248 <rt_hw_interrupt_disable>
70005b5c:	e1a03000 	mov	r3, r0
70005b60:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
70005b64:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70005b68:	e3530000 	cmp	r3, #0
70005b6c:	da00000e 	ble	70005bac <rt_mq_recv+0x494>
        {
            tick_delta = rt_tick_get() - tick_delta;
70005b70:	ebffead5 	bl	700006cc <rt_tick_get>
70005b74:	e1a02000 	mov	r2, r0
70005b78:	e51b3010 	ldr	r3, [fp, #-16]
70005b7c:	e0633002 	rsb	r3, r3, r2
70005b80:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
70005b84:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70005b88:	e1a02003 	mov	r2, r3
70005b8c:	e51b3010 	ldr	r3, [fp, #-16]
70005b90:	e0633002 	rsb	r3, r3, r2
70005b94:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
            if (timeout < 0)
70005b98:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70005b9c:	e3530000 	cmp	r3, #0
70005ba0:	aa000001 	bge	70005bac <rt_mq_recv+0x494>
                timeout = 0;
70005ba4:	e3a03000 	mov	r3, #0
70005ba8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
70005bac:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bb0:	e1d332b0 	ldrh	r3, [r3, #32]
70005bb4:	e3530000 	cmp	r3, #0
70005bb8:	0affff5f 	beq	7000593c <rt_mq_recv+0x224>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
70005bbc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bc0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70005bc4:	e50b3020 	str	r3, [fp, #-32]

    /* move message queue head */
    mq->msg_queue_head = msg->next;
70005bc8:	e51b3020 	ldr	r3, [fp, #-32]
70005bcc:	e5932000 	ldr	r2, [r3]
70005bd0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bd4:	e5832024 	str	r2, [r3, #36]	; 0x24
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
70005bd8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bdc:	e5932028 	ldr	r2, [r3, #40]	; 0x28
70005be0:	e51b3020 	ldr	r3, [fp, #-32]
70005be4:	e1520003 	cmp	r2, r3
70005be8:	1a000002 	bne	70005bf8 <rt_mq_recv+0x4e0>
        mq->msg_queue_tail = RT_NULL;
70005bec:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bf0:	e3a02000 	mov	r2, #0
70005bf4:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* decrease message entry */
    mq->entry --;
70005bf8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005bfc:	e1d332b0 	ldrh	r3, [r3, #32]
70005c00:	e2433001 	sub	r3, r3, #1
70005c04:	e6ff2073 	uxth	r2, r3
70005c08:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005c0c:	e1c322b0 	strh	r2, [r3, #32]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70005c10:	e1a03004 	mov	r3, r4
70005c14:	e1a00003 	mov	r0, r3
70005c18:	eb00218d 	bl	7000e254 <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
70005c1c:	e51b3020 	ldr	r3, [fp, #-32]
70005c20:	e2832004 	add	r2, r3, #4
70005c24:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005c28:	e1d331bc 	ldrh	r3, [r3, #28]
70005c2c:	e1a01003 	mov	r1, r3
70005c30:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70005c34:	e1510003 	cmp	r1, r3
70005c38:	31a03001 	movcc	r3, r1
70005c3c:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
70005c40:	e1a01002 	mov	r1, r2
70005c44:	e1a02003 	mov	r2, r3
70005c48:	eb000148 	bl	70006170 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70005c4c:	eb00217d 	bl	7000e248 <rt_hw_interrupt_disable>
70005c50:	e1a03000 	mov	r3, r0
70005c54:	e1a04003 	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
70005c58:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005c5c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
70005c60:	e51b3020 	ldr	r3, [fp, #-32]
70005c64:	e5832000 	str	r2, [r3]
    mq->msg_queue_free = msg;
70005c68:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70005c6c:	e51b2020 	ldr	r2, [fp, #-32]
70005c70:	e583202c 	str	r2, [r3, #44]	; 0x2c
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70005c74:	e1a03004 	mov	r3, r4
70005c78:	e1a00003 	mov	r0, r3
70005c7c:	eb002174 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
70005c80:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70005c84:	e3473002 	movt	r3, #28674	; 0x7002
70005c88:	e5933000 	ldr	r3, [r3]
70005c8c:	e3530000 	cmp	r3, #0
70005c90:	0a000005 	beq	70005cac <rt_mq_recv+0x594>
70005c94:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70005c98:	e3473002 	movt	r3, #28674	; 0x7002
70005c9c:	e5933000 	ldr	r3, [r3]
70005ca0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
70005ca4:	e1a00002 	mov	r0, r2
70005ca8:	e12fff33 	blx	r3

    return RT_EOK;
70005cac:	e3a03000 	mov	r3, #0
}
70005cb0:	e1a00003 	mov	r0, r3
70005cb4:	e24bd008 	sub	sp, fp, #8
70005cb8:	e8bd8810 	pop	{r4, fp, pc}

70005cbc <rt_mq_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
{
70005cbc:	e92d4800 	push	{fp, lr}
70005cc0:	e28db004 	add	fp, sp, #4
70005cc4:	e24dd020 	sub	sp, sp, #32
70005cc8:	e50b0018 	str	r0, [fp, #-24]
70005ccc:	e1a03001 	mov	r3, r1
70005cd0:	e50b2020 	str	r2, [fp, #-32]
70005cd4:	e54b3019 	strb	r3, [fp, #-25]
    rt_ubase_t level;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
70005cd8:	e51b3018 	ldr	r3, [fp, #-24]
70005cdc:	e3530000 	cmp	r3, #0
70005ce0:	1a00001d 	bne	70005d5c <rt_mq_control+0xa0>
70005ce4:	e3a03000 	mov	r3, #0
70005ce8:	e54b300d 	strb	r3, [fp, #-13]
70005cec:	e30a3b74 	movw	r3, #43892	; 0xab74
70005cf0:	e3473002 	movt	r3, #28674	; 0x7002
70005cf4:	e5933000 	ldr	r3, [r3]
70005cf8:	e3530000 	cmp	r3, #0
70005cfc:	1a00000d 	bne	70005d38 <rt_mq_control+0x7c>
70005d00:	e3060324 	movw	r0, #25380	; 0x6324
70005d04:	e3470002 	movt	r0, #28674	; 0x7002
70005d08:	e30613ec 	movw	r1, #25580	; 0x63ec
70005d0c:	e3471002 	movt	r1, #28674	; 0x7002
70005d10:	e3062618 	movw	r2, #26136	; 0x6618
70005d14:	e3472002 	movt	r2, #28674	; 0x7002
70005d18:	e30038bf 	movw	r3, #2239	; 0x8bf
70005d1c:	eb0006b4 	bl	700077f4 <rt_kprintf>
70005d20:	e1a00000 	nop			; (mov r0, r0)
70005d24:	e55b300d 	ldrb	r3, [fp, #-13]
70005d28:	e6ef3073 	uxtb	r3, r3
70005d2c:	e3530000 	cmp	r3, #0
70005d30:	0afffffb 	beq	70005d24 <rt_mq_control+0x68>
70005d34:	ea000008 	b	70005d5c <rt_mq_control+0xa0>
70005d38:	e30a3b74 	movw	r3, #43892	; 0xab74
70005d3c:	e3473002 	movt	r3, #28674	; 0x7002
70005d40:	e5933000 	ldr	r3, [r3]
70005d44:	e30603ec 	movw	r0, #25580	; 0x63ec
70005d48:	e3470002 	movt	r0, #28674	; 0x7002
70005d4c:	e3061618 	movw	r1, #26136	; 0x6618
70005d50:	e3471002 	movt	r1, #28674	; 0x7002
70005d54:	e30028bf 	movw	r2, #2239	; 0x8bf
70005d58:	e12fff33 	blx	r3

    if (cmd == RT_IPC_CMD_RESET)
70005d5c:	e55b3019 	ldrb	r3, [fp, #-25]
70005d60:	e3530001 	cmp	r3, #1
70005d64:	1a00002a 	bne	70005e14 <rt_mq_control+0x158>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
70005d68:	eb002136 	bl	7000e248 <rt_hw_interrupt_disable>
70005d6c:	e1a03000 	mov	r3, r0
70005d70:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);
70005d74:	e51b3018 	ldr	r3, [fp, #-24]
70005d78:	e2833010 	add	r3, r3, #16
70005d7c:	e1a00003 	mov	r0, r3
70005d80:	ebffeeea 	bl	70001930 <rt_ipc_list_resume_all>

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
70005d84:	ea000015 	b	70005de0 <rt_mq_control+0x124>
        {
            /* get message from queue */
            msg = (struct rt_mq_message *)mq->msg_queue_head;
70005d88:	e51b3018 	ldr	r3, [fp, #-24]
70005d8c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70005d90:	e50b300c 	str	r3, [fp, #-12]

            /* move message queue head */
            mq->msg_queue_head = msg->next;
70005d94:	e51b300c 	ldr	r3, [fp, #-12]
70005d98:	e5932000 	ldr	r2, [r3]
70005d9c:	e51b3018 	ldr	r3, [fp, #-24]
70005da0:	e5832024 	str	r2, [r3, #36]	; 0x24
            /* reach queue tail, set to NULL */
            if (mq->msg_queue_tail == msg)
70005da4:	e51b3018 	ldr	r3, [fp, #-24]
70005da8:	e5932028 	ldr	r2, [r3, #40]	; 0x28
70005dac:	e51b300c 	ldr	r3, [fp, #-12]
70005db0:	e1520003 	cmp	r2, r3
70005db4:	1a000002 	bne	70005dc4 <rt_mq_control+0x108>
                mq->msg_queue_tail = RT_NULL;
70005db8:	e51b3018 	ldr	r3, [fp, #-24]
70005dbc:	e3a02000 	mov	r2, #0
70005dc0:	e5832028 	str	r2, [r3, #40]	; 0x28

            /* put message to free list */
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
70005dc4:	e51b3018 	ldr	r3, [fp, #-24]
70005dc8:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
70005dcc:	e51b300c 	ldr	r3, [fp, #-12]
70005dd0:	e5832000 	str	r2, [r3]
            mq->msg_queue_free = msg;
70005dd4:	e51b3018 	ldr	r3, [fp, #-24]
70005dd8:	e51b200c 	ldr	r2, [fp, #-12]
70005ddc:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
70005de0:	e51b3018 	ldr	r3, [fp, #-24]
70005de4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
70005de8:	e3530000 	cmp	r3, #0
70005dec:	1affffe5 	bne	70005d88 <rt_mq_control+0xcc>
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
            mq->msg_queue_free = msg;
        }

        /* clean entry */
        mq->entry = 0;
70005df0:	e51b3018 	ldr	r3, [fp, #-24]
70005df4:	e3a02000 	mov	r2, #0
70005df8:	e1c322b0 	strh	r2, [r3, #32]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70005dfc:	e51b3008 	ldr	r3, [fp, #-8]
70005e00:	e1a00003 	mov	r0, r3
70005e04:	eb002112 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
70005e08:	eb000f75 	bl	70009be4 <rt_schedule>

        return RT_EOK;
70005e0c:	e3a03000 	mov	r3, #0
70005e10:	ea000000 	b	70005e18 <rt_mq_control+0x15c>
    }

    return -RT_ERROR;
70005e14:	e3e03000 	mvn	r3, #0
}
70005e18:	e1a00003 	mov	r0, r3
70005e1c:	e24bd004 	sub	sp, fp, #4
70005e20:	e8bd8800 	pop	{fp, pc}

70005e24 <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
70005e24:	e92d4800 	push	{fp, lr}
70005e28:	e28db004 	add	fp, sp, #4
70005e2c:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
70005e30:	eb002104 	bl	7000e248 <rt_hw_interrupt_disable>
70005e34:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest ++;
70005e38:	e30a3b70 	movw	r3, #43888	; 0xab70
70005e3c:	e3473002 	movt	r3, #28674	; 0x7002
70005e40:	e5d33000 	ldrb	r3, [r3]
70005e44:	e6ef3073 	uxtb	r3, r3
70005e48:	e2833001 	add	r3, r3, #1
70005e4c:	e6ef2073 	uxtb	r2, r3
70005e50:	e30a3b70 	movw	r3, #43888	; 0xab70
70005e54:	e3473002 	movt	r3, #28674	; 0x7002
70005e58:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
70005e5c:	e51b0008 	ldr	r0, [fp, #-8]
70005e60:	eb0020fb 	bl	7000e254 <rt_hw_interrupt_enable>
}
70005e64:	e24bd004 	sub	sp, fp, #4
70005e68:	e8bd8800 	pop	{fp, pc}

70005e6c <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
70005e6c:	e92d4800 	push	{fp, lr}
70005e70:	e28db004 	add	fp, sp, #4
70005e74:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
70005e78:	eb0020f2 	bl	7000e248 <rt_hw_interrupt_disable>
70005e7c:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest --;
70005e80:	e30a3b70 	movw	r3, #43888	; 0xab70
70005e84:	e3473002 	movt	r3, #28674	; 0x7002
70005e88:	e5d33000 	ldrb	r3, [r3]
70005e8c:	e6ef3073 	uxtb	r3, r3
70005e90:	e2433001 	sub	r3, r3, #1
70005e94:	e6ef2073 	uxtb	r2, r3
70005e98:	e30a3b70 	movw	r3, #43888	; 0xab70
70005e9c:	e3473002 	movt	r3, #28674	; 0x7002
70005ea0:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
70005ea4:	e51b0008 	ldr	r0, [fp, #-8]
70005ea8:	eb0020e9 	bl	7000e254 <rt_hw_interrupt_enable>
}
70005eac:	e24bd004 	sub	sp, fp, #4
70005eb0:	e8bd8800 	pop	{fp, pc}

70005eb4 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
70005eb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70005eb8:	e28db000 	add	fp, sp, #0
    return rt_interrupt_nest;
70005ebc:	e30a3b70 	movw	r3, #43888	; 0xab70
70005ec0:	e3473002 	movt	r3, #28674	; 0x7002
70005ec4:	e5d33000 	ldrb	r3, [r3]
70005ec8:	e6ef3073 	uxtb	r3, r3
}
70005ecc:	e1a00003 	mov	r0, r3
70005ed0:	e24bd000 	sub	sp, fp, #0
70005ed4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70005ed8:	e12fff1e 	bx	lr

70005edc <rt_get_errno>:
 * This function will get errno
 *
 * @return errno
 */
rt_err_t rt_get_errno(void)
{
70005edc:	e92d4800 	push	{fp, lr}
70005ee0:	e28db004 	add	fp, sp, #4
70005ee4:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
70005ee8:	ebfffff1 	bl	70005eb4 <rt_interrupt_get_nest>
70005eec:	e1a03000 	mov	r3, r0
70005ef0:	e3530000 	cmp	r3, #0
70005ef4:	0a000003 	beq	70005f08 <rt_get_errno+0x2c>
    {
        /* it's in interrupt context */
        return _errno;
70005ef8:	e309381c 	movw	r3, #38940	; 0x981c
70005efc:	e3473002 	movt	r3, #28674	; 0x7002
70005f00:	e5933000 	ldr	r3, [r3]
70005f04:	ea00000a 	b	70005f34 <rt_get_errno+0x58>
    }

    tid = rt_thread_self();
70005f08:	eb001198 	bl	7000a570 <rt_thread_self>
70005f0c:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
70005f10:	e51b3008 	ldr	r3, [fp, #-8]
70005f14:	e3530000 	cmp	r3, #0
70005f18:	1a000003 	bne	70005f2c <rt_get_errno+0x50>
        return _errno;
70005f1c:	e309381c 	movw	r3, #38940	; 0x981c
70005f20:	e3473002 	movt	r3, #28674	; 0x7002
70005f24:	e5933000 	ldr	r3, [r3]
70005f28:	ea000001 	b	70005f34 <rt_get_errno+0x58>

    return tid->error;
70005f2c:	e51b3008 	ldr	r3, [fp, #-8]
70005f30:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
70005f34:	e1a00003 	mov	r0, r3
70005f38:	e24bd004 	sub	sp, fp, #4
70005f3c:	e8bd8800 	pop	{fp, pc}

70005f40 <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
70005f40:	e92d4800 	push	{fp, lr}
70005f44:	e28db004 	add	fp, sp, #4
70005f48:	e24dd010 	sub	sp, sp, #16
70005f4c:	e50b0010 	str	r0, [fp, #-16]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
70005f50:	ebffffd7 	bl	70005eb4 <rt_interrupt_get_nest>
70005f54:	e1a03000 	mov	r3, r0
70005f58:	e3530000 	cmp	r3, #0
70005f5c:	0a000004 	beq	70005f74 <rt_set_errno+0x34>
    {
        /* it's in interrupt context */
        _errno = error;
70005f60:	e309381c 	movw	r3, #38940	; 0x981c
70005f64:	e3473002 	movt	r3, #28674	; 0x7002
70005f68:	e51b2010 	ldr	r2, [fp, #-16]
70005f6c:	e5832000 	str	r2, [r3]

        return;
70005f70:	ea00000c 	b	70005fa8 <rt_set_errno+0x68>
    }

    tid = rt_thread_self();
70005f74:	eb00117d 	bl	7000a570 <rt_thread_self>
70005f78:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
70005f7c:	e51b3008 	ldr	r3, [fp, #-8]
70005f80:	e3530000 	cmp	r3, #0
70005f84:	1a000004 	bne	70005f9c <rt_set_errno+0x5c>
    {
        _errno = error;
70005f88:	e309381c 	movw	r3, #38940	; 0x981c
70005f8c:	e3473002 	movt	r3, #28674	; 0x7002
70005f90:	e51b2010 	ldr	r2, [fp, #-16]
70005f94:	e5832000 	str	r2, [r3]

        return;
70005f98:	ea000002 	b	70005fa8 <rt_set_errno+0x68>
    }

    tid->error = error;
70005f9c:	e51b3008 	ldr	r3, [fp, #-8]
70005fa0:	e51b2010 	ldr	r2, [fp, #-16]
70005fa4:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
70005fa8:	e24bd004 	sub	sp, fp, #4
70005fac:	e8bd8800 	pop	{fp, pc}

70005fb0 <_rt_errno>:
 * This function returns errno.
 *
 * @return the errno in the system
 */
int *_rt_errno(void)
{
70005fb0:	e92d4800 	push	{fp, lr}
70005fb4:	e28db004 	add	fp, sp, #4
70005fb8:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
70005fbc:	ebffffbc 	bl	70005eb4 <rt_interrupt_get_nest>
70005fc0:	e1a03000 	mov	r3, r0
70005fc4:	e3530000 	cmp	r3, #0
70005fc8:	0a000002 	beq	70005fd8 <_rt_errno+0x28>
        return (int *)&_errno;
70005fcc:	e309381c 	movw	r3, #38940	; 0x981c
70005fd0:	e3473002 	movt	r3, #28674	; 0x7002
70005fd4:	ea000009 	b	70006000 <_rt_errno+0x50>

    tid = rt_thread_self();
70005fd8:	eb001164 	bl	7000a570 <rt_thread_self>
70005fdc:	e50b0008 	str	r0, [fp, #-8]
    if (tid != RT_NULL)
70005fe0:	e51b3008 	ldr	r3, [fp, #-8]
70005fe4:	e3530000 	cmp	r3, #0
70005fe8:	0a000002 	beq	70005ff8 <_rt_errno+0x48>
        return (int *)&(tid->error);
70005fec:	e51b3008 	ldr	r3, [fp, #-8]
70005ff0:	e283302c 	add	r3, r3, #44	; 0x2c
70005ff4:	ea000001 	b	70006000 <_rt_errno+0x50>

    return (int *)&_errno;
70005ff8:	e309381c 	movw	r3, #38940	; 0x981c
70005ffc:	e3473002 	movt	r3, #28674	; 0x7002
}
70006000:	e1a00003 	mov	r0, r3
70006004:	e24bd004 	sub	sp, fp, #4
70006008:	e8bd8800 	pop	{fp, pc}

7000600c <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
7000600c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006010:	e28db000 	add	fp, sp, #0
70006014:	e24dd024 	sub	sp, sp, #36	; 0x24
70006018:	e50b0018 	str	r0, [fp, #-24]
7000601c:	e50b101c 	str	r1, [fp, #-28]
70006020:	e50b2020 	str	r2, [fp, #-32]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
70006024:	e51b3018 	ldr	r3, [fp, #-24]
70006028:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
7000602c:	e51b301c 	ldr	r3, [fp, #-28]
70006030:	e6ef3073 	uxtb	r3, r3
70006034:	e50b3010 	str	r3, [fp, #-16]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
70006038:	e51b3020 	ldr	r3, [fp, #-32]
7000603c:	e3530003 	cmp	r3, #3
70006040:	9a000039 	bls	7000612c <rt_memset+0x120>
70006044:	e51b3018 	ldr	r3, [fp, #-24]
70006048:	e2033003 	and	r3, r3, #3
7000604c:	e3530000 	cmp	r3, #0
70006050:	1a000035 	bne	7000612c <rt_memset+0x120>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
70006054:	e51b3018 	ldr	r3, [fp, #-24]
70006058:	e50b300c 	str	r3, [fp, #-12]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
7000605c:	e51b3010 	ldr	r3, [fp, #-16]
70006060:	e1a02403 	lsl	r2, r3, #8
70006064:	e51b3010 	ldr	r3, [fp, #-16]
70006068:	e1823003 	orr	r3, r2, r3
7000606c:	e50b3014 	str	r3, [fp, #-20]
            buffer |= (buffer << 16);
70006070:	e51b3014 	ldr	r3, [fp, #-20]
70006074:	e1a03803 	lsl	r3, r3, #16
70006078:	e51b2014 	ldr	r2, [fp, #-20]
7000607c:	e1823003 	orr	r3, r2, r3
70006080:	e50b3014 	str	r3, [fp, #-20]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
70006084:	ea000016 	b	700060e4 <rt_memset+0xd8>
        {
            *aligned_addr++ = buffer;
70006088:	e51b300c 	ldr	r3, [fp, #-12]
7000608c:	e2832004 	add	r2, r3, #4
70006090:	e50b200c 	str	r2, [fp, #-12]
70006094:	e51b2014 	ldr	r2, [fp, #-20]
70006098:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
7000609c:	e51b300c 	ldr	r3, [fp, #-12]
700060a0:	e2832004 	add	r2, r3, #4
700060a4:	e50b200c 	str	r2, [fp, #-12]
700060a8:	e51b2014 	ldr	r2, [fp, #-20]
700060ac:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
700060b0:	e51b300c 	ldr	r3, [fp, #-12]
700060b4:	e2832004 	add	r2, r3, #4
700060b8:	e50b200c 	str	r2, [fp, #-12]
700060bc:	e51b2014 	ldr	r2, [fp, #-20]
700060c0:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
700060c4:	e51b300c 	ldr	r3, [fp, #-12]
700060c8:	e2832004 	add	r2, r3, #4
700060cc:	e50b200c 	str	r2, [fp, #-12]
700060d0:	e51b2014 	ldr	r2, [fp, #-20]
700060d4:	e5832000 	str	r2, [r3]
            count -= 4 * LBLOCKSIZE;
700060d8:	e51b3020 	ldr	r3, [fp, #-32]
700060dc:	e2433010 	sub	r3, r3, #16
700060e0:	e50b3020 	str	r3, [fp, #-32]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
700060e4:	e51b3020 	ldr	r3, [fp, #-32]
700060e8:	e353000f 	cmp	r3, #15
700060ec:	8affffe5 	bhi	70006088 <rt_memset+0x7c>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
700060f0:	ea000007 	b	70006114 <rt_memset+0x108>
        {
            *aligned_addr++ = buffer;
700060f4:	e51b300c 	ldr	r3, [fp, #-12]
700060f8:	e2832004 	add	r2, r3, #4
700060fc:	e50b200c 	str	r2, [fp, #-12]
70006100:	e51b2014 	ldr	r2, [fp, #-20]
70006104:	e5832000 	str	r2, [r3]
            count -= LBLOCKSIZE;
70006108:	e51b3020 	ldr	r3, [fp, #-32]
7000610c:	e2433004 	sub	r3, r3, #4
70006110:	e50b3020 	str	r3, [fp, #-32]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
70006114:	e51b3020 	ldr	r3, [fp, #-32]
70006118:	e3530003 	cmp	r3, #3
7000611c:	8afffff4 	bhi	700060f4 <rt_memset+0xe8>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
70006120:	e51b300c 	ldr	r3, [fp, #-12]
70006124:	e50b3008 	str	r3, [fp, #-8]
    }

    while (count--)
70006128:	ea000006 	b	70006148 <rt_memset+0x13c>
7000612c:	ea000005 	b	70006148 <rt_memset+0x13c>
    {
        *m++ = (char)d;
70006130:	e51b3008 	ldr	r3, [fp, #-8]
70006134:	e2832001 	add	r2, r3, #1
70006138:	e50b2008 	str	r2, [fp, #-8]
7000613c:	e51b2010 	ldr	r2, [fp, #-16]
70006140:	e6ef2072 	uxtb	r2, r2
70006144:	e5c32000 	strb	r2, [r3]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
70006148:	e51b3020 	ldr	r3, [fp, #-32]
7000614c:	e2432001 	sub	r2, r3, #1
70006150:	e50b2020 	str	r2, [fp, #-32]
70006154:	e3530000 	cmp	r3, #0
70006158:	1afffff4 	bne	70006130 <rt_memset+0x124>
    {
        *m++ = (char)d;
    }

    return s;
7000615c:	e51b3018 	ldr	r3, [fp, #-24]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
70006160:	e1a00003 	mov	r0, r3
70006164:	e24bd000 	sub	sp, fp, #0
70006168:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000616c:	e12fff1e 	bx	lr

70006170 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
70006170:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006174:	e28db000 	add	fp, sp, #0
70006178:	e24dd02c 	sub	sp, sp, #44	; 0x2c
7000617c:	e50b0020 	str	r0, [fp, #-32]
70006180:	e50b1024 	str	r1, [fp, #-36]	; 0x24
70006184:	e50b2028 	str	r2, [fp, #-40]	; 0x28
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
70006188:	e51b3020 	ldr	r3, [fp, #-32]
7000618c:	e50b3008 	str	r3, [fp, #-8]
    char *src_ptr = (char *)src;
70006190:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70006194:	e50b300c 	str	r3, [fp, #-12]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
70006198:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000619c:	e50b3018 	str	r3, [fp, #-24]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
700061a0:	e51b3018 	ldr	r3, [fp, #-24]
700061a4:	e353000f 	cmp	r3, #15
700061a8:	9a000044 	bls	700062c0 <rt_memcpy+0x150>
700061ac:	e51b200c 	ldr	r2, [fp, #-12]
700061b0:	e51b3008 	ldr	r3, [fp, #-8]
700061b4:	e1823003 	orr	r3, r2, r3
700061b8:	e2033003 	and	r3, r3, #3
700061bc:	e3530000 	cmp	r3, #0
700061c0:	1a00003e 	bne	700062c0 <rt_memcpy+0x150>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
700061c4:	e51b3008 	ldr	r3, [fp, #-8]
700061c8:	e50b3010 	str	r3, [fp, #-16]
        aligned_src = (rt_int32_t *)src_ptr;
700061cc:	e51b300c 	ldr	r3, [fp, #-12]
700061d0:	e50b3014 	str	r3, [fp, #-20]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
700061d4:	ea000022 	b	70006264 <rt_memcpy+0xf4>
        {
            *aligned_dst++ = *aligned_src++;
700061d8:	e51b3010 	ldr	r3, [fp, #-16]
700061dc:	e2832004 	add	r2, r3, #4
700061e0:	e50b2010 	str	r2, [fp, #-16]
700061e4:	e51b2014 	ldr	r2, [fp, #-20]
700061e8:	e2821004 	add	r1, r2, #4
700061ec:	e50b1014 	str	r1, [fp, #-20]
700061f0:	e5922000 	ldr	r2, [r2]
700061f4:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
700061f8:	e51b3010 	ldr	r3, [fp, #-16]
700061fc:	e2832004 	add	r2, r3, #4
70006200:	e50b2010 	str	r2, [fp, #-16]
70006204:	e51b2014 	ldr	r2, [fp, #-20]
70006208:	e2821004 	add	r1, r2, #4
7000620c:	e50b1014 	str	r1, [fp, #-20]
70006210:	e5922000 	ldr	r2, [r2]
70006214:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
70006218:	e51b3010 	ldr	r3, [fp, #-16]
7000621c:	e2832004 	add	r2, r3, #4
70006220:	e50b2010 	str	r2, [fp, #-16]
70006224:	e51b2014 	ldr	r2, [fp, #-20]
70006228:	e2821004 	add	r1, r2, #4
7000622c:	e50b1014 	str	r1, [fp, #-20]
70006230:	e5922000 	ldr	r2, [r2]
70006234:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
70006238:	e51b3010 	ldr	r3, [fp, #-16]
7000623c:	e2832004 	add	r2, r3, #4
70006240:	e50b2010 	str	r2, [fp, #-16]
70006244:	e51b2014 	ldr	r2, [fp, #-20]
70006248:	e2821004 	add	r1, r2, #4
7000624c:	e50b1014 	str	r1, [fp, #-20]
70006250:	e5922000 	ldr	r2, [r2]
70006254:	e5832000 	str	r2, [r3]
            len -= BIGBLOCKSIZE;
70006258:	e51b3018 	ldr	r3, [fp, #-24]
7000625c:	e2433010 	sub	r3, r3, #16
70006260:	e50b3018 	str	r3, [fp, #-24]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
70006264:	e51b3018 	ldr	r3, [fp, #-24]
70006268:	e353000f 	cmp	r3, #15
7000626c:	8affffd9 	bhi	700061d8 <rt_memcpy+0x68>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
70006270:	ea00000a 	b	700062a0 <rt_memcpy+0x130>
        {
            *aligned_dst++ = *aligned_src++;
70006274:	e51b3010 	ldr	r3, [fp, #-16]
70006278:	e2832004 	add	r2, r3, #4
7000627c:	e50b2010 	str	r2, [fp, #-16]
70006280:	e51b2014 	ldr	r2, [fp, #-20]
70006284:	e2821004 	add	r1, r2, #4
70006288:	e50b1014 	str	r1, [fp, #-20]
7000628c:	e5922000 	ldr	r2, [r2]
70006290:	e5832000 	str	r2, [r3]
            len -= LITTLEBLOCKSIZE;
70006294:	e51b3018 	ldr	r3, [fp, #-24]
70006298:	e2433004 	sub	r3, r3, #4
7000629c:	e50b3018 	str	r3, [fp, #-24]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
700062a0:	e51b3018 	ldr	r3, [fp, #-24]
700062a4:	e3530003 	cmp	r3, #3
700062a8:	8afffff1 	bhi	70006274 <rt_memcpy+0x104>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
700062ac:	e51b3010 	ldr	r3, [fp, #-16]
700062b0:	e50b3008 	str	r3, [fp, #-8]
        src_ptr = (char *)aligned_src;
700062b4:	e51b3014 	ldr	r3, [fp, #-20]
700062b8:	e50b300c 	str	r3, [fp, #-12]
    }

    while (len--)
700062bc:	ea000008 	b	700062e4 <rt_memcpy+0x174>
700062c0:	ea000007 	b	700062e4 <rt_memcpy+0x174>
        *dst_ptr++ = *src_ptr++;
700062c4:	e51b3008 	ldr	r3, [fp, #-8]
700062c8:	e2832001 	add	r2, r3, #1
700062cc:	e50b2008 	str	r2, [fp, #-8]
700062d0:	e51b200c 	ldr	r2, [fp, #-12]
700062d4:	e2821001 	add	r1, r2, #1
700062d8:	e50b100c 	str	r1, [fp, #-12]
700062dc:	e5d22000 	ldrb	r2, [r2]
700062e0:	e5c32000 	strb	r2, [r3]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
700062e4:	e51b3018 	ldr	r3, [fp, #-24]
700062e8:	e2432001 	sub	r2, r3, #1
700062ec:	e50b2018 	str	r2, [fp, #-24]
700062f0:	e3530000 	cmp	r3, #0
700062f4:	1afffff2 	bne	700062c4 <rt_memcpy+0x154>
        *dst_ptr++ = *src_ptr++;

    return dst;
700062f8:	e51b3020 	ldr	r3, [fp, #-32]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
700062fc:	e1a00003 	mov	r0, r3
70006300:	e24bd000 	sub	sp, fp, #0
70006304:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70006308:	e12fff1e 	bx	lr

7000630c <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
7000630c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006310:	e28db000 	add	fp, sp, #0
70006314:	e24dd01c 	sub	sp, sp, #28
70006318:	e50b0010 	str	r0, [fp, #-16]
7000631c:	e50b1014 	str	r1, [fp, #-20]
70006320:	e50b2018 	str	r2, [fp, #-24]
    char *tmp = (char *)dest, *s = (char *)src;
70006324:	e51b3010 	ldr	r3, [fp, #-16]
70006328:	e50b3008 	str	r3, [fp, #-8]
7000632c:	e51b3014 	ldr	r3, [fp, #-20]
70006330:	e50b300c 	str	r3, [fp, #-12]

    if (s < tmp && tmp < s + n)
70006334:	e51b200c 	ldr	r2, [fp, #-12]
70006338:	e51b3008 	ldr	r3, [fp, #-8]
7000633c:	e1520003 	cmp	r2, r3
70006340:	2a00001e 	bcs	700063c0 <rt_memmove+0xb4>
70006344:	e51b200c 	ldr	r2, [fp, #-12]
70006348:	e51b3018 	ldr	r3, [fp, #-24]
7000634c:	e0822003 	add	r2, r2, r3
70006350:	e51b3008 	ldr	r3, [fp, #-8]
70006354:	e1520003 	cmp	r2, r3
70006358:	9a000018 	bls	700063c0 <rt_memmove+0xb4>
    {
        tmp += n;
7000635c:	e51b2008 	ldr	r2, [fp, #-8]
70006360:	e51b3018 	ldr	r3, [fp, #-24]
70006364:	e0823003 	add	r3, r2, r3
70006368:	e50b3008 	str	r3, [fp, #-8]
        s += n;
7000636c:	e51b200c 	ldr	r2, [fp, #-12]
70006370:	e51b3018 	ldr	r3, [fp, #-24]
70006374:	e0823003 	add	r3, r2, r3
70006378:	e50b300c 	str	r3, [fp, #-12]

        while (n--)
7000637c:	ea000009 	b	700063a8 <rt_memmove+0x9c>
            *(--tmp) = *(--s);
70006380:	e51b3008 	ldr	r3, [fp, #-8]
70006384:	e2433001 	sub	r3, r3, #1
70006388:	e50b3008 	str	r3, [fp, #-8]
7000638c:	e51b300c 	ldr	r3, [fp, #-12]
70006390:	e2433001 	sub	r3, r3, #1
70006394:	e50b300c 	str	r3, [fp, #-12]
70006398:	e51b300c 	ldr	r3, [fp, #-12]
7000639c:	e5d32000 	ldrb	r2, [r3]
700063a0:	e51b3008 	ldr	r3, [fp, #-8]
700063a4:	e5c32000 	strb	r2, [r3]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
700063a8:	e51b3018 	ldr	r3, [fp, #-24]
700063ac:	e2432001 	sub	r2, r3, #1
700063b0:	e50b2018 	str	r2, [fp, #-24]
700063b4:	e3530000 	cmp	r3, #0
700063b8:	1afffff0 	bne	70006380 <rt_memmove+0x74>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
700063bc:	ea00000d 	b	700063f8 <rt_memmove+0xec>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
700063c0:	ea000007 	b	700063e4 <rt_memmove+0xd8>
            *tmp++ = *s++;
700063c4:	e51b3008 	ldr	r3, [fp, #-8]
700063c8:	e2832001 	add	r2, r3, #1
700063cc:	e50b2008 	str	r2, [fp, #-8]
700063d0:	e51b200c 	ldr	r2, [fp, #-12]
700063d4:	e2821001 	add	r1, r2, #1
700063d8:	e50b100c 	str	r1, [fp, #-12]
700063dc:	e5d22000 	ldrb	r2, [r2]
700063e0:	e5c32000 	strb	r2, [r3]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
700063e4:	e51b3018 	ldr	r3, [fp, #-24]
700063e8:	e2432001 	sub	r2, r3, #1
700063ec:	e50b2018 	str	r2, [fp, #-24]
700063f0:	e3530000 	cmp	r3, #0
700063f4:	1afffff2 	bne	700063c4 <rt_memmove+0xb8>
            *tmp++ = *s++;
    }

    return dest;
700063f8:	e51b3010 	ldr	r3, [fp, #-16]
}
700063fc:	e1a00003 	mov	r0, r3
70006400:	e24bd000 	sub	sp, fp, #0
70006404:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70006408:	e12fff1e 	bx	lr

7000640c <rt_memcmp>:
 * @param count the size of the area
 *
 * @return the result
 */
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
7000640c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006410:	e28db000 	add	fp, sp, #0
70006414:	e24dd024 	sub	sp, sp, #36	; 0x24
70006418:	e50b0018 	str	r0, [fp, #-24]
7000641c:	e50b101c 	str	r1, [fp, #-28]
70006420:	e50b2020 	str	r2, [fp, #-32]
    const unsigned char *su1, *su2;
    int res = 0;
70006424:	e3a03000 	mov	r3, #0
70006428:	e50b3010 	str	r3, [fp, #-16]

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
7000642c:	e51b3018 	ldr	r3, [fp, #-24]
70006430:	e50b3008 	str	r3, [fp, #-8]
70006434:	e51b301c 	ldr	r3, [fp, #-28]
70006438:	e50b300c 	str	r3, [fp, #-12]
7000643c:	ea000013 	b	70006490 <rt_memcmp+0x84>
        if ((res = *su1 - *su2) != 0)
70006440:	e51b3008 	ldr	r3, [fp, #-8]
70006444:	e5d33000 	ldrb	r3, [r3]
70006448:	e1a02003 	mov	r2, r3
7000644c:	e51b300c 	ldr	r3, [fp, #-12]
70006450:	e5d33000 	ldrb	r3, [r3]
70006454:	e0633002 	rsb	r3, r3, r2
70006458:	e50b3010 	str	r3, [fp, #-16]
7000645c:	e51b3010 	ldr	r3, [fp, #-16]
70006460:	e3530000 	cmp	r3, #0
70006464:	0a000000 	beq	7000646c <rt_memcmp+0x60>
            break;
70006468:	ea00000b 	b	7000649c <rt_memcmp+0x90>
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
    const unsigned char *su1, *su2;
    int res = 0;

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
7000646c:	e51b3008 	ldr	r3, [fp, #-8]
70006470:	e2833001 	add	r3, r3, #1
70006474:	e50b3008 	str	r3, [fp, #-8]
70006478:	e51b300c 	ldr	r3, [fp, #-12]
7000647c:	e2833001 	add	r3, r3, #1
70006480:	e50b300c 	str	r3, [fp, #-12]
70006484:	e51b3020 	ldr	r3, [fp, #-32]
70006488:	e2433001 	sub	r3, r3, #1
7000648c:	e50b3020 	str	r3, [fp, #-32]
70006490:	e51b3020 	ldr	r3, [fp, #-32]
70006494:	e3530000 	cmp	r3, #0
70006498:	1affffe8 	bne	70006440 <rt_memcmp+0x34>
        if ((res = *su1 - *su2) != 0)
            break;

    return res;
7000649c:	e51b3010 	ldr	r3, [fp, #-16]
}
700064a0:	e1a00003 	mov	r0, r3
700064a4:	e24bd000 	sub	sp, fp, #0
700064a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700064ac:	e12fff1e 	bx	lr

700064b0 <rt_strstr>:
 * @param s2 the find string
 *
 * @return the first occurrence of a s2 in s1, or RT_NULL if no found.
 */
char *rt_strstr(const char *s1, const char *s2)
{
700064b0:	e92d4800 	push	{fp, lr}
700064b4:	e28db004 	add	fp, sp, #4
700064b8:	e24dd010 	sub	sp, sp, #16
700064bc:	e50b0010 	str	r0, [fp, #-16]
700064c0:	e50b1014 	str	r1, [fp, #-20]
    int l1, l2;

    l2 = rt_strlen(s2);
700064c4:	e51b0014 	ldr	r0, [fp, #-20]
700064c8:	eb0000c6 	bl	700067e8 <rt_strlen>
700064cc:	e1a03000 	mov	r3, r0
700064d0:	e50b300c 	str	r3, [fp, #-12]
    if (!l2)
700064d4:	e51b300c 	ldr	r3, [fp, #-12]
700064d8:	e3530000 	cmp	r3, #0
700064dc:	1a000001 	bne	700064e8 <rt_strstr+0x38>
        return (char *)s1;
700064e0:	e51b3010 	ldr	r3, [fp, #-16]
700064e4:	ea000019 	b	70006550 <rt_strstr+0xa0>
    l1 = rt_strlen(s1);
700064e8:	e51b0010 	ldr	r0, [fp, #-16]
700064ec:	eb0000bd 	bl	700067e8 <rt_strlen>
700064f0:	e1a03000 	mov	r3, r0
700064f4:	e50b3008 	str	r3, [fp, #-8]
    while (l1 >= l2)
700064f8:	ea00000f 	b	7000653c <rt_strstr+0x8c>
    {
        l1 --;
700064fc:	e51b3008 	ldr	r3, [fp, #-8]
70006500:	e2433001 	sub	r3, r3, #1
70006504:	e50b3008 	str	r3, [fp, #-8]
        if (!rt_memcmp(s1, s2, l2))
70006508:	e51b300c 	ldr	r3, [fp, #-12]
7000650c:	e51b0010 	ldr	r0, [fp, #-16]
70006510:	e51b1014 	ldr	r1, [fp, #-20]
70006514:	e1a02003 	mov	r2, r3
70006518:	ebffffbb 	bl	7000640c <rt_memcmp>
7000651c:	e1a03000 	mov	r3, r0
70006520:	e3530000 	cmp	r3, #0
70006524:	1a000001 	bne	70006530 <rt_strstr+0x80>
            return (char *)s1;
70006528:	e51b3010 	ldr	r3, [fp, #-16]
7000652c:	ea000007 	b	70006550 <rt_strstr+0xa0>
        s1 ++;
70006530:	e51b3010 	ldr	r3, [fp, #-16]
70006534:	e2833001 	add	r3, r3, #1
70006538:	e50b3010 	str	r3, [fp, #-16]

    l2 = rt_strlen(s2);
    if (!l2)
        return (char *)s1;
    l1 = rt_strlen(s1);
    while (l1 >= l2)
7000653c:	e51b2008 	ldr	r2, [fp, #-8]
70006540:	e51b300c 	ldr	r3, [fp, #-12]
70006544:	e1520003 	cmp	r2, r3
70006548:	aaffffeb 	bge	700064fc <rt_strstr+0x4c>
        if (!rt_memcmp(s1, s2, l2))
            return (char *)s1;
        s1 ++;
    }

    return RT_NULL;
7000654c:	e3a03000 	mov	r3, #0
}
70006550:	e1a00003 	mov	r0, r3
70006554:	e24bd004 	sub	sp, fp, #4
70006558:	e8bd8800 	pop	{fp, pc}

7000655c <rt_strcasecmp>:
 * @param b the string to be compared
 *
 * @return the result
 */
rt_uint32_t rt_strcasecmp(const char *a, const char *b)
{
7000655c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006560:	e28db000 	add	fp, sp, #0
70006564:	e24dd014 	sub	sp, sp, #20
70006568:	e50b0010 	str	r0, [fp, #-16]
7000656c:	e50b1014 	str	r1, [fp, #-20]
    int ca, cb;

    do
    {
        ca = *a++ & 0xff;
70006570:	e51b3010 	ldr	r3, [fp, #-16]
70006574:	e2832001 	add	r2, r3, #1
70006578:	e50b2010 	str	r2, [fp, #-16]
7000657c:	e5d33000 	ldrb	r3, [r3]
70006580:	e50b3008 	str	r3, [fp, #-8]
        cb = *b++ & 0xff;
70006584:	e51b3014 	ldr	r3, [fp, #-20]
70006588:	e2832001 	add	r2, r3, #1
7000658c:	e50b2014 	str	r2, [fp, #-20]
70006590:	e5d33000 	ldrb	r3, [r3]
70006594:	e50b300c 	str	r3, [fp, #-12]
        if (ca >= 'A' && ca <= 'Z')
70006598:	e51b3008 	ldr	r3, [fp, #-8]
7000659c:	e3530040 	cmp	r3, #64	; 0x40
700065a0:	da000005 	ble	700065bc <rt_strcasecmp+0x60>
700065a4:	e51b3008 	ldr	r3, [fp, #-8]
700065a8:	e353005a 	cmp	r3, #90	; 0x5a
700065ac:	ca000002 	bgt	700065bc <rt_strcasecmp+0x60>
            ca += 'a' - 'A';
700065b0:	e51b3008 	ldr	r3, [fp, #-8]
700065b4:	e2833020 	add	r3, r3, #32
700065b8:	e50b3008 	str	r3, [fp, #-8]
        if (cb >= 'A' && cb <= 'Z')
700065bc:	e51b300c 	ldr	r3, [fp, #-12]
700065c0:	e3530040 	cmp	r3, #64	; 0x40
700065c4:	da000005 	ble	700065e0 <rt_strcasecmp+0x84>
700065c8:	e51b300c 	ldr	r3, [fp, #-12]
700065cc:	e353005a 	cmp	r3, #90	; 0x5a
700065d0:	ca000002 	bgt	700065e0 <rt_strcasecmp+0x84>
            cb += 'a' - 'A';
700065d4:	e51b300c 	ldr	r3, [fp, #-12]
700065d8:	e2833020 	add	r3, r3, #32
700065dc:	e50b300c 	str	r3, [fp, #-12]
    }
    while (ca == cb && ca != '\0');
700065e0:	e51b2008 	ldr	r2, [fp, #-8]
700065e4:	e51b300c 	ldr	r3, [fp, #-12]
700065e8:	e1520003 	cmp	r2, r3
700065ec:	1a000002 	bne	700065fc <rt_strcasecmp+0xa0>
700065f0:	e51b3008 	ldr	r3, [fp, #-8]
700065f4:	e3530000 	cmp	r3, #0
700065f8:	1affffdc 	bne	70006570 <rt_strcasecmp+0x14>

    return ca - cb;
700065fc:	e51b2008 	ldr	r2, [fp, #-8]
70006600:	e51b300c 	ldr	r3, [fp, #-12]
70006604:	e0633002 	rsb	r3, r3, r2
}
70006608:	e1a00003 	mov	r0, r3
7000660c:	e24bd000 	sub	sp, fp, #0
70006610:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70006614:	e12fff1e 	bx	lr

70006618 <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
70006618:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000661c:	e28db000 	add	fp, sp, #0
70006620:	e24dd01c 	sub	sp, sp, #28
70006624:	e50b0010 	str	r0, [fp, #-16]
70006628:	e50b1014 	str	r1, [fp, #-20]
7000662c:	e50b2018 	str	r2, [fp, #-24]
    if (n != 0)
70006630:	e51b3018 	ldr	r3, [fp, #-24]
70006634:	e3530000 	cmp	r3, #0
70006638:	0a000021 	beq	700066c4 <rt_strncpy+0xac>
    {
        char *d = dst;
7000663c:	e51b3010 	ldr	r3, [fp, #-16]
70006640:	e50b3008 	str	r3, [fp, #-8]
        const char *s = src;
70006644:	e51b3014 	ldr	r3, [fp, #-20]
70006648:	e50b300c 	str	r3, [fp, #-12]

        do
        {
            if ((*d++ = *s++) == 0)
7000664c:	e51b3008 	ldr	r3, [fp, #-8]
70006650:	e2832001 	add	r2, r3, #1
70006654:	e50b2008 	str	r2, [fp, #-8]
70006658:	e51b200c 	ldr	r2, [fp, #-12]
7000665c:	e2821001 	add	r1, r2, #1
70006660:	e50b100c 	str	r1, [fp, #-12]
70006664:	e5d22000 	ldrb	r2, [r2]
70006668:	e5c32000 	strb	r2, [r3]
7000666c:	e5d33000 	ldrb	r3, [r3]
70006670:	e3530000 	cmp	r3, #0
70006674:	1a00000c 	bne	700066ac <rt_strncpy+0x94>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
70006678:	ea000004 	b	70006690 <rt_strncpy+0x78>
                    *d++ = 0;
7000667c:	e51b3008 	ldr	r3, [fp, #-8]
70006680:	e2832001 	add	r2, r3, #1
70006684:	e50b2008 	str	r2, [fp, #-8]
70006688:	e3a02000 	mov	r2, #0
7000668c:	e5c32000 	strb	r2, [r3]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
70006690:	e51b3018 	ldr	r3, [fp, #-24]
70006694:	e2433001 	sub	r3, r3, #1
70006698:	e50b3018 	str	r3, [fp, #-24]
7000669c:	e51b3018 	ldr	r3, [fp, #-24]
700066a0:	e3530000 	cmp	r3, #0
700066a4:	1afffff4 	bne	7000667c <rt_strncpy+0x64>
                    *d++ = 0;
                break;
700066a8:	ea000005 	b	700066c4 <rt_strncpy+0xac>
            }
        } while (--n != 0);
700066ac:	e51b3018 	ldr	r3, [fp, #-24]
700066b0:	e2433001 	sub	r3, r3, #1
700066b4:	e50b3018 	str	r3, [fp, #-24]
700066b8:	e51b3018 	ldr	r3, [fp, #-24]
700066bc:	e3530000 	cmp	r3, #0
700066c0:	1affffe1 	bne	7000664c <rt_strncpy+0x34>
    }

    return (dst);
700066c4:	e51b3010 	ldr	r3, [fp, #-16]
}
700066c8:	e1a00003 	mov	r0, r3
700066cc:	e24bd000 	sub	sp, fp, #0
700066d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700066d4:	e12fff1e 	bx	lr

700066d8 <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
700066d8:	e92d0810 	push	{r4, fp}
700066dc:	e28db004 	add	fp, sp, #4
700066e0:	e24dd010 	sub	sp, sp, #16
700066e4:	e50b0008 	str	r0, [fp, #-8]
700066e8:	e50b100c 	str	r1, [fp, #-12]
700066ec:	e50b2010 	str	r2, [fp, #-16]
    register signed char __res = 0;
700066f0:	e3a04000 	mov	r4, #0

    while (count)
700066f4:	ea000013 	b	70006748 <rt_strncmp+0x70>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
700066f8:	e51b3008 	ldr	r3, [fp, #-8]
700066fc:	e5d32000 	ldrb	r2, [r3]
70006700:	e51b300c 	ldr	r3, [fp, #-12]
70006704:	e2831001 	add	r1, r3, #1
70006708:	e50b100c 	str	r1, [fp, #-12]
7000670c:	e5d33000 	ldrb	r3, [r3]
70006710:	e0633002 	rsb	r3, r3, r2
70006714:	e6ef3073 	uxtb	r3, r3
70006718:	e6ef4073 	uxtb	r4, r3
7000671c:	e3540000 	cmp	r4, #0
70006720:	1a00000b 	bne	70006754 <rt_strncmp+0x7c>
70006724:	e51b3008 	ldr	r3, [fp, #-8]
70006728:	e2832001 	add	r2, r3, #1
7000672c:	e50b2008 	str	r2, [fp, #-8]
70006730:	e5d33000 	ldrb	r3, [r3]
70006734:	e3530000 	cmp	r3, #0
70006738:	0a000005 	beq	70006754 <rt_strncmp+0x7c>
            break;
        count --;
7000673c:	e51b3010 	ldr	r3, [fp, #-16]
70006740:	e2433001 	sub	r3, r3, #1
70006744:	e50b3010 	str	r3, [fp, #-16]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
70006748:	e51b3010 	ldr	r3, [fp, #-16]
7000674c:	e3530000 	cmp	r3, #0
70006750:	1affffe8 	bne	700066f8 <rt_strncmp+0x20>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
70006754:	e6af3074 	sxtb	r3, r4
}
70006758:	e1a00003 	mov	r0, r3
7000675c:	e24bd004 	sub	sp, fp, #4
70006760:	e8bd0810 	pop	{r4, fp}
70006764:	e12fff1e 	bx	lr

70006768 <rt_strcmp>:
 * @param ct the string to be compared
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
70006768:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000676c:	e28db000 	add	fp, sp, #0
70006770:	e24dd00c 	sub	sp, sp, #12
70006774:	e50b0008 	str	r0, [fp, #-8]
70006778:	e50b100c 	str	r1, [fp, #-12]
    while (*cs && *cs == *ct)
7000677c:	ea000005 	b	70006798 <rt_strcmp+0x30>
        cs++, ct++;
70006780:	e51b3008 	ldr	r3, [fp, #-8]
70006784:	e2833001 	add	r3, r3, #1
70006788:	e50b3008 	str	r3, [fp, #-8]
7000678c:	e51b300c 	ldr	r3, [fp, #-12]
70006790:	e2833001 	add	r3, r3, #1
70006794:	e50b300c 	str	r3, [fp, #-12]
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
    while (*cs && *cs == *ct)
70006798:	e51b3008 	ldr	r3, [fp, #-8]
7000679c:	e5d33000 	ldrb	r3, [r3]
700067a0:	e3530000 	cmp	r3, #0
700067a4:	0a000005 	beq	700067c0 <rt_strcmp+0x58>
700067a8:	e51b3008 	ldr	r3, [fp, #-8]
700067ac:	e5d32000 	ldrb	r2, [r3]
700067b0:	e51b300c 	ldr	r3, [fp, #-12]
700067b4:	e5d33000 	ldrb	r3, [r3]
700067b8:	e1520003 	cmp	r2, r3
700067bc:	0affffef 	beq	70006780 <rt_strcmp+0x18>
        cs++, ct++;

    return (*cs - *ct);
700067c0:	e51b3008 	ldr	r3, [fp, #-8]
700067c4:	e5d33000 	ldrb	r3, [r3]
700067c8:	e1a02003 	mov	r2, r3
700067cc:	e51b300c 	ldr	r3, [fp, #-12]
700067d0:	e5d33000 	ldrb	r3, [r3]
700067d4:	e0633002 	rsb	r3, r3, r2
}
700067d8:	e1a00003 	mov	r0, r3
700067dc:	e24bd000 	sub	sp, fp, #0
700067e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700067e4:	e12fff1e 	bx	lr

700067e8 <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
700067e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700067ec:	e28db000 	add	fp, sp, #0
700067f0:	e24dd014 	sub	sp, sp, #20
700067f4:	e50b0010 	str	r0, [fp, #-16]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
700067f8:	e51b3010 	ldr	r3, [fp, #-16]
700067fc:	e50b3008 	str	r3, [fp, #-8]
70006800:	ea000002 	b	70006810 <rt_strlen+0x28>
70006804:	e51b3008 	ldr	r3, [fp, #-8]
70006808:	e2833001 	add	r3, r3, #1
7000680c:	e50b3008 	str	r3, [fp, #-8]
70006810:	e51b3008 	ldr	r3, [fp, #-8]
70006814:	e5d33000 	ldrb	r3, [r3]
70006818:	e3530000 	cmp	r3, #0
7000681c:	1afffff8 	bne	70006804 <rt_strlen+0x1c>
        ;

    return sc - s;
70006820:	e51b2008 	ldr	r2, [fp, #-8]
70006824:	e51b3010 	ldr	r3, [fp, #-16]
70006828:	e0633002 	rsb	r3, r3, r2
}
7000682c:	e1a00003 	mov	r0, r3
70006830:	e24bd000 	sub	sp, fp, #0
70006834:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70006838:	e12fff1e 	bx	lr

7000683c <rt_strdup>:
 * @param s the string to be duplicated
 *
 * @return the duplicated string pointer
 */
char *rt_strdup(const char *s)
{
7000683c:	e92d4800 	push	{fp, lr}
70006840:	e28db004 	add	fp, sp, #4
70006844:	e24dd010 	sub	sp, sp, #16
70006848:	e50b0010 	str	r0, [fp, #-16]
    rt_size_t len = rt_strlen(s) + 1;
7000684c:	e51b0010 	ldr	r0, [fp, #-16]
70006850:	ebffffe4 	bl	700067e8 <rt_strlen>
70006854:	e1a03000 	mov	r3, r0
70006858:	e2833001 	add	r3, r3, #1
7000685c:	e50b3008 	str	r3, [fp, #-8]
    char *tmp = (char *)rt_malloc(len);
70006860:	e51b0008 	ldr	r0, [fp, #-8]
70006864:	eb000614 	bl	700080bc <rt_malloc>
70006868:	e50b000c 	str	r0, [fp, #-12]

    if (!tmp)
7000686c:	e51b300c 	ldr	r3, [fp, #-12]
70006870:	e3530000 	cmp	r3, #0
70006874:	1a000001 	bne	70006880 <rt_strdup+0x44>
        return RT_NULL;
70006878:	e3a03000 	mov	r3, #0
7000687c:	ea000004 	b	70006894 <rt_strdup+0x58>

    rt_memcpy(tmp, s, len);
70006880:	e51b000c 	ldr	r0, [fp, #-12]
70006884:	e51b1010 	ldr	r1, [fp, #-16]
70006888:	e51b2008 	ldr	r2, [fp, #-8]
7000688c:	ebfffe37 	bl	70006170 <rt_memcpy>

    return tmp;
70006890:	e51b300c 	ldr	r3, [fp, #-12]
}
70006894:	e1a00003 	mov	r0, r3
70006898:	e24bd004 	sub	sp, fp, #4
7000689c:	e8bd8800 	pop	{fp, pc}

700068a0 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
700068a0:	e92d4800 	push	{fp, lr}
700068a4:	e28db004 	add	fp, sp, #4
700068a8:	e24dd008 	sub	sp, sp, #8
    rt_kprintf("\n \\ | /\n");
700068ac:	e3060628 	movw	r0, #26152	; 0x6628
700068b0:	e3470002 	movt	r0, #28674	; 0x7002
700068b4:	eb0003ce 	bl	700077f4 <rt_kprintf>
    rt_kprintf("- RT -     Thread Operating System\n");
700068b8:	e3060634 	movw	r0, #26164	; 0x6634
700068bc:	e3470002 	movt	r0, #28674	; 0x7002
700068c0:	eb0003cb 	bl	700077f4 <rt_kprintf>
    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
700068c4:	e3063678 	movw	r3, #26232	; 0x6678
700068c8:	e3473002 	movt	r3, #28674	; 0x7002
700068cc:	e58d3000 	str	r3, [sp]
700068d0:	e3060658 	movw	r0, #26200	; 0x6658
700068d4:	e3470002 	movt	r0, #28674	; 0x7002
700068d8:	e3a01002 	mov	r1, #2
700068dc:	e3a02001 	mov	r2, #1
700068e0:	e3a03000 	mov	r3, #0
700068e4:	eb0003c2 	bl	700077f4 <rt_kprintf>
               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
700068e8:	e3060684 	movw	r0, #26244	; 0x6684
700068ec:	e3470002 	movt	r0, #28674	; 0x7002
700068f0:	eb0003bf 	bl	700077f4 <rt_kprintf>
}
700068f4:	e24bd004 	sub	sp, fp, #4
700068f8:	e8bd8800 	pop	{fp, pc}

700068fc <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
700068fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70006900:	e28db000 	add	fp, sp, #0
70006904:	e24dd014 	sub	sp, sp, #20
70006908:	e50b0010 	str	r0, [fp, #-16]
7000690c:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
70006910:	e51b3014 	ldr	r3, [fp, #-20]
70006914:	e353000a 	cmp	r3, #10
70006918:	1a000017 	bne	7000697c <divide+0x80>
    {
        res = ((rt_uint32_t)*n) % 10U;
7000691c:	e51b3010 	ldr	r3, [fp, #-16]
70006920:	e5933000 	ldr	r3, [r3]
70006924:	e1a01003 	mov	r1, r3
70006928:	e30c3ccd 	movw	r3, #52429	; 0xcccd
7000692c:	e34c3ccc 	movt	r3, #52428	; 0xcccc
70006930:	e0832193 	umull	r2, r3, r3, r1
70006934:	e1a021a3 	lsr	r2, r3, #3
70006938:	e1a03002 	mov	r3, r2
7000693c:	e1a03103 	lsl	r3, r3, #2
70006940:	e0833002 	add	r3, r3, r2
70006944:	e1a03083 	lsl	r3, r3, #1
70006948:	e0632001 	rsb	r2, r3, r1
7000694c:	e50b2008 	str	r2, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 10U;
70006950:	e51b3010 	ldr	r3, [fp, #-16]
70006954:	e5933000 	ldr	r3, [r3]
70006958:	e1a02003 	mov	r2, r3
7000695c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
70006960:	e34c3ccc 	movt	r3, #52428	; 0xcccc
70006964:	e0831293 	umull	r1, r3, r3, r2
70006968:	e1a031a3 	lsr	r3, r3, #3
7000696c:	e1a02003 	mov	r2, r3
70006970:	e51b3010 	ldr	r3, [fp, #-16]
70006974:	e5832000 	str	r2, [r3]
70006978:	ea000009 	b	700069a4 <divide+0xa8>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
7000697c:	e51b3010 	ldr	r3, [fp, #-16]
70006980:	e5933000 	ldr	r3, [r3]
70006984:	e203300f 	and	r3, r3, #15
70006988:	e50b3008 	str	r3, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 16U;
7000698c:	e51b3010 	ldr	r3, [fp, #-16]
70006990:	e5933000 	ldr	r3, [r3]
70006994:	e1a03223 	lsr	r3, r3, #4
70006998:	e1a02003 	mov	r2, r3
7000699c:	e51b3010 	ldr	r3, [fp, #-16]
700069a0:	e5832000 	str	r2, [r3]
    }

    return res;
700069a4:	e51b3008 	ldr	r3, [fp, #-8]
}
700069a8:	e1a00003 	mov	r0, r3
700069ac:	e24bd000 	sub	sp, fp, #0
700069b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700069b4:	e12fff1e 	bx	lr

700069b8 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
700069b8:	e92d0810 	push	{r4, fp}
700069bc:	e28db004 	add	fp, sp, #4
700069c0:	e24dd008 	sub	sp, sp, #8
700069c4:	e50b0008 	str	r0, [fp, #-8]
    register int i=0;
700069c8:	e3a04000 	mov	r4, #0
    while (isdigit(**s))
700069cc:	ea00000c 	b	70006a04 <skip_atoi+0x4c>
        i = i * 10 + *((*s)++) - '0';
700069d0:	e1a03004 	mov	r3, r4
700069d4:	e1a03103 	lsl	r3, r3, #2
700069d8:	e0833004 	add	r3, r3, r4
700069dc:	e1a03083 	lsl	r3, r3, #1
700069e0:	e1a02003 	mov	r2, r3
700069e4:	e51b3008 	ldr	r3, [fp, #-8]
700069e8:	e5933000 	ldr	r3, [r3]
700069ec:	e2830001 	add	r0, r3, #1
700069f0:	e51b1008 	ldr	r1, [fp, #-8]
700069f4:	e5810000 	str	r0, [r1]
700069f8:	e5d33000 	ldrb	r3, [r3]
700069fc:	e0823003 	add	r3, r2, r3
70006a00:	e2434030 	sub	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
70006a04:	e51b3008 	ldr	r3, [fp, #-8]
70006a08:	e5933000 	ldr	r3, [r3]
70006a0c:	e5d33000 	ldrb	r3, [r3]
70006a10:	e2433030 	sub	r3, r3, #48	; 0x30
70006a14:	e3530009 	cmp	r3, #9
70006a18:	9affffec 	bls	700069d0 <skip_atoi+0x18>
        i = i * 10 + *((*s)++) - '0';

    return i;
70006a1c:	e1a03004 	mov	r3, r4
}
70006a20:	e1a00003 	mov	r0, r3
70006a24:	e24bd004 	sub	sp, fp, #4
70006a28:	e8bd0810 	pop	{r4, fp}
70006a2c:	e12fff1e 	bx	lr

70006a30 <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
70006a30:	e92d4870 	push	{r4, r5, r6, fp, lr}
70006a34:	e28db010 	add	fp, sp, #16
70006a38:	e24dd034 	sub	sp, sp, #52	; 0x34
70006a3c:	e50b0038 	str	r0, [fp, #-56]	; 0x38
70006a40:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
70006a44:	e50b2040 	str	r2, [fp, #-64]	; 0x40
70006a48:	e50b3044 	str	r3, [fp, #-68]	; 0x44
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
70006a4c:	e59b4004 	ldr	r4, [fp, #4]

    digits = (type & LARGE) ? large_digits : small_digits;
70006a50:	e59b300c 	ldr	r3, [fp, #12]
70006a54:	e2033040 	and	r3, r3, #64	; 0x40
70006a58:	e3530000 	cmp	r3, #0
70006a5c:	0a000002 	beq	70006a6c <print_number+0x3c>
70006a60:	e30637b8 	movw	r3, #26552	; 0x67b8
70006a64:	e3473002 	movt	r3, #28674	; 0x7002
70006a68:	ea000001 	b	70006a74 <print_number+0x44>
70006a6c:	e30637cc 	movw	r3, #26572	; 0x67cc
70006a70:	e3473002 	movt	r3, #28674	; 0x7002
70006a74:	e50b301c 	str	r3, [fp, #-28]
    if (type & LEFT)
70006a78:	e59b300c 	ldr	r3, [fp, #12]
70006a7c:	e2033010 	and	r3, r3, #16
70006a80:	e3530000 	cmp	r3, #0
70006a84:	0a000002 	beq	70006a94 <print_number+0x64>
        type &= ~ZEROPAD;
70006a88:	e59b300c 	ldr	r3, [fp, #12]
70006a8c:	e3c33001 	bic	r3, r3, #1
70006a90:	e58b300c 	str	r3, [fp, #12]

    c = (type & ZEROPAD) ? '0' : ' ';
70006a94:	e59b300c 	ldr	r3, [fp, #12]
70006a98:	e2033001 	and	r3, r3, #1
70006a9c:	e3530000 	cmp	r3, #0
70006aa0:	0a000001 	beq	70006aac <print_number+0x7c>
70006aa4:	e3a03030 	mov	r3, #48	; 0x30
70006aa8:	ea000000 	b	70006ab0 <print_number+0x80>
70006aac:	e3a03020 	mov	r3, #32
70006ab0:	e54b301d 	strb	r3, [fp, #-29]

    /* get sign */
    sign = 0;
70006ab4:	e3a03000 	mov	r3, #0
70006ab8:	e54b3015 	strb	r3, [fp, #-21]
    if (type & SIGN)
70006abc:	e59b300c 	ldr	r3, [fp, #12]
70006ac0:	e2033002 	and	r3, r3, #2
70006ac4:	e3530000 	cmp	r3, #0
70006ac8:	0a000015 	beq	70006b24 <print_number+0xf4>
    {
        if (num < 0)
70006acc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70006ad0:	e3530000 	cmp	r3, #0
70006ad4:	aa000005 	bge	70006af0 <print_number+0xc0>
        {
            sign = '-';
70006ad8:	e3a0302d 	mov	r3, #45	; 0x2d
70006adc:	e54b3015 	strb	r3, [fp, #-21]
            num = -num;
70006ae0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70006ae4:	e2633000 	rsb	r3, r3, #0
70006ae8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
70006aec:	ea00000c 	b	70006b24 <print_number+0xf4>
        }
        else if (type & PLUS)
70006af0:	e59b300c 	ldr	r3, [fp, #12]
70006af4:	e2033004 	and	r3, r3, #4
70006af8:	e3530000 	cmp	r3, #0
70006afc:	0a000002 	beq	70006b0c <print_number+0xdc>
            sign = '+';
70006b00:	e3a0302b 	mov	r3, #43	; 0x2b
70006b04:	e54b3015 	strb	r3, [fp, #-21]
70006b08:	ea000005 	b	70006b24 <print_number+0xf4>
        else if (type & SPACE)
70006b0c:	e59b300c 	ldr	r3, [fp, #12]
70006b10:	e2033008 	and	r3, r3, #8
70006b14:	e3530000 	cmp	r3, #0
70006b18:	0a000001 	beq	70006b24 <print_number+0xf4>
            sign = ' ';
70006b1c:	e3a03020 	mov	r3, #32
70006b20:	e54b3015 	strb	r3, [fp, #-21]
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
70006b24:	e3a05000 	mov	r5, #0
    if (num == 0)
70006b28:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70006b2c:	e3530000 	cmp	r3, #0
70006b30:	1a000008 	bne	70006b58 <print_number+0x128>
        tmp[i++]='0';
70006b34:	e1a03005 	mov	r3, r5
70006b38:	e2835001 	add	r5, r3, #1
70006b3c:	e3e0201b 	mvn	r2, #27
70006b40:	e24b0014 	sub	r0, fp, #20
70006b44:	e0803003 	add	r3, r0, r3
70006b48:	e0833002 	add	r3, r3, r2
70006b4c:	e3a02030 	mov	r2, #48	; 0x30
70006b50:	e5c32000 	strb	r2, [r3]
70006b54:	ea000012 	b	70006ba4 <print_number+0x174>
    else
    {
        while (num != 0)
70006b58:	ea00000e 	b	70006b98 <print_number+0x168>
            tmp[i++] = digits[divide(&num, base)];
70006b5c:	e1a06005 	mov	r6, r5
70006b60:	e2865001 	add	r5, r6, #1
70006b64:	e24b3040 	sub	r3, fp, #64	; 0x40
70006b68:	e1a00003 	mov	r0, r3
70006b6c:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
70006b70:	ebffff61 	bl	700068fc <divide>
70006b74:	e1a03000 	mov	r3, r0
70006b78:	e51b201c 	ldr	r2, [fp, #-28]
70006b7c:	e0823003 	add	r3, r2, r3
70006b80:	e5d32000 	ldrb	r2, [r3]
70006b84:	e3e0301b 	mvn	r3, #27
70006b88:	e24b0014 	sub	r0, fp, #20
70006b8c:	e0801006 	add	r1, r0, r6
70006b90:	e0813003 	add	r3, r1, r3
70006b94:	e5c32000 	strb	r2, [r3]
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
70006b98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70006b9c:	e3530000 	cmp	r3, #0
70006ba0:	1affffed 	bne	70006b5c <print_number+0x12c>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
70006ba4:	e59b3008 	ldr	r3, [fp, #8]
70006ba8:	e1550003 	cmp	r5, r3
70006bac:	da000000 	ble	70006bb4 <print_number+0x184>
        precision = i;
70006bb0:	e58b5008 	str	r5, [fp, #8]
    size -= precision;
70006bb4:	e59b3008 	ldr	r3, [fp, #8]
70006bb8:	e0634004 	rsb	r4, r3, r4
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
70006bbc:	e59b300c 	ldr	r3, [fp, #12]
70006bc0:	e2033011 	and	r3, r3, #17
70006bc4:	e3530000 	cmp	r3, #0
70006bc8:	1a000015 	bne	70006c24 <print_number+0x1f4>
    {
        if ((sign)&&(size>0))
70006bcc:	e55b3015 	ldrb	r3, [fp, #-21]
70006bd0:	e3530000 	cmp	r3, #0
70006bd4:	0a000003 	beq	70006be8 <print_number+0x1b8>
70006bd8:	e3540000 	cmp	r4, #0
70006bdc:	da000001 	ble	70006be8 <print_number+0x1b8>
            size--;
70006be0:	e2444001 	sub	r4, r4, #1

        while (size-->0)
70006be4:	ea00000a 	b	70006c14 <print_number+0x1e4>
70006be8:	ea000009 	b	70006c14 <print_number+0x1e4>
        {
            if (buf <= end)
70006bec:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006bf0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006bf4:	e1520003 	cmp	r2, r3
70006bf8:	8a000002 	bhi	70006c08 <print_number+0x1d8>
                *buf = ' ';
70006bfc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c00:	e3a02020 	mov	r2, #32
70006c04:	e5c32000 	strb	r2, [r3]
            ++ buf;
70006c08:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c0c:	e2833001 	add	r3, r3, #1
70006c10:	e50b3038 	str	r3, [fp, #-56]	; 0x38
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
70006c14:	e1a03004 	mov	r3, r4
70006c18:	e2434001 	sub	r4, r3, #1
70006c1c:	e3530000 	cmp	r3, #0
70006c20:	cafffff1 	bgt	70006bec <print_number+0x1bc>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
70006c24:	e55b3015 	ldrb	r3, [fp, #-21]
70006c28:	e3530000 	cmp	r3, #0
70006c2c:	0a00000a 	beq	70006c5c <print_number+0x22c>
    {
        if (buf <= end)
70006c30:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006c34:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006c38:	e1520003 	cmp	r2, r3
70006c3c:	8a000003 	bhi	70006c50 <print_number+0x220>
        {
            *buf = sign;
70006c40:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c44:	e55b2015 	ldrb	r2, [fp, #-21]
70006c48:	e5c32000 	strb	r2, [r3]
            -- size;
70006c4c:	e2444001 	sub	r4, r4, #1
        }
        ++ buf;
70006c50:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c54:	e2833001 	add	r3, r3, #1
70006c58:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
70006c5c:	e59b300c 	ldr	r3, [fp, #12]
70006c60:	e2033010 	and	r3, r3, #16
70006c64:	e3530000 	cmp	r3, #0
70006c68:	1a00000e 	bne	70006ca8 <print_number+0x278>
    {
        while (size-- > 0)
70006c6c:	ea000009 	b	70006c98 <print_number+0x268>
        {
            if (buf <= end)
70006c70:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006c74:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006c78:	e1520003 	cmp	r2, r3
70006c7c:	8a000002 	bhi	70006c8c <print_number+0x25c>
                *buf = c;
70006c80:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c84:	e55b201d 	ldrb	r2, [fp, #-29]
70006c88:	e5c32000 	strb	r2, [r3]
            ++ buf;
70006c8c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006c90:	e2833001 	add	r3, r3, #1
70006c94:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
70006c98:	e1a03004 	mov	r3, r4
70006c9c:	e2434001 	sub	r4, r3, #1
70006ca0:	e3530000 	cmp	r3, #0
70006ca4:	cafffff1 	bgt	70006c70 <print_number+0x240>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
70006ca8:	ea000009 	b	70006cd4 <print_number+0x2a4>
    {
        if (buf <= end)
70006cac:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006cb0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006cb4:	e1520003 	cmp	r2, r3
70006cb8:	8a000002 	bhi	70006cc8 <print_number+0x298>
            *buf = '0';
70006cbc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006cc0:	e3a02030 	mov	r2, #48	; 0x30
70006cc4:	e5c32000 	strb	r2, [r3]
        ++ buf;
70006cc8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006ccc:	e2833001 	add	r3, r3, #1
70006cd0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
70006cd4:	e59b3008 	ldr	r3, [fp, #8]
70006cd8:	e2432001 	sub	r2, r3, #1
70006cdc:	e58b2008 	str	r2, [fp, #8]
70006ce0:	e1530005 	cmp	r3, r5
70006ce4:	cafffff0 	bgt	70006cac <print_number+0x27c>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
70006ce8:	ea00000d 	b	70006d24 <print_number+0x2f4>
    {
        if (buf <= end)
70006cec:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006cf0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006cf4:	e1520003 	cmp	r2, r3
70006cf8:	8a000006 	bhi	70006d18 <print_number+0x2e8>
            *buf = tmp[i];
70006cfc:	e3e0301b 	mvn	r3, #27
70006d00:	e24b1014 	sub	r1, fp, #20
70006d04:	e0812005 	add	r2, r1, r5
70006d08:	e0823003 	add	r3, r2, r3
70006d0c:	e5d32000 	ldrb	r2, [r3]
70006d10:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006d14:	e5c32000 	strb	r2, [r3]
        ++ buf;
70006d18:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006d1c:	e2833001 	add	r3, r3, #1
70006d20:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
70006d24:	e1a03005 	mov	r3, r5
70006d28:	e2435001 	sub	r5, r3, #1
70006d2c:	e3530000 	cmp	r3, #0
70006d30:	caffffed 	bgt	70006cec <print_number+0x2bc>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
70006d34:	ea000009 	b	70006d60 <print_number+0x330>
    {
        if (buf <= end)
70006d38:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70006d3c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006d40:	e1520003 	cmp	r2, r3
70006d44:	8a000002 	bhi	70006d54 <print_number+0x324>
            *buf = ' ';
70006d48:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006d4c:	e3a02020 	mov	r2, #32
70006d50:	e5c32000 	strb	r2, [r3]
        ++ buf;
70006d54:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006d58:	e2833001 	add	r3, r3, #1
70006d5c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
70006d60:	e1a03004 	mov	r3, r4
70006d64:	e2434001 	sub	r4, r3, #1
70006d68:	e3530000 	cmp	r3, #0
70006d6c:	cafffff1 	bgt	70006d38 <print_number+0x308>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
70006d70:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
}
70006d74:	e1a00003 	mov	r0, r3
70006d78:	e24bd010 	sub	sp, fp, #16
70006d7c:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

70006d80 <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
70006d80:	e92d4800 	push	{fp, lr}
70006d84:	e28db004 	add	fp, sp, #4
70006d88:	e24dd048 	sub	sp, sp, #72	; 0x48
70006d8c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
70006d90:	e50b1034 	str	r1, [fp, #-52]	; 0x34
70006d94:	e50b2038 	str	r2, [fp, #-56]	; 0x38
70006d98:	e50b303c 	str	r3, [fp, #-60]	; 0x3c

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
70006d9c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70006da0:	e50b3014 	str	r3, [fp, #-20]
    end = buf + size - 1;
70006da4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
70006da8:	e2433001 	sub	r3, r3, #1
70006dac:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
70006db0:	e0823003 	add	r3, r2, r3
70006db4:	e50b3018 	str	r3, [fp, #-24]

    /* Make sure end is always >= buf */
    if (end < buf)
70006db8:	e51b2018 	ldr	r2, [fp, #-24]
70006dbc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70006dc0:	e1520003 	cmp	r2, r3
70006dc4:	2a000006 	bcs	70006de4 <rt_vsnprintf+0x64>
    {
        end  = ((char *)-1);
70006dc8:	e3e03000 	mvn	r3, #0
70006dcc:	e50b3018 	str	r3, [fp, #-24]
        size = end - buf;
70006dd0:	e51b2018 	ldr	r2, [fp, #-24]
70006dd4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70006dd8:	e0633002 	rsb	r3, r3, r2
70006ddc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
    }

    for (; *fmt ; ++fmt)
70006de0:	ea000203 	b	700075f4 <rt_vsnprintf+0x874>
70006de4:	ea000202 	b	700075f4 <rt_vsnprintf+0x874>
    {
        if (*fmt != '%')
70006de8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006dec:	e5d33000 	ldrb	r3, [r3]
70006df0:	e3530025 	cmp	r3, #37	; 0x25
70006df4:	0a00000b 	beq	70006e28 <rt_vsnprintf+0xa8>
        {
            if (str <= end)
70006df8:	e51b2014 	ldr	r2, [fp, #-20]
70006dfc:	e51b3018 	ldr	r3, [fp, #-24]
70006e00:	e1520003 	cmp	r2, r3
70006e04:	8a000003 	bhi	70006e18 <rt_vsnprintf+0x98>
                *str = *fmt;
70006e08:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006e0c:	e5d32000 	ldrb	r2, [r3]
70006e10:	e51b3014 	ldr	r3, [fp, #-20]
70006e14:	e5c32000 	strb	r2, [r3]
            ++ str;
70006e18:	e51b3014 	ldr	r3, [fp, #-20]
70006e1c:	e2833001 	add	r3, r3, #1
70006e20:	e50b3014 	str	r3, [fp, #-20]
            continue;
70006e24:	ea0001ef 	b	700075e8 <rt_vsnprintf+0x868>
        }

        /* process flags */
        flags = 0;
70006e28:	e3a03000 	mov	r3, #0
70006e2c:	e54b301e 	strb	r3, [fp, #-30]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
70006e30:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006e34:	e2833001 	add	r3, r3, #1
70006e38:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            if (*fmt == '-') flags |= LEFT;
70006e3c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006e40:	e5d33000 	ldrb	r3, [r3]
70006e44:	e353002d 	cmp	r3, #45	; 0x2d
70006e48:	1a000003 	bne	70006e5c <rt_vsnprintf+0xdc>
70006e4c:	e55b301e 	ldrb	r3, [fp, #-30]
70006e50:	e3833010 	orr	r3, r3, #16
70006e54:	e54b301e 	strb	r3, [fp, #-30]
70006e58:	ea000028 	b	70006f00 <rt_vsnprintf+0x180>
            else if (*fmt == '+') flags |= PLUS;
70006e5c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006e60:	e5d33000 	ldrb	r3, [r3]
70006e64:	e353002b 	cmp	r3, #43	; 0x2b
70006e68:	1a000003 	bne	70006e7c <rt_vsnprintf+0xfc>
70006e6c:	e55b301e 	ldrb	r3, [fp, #-30]
70006e70:	e3833004 	orr	r3, r3, #4
70006e74:	e54b301e 	strb	r3, [fp, #-30]
70006e78:	ea000020 	b	70006f00 <rt_vsnprintf+0x180>
            else if (*fmt == ' ') flags |= SPACE;
70006e7c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006e80:	e5d33000 	ldrb	r3, [r3]
70006e84:	e3530020 	cmp	r3, #32
70006e88:	1a000003 	bne	70006e9c <rt_vsnprintf+0x11c>
70006e8c:	e55b301e 	ldrb	r3, [fp, #-30]
70006e90:	e3833008 	orr	r3, r3, #8
70006e94:	e54b301e 	strb	r3, [fp, #-30]
70006e98:	ea000018 	b	70006f00 <rt_vsnprintf+0x180>
            else if (*fmt == '#') flags |= SPECIAL;
70006e9c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006ea0:	e5d33000 	ldrb	r3, [r3]
70006ea4:	e3530023 	cmp	r3, #35	; 0x23
70006ea8:	1a000003 	bne	70006ebc <rt_vsnprintf+0x13c>
70006eac:	e55b301e 	ldrb	r3, [fp, #-30]
70006eb0:	e3833020 	orr	r3, r3, #32
70006eb4:	e54b301e 	strb	r3, [fp, #-30]
70006eb8:	ea000010 	b	70006f00 <rt_vsnprintf+0x180>
            else if (*fmt == '0') flags |= ZEROPAD;
70006ebc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006ec0:	e5d33000 	ldrb	r3, [r3]
70006ec4:	e3530030 	cmp	r3, #48	; 0x30
70006ec8:	1a000003 	bne	70006edc <rt_vsnprintf+0x15c>
70006ecc:	e55b301e 	ldrb	r3, [fp, #-30]
70006ed0:	e3833001 	orr	r3, r3, #1
70006ed4:	e54b301e 	strb	r3, [fp, #-30]
70006ed8:	ea000008 	b	70006f00 <rt_vsnprintf+0x180>
            else break;
70006edc:	e1a00000 	nop			; (mov r0, r0)
        }

        /* get field width */
        field_width = -1;
70006ee0:	e3e03000 	mvn	r3, #0
70006ee4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
70006ee8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006eec:	e5d33000 	ldrb	r3, [r3]
70006ef0:	e2433030 	sub	r3, r3, #48	; 0x30
70006ef4:	e3530009 	cmp	r3, #9
70006ef8:	8a000006 	bhi	70006f18 <rt_vsnprintf+0x198>
70006efc:	ea000000 	b	70006f04 <rt_vsnprintf+0x184>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
70006f00:	eaffffca 	b	70006e30 <rt_vsnprintf+0xb0>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
70006f04:	e24b3038 	sub	r3, fp, #56	; 0x38
70006f08:	e1a00003 	mov	r0, r3
70006f0c:	ebfffea9 	bl	700069b8 <skip_atoi>
70006f10:	e50b0024 	str	r0, [fp, #-36]	; 0x24
70006f14:	ea000014 	b	70006f6c <rt_vsnprintf+0x1ec>
        else if (*fmt == '*')
70006f18:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006f1c:	e5d33000 	ldrb	r3, [r3]
70006f20:	e353002a 	cmp	r3, #42	; 0x2a
70006f24:	1a000010 	bne	70006f6c <rt_vsnprintf+0x1ec>
        {
            ++ fmt;
70006f28:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006f2c:	e2833001 	add	r3, r3, #1
70006f30:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            /* it's the next argument */
            field_width = va_arg(args, int);
70006f34:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006f38:	e2832004 	add	r2, r3, #4
70006f3c:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
70006f40:	e5933000 	ldr	r3, [r3]
70006f44:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            if (field_width < 0)
70006f48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70006f4c:	e3530000 	cmp	r3, #0
70006f50:	aa000005 	bge	70006f6c <rt_vsnprintf+0x1ec>
            {
                field_width = -field_width;
70006f54:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70006f58:	e2633000 	rsb	r3, r3, #0
70006f5c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
                flags |= LEFT;
70006f60:	e55b301e 	ldrb	r3, [fp, #-30]
70006f64:	e3833010 	orr	r3, r3, #16
70006f68:	e54b301e 	strb	r3, [fp, #-30]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
70006f6c:	e3e03000 	mvn	r3, #0
70006f70:	e50b3028 	str	r3, [fp, #-40]	; 0x28
        if (*fmt == '.')
70006f74:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006f78:	e5d33000 	ldrb	r3, [r3]
70006f7c:	e353002e 	cmp	r3, #46	; 0x2e
70006f80:	1a00001d 	bne	70006ffc <rt_vsnprintf+0x27c>
        {
            ++ fmt;
70006f84:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006f88:	e2833001 	add	r3, r3, #1
70006f8c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
70006f90:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006f94:	e5d33000 	ldrb	r3, [r3]
70006f98:	e2433030 	sub	r3, r3, #48	; 0x30
70006f9c:	e3530009 	cmp	r3, #9
70006fa0:	8a000004 	bhi	70006fb8 <rt_vsnprintf+0x238>
70006fa4:	e24b3038 	sub	r3, fp, #56	; 0x38
70006fa8:	e1a00003 	mov	r0, r3
70006fac:	ebfffe81 	bl	700069b8 <skip_atoi>
70006fb0:	e50b0028 	str	r0, [fp, #-40]	; 0x28
70006fb4:	ea00000b 	b	70006fe8 <rt_vsnprintf+0x268>
            else if (*fmt == '*')
70006fb8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006fbc:	e5d33000 	ldrb	r3, [r3]
70006fc0:	e353002a 	cmp	r3, #42	; 0x2a
70006fc4:	1a000007 	bne	70006fe8 <rt_vsnprintf+0x268>
            {
                ++ fmt;
70006fc8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70006fcc:	e2833001 	add	r3, r3, #1
70006fd0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
                /* it's the next argument */
                precision = va_arg(args, int);
70006fd4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70006fd8:	e2832004 	add	r2, r3, #4
70006fdc:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
70006fe0:	e5933000 	ldr	r3, [r3]
70006fe4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            }
            if (precision < 0) precision = 0;
70006fe8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70006fec:	e3530000 	cmp	r3, #0
70006ff0:	aa000001 	bge	70006ffc <rt_vsnprintf+0x27c>
70006ff4:	e3a03000 	mov	r3, #0
70006ff8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
70006ffc:	e3a03000 	mov	r3, #0
70007000:	e54b301f 	strb	r3, [fp, #-31]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
70007004:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007008:	e5d33000 	ldrb	r3, [r3]
7000700c:	e3530068 	cmp	r3, #104	; 0x68
70007010:	0a000003 	beq	70007024 <rt_vsnprintf+0x2a4>
70007014:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007018:	e5d33000 	ldrb	r3, [r3]
7000701c:	e353006c 	cmp	r3, #108	; 0x6c
70007020:	1a000005 	bne	7000703c <rt_vsnprintf+0x2bc>
#endif
        {
            qualifier = *fmt;
70007024:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007028:	e5d33000 	ldrb	r3, [r3]
7000702c:	e54b301f 	strb	r3, [fp, #-31]
            ++ fmt;
70007030:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007034:	e2833001 	add	r3, r3, #1
70007038:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            }
#endif
        }

        /* the default base */
        base = 10;
7000703c:	e3a0300a 	mov	r3, #10
70007040:	e54b301d 	strb	r3, [fp, #-29]

        switch (*fmt)
70007044:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007048:	e5d33000 	ldrb	r3, [r3]
7000704c:	e2433025 	sub	r3, r3, #37	; 0x25
70007050:	e3530053 	cmp	r3, #83	; 0x53
70007054:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70007058:	ea000111 	b	700074a4 <rt_vsnprintf+0x724>
7000705c:	70007444 	.word	0x70007444
70007060:	700074a4 	.word	0x700074a4
70007064:	700074a4 	.word	0x700074a4
70007068:	700074a4 	.word	0x700074a4
7000706c:	700074a4 	.word	0x700074a4
70007070:	700074a4 	.word	0x700074a4
70007074:	700074a4 	.word	0x700074a4
70007078:	700074a4 	.word	0x700074a4
7000707c:	700074a4 	.word	0x700074a4
70007080:	700074a4 	.word	0x700074a4
70007084:	700074a4 	.word	0x700074a4
70007088:	700074a4 	.word	0x700074a4
7000708c:	700074a4 	.word	0x700074a4
70007090:	700074a4 	.word	0x700074a4
70007094:	700074a4 	.word	0x700074a4
70007098:	700074a4 	.word	0x700074a4
7000709c:	700074a4 	.word	0x700074a4
700070a0:	700074a4 	.word	0x700074a4
700070a4:	700074a4 	.word	0x700074a4
700070a8:	700074a4 	.word	0x700074a4
700070ac:	700074a4 	.word	0x700074a4
700070b0:	700074a4 	.word	0x700074a4
700070b4:	700074a4 	.word	0x700074a4
700070b8:	700074a4 	.word	0x700074a4
700070bc:	700074a4 	.word	0x700074a4
700070c0:	700074a4 	.word	0x700074a4
700070c4:	700074a4 	.word	0x700074a4
700070c8:	700074a4 	.word	0x700074a4
700070cc:	700074a4 	.word	0x700074a4
700070d0:	700074a4 	.word	0x700074a4
700070d4:	700074a4 	.word	0x700074a4
700070d8:	700074a4 	.word	0x700074a4
700070dc:	700074a4 	.word	0x700074a4
700070e0:	700074a4 	.word	0x700074a4
700070e4:	700074a4 	.word	0x700074a4
700070e8:	700074a4 	.word	0x700074a4
700070ec:	700074a4 	.word	0x700074a4
700070f0:	700074a4 	.word	0x700074a4
700070f4:	700074a4 	.word	0x700074a4
700070f8:	700074a4 	.word	0x700074a4
700070fc:	700074a4 	.word	0x700074a4
70007100:	700074a4 	.word	0x700074a4
70007104:	700074a4 	.word	0x700074a4
70007108:	700074a4 	.word	0x700074a4
7000710c:	700074a4 	.word	0x700074a4
70007110:	700074a4 	.word	0x700074a4
70007114:	700074a4 	.word	0x700074a4
70007118:	700074a4 	.word	0x700074a4
7000711c:	700074a4 	.word	0x700074a4
70007120:	700074a4 	.word	0x700074a4
70007124:	700074a4 	.word	0x700074a4
70007128:	7000747c 	.word	0x7000747c
7000712c:	700074a4 	.word	0x700074a4
70007130:	700074a4 	.word	0x700074a4
70007134:	700074a4 	.word	0x700074a4
70007138:	700074a4 	.word	0x700074a4
7000713c:	700074a4 	.word	0x700074a4
70007140:	700074a4 	.word	0x700074a4
70007144:	700074a4 	.word	0x700074a4
70007148:	700074a4 	.word	0x700074a4
7000714c:	700074a4 	.word	0x700074a4
70007150:	700074a4 	.word	0x700074a4
70007154:	700071ac 	.word	0x700071ac
70007158:	70007494 	.word	0x70007494
7000715c:	700074a4 	.word	0x700074a4
70007160:	700074a4 	.word	0x700074a4
70007164:	700074a4 	.word	0x700074a4
70007168:	700074a4 	.word	0x700074a4
7000716c:	70007494 	.word	0x70007494
70007170:	700074a4 	.word	0x700074a4
70007174:	700074a4 	.word	0x700074a4
70007178:	700074a4 	.word	0x700074a4
7000717c:	700074a4 	.word	0x700074a4
70007180:	700074a4 	.word	0x700074a4
70007184:	70007470 	.word	0x70007470
70007188:	700073e0 	.word	0x700073e0
7000718c:	700074a4 	.word	0x700074a4
70007190:	700074a4 	.word	0x700074a4
70007194:	70007284 	.word	0x70007284
70007198:	700074a4 	.word	0x700074a4
7000719c:	7000751c 	.word	0x7000751c
700071a0:	700074a4 	.word	0x700074a4
700071a4:	700074a4 	.word	0x700074a4
700071a8:	70007488 	.word	0x70007488
        {
        case 'c':
            if (!(flags & LEFT))
700071ac:	e55b301e 	ldrb	r3, [fp, #-30]
700071b0:	e2033010 	and	r3, r3, #16
700071b4:	e3530000 	cmp	r3, #0
700071b8:	1a000010 	bne	70007200 <rt_vsnprintf+0x480>
            {
                while (--field_width > 0)
700071bc:	ea000009 	b	700071e8 <rt_vsnprintf+0x468>
                {
                    if (str <= end) *str = ' ';
700071c0:	e51b2014 	ldr	r2, [fp, #-20]
700071c4:	e51b3018 	ldr	r3, [fp, #-24]
700071c8:	e1520003 	cmp	r2, r3
700071cc:	8a000002 	bhi	700071dc <rt_vsnprintf+0x45c>
700071d0:	e51b3014 	ldr	r3, [fp, #-20]
700071d4:	e3a02020 	mov	r2, #32
700071d8:	e5c32000 	strb	r2, [r3]
                    ++ str;
700071dc:	e51b3014 	ldr	r3, [fp, #-20]
700071e0:	e2833001 	add	r3, r3, #1
700071e4:	e50b3014 	str	r3, [fp, #-20]
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
700071e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700071ec:	e2433001 	sub	r3, r3, #1
700071f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
700071f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700071f8:	e3530000 	cmp	r3, #0
700071fc:	caffffef 	bgt	700071c0 <rt_vsnprintf+0x440>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
70007200:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70007204:	e2832004 	add	r2, r3, #4
70007208:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
7000720c:	e5933000 	ldr	r3, [r3]
70007210:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
            if (str <= end) *str = c;
70007214:	e51b2014 	ldr	r2, [fp, #-20]
70007218:	e51b3018 	ldr	r3, [fp, #-24]
7000721c:	e1520003 	cmp	r2, r3
70007220:	8a000002 	bhi	70007230 <rt_vsnprintf+0x4b0>
70007224:	e51b3014 	ldr	r3, [fp, #-20]
70007228:	e55b2029 	ldrb	r2, [fp, #-41]	; 0x29
7000722c:	e5c32000 	strb	r2, [r3]
            ++ str;
70007230:	e51b3014 	ldr	r3, [fp, #-20]
70007234:	e2833001 	add	r3, r3, #1
70007238:	e50b3014 	str	r3, [fp, #-20]

            /* put width */
            while (--field_width > 0)
7000723c:	ea000009 	b	70007268 <rt_vsnprintf+0x4e8>
            {
                if (str <= end) *str = ' ';
70007240:	e51b2014 	ldr	r2, [fp, #-20]
70007244:	e51b3018 	ldr	r3, [fp, #-24]
70007248:	e1520003 	cmp	r2, r3
7000724c:	8a000002 	bhi	7000725c <rt_vsnprintf+0x4dc>
70007250:	e51b3014 	ldr	r3, [fp, #-20]
70007254:	e3a02020 	mov	r2, #32
70007258:	e5c32000 	strb	r2, [r3]
                ++ str;
7000725c:	e51b3014 	ldr	r3, [fp, #-20]
70007260:	e2833001 	add	r3, r3, #1
70007264:	e50b3014 	str	r3, [fp, #-20]
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
70007268:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7000726c:	e2433001 	sub	r3, r3, #1
70007270:	e50b3024 	str	r3, [fp, #-36]	; 0x24
70007274:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70007278:	e3530000 	cmp	r3, #0
7000727c:	caffffef 	bgt	70007240 <rt_vsnprintf+0x4c0>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
70007280:	ea0000d8 	b	700075e8 <rt_vsnprintf+0x868>

        case 's':
            s = va_arg(args, char *);
70007284:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70007288:	e2832004 	add	r2, r3, #4
7000728c:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
70007290:	e5933000 	ldr	r3, [r3]
70007294:	e50b301c 	str	r3, [fp, #-28]
            if (!s) s = "(NULL)";
70007298:	e51b301c 	ldr	r3, [fp, #-28]
7000729c:	e3530000 	cmp	r3, #0
700072a0:	1a000002 	bne	700072b0 <rt_vsnprintf+0x530>
700072a4:	e30636b0 	movw	r3, #26288	; 0x66b0
700072a8:	e3473002 	movt	r3, #28674	; 0x7002
700072ac:	e50b301c 	str	r3, [fp, #-28]

            len = rt_strlen(s);
700072b0:	e51b001c 	ldr	r0, [fp, #-28]
700072b4:	ebfffd4b 	bl	700067e8 <rt_strlen>
700072b8:	e1a03000 	mov	r3, r0
700072bc:	e50b3010 	str	r3, [fp, #-16]
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
700072c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700072c4:	e3530000 	cmp	r3, #0
700072c8:	da000005 	ble	700072e4 <rt_vsnprintf+0x564>
700072cc:	e51b2010 	ldr	r2, [fp, #-16]
700072d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700072d4:	e1520003 	cmp	r2, r3
700072d8:	da000001 	ble	700072e4 <rt_vsnprintf+0x564>
700072dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700072e0:	e50b3010 	str	r3, [fp, #-16]
#endif

            if (!(flags & LEFT))
700072e4:	e55b301e 	ldrb	r3, [fp, #-30]
700072e8:	e2033010 	and	r3, r3, #16
700072ec:	e3530000 	cmp	r3, #0
700072f0:	1a000010 	bne	70007338 <rt_vsnprintf+0x5b8>
            {
                while (len < field_width--)
700072f4:	ea000009 	b	70007320 <rt_vsnprintf+0x5a0>
                {
                    if (str <= end) *str = ' ';
700072f8:	e51b2014 	ldr	r2, [fp, #-20]
700072fc:	e51b3018 	ldr	r3, [fp, #-24]
70007300:	e1520003 	cmp	r2, r3
70007304:	8a000002 	bhi	70007314 <rt_vsnprintf+0x594>
70007308:	e51b3014 	ldr	r3, [fp, #-20]
7000730c:	e3a02020 	mov	r2, #32
70007310:	e5c32000 	strb	r2, [r3]
                    ++ str;
70007314:	e51b3014 	ldr	r3, [fp, #-20]
70007318:	e2833001 	add	r3, r3, #1
7000731c:	e50b3014 	str	r3, [fp, #-20]
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
70007320:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70007324:	e2432001 	sub	r2, r3, #1
70007328:	e50b2024 	str	r2, [fp, #-36]	; 0x24
7000732c:	e51b2010 	ldr	r2, [fp, #-16]
70007330:	e1530002 	cmp	r3, r2
70007334:	caffffef 	bgt	700072f8 <rt_vsnprintf+0x578>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
70007338:	e3a03000 	mov	r3, #0
7000733c:	e50b300c 	str	r3, [fp, #-12]
70007340:	ea000010 	b	70007388 <rt_vsnprintf+0x608>
            {
                if (str <= end) *str = *s;
70007344:	e51b2014 	ldr	r2, [fp, #-20]
70007348:	e51b3018 	ldr	r3, [fp, #-24]
7000734c:	e1520003 	cmp	r2, r3
70007350:	8a000003 	bhi	70007364 <rt_vsnprintf+0x5e4>
70007354:	e51b301c 	ldr	r3, [fp, #-28]
70007358:	e5d32000 	ldrb	r2, [r3]
7000735c:	e51b3014 	ldr	r3, [fp, #-20]
70007360:	e5c32000 	strb	r2, [r3]
                ++ str;
70007364:	e51b3014 	ldr	r3, [fp, #-20]
70007368:	e2833001 	add	r3, r3, #1
7000736c:	e50b3014 	str	r3, [fp, #-20]
                ++ s;
70007370:	e51b301c 	ldr	r3, [fp, #-28]
70007374:	e2833001 	add	r3, r3, #1
70007378:	e50b301c 	str	r3, [fp, #-28]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
7000737c:	e51b300c 	ldr	r3, [fp, #-12]
70007380:	e2833001 	add	r3, r3, #1
70007384:	e50b300c 	str	r3, [fp, #-12]
70007388:	e51b200c 	ldr	r2, [fp, #-12]
7000738c:	e51b3010 	ldr	r3, [fp, #-16]
70007390:	e1520003 	cmp	r2, r3
70007394:	baffffea 	blt	70007344 <rt_vsnprintf+0x5c4>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
70007398:	ea000009 	b	700073c4 <rt_vsnprintf+0x644>
            {
                if (str <= end) *str = ' ';
7000739c:	e51b2014 	ldr	r2, [fp, #-20]
700073a0:	e51b3018 	ldr	r3, [fp, #-24]
700073a4:	e1520003 	cmp	r2, r3
700073a8:	8a000002 	bhi	700073b8 <rt_vsnprintf+0x638>
700073ac:	e51b3014 	ldr	r3, [fp, #-20]
700073b0:	e3a02020 	mov	r2, #32
700073b4:	e5c32000 	strb	r2, [r3]
                ++ str;
700073b8:	e51b3014 	ldr	r3, [fp, #-20]
700073bc:	e2833001 	add	r3, r3, #1
700073c0:	e50b3014 	str	r3, [fp, #-20]
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
700073c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700073c8:	e2432001 	sub	r2, r3, #1
700073cc:	e50b2024 	str	r2, [fp, #-36]	; 0x24
700073d0:	e51b2010 	ldr	r2, [fp, #-16]
700073d4:	e1530002 	cmp	r3, r2
700073d8:	caffffef 	bgt	7000739c <rt_vsnprintf+0x61c>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
700073dc:	ea000081 	b	700075e8 <rt_vsnprintf+0x868>

        case 'p':
            if (field_width == -1)
700073e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700073e4:	e3730001 	cmn	r3, #1
700073e8:	1a000004 	bne	70007400 <rt_vsnprintf+0x680>
            {
                field_width = sizeof(void *) << 1;
700073ec:	e3a03008 	mov	r3, #8
700073f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
                flags |= ZEROPAD;
700073f4:	e55b301e 	ldrb	r3, [fp, #-30]
700073f8:	e3833001 	orr	r3, r3, #1
700073fc:	e54b301e 	strb	r3, [fp, #-30]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
70007400:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70007404:	e2832004 	add	r2, r3, #4
70007408:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
7000740c:	e5933000 	ldr	r3, [r3]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
70007410:	e55b201e 	ldrb	r2, [fp, #-30]
70007414:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
70007418:	e58d1000 	str	r1, [sp]
7000741c:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
70007420:	e58d1004 	str	r1, [sp, #4]
70007424:	e58d2008 	str	r2, [sp, #8]
70007428:	e51b0014 	ldr	r0, [fp, #-20]
7000742c:	e51b1018 	ldr	r1, [fp, #-24]
70007430:	e1a02003 	mov	r2, r3
70007434:	e3a03010 	mov	r3, #16
70007438:	ebfffd7c 	bl	70006a30 <print_number>
7000743c:	e50b0014 	str	r0, [fp, #-20]
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
70007440:	ea000068 	b	700075e8 <rt_vsnprintf+0x868>

        case '%':
            if (str <= end) *str = '%';
70007444:	e51b2014 	ldr	r2, [fp, #-20]
70007448:	e51b3018 	ldr	r3, [fp, #-24]
7000744c:	e1520003 	cmp	r2, r3
70007450:	8a000002 	bhi	70007460 <rt_vsnprintf+0x6e0>
70007454:	e51b3014 	ldr	r3, [fp, #-20]
70007458:	e3a02025 	mov	r2, #37	; 0x25
7000745c:	e5c32000 	strb	r2, [r3]
            ++ str;
70007460:	e51b3014 	ldr	r3, [fp, #-20]
70007464:	e2833001 	add	r3, r3, #1
70007468:	e50b3014 	str	r3, [fp, #-20]
            continue;
7000746c:	ea00005d 	b	700075e8 <rt_vsnprintf+0x868>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
70007470:	e3a03008 	mov	r3, #8
70007474:	e54b301d 	strb	r3, [fp, #-29]
            break;
70007478:	ea000028 	b	70007520 <rt_vsnprintf+0x7a0>

        case 'X':
            flags |= LARGE;
7000747c:	e55b301e 	ldrb	r3, [fp, #-30]
70007480:	e3833040 	orr	r3, r3, #64	; 0x40
70007484:	e54b301e 	strb	r3, [fp, #-30]
        case 'x':
            base = 16;
70007488:	e3a03010 	mov	r3, #16
7000748c:	e54b301d 	strb	r3, [fp, #-29]
            break;
70007490:	ea000022 	b	70007520 <rt_vsnprintf+0x7a0>

        case 'd':
        case 'i':
            flags |= SIGN;
70007494:	e55b301e 	ldrb	r3, [fp, #-30]
70007498:	e3833002 	orr	r3, r3, #2
7000749c:	e54b301e 	strb	r3, [fp, #-30]
        case 'u':
            break;
700074a0:	ea00001d 	b	7000751c <rt_vsnprintf+0x79c>

        default:
            if (str <= end) *str = '%';
700074a4:	e51b2014 	ldr	r2, [fp, #-20]
700074a8:	e51b3018 	ldr	r3, [fp, #-24]
700074ac:	e1520003 	cmp	r2, r3
700074b0:	8a000002 	bhi	700074c0 <rt_vsnprintf+0x740>
700074b4:	e51b3014 	ldr	r3, [fp, #-20]
700074b8:	e3a02025 	mov	r2, #37	; 0x25
700074bc:	e5c32000 	strb	r2, [r3]
            ++ str;
700074c0:	e51b3014 	ldr	r3, [fp, #-20]
700074c4:	e2833001 	add	r3, r3, #1
700074c8:	e50b3014 	str	r3, [fp, #-20]

            if (*fmt)
700074cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
700074d0:	e5d33000 	ldrb	r3, [r3]
700074d4:	e3530000 	cmp	r3, #0
700074d8:	0a00000b 	beq	7000750c <rt_vsnprintf+0x78c>
            {
                if (str <= end) *str = *fmt;
700074dc:	e51b2014 	ldr	r2, [fp, #-20]
700074e0:	e51b3018 	ldr	r3, [fp, #-24]
700074e4:	e1520003 	cmp	r2, r3
700074e8:	8a000003 	bhi	700074fc <rt_vsnprintf+0x77c>
700074ec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
700074f0:	e5d32000 	ldrb	r2, [r3]
700074f4:	e51b3014 	ldr	r3, [fp, #-20]
700074f8:	e5c32000 	strb	r2, [r3]
                ++ str;
700074fc:	e51b3014 	ldr	r3, [fp, #-20]
70007500:	e2833001 	add	r3, r3, #1
70007504:	e50b3014 	str	r3, [fp, #-20]
            }
            else
            {
                -- fmt;
            }
            continue;
70007508:	ea000036 	b	700075e8 <rt_vsnprintf+0x868>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
7000750c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70007510:	e2433001 	sub	r3, r3, #1
70007514:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            }
            continue;
70007518:	ea000032 	b	700075e8 <rt_vsnprintf+0x868>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
7000751c:	e1a00000 	nop			; (mov r0, r0)

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
70007520:	e55b301f 	ldrb	r3, [fp, #-31]
70007524:	e353006c 	cmp	r3, #108	; 0x6c
70007528:	1a000008 	bne	70007550 <rt_vsnprintf+0x7d0>
#endif
        {
            num = va_arg(args, rt_uint32_t);
7000752c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70007530:	e2832004 	add	r2, r3, #4
70007534:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
70007538:	e5933000 	ldr	r3, [r3]
7000753c:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int32_t)num;
70007540:	e55b301e 	ldrb	r3, [fp, #-30]
70007544:	e2033002 	and	r3, r3, #2
70007548:	e3530000 	cmp	r3, #0
7000754c:	ea000019 	b	700075b8 <rt_vsnprintf+0x838>
        }
        else if (qualifier == 'h')
70007550:	e55b301f 	ldrb	r3, [fp, #-31]
70007554:	e3530068 	cmp	r3, #104	; 0x68
70007558:	1a00000e 	bne	70007598 <rt_vsnprintf+0x818>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
7000755c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70007560:	e2832004 	add	r2, r3, #4
70007564:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
70007568:	e5933000 	ldr	r3, [r3]
7000756c:	e6ff3073 	uxth	r3, r3
70007570:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int16_t)num;
70007574:	e55b301e 	ldrb	r3, [fp, #-30]
70007578:	e2033002 	and	r3, r3, #2
7000757c:	e3530000 	cmp	r3, #0
70007580:	0a00000c 	beq	700075b8 <rt_vsnprintf+0x838>
70007584:	e51b3008 	ldr	r3, [fp, #-8]
70007588:	e6ff3073 	uxth	r3, r3
7000758c:	e6bf3073 	sxth	r3, r3
70007590:	e50b3008 	str	r3, [fp, #-8]
70007594:	ea000007 	b	700075b8 <rt_vsnprintf+0x838>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
70007598:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
7000759c:	e2832004 	add	r2, r3, #4
700075a0:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
700075a4:	e5933000 	ldr	r3, [r3]
700075a8:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int32_t)num;
700075ac:	e55b301e 	ldrb	r3, [fp, #-30]
700075b0:	e2033002 	and	r3, r3, #2
700075b4:	e3530000 	cmp	r3, #0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
700075b8:	e51b2008 	ldr	r2, [fp, #-8]
700075bc:	e55b301d 	ldrb	r3, [fp, #-29]
700075c0:	e55b101e 	ldrb	r1, [fp, #-30]
700075c4:	e51b0024 	ldr	r0, [fp, #-36]	; 0x24
700075c8:	e58d0000 	str	r0, [sp]
700075cc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
700075d0:	e58d0004 	str	r0, [sp, #4]
700075d4:	e58d1008 	str	r1, [sp, #8]
700075d8:	e51b0014 	ldr	r0, [fp, #-20]
700075dc:	e51b1018 	ldr	r1, [fp, #-24]
700075e0:	ebfffd12 	bl	70006a30 <print_number>
700075e4:	e50b0014 	str	r0, [fp, #-20]
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
700075e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
700075ec:	e2833001 	add	r3, r3, #1
700075f0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
700075f4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
700075f8:	e5d33000 	ldrb	r3, [r3]
700075fc:	e3530000 	cmp	r3, #0
70007600:	1afffdf8 	bne	70006de8 <rt_vsnprintf+0x68>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
70007604:	e51b2014 	ldr	r2, [fp, #-20]
70007608:	e51b3018 	ldr	r3, [fp, #-24]
7000760c:	e1520003 	cmp	r2, r3
70007610:	8a000003 	bhi	70007624 <rt_vsnprintf+0x8a4>
70007614:	e51b3014 	ldr	r3, [fp, #-20]
70007618:	e3a02000 	mov	r2, #0
7000761c:	e5c32000 	strb	r2, [r3]
70007620:	ea000002 	b	70007630 <rt_vsnprintf+0x8b0>
    else *end = '\0';
70007624:	e51b3018 	ldr	r3, [fp, #-24]
70007628:	e3a02000 	mov	r2, #0
7000762c:	e5c32000 	strb	r2, [r3]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
70007630:	e51b2014 	ldr	r2, [fp, #-20]
70007634:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70007638:	e0633002 	rsb	r3, r3, r2
}
7000763c:	e1a00003 	mov	r0, r3
70007640:	e24bd004 	sub	sp, fp, #4
70007644:	e8bd8800 	pop	{fp, pc}

70007648 <rt_snprintf>:
 * @param buf the buffer to save formatted string
 * @param size the size of buffer
 * @param fmt the format
 */
rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
{
70007648:	e92d000c 	push	{r2, r3}
7000764c:	e92d4800 	push	{fp, lr}
70007650:	e28db004 	add	fp, sp, #4
70007654:	e24dd010 	sub	sp, sp, #16
70007658:	e50b0010 	str	r0, [fp, #-16]
7000765c:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t n;
    va_list args;

    va_start(args, fmt);
70007660:	e28b3008 	add	r3, fp, #8
70007664:	e50b300c 	str	r3, [fp, #-12]
    n = rt_vsnprintf(buf, size, fmt, args);
70007668:	e51b0010 	ldr	r0, [fp, #-16]
7000766c:	e51b1014 	ldr	r1, [fp, #-20]
70007670:	e59b2004 	ldr	r2, [fp, #4]
70007674:	e51b300c 	ldr	r3, [fp, #-12]
70007678:	ebfffdc0 	bl	70006d80 <rt_vsnprintf>
7000767c:	e50b0008 	str	r0, [fp, #-8]
    va_end(args);

    return n;
70007680:	e51b3008 	ldr	r3, [fp, #-8]
}
70007684:	e1a00003 	mov	r0, r3
70007688:	e24bd004 	sub	sp, fp, #4
7000768c:	e8bd4800 	pop	{fp, lr}
70007690:	e28dd008 	add	sp, sp, #8
70007694:	e12fff1e 	bx	lr

70007698 <rt_vsprintf>:
 * @param buf the buffer to save formatted string
 * @param arg_ptr the arg_ptr
 * @param format the format
 */
rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
{
70007698:	e92d4800 	push	{fp, lr}
7000769c:	e28db004 	add	fp, sp, #4
700076a0:	e24dd010 	sub	sp, sp, #16
700076a4:	e50b0008 	str	r0, [fp, #-8]
700076a8:	e50b100c 	str	r1, [fp, #-12]
700076ac:	e50b2010 	str	r2, [fp, #-16]
    return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
700076b0:	e51b0008 	ldr	r0, [fp, #-8]
700076b4:	e3e01000 	mvn	r1, #0
700076b8:	e51b200c 	ldr	r2, [fp, #-12]
700076bc:	e51b3010 	ldr	r3, [fp, #-16]
700076c0:	ebfffdae 	bl	70006d80 <rt_vsnprintf>
700076c4:	e1a03000 	mov	r3, r0
}
700076c8:	e1a00003 	mov	r0, r3
700076cc:	e24bd004 	sub	sp, fp, #4
700076d0:	e8bd8800 	pop	{fp, pc}

700076d4 <rt_sprintf>:
 *
 * @param buf the buffer to save formatted string
 * @param format the format
 */
rt_int32_t rt_sprintf(char *buf, const char *format, ...)
{
700076d4:	e92d000e 	push	{r1, r2, r3}
700076d8:	e92d4800 	push	{fp, lr}
700076dc:	e28db004 	add	fp, sp, #4
700076e0:	e24dd014 	sub	sp, sp, #20
700076e4:	e50b0014 	str	r0, [fp, #-20]
    rt_int32_t n;
    va_list arg_ptr;

    va_start(arg_ptr, format);
700076e8:	e28b3008 	add	r3, fp, #8
700076ec:	e50b3010 	str	r3, [fp, #-16]
    n = rt_vsprintf(buf ,format, arg_ptr);
700076f0:	e51b0014 	ldr	r0, [fp, #-20]
700076f4:	e59b1004 	ldr	r1, [fp, #4]
700076f8:	e51b2010 	ldr	r2, [fp, #-16]
700076fc:	ebffffe5 	bl	70007698 <rt_vsprintf>
70007700:	e50b000c 	str	r0, [fp, #-12]
    va_end(arg_ptr);

    return n;
70007704:	e51b300c 	ldr	r3, [fp, #-12]
}
70007708:	e1a00003 	mov	r0, r3
7000770c:	e24bd004 	sub	sp, fp, #4
70007710:	e8bd4800 	pop	{fp, lr}
70007714:	e28dd00c 	add	sp, sp, #12
70007718:	e12fff1e 	bx	lr

7000771c <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
7000771c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70007720:	e28db000 	add	fp, sp, #0
    return _console_device;
70007724:	e3093820 	movw	r3, #38944	; 0x9820
70007728:	e3473002 	movt	r3, #28674	; 0x7002
7000772c:	e5933000 	ldr	r3, [r3]
}
70007730:	e1a00003 	mov	r0, r3
70007734:	e24bd000 	sub	sp, fp, #0
70007738:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000773c:	e12fff1e 	bx	lr

70007740 <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
70007740:	e92d4800 	push	{fp, lr}
70007744:	e28db004 	add	fp, sp, #4
70007748:	e24dd010 	sub	sp, sp, #16
7000774c:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
70007750:	e3093820 	movw	r3, #38944	; 0x9820
70007754:	e3473002 	movt	r3, #28674	; 0x7002
70007758:	e5933000 	ldr	r3, [r3]
7000775c:	e50b3008 	str	r3, [fp, #-8]

    /* find new console device */
    new = rt_device_find(name);
70007760:	e51b0010 	ldr	r0, [fp, #-16]
70007764:	ebffe4af 	bl	70000a28 <rt_device_find>
70007768:	e50b000c 	str	r0, [fp, #-12]
    if (new != RT_NULL)
7000776c:	e51b300c 	ldr	r3, [fp, #-12]
70007770:	e3530000 	cmp	r3, #0
70007774:	0a000013 	beq	700077c8 <rt_console_set_device+0x88>
    {
        if (_console_device != RT_NULL)
70007778:	e3093820 	movw	r3, #38944	; 0x9820
7000777c:	e3473002 	movt	r3, #28674	; 0x7002
70007780:	e5933000 	ldr	r3, [r3]
70007784:	e3530000 	cmp	r3, #0
70007788:	0a000004 	beq	700077a0 <rt_console_set_device+0x60>
        {
            /* close old console device */
            rt_device_close(_console_device);
7000778c:	e3093820 	movw	r3, #38944	; 0x9820
70007790:	e3473002 	movt	r3, #28674	; 0x7002
70007794:	e5933000 	ldr	r3, [r3]
70007798:	e1a00003 	mov	r0, r3
7000779c:	ebffe5b3 	bl	70000e70 <rt_device_close>
        }

        /* set new console device */
        _console_device = new;
700077a0:	e3093820 	movw	r3, #38944	; 0x9820
700077a4:	e3473002 	movt	r3, #28674	; 0x7002
700077a8:	e51b200c 	ldr	r2, [fp, #-12]
700077ac:	e5832000 	str	r2, [r3]
        rt_device_open(_console_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
700077b0:	e3093820 	movw	r3, #38944	; 0x9820
700077b4:	e3473002 	movt	r3, #28674	; 0x7002
700077b8:	e5933000 	ldr	r3, [r3]
700077bc:	e1a00003 	mov	r0, r3
700077c0:	e3a01043 	mov	r1, #67	; 0x43
700077c4:	ebffe513 	bl	70000c18 <rt_device_open>
    }

    return old;
700077c8:	e51b3008 	ldr	r3, [fp, #-8]
}
700077cc:	e1a00003 	mov	r0, r3
700077d0:	e24bd004 	sub	sp, fp, #4
700077d4:	e8bd8800 	pop	{fp, pc}

700077d8 <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
700077d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700077dc:	e28db000 	add	fp, sp, #0
700077e0:	e24dd00c 	sub	sp, sp, #12
700077e4:	e50b0008 	str	r0, [fp, #-8]
    /* empty console output */
}
700077e8:	e24bd000 	sub	sp, fp, #0
700077ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700077f0:	e12fff1e 	bx	lr

700077f4 <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
700077f4:	e92d000f 	push	{r0, r1, r2, r3}
700077f8:	e92d4800 	push	{fp, lr}
700077fc:	e28db004 	add	fp, sp, #4
70007800:	e24dd010 	sub	sp, sp, #16
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
70007804:	e28b3008 	add	r3, fp, #8
70007808:	e50b3010 	str	r3, [fp, #-16]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
7000780c:	e3090824 	movw	r0, #38948	; 0x9824
70007810:	e3470002 	movt	r0, #28674	; 0x7002
70007814:	e3a0107f 	mov	r1, #127	; 0x7f
70007818:	e59b2004 	ldr	r2, [fp, #4]
7000781c:	e51b3010 	ldr	r3, [fp, #-16]
70007820:	ebfffd56 	bl	70006d80 <rt_vsnprintf>
70007824:	e1a03000 	mov	r3, r0
70007828:	e50b3008 	str	r3, [fp, #-8]
    if (length > RT_CONSOLEBUF_SIZE - 1)
7000782c:	e51b3008 	ldr	r3, [fp, #-8]
70007830:	e353007f 	cmp	r3, #127	; 0x7f
70007834:	9a000001 	bls	70007840 <rt_kprintf+0x4c>
        length = RT_CONSOLEBUF_SIZE - 1;
70007838:	e3a0307f 	mov	r3, #127	; 0x7f
7000783c:	e50b3008 	str	r3, [fp, #-8]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
70007840:	e3093820 	movw	r3, #38944	; 0x9820
70007844:	e3473002 	movt	r3, #28674	; 0x7002
70007848:	e5933000 	ldr	r3, [r3]
7000784c:	e3530000 	cmp	r3, #0
70007850:	1a000003 	bne	70007864 <rt_kprintf+0x70>
    {
        rt_hw_console_output(rt_log_buf);
70007854:	e3090824 	movw	r0, #38948	; 0x9824
70007858:	e3470002 	movt	r0, #28674	; 0x7002
7000785c:	ebffffdd 	bl	700077d8 <rt_hw_console_output>
70007860:	ea00001c 	b	700078d8 <rt_kprintf+0xe4>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
70007864:	e3093820 	movw	r3, #38944	; 0x9820
70007868:	e3473002 	movt	r3, #28674	; 0x7002
7000786c:	e5933000 	ldr	r3, [r3]
70007870:	e1d331b4 	ldrh	r3, [r3, #20]
70007874:	e14b30ba 	strh	r3, [fp, #-10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
70007878:	e3093820 	movw	r3, #38944	; 0x9820
7000787c:	e3473002 	movt	r3, #28674	; 0x7002
70007880:	e5932000 	ldr	r2, [r3]
70007884:	e3093820 	movw	r3, #38944	; 0x9820
70007888:	e3473002 	movt	r3, #28674	; 0x7002
7000788c:	e5933000 	ldr	r3, [r3]
70007890:	e1d331b4 	ldrh	r3, [r3, #20]
70007894:	e3833040 	orr	r3, r3, #64	; 0x40
70007898:	e6ff3073 	uxth	r3, r3
7000789c:	e1c231b4 	strh	r3, [r2, #20]
        rt_device_write(_console_device, 0, rt_log_buf, length);
700078a0:	e3093820 	movw	r3, #38944	; 0x9820
700078a4:	e3473002 	movt	r3, #28674	; 0x7002
700078a8:	e5933000 	ldr	r3, [r3]
700078ac:	e1a00003 	mov	r0, r3
700078b0:	e3a01000 	mov	r1, #0
700078b4:	e3092824 	movw	r2, #38948	; 0x9824
700078b8:	e3472002 	movt	r2, #28674	; 0x7002
700078bc:	e51b3008 	ldr	r3, [fp, #-8]
700078c0:	ebffe5fc 	bl	700010b8 <rt_device_write>
        _console_device->open_flag = old_flag;
700078c4:	e3093820 	movw	r3, #38944	; 0x9820
700078c8:	e3473002 	movt	r3, #28674	; 0x7002
700078cc:	e5933000 	ldr	r3, [r3]
700078d0:	e15b20ba 	ldrh	r2, [fp, #-10]
700078d4:	e1c321b4 	strh	r2, [r3, #20]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
700078d8:	e24bd004 	sub	sp, fp, #4
700078dc:	e8bd4800 	pop	{fp, lr}
700078e0:	e28dd010 	add	sp, sp, #16
700078e4:	e12fff1e 	bx	lr

700078e8 <rt_malloc_align>:
 * @param align the alignment size
 *
 * @return the allocated memory block on successful, otherwise returns RT_NULL
 */
void* rt_malloc_align(rt_size_t size, rt_size_t align)
{
700078e8:	e92d4800 	push	{fp, lr}
700078ec:	e28db004 	add	fp, sp, #4
700078f0:	e24dd018 	sub	sp, sp, #24
700078f4:	e50b0018 	str	r0, [fp, #-24]
700078f8:	e50b101c 	str	r1, [fp, #-28]
    void *align_ptr;
    void *ptr;
    rt_size_t align_size;

    /* align the alignment size to 4 byte */
    align = ((align + 0x03) & ~0x03);
700078fc:	e51b301c 	ldr	r3, [fp, #-28]
70007900:	e2833003 	add	r3, r3, #3
70007904:	e3c33003 	bic	r3, r3, #3
70007908:	e50b301c 	str	r3, [fp, #-28]

    /* get total aligned size */
    align_size = ((size + 0x03) & ~0x03) + align;
7000790c:	e51b3018 	ldr	r3, [fp, #-24]
70007910:	e2833003 	add	r3, r3, #3
70007914:	e3c32003 	bic	r2, r3, #3
70007918:	e51b301c 	ldr	r3, [fp, #-28]
7000791c:	e0823003 	add	r3, r2, r3
70007920:	e50b3010 	str	r3, [fp, #-16]
    /* allocate memory block from heap */
    ptr = rt_malloc(align_size);
70007924:	e51b0010 	ldr	r0, [fp, #-16]
70007928:	eb0001e3 	bl	700080bc <rt_malloc>
7000792c:	e50b000c 	str	r0, [fp, #-12]
    if (ptr != RT_NULL)
70007930:	e51b300c 	ldr	r3, [fp, #-12]
70007934:	e3530000 	cmp	r3, #0
70007938:	0a000018 	beq	700079a0 <rt_malloc_align+0xb8>
    {
         /* the allocated memory block is aligned */
        if (((rt_uint32_t)ptr & (align - 1)) == 0)
7000793c:	e51b301c 	ldr	r3, [fp, #-28]
70007940:	e2432001 	sub	r2, r3, #1
70007944:	e51b300c 	ldr	r3, [fp, #-12]
70007948:	e0023003 	and	r3, r2, r3
7000794c:	e3530000 	cmp	r3, #0
70007950:	1a000004 	bne	70007968 <rt_malloc_align+0x80>
        {
            align_ptr = (void *)((rt_uint32_t)ptr + align);
70007954:	e51b200c 	ldr	r2, [fp, #-12]
70007958:	e51b301c 	ldr	r3, [fp, #-28]
7000795c:	e0823003 	add	r3, r2, r3
70007960:	e50b3008 	str	r3, [fp, #-8]
70007964:	ea000007 	b	70007988 <rt_malloc_align+0xa0>
        }
        else
        {
            align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
70007968:	e51b200c 	ldr	r2, [fp, #-12]
7000796c:	e51b301c 	ldr	r3, [fp, #-28]
70007970:	e0823003 	add	r3, r2, r3
70007974:	e2432001 	sub	r2, r3, #1
70007978:	e51b301c 	ldr	r3, [fp, #-28]
7000797c:	e2633000 	rsb	r3, r3, #0
70007980:	e0023003 	and	r3, r2, r3
70007984:	e50b3008 	str	r3, [fp, #-8]
        }

        /* set the pointer before alignment pointer to the real pointer */
        *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
70007988:	e51b3008 	ldr	r3, [fp, #-8]
7000798c:	e2433004 	sub	r3, r3, #4
70007990:	e51b200c 	ldr	r2, [fp, #-12]
70007994:	e5832000 	str	r2, [r3]

        ptr = align_ptr;
70007998:	e51b3008 	ldr	r3, [fp, #-8]
7000799c:	e50b300c 	str	r3, [fp, #-12]
    }

    return ptr;
700079a0:	e51b300c 	ldr	r3, [fp, #-12]
}
700079a4:	e1a00003 	mov	r0, r3
700079a8:	e24bd004 	sub	sp, fp, #4
700079ac:	e8bd8800 	pop	{fp, pc}

700079b0 <rt_free_align>:
 * rt_malloc_align function and address is aligned.
 *
 * @param ptr the memory block pointer
 */
void rt_free_align(void *ptr)
{
700079b0:	e92d4800 	push	{fp, lr}
700079b4:	e28db004 	add	fp, sp, #4
700079b8:	e24dd010 	sub	sp, sp, #16
700079bc:	e50b0010 	str	r0, [fp, #-16]
    void *real_ptr;

    real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
700079c0:	e51b3010 	ldr	r3, [fp, #-16]
700079c4:	e2433004 	sub	r3, r3, #4
700079c8:	e5933000 	ldr	r3, [r3]
700079cc:	e50b3008 	str	r3, [fp, #-8]
    rt_free(real_ptr);
700079d0:	e51b0008 	ldr	r0, [fp, #-8]
700079d4:	eb00047b 	bl	70008bc8 <rt_free>
}
700079d8:	e24bd004 	sub	sp, fp, #4
700079dc:	e8bd8800 	pop	{fp, pc}

700079e0 <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
700079e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700079e4:	e28db000 	add	fp, sp, #0
700079e8:	e24dd00c 	sub	sp, sp, #12
700079ec:	e50b0008 	str	r0, [fp, #-8]
    if (value == 0) return 0;
700079f0:	e51b3008 	ldr	r3, [fp, #-8]
700079f4:	e3530000 	cmp	r3, #0
700079f8:	1a000001 	bne	70007a04 <__rt_ffs+0x24>
700079fc:	e3a03000 	mov	r3, #0
70007a00:	ea000028 	b	70007aa8 <__rt_ffs+0xc8>

    if (value & 0xff)
70007a04:	e51b3008 	ldr	r3, [fp, #-8]
70007a08:	e6ef3073 	uxtb	r3, r3
70007a0c:	e3530000 	cmp	r3, #0
70007a10:	0a000006 	beq	70007a30 <__rt_ffs+0x50>
        return __lowest_bit_bitmap[value & 0xff] + 1;
70007a14:	e51b3008 	ldr	r3, [fp, #-8]
70007a18:	e6ef2073 	uxtb	r2, r3
70007a1c:	e30636b8 	movw	r3, #26296	; 0x66b8
70007a20:	e3473002 	movt	r3, #28674	; 0x7002
70007a24:	e7d33002 	ldrb	r3, [r3, r2]
70007a28:	e2833001 	add	r3, r3, #1
70007a2c:	ea00001d 	b	70007aa8 <__rt_ffs+0xc8>

    if (value & 0xff00)
70007a30:	e51b3008 	ldr	r3, [fp, #-8]
70007a34:	e2033cff 	and	r3, r3, #65280	; 0xff00
70007a38:	e3530000 	cmp	r3, #0
70007a3c:	0a000007 	beq	70007a60 <__rt_ffs+0x80>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
70007a40:	e51b3008 	ldr	r3, [fp, #-8]
70007a44:	e2033cff 	and	r3, r3, #65280	; 0xff00
70007a48:	e1a02443 	asr	r2, r3, #8
70007a4c:	e30636b8 	movw	r3, #26296	; 0x66b8
70007a50:	e3473002 	movt	r3, #28674	; 0x7002
70007a54:	e7d33002 	ldrb	r3, [r3, r2]
70007a58:	e2833009 	add	r3, r3, #9
70007a5c:	ea000011 	b	70007aa8 <__rt_ffs+0xc8>

    if (value & 0xff0000)
70007a60:	e51b3008 	ldr	r3, [fp, #-8]
70007a64:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
70007a68:	e3530000 	cmp	r3, #0
70007a6c:	0a000007 	beq	70007a90 <__rt_ffs+0xb0>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
70007a70:	e51b3008 	ldr	r3, [fp, #-8]
70007a74:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
70007a78:	e1a02843 	asr	r2, r3, #16
70007a7c:	e30636b8 	movw	r3, #26296	; 0x66b8
70007a80:	e3473002 	movt	r3, #28674	; 0x7002
70007a84:	e7d33002 	ldrb	r3, [r3, r2]
70007a88:	e2833011 	add	r3, r3, #17
70007a8c:	ea000005 	b	70007aa8 <__rt_ffs+0xc8>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
70007a90:	e51b3008 	ldr	r3, [fp, #-8]
70007a94:	e1a02c23 	lsr	r2, r3, #24
70007a98:	e30636b8 	movw	r3, #26296	; 0x66b8
70007a9c:	e3473002 	movt	r3, #28674	; 0x7002
70007aa0:	e7d33002 	ldrb	r3, [r3, r2]
70007aa4:	e2833019 	add	r3, r3, #25
}
70007aa8:	e1a00003 	mov	r0, r3
70007aac:	e24bd000 	sub	sp, fp, #0
70007ab0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70007ab4:	e12fff1e 	bx	lr

70007ab8 <rt_assert_set_hook>:
/**
 * This function will set a hook function to RT_ASSERT(EX). It will run when the expression is false.
 *
 * @param hook the hook function
 */
void rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line)) {
70007ab8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70007abc:	e28db000 	add	fp, sp, #0
70007ac0:	e24dd00c 	sub	sp, sp, #12
70007ac4:	e50b0008 	str	r0, [fp, #-8]
    rt_assert_hook = hook;
70007ac8:	e30a3b74 	movw	r3, #43892	; 0xab74
70007acc:	e3473002 	movt	r3, #28674	; 0x7002
70007ad0:	e51b2008 	ldr	r2, [fp, #-8]
70007ad4:	e5832000 	str	r2, [r3]
}
70007ad8:	e24bd000 	sub	sp, fp, #0
70007adc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70007ae0:	e12fff1e 	bx	lr

70007ae4 <rt_malloc_sethook>:
 * block is allocated from heap memory.
 *
 * @param hook the hook function
 */
void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
{
70007ae4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70007ae8:	e28db000 	add	fp, sp, #0
70007aec:	e24dd00c 	sub	sp, sp, #12
70007af0:	e50b0008 	str	r0, [fp, #-8]
    rt_malloc_hook = hook;
70007af4:	e30938a4 	movw	r3, #39076	; 0x98a4
70007af8:	e3473002 	movt	r3, #28674	; 0x7002
70007afc:	e51b2008 	ldr	r2, [fp, #-8]
70007b00:	e5832000 	str	r2, [r3]
}
70007b04:	e24bd000 	sub	sp, fp, #0
70007b08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70007b0c:	e12fff1e 	bx	lr

70007b10 <rt_free_sethook>:
 * block is released to heap memory.
 *
 * @param hook the hook function
 */
void rt_free_sethook(void (*hook)(void *ptr))
{
70007b10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70007b14:	e28db000 	add	fp, sp, #0
70007b18:	e24dd00c 	sub	sp, sp, #12
70007b1c:	e50b0008 	str	r0, [fp, #-8]
    rt_free_hook = hook;
70007b20:	e30938a8 	movw	r3, #39080	; 0x98a8
70007b24:	e3473002 	movt	r3, #28674	; 0x7002
70007b28:	e51b2008 	ldr	r2, [fp, #-8]
70007b2c:	e5832000 	str	r2, [r3]
}
70007b30:	e24bd000 	sub	sp, fp, #0
70007b34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70007b38:	e12fff1e 	bx	lr

70007b3c <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
70007b3c:	e92d4800 	push	{fp, lr}
70007b40:	e28db004 	add	fp, sp, #4
70007b44:	e24dd018 	sub	sp, sp, #24
70007b48:	e50b0018 	str	r0, [fp, #-24]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
70007b4c:	e30938ac 	movw	r3, #39084	; 0x98ac
70007b50:	e3473002 	movt	r3, #28674	; 0x7002
70007b54:	e5933000 	ldr	r3, [r3]
70007b58:	e51b2018 	ldr	r2, [fp, #-24]
70007b5c:	e1520003 	cmp	r2, r3
70007b60:	2a00001d 	bcs	70007bdc <plug_holes+0xa0>
70007b64:	e3a03000 	mov	r3, #0
70007b68:	e54b300d 	strb	r3, [fp, #-13]
70007b6c:	e30a3b74 	movw	r3, #43892	; 0xab74
70007b70:	e3473002 	movt	r3, #28674	; 0x7002
70007b74:	e5933000 	ldr	r3, [r3]
70007b78:	e3530000 	cmp	r3, #0
70007b7c:	1a00000d 	bne	70007bb8 <plug_holes+0x7c>
70007b80:	e30607e0 	movw	r0, #26592	; 0x67e0
70007b84:	e3470002 	movt	r0, #28674	; 0x7002
70007b88:	e3061800 	movw	r1, #26624	; 0x6800
70007b8c:	e3471002 	movt	r1, #28674	; 0x7002
70007b90:	e3062adc 	movw	r2, #27356	; 0x6adc
70007b94:	e3472002 	movt	r2, #28674	; 0x7002
70007b98:	e3a0308d 	mov	r3, #141	; 0x8d
70007b9c:	ebffff14 	bl	700077f4 <rt_kprintf>
70007ba0:	e1a00000 	nop			; (mov r0, r0)
70007ba4:	e55b300d 	ldrb	r3, [fp, #-13]
70007ba8:	e6ef3073 	uxtb	r3, r3
70007bac:	e3530000 	cmp	r3, #0
70007bb0:	0afffffb 	beq	70007ba4 <plug_holes+0x68>
70007bb4:	ea000008 	b	70007bdc <plug_holes+0xa0>
70007bb8:	e30a3b74 	movw	r3, #43892	; 0xab74
70007bbc:	e3473002 	movt	r3, #28674	; 0x7002
70007bc0:	e5933000 	ldr	r3, [r3]
70007bc4:	e3060800 	movw	r0, #26624	; 0x6800
70007bc8:	e3470002 	movt	r0, #28674	; 0x7002
70007bcc:	e3061adc 	movw	r1, #27356	; 0x6adc
70007bd0:	e3471002 	movt	r1, #28674	; 0x7002
70007bd4:	e3a0208d 	mov	r2, #141	; 0x8d
70007bd8:	e12fff33 	blx	r3
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
70007bdc:	e30938b0 	movw	r3, #39088	; 0x98b0
70007be0:	e3473002 	movt	r3, #28674	; 0x7002
70007be4:	e5933000 	ldr	r3, [r3]
70007be8:	e51b2018 	ldr	r2, [fp, #-24]
70007bec:	e1520003 	cmp	r2, r3
70007bf0:	3a00001d 	bcc	70007c6c <plug_holes+0x130>
70007bf4:	e3a03000 	mov	r3, #0
70007bf8:	e54b300e 	strb	r3, [fp, #-14]
70007bfc:	e30a3b74 	movw	r3, #43892	; 0xab74
70007c00:	e3473002 	movt	r3, #28674	; 0x7002
70007c04:	e5933000 	ldr	r3, [r3]
70007c08:	e3530000 	cmp	r3, #0
70007c0c:	1a00000d 	bne	70007c48 <plug_holes+0x10c>
70007c10:	e30607e0 	movw	r0, #26592	; 0x67e0
70007c14:	e3470002 	movt	r0, #28674	; 0x7002
70007c18:	e3061820 	movw	r1, #26656	; 0x6820
70007c1c:	e3471002 	movt	r1, #28674	; 0x7002
70007c20:	e3062adc 	movw	r2, #27356	; 0x6adc
70007c24:	e3472002 	movt	r2, #28674	; 0x7002
70007c28:	e3a0308e 	mov	r3, #142	; 0x8e
70007c2c:	ebfffef0 	bl	700077f4 <rt_kprintf>
70007c30:	e1a00000 	nop			; (mov r0, r0)
70007c34:	e55b300e 	ldrb	r3, [fp, #-14]
70007c38:	e6ef3073 	uxtb	r3, r3
70007c3c:	e3530000 	cmp	r3, #0
70007c40:	0afffffb 	beq	70007c34 <plug_holes+0xf8>
70007c44:	ea000008 	b	70007c6c <plug_holes+0x130>
70007c48:	e30a3b74 	movw	r3, #43892	; 0xab74
70007c4c:	e3473002 	movt	r3, #28674	; 0x7002
70007c50:	e5933000 	ldr	r3, [r3]
70007c54:	e3060820 	movw	r0, #26656	; 0x6820
70007c58:	e3470002 	movt	r0, #28674	; 0x7002
70007c5c:	e3061adc 	movw	r1, #27356	; 0x6adc
70007c60:	e3471002 	movt	r1, #28674	; 0x7002
70007c64:	e3a0208e 	mov	r2, #142	; 0x8e
70007c68:	e12fff33 	blx	r3
    RT_ASSERT(mem->used == 0);
70007c6c:	e51b3018 	ldr	r3, [fp, #-24]
70007c70:	e1d330b2 	ldrh	r3, [r3, #2]
70007c74:	e3530000 	cmp	r3, #0
70007c78:	0a00001d 	beq	70007cf4 <plug_holes+0x1b8>
70007c7c:	e3a03000 	mov	r3, #0
70007c80:	e54b300f 	strb	r3, [fp, #-15]
70007c84:	e30a3b74 	movw	r3, #43892	; 0xab74
70007c88:	e3473002 	movt	r3, #28674	; 0x7002
70007c8c:	e5933000 	ldr	r3, [r3]
70007c90:	e3530000 	cmp	r3, #0
70007c94:	1a00000d 	bne	70007cd0 <plug_holes+0x194>
70007c98:	e30607e0 	movw	r0, #26592	; 0x67e0
70007c9c:	e3470002 	movt	r0, #28674	; 0x7002
70007ca0:	e306184c 	movw	r1, #26700	; 0x684c
70007ca4:	e3471002 	movt	r1, #28674	; 0x7002
70007ca8:	e3062adc 	movw	r2, #27356	; 0x6adc
70007cac:	e3472002 	movt	r2, #28674	; 0x7002
70007cb0:	e3a0308f 	mov	r3, #143	; 0x8f
70007cb4:	ebfffece 	bl	700077f4 <rt_kprintf>
70007cb8:	e1a00000 	nop			; (mov r0, r0)
70007cbc:	e55b300f 	ldrb	r3, [fp, #-15]
70007cc0:	e6ef3073 	uxtb	r3, r3
70007cc4:	e3530000 	cmp	r3, #0
70007cc8:	0afffffb 	beq	70007cbc <plug_holes+0x180>
70007ccc:	ea000008 	b	70007cf4 <plug_holes+0x1b8>
70007cd0:	e30a3b74 	movw	r3, #43892	; 0xab74
70007cd4:	e3473002 	movt	r3, #28674	; 0x7002
70007cd8:	e5933000 	ldr	r3, [r3]
70007cdc:	e306084c 	movw	r0, #26700	; 0x684c
70007ce0:	e3470002 	movt	r0, #28674	; 0x7002
70007ce4:	e3061adc 	movw	r1, #27356	; 0x6adc
70007ce8:	e3471002 	movt	r1, #28674	; 0x7002
70007cec:	e3a0208f 	mov	r2, #143	; 0x8f
70007cf0:	e12fff33 	blx	r3

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
70007cf4:	e30938ac 	movw	r3, #39084	; 0x98ac
70007cf8:	e3473002 	movt	r3, #28674	; 0x7002
70007cfc:	e5932000 	ldr	r2, [r3]
70007d00:	e51b3018 	ldr	r3, [fp, #-24]
70007d04:	e5933004 	ldr	r3, [r3, #4]
70007d08:	e0823003 	add	r3, r2, r3
70007d0c:	e50b3008 	str	r3, [fp, #-8]
    if (mem != nmem &&
70007d10:	e51b2018 	ldr	r2, [fp, #-24]
70007d14:	e51b3008 	ldr	r3, [fp, #-8]
70007d18:	e1520003 	cmp	r2, r3
70007d1c:	0a000023 	beq	70007db0 <plug_holes+0x274>
        nmem->used == 0 &&
70007d20:	e51b3008 	ldr	r3, [fp, #-8]
70007d24:	e1d330b2 	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
70007d28:	e3530000 	cmp	r3, #0
70007d2c:	1a00001f 	bne	70007db0 <plug_holes+0x274>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
70007d30:	e30938b0 	movw	r3, #39088	; 0x98b0
70007d34:	e3473002 	movt	r3, #28674	; 0x7002
70007d38:	e5933000 	ldr	r3, [r3]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
70007d3c:	e51b2008 	ldr	r2, [fp, #-8]
70007d40:	e1520003 	cmp	r2, r3
70007d44:	0a000019 	beq	70007db0 <plug_holes+0x274>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
70007d48:	e30938b4 	movw	r3, #39092	; 0x98b4
70007d4c:	e3473002 	movt	r3, #28674	; 0x7002
70007d50:	e5932000 	ldr	r2, [r3]
70007d54:	e51b3008 	ldr	r3, [fp, #-8]
70007d58:	e1520003 	cmp	r2, r3
70007d5c:	1a000003 	bne	70007d70 <plug_holes+0x234>
        {
            lfree = mem;
70007d60:	e30938b4 	movw	r3, #39092	; 0x98b4
70007d64:	e3473002 	movt	r3, #28674	; 0x7002
70007d68:	e51b2018 	ldr	r2, [fp, #-24]
70007d6c:	e5832000 	str	r2, [r3]
        }
        mem->next = nmem->next;
70007d70:	e51b3008 	ldr	r3, [fp, #-8]
70007d74:	e5932004 	ldr	r2, [r3, #4]
70007d78:	e51b3018 	ldr	r3, [fp, #-24]
70007d7c:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
70007d80:	e30938ac 	movw	r3, #39084	; 0x98ac
70007d84:	e3473002 	movt	r3, #28674	; 0x7002
70007d88:	e5932000 	ldr	r2, [r3]
70007d8c:	e51b3008 	ldr	r3, [fp, #-8]
70007d90:	e5933004 	ldr	r3, [r3, #4]
70007d94:	e0822003 	add	r2, r2, r3
70007d98:	e51b1018 	ldr	r1, [fp, #-24]
70007d9c:	e30938ac 	movw	r3, #39084	; 0x98ac
70007da0:	e3473002 	movt	r3, #28674	; 0x7002
70007da4:	e5933000 	ldr	r3, [r3]
70007da8:	e0633001 	rsb	r3, r3, r1
70007dac:	e5823008 	str	r3, [r2, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
70007db0:	e30938ac 	movw	r3, #39084	; 0x98ac
70007db4:	e3473002 	movt	r3, #28674	; 0x7002
70007db8:	e5932000 	ldr	r2, [r3]
70007dbc:	e51b3018 	ldr	r3, [fp, #-24]
70007dc0:	e5933008 	ldr	r3, [r3, #8]
70007dc4:	e0823003 	add	r3, r2, r3
70007dc8:	e50b300c 	str	r3, [fp, #-12]
    if (pmem != mem && pmem->used == 0)
70007dcc:	e51b200c 	ldr	r2, [fp, #-12]
70007dd0:	e51b3018 	ldr	r3, [fp, #-24]
70007dd4:	e1520003 	cmp	r2, r3
70007dd8:	0a00001d 	beq	70007e54 <plug_holes+0x318>
70007ddc:	e51b300c 	ldr	r3, [fp, #-12]
70007de0:	e1d330b2 	ldrh	r3, [r3, #2]
70007de4:	e3530000 	cmp	r3, #0
70007de8:	1a000019 	bne	70007e54 <plug_holes+0x318>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
70007dec:	e30938b4 	movw	r3, #39092	; 0x98b4
70007df0:	e3473002 	movt	r3, #28674	; 0x7002
70007df4:	e5932000 	ldr	r2, [r3]
70007df8:	e51b3018 	ldr	r3, [fp, #-24]
70007dfc:	e1520003 	cmp	r2, r3
70007e00:	1a000003 	bne	70007e14 <plug_holes+0x2d8>
        {
            lfree = pmem;
70007e04:	e30938b4 	movw	r3, #39092	; 0x98b4
70007e08:	e3473002 	movt	r3, #28674	; 0x7002
70007e0c:	e51b200c 	ldr	r2, [fp, #-12]
70007e10:	e5832000 	str	r2, [r3]
        }
        pmem->next = mem->next;
70007e14:	e51b3018 	ldr	r3, [fp, #-24]
70007e18:	e5932004 	ldr	r2, [r3, #4]
70007e1c:	e51b300c 	ldr	r3, [fp, #-12]
70007e20:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
70007e24:	e30938ac 	movw	r3, #39084	; 0x98ac
70007e28:	e3473002 	movt	r3, #28674	; 0x7002
70007e2c:	e5932000 	ldr	r2, [r3]
70007e30:	e51b3018 	ldr	r3, [fp, #-24]
70007e34:	e5933004 	ldr	r3, [r3, #4]
70007e38:	e0822003 	add	r2, r2, r3
70007e3c:	e51b100c 	ldr	r1, [fp, #-12]
70007e40:	e30938ac 	movw	r3, #39084	; 0x98ac
70007e44:	e3473002 	movt	r3, #28674	; 0x7002
70007e48:	e5933000 	ldr	r3, [r3]
70007e4c:	e0633001 	rsb	r3, r3, r1
70007e50:	e5823008 	str	r3, [r2, #8]
    }
}
70007e54:	e24bd004 	sub	sp, fp, #4
70007e58:	e8bd8800 	pop	{fp, pc}

70007e5c <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
70007e5c:	e92d4800 	push	{fp, lr}
70007e60:	e28db004 	add	fp, sp, #4
70007e64:	e24dd020 	sub	sp, sp, #32
70007e68:	e50b0020 	str	r0, [fp, #-32]
70007e6c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
70007e70:	e51b3020 	ldr	r3, [fp, #-32]
70007e74:	e2833003 	add	r3, r3, #3
70007e78:	e3c33003 	bic	r3, r3, #3
70007e7c:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
70007e80:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70007e84:	e3c33003 	bic	r3, r3, #3
70007e88:	e50b300c 	str	r3, [fp, #-12]

    RT_DEBUG_NOT_IN_INTERRUPT;
70007e8c:	eb0018ed 	bl	7000e248 <rt_hw_interrupt_disable>
70007e90:	e50b0010 	str	r0, [fp, #-16]
70007e94:	ebfff806 	bl	70005eb4 <rt_interrupt_get_nest>
70007e98:	e1a03000 	mov	r3, r0
70007e9c:	e3530000 	cmp	r3, #0
70007ea0:	0a000022 	beq	70007f30 <rt_system_heap_init+0xd4>
70007ea4:	e306085c 	movw	r0, #26716	; 0x685c
70007ea8:	e3470002 	movt	r0, #28674	; 0x7002
70007eac:	e3061ae8 	movw	r1, #27368	; 0x6ae8
70007eb0:	e3471002 	movt	r1, #28674	; 0x7002
70007eb4:	ebfffe4e 	bl	700077f4 <rt_kprintf>
70007eb8:	e3a03000 	mov	r3, #0
70007ebc:	e54b3015 	strb	r3, [fp, #-21]
70007ec0:	e30a3b74 	movw	r3, #43892	; 0xab74
70007ec4:	e3473002 	movt	r3, #28674	; 0x7002
70007ec8:	e5933000 	ldr	r3, [r3]
70007ecc:	e3530000 	cmp	r3, #0
70007ed0:	1a00000d 	bne	70007f0c <rt_system_heap_init+0xb0>
70007ed4:	e30607e0 	movw	r0, #26592	; 0x67e0
70007ed8:	e3470002 	movt	r0, #28674	; 0x7002
70007edc:	e3061880 	movw	r1, #26752	; 0x6880
70007ee0:	e3471002 	movt	r1, #28674	; 0x7002
70007ee4:	e3062ae8 	movw	r2, #27368	; 0x6ae8
70007ee8:	e3472002 	movt	r2, #28674	; 0x7002
70007eec:	e3a030be 	mov	r3, #190	; 0xbe
70007ef0:	ebfffe3f 	bl	700077f4 <rt_kprintf>
70007ef4:	e1a00000 	nop			; (mov r0, r0)
70007ef8:	e55b3015 	ldrb	r3, [fp, #-21]
70007efc:	e6ef3073 	uxtb	r3, r3
70007f00:	e3530000 	cmp	r3, #0
70007f04:	0afffffb 	beq	70007ef8 <rt_system_heap_init+0x9c>
70007f08:	ea000008 	b	70007f30 <rt_system_heap_init+0xd4>
70007f0c:	e30a3b74 	movw	r3, #43892	; 0xab74
70007f10:	e3473002 	movt	r3, #28674	; 0x7002
70007f14:	e5933000 	ldr	r3, [r3]
70007f18:	e3060880 	movw	r0, #26752	; 0x6880
70007f1c:	e3470002 	movt	r0, #28674	; 0x7002
70007f20:	e3061ae8 	movw	r1, #27368	; 0x6ae8
70007f24:	e3471002 	movt	r1, #28674	; 0x7002
70007f28:	e3a020be 	mov	r2, #190	; 0xbe
70007f2c:	e12fff33 	blx	r3
70007f30:	e51b0010 	ldr	r0, [fp, #-16]
70007f34:	eb0018c6 	bl	7000e254 <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
70007f38:	e51b300c 	ldr	r3, [fp, #-12]
70007f3c:	e3530018 	cmp	r3, #24
70007f40:	9a000053 	bls	70008094 <rt_system_heap_init+0x238>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
70007f44:	e51b300c 	ldr	r3, [fp, #-12]
70007f48:	e2432018 	sub	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
70007f4c:	e51b3008 	ldr	r3, [fp, #-8]
70007f50:	e1520003 	cmp	r2, r3
70007f54:	3a00004e 	bcc	70008094 <rt_system_heap_init+0x238>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
70007f58:	e51b200c 	ldr	r2, [fp, #-12]
70007f5c:	e51b3008 	ldr	r3, [fp, #-8]
70007f60:	e0633002 	rsb	r3, r3, r2
70007f64:	e2432018 	sub	r2, r3, #24
70007f68:	e30938d4 	movw	r3, #39124	; 0x98d4
70007f6c:	e3473002 	movt	r3, #28674	; 0x7002
70007f70:	e5832000 	str	r2, [r3]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
70007f74:	e51b2008 	ldr	r2, [fp, #-8]
70007f78:	e30938ac 	movw	r3, #39084	; 0x98ac
70007f7c:	e3473002 	movt	r3, #28674	; 0x7002
70007f80:	e5832000 	str	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
70007f84:	e30938ac 	movw	r3, #39084	; 0x98ac
70007f88:	e3473002 	movt	r3, #28674	; 0x7002
70007f8c:	e5933000 	ldr	r3, [r3]
70007f90:	e50b3014 	str	r3, [fp, #-20]
    mem->magic = HEAP_MAGIC;
70007f94:	e51b3014 	ldr	r3, [fp, #-20]
70007f98:	e3012ea0 	movw	r2, #7840	; 0x1ea0
70007f9c:	e1c320b0 	strh	r2, [r3]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
70007fa0:	e30938d4 	movw	r3, #39124	; 0x98d4
70007fa4:	e3473002 	movt	r3, #28674	; 0x7002
70007fa8:	e5933000 	ldr	r3, [r3]
70007fac:	e283200c 	add	r2, r3, #12
70007fb0:	e51b3014 	ldr	r3, [fp, #-20]
70007fb4:	e5832004 	str	r2, [r3, #4]
    mem->prev  = 0;
70007fb8:	e51b3014 	ldr	r3, [fp, #-20]
70007fbc:	e3a02000 	mov	r2, #0
70007fc0:	e5832008 	str	r2, [r3, #8]
    mem->used  = 0;
70007fc4:	e51b3014 	ldr	r3, [fp, #-20]
70007fc8:	e3a02000 	mov	r2, #0
70007fcc:	e1c320b2 	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
70007fd0:	e30938ac 	movw	r3, #39084	; 0x98ac
70007fd4:	e3473002 	movt	r3, #28674	; 0x7002
70007fd8:	e5932000 	ldr	r2, [r3]
70007fdc:	e51b3014 	ldr	r3, [fp, #-20]
70007fe0:	e5933004 	ldr	r3, [r3, #4]
70007fe4:	e0822003 	add	r2, r2, r3
70007fe8:	e30938b0 	movw	r3, #39088	; 0x98b0
70007fec:	e3473002 	movt	r3, #28674	; 0x7002
70007ff0:	e5832000 	str	r2, [r3]
    heap_end->magic = HEAP_MAGIC;
70007ff4:	e30938b0 	movw	r3, #39088	; 0x98b0
70007ff8:	e3473002 	movt	r3, #28674	; 0x7002
70007ffc:	e5933000 	ldr	r3, [r3]
70008000:	e3012ea0 	movw	r2, #7840	; 0x1ea0
70008004:	e1c320b0 	strh	r2, [r3]
    heap_end->used  = 1;
70008008:	e30938b0 	movw	r3, #39088	; 0x98b0
7000800c:	e3473002 	movt	r3, #28674	; 0x7002
70008010:	e5933000 	ldr	r3, [r3]
70008014:	e3a02001 	mov	r2, #1
70008018:	e1c320b2 	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
7000801c:	e30938b0 	movw	r3, #39088	; 0x98b0
70008020:	e3473002 	movt	r3, #28674	; 0x7002
70008024:	e5932000 	ldr	r2, [r3]
70008028:	e30938d4 	movw	r3, #39124	; 0x98d4
7000802c:	e3473002 	movt	r3, #28674	; 0x7002
70008030:	e5933000 	ldr	r3, [r3]
70008034:	e283300c 	add	r3, r3, #12
70008038:	e5823004 	str	r3, [r2, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
7000803c:	e30938b0 	movw	r3, #39088	; 0x98b0
70008040:	e3473002 	movt	r3, #28674	; 0x7002
70008044:	e5932000 	ldr	r2, [r3]
70008048:	e30938d4 	movw	r3, #39124	; 0x98d4
7000804c:	e3473002 	movt	r3, #28674	; 0x7002
70008050:	e5933000 	ldr	r3, [r3]
70008054:	e283300c 	add	r3, r3, #12
70008058:	e5823008 	str	r3, [r2, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
7000805c:	e30908b8 	movw	r0, #39096	; 0x98b8
70008060:	e3470002 	movt	r0, #28674	; 0x7002
70008064:	e30618c0 	movw	r1, #26816	; 0x68c0
70008068:	e3471002 	movt	r1, #28674	; 0x7002
7000806c:	e3a02001 	mov	r2, #1
70008070:	e3a03000 	mov	r3, #0
70008074:	ebffe64a 	bl	700019a4 <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
70008078:	e30938ac 	movw	r3, #39084	; 0x98ac
7000807c:	e3473002 	movt	r3, #28674	; 0x7002
70008080:	e5932000 	ldr	r2, [r3]
70008084:	e30938b4 	movw	r3, #39092	; 0x98b4
70008088:	e3473002 	movt	r3, #28674	; 0x7002
7000808c:	e5832000 	str	r2, [r3]
70008090:	ea000007 	b	700080b4 <rt_system_heap_init+0x258>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
70008094:	e51b2020 	ldr	r2, [fp, #-32]
70008098:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7000809c:	e3060884 	movw	r0, #26756	; 0x6884
700080a0:	e3470002 	movt	r0, #28674	; 0x7002
700080a4:	e1a01002 	mov	r1, r2
700080a8:	e1a02003 	mov	r2, r3
700080ac:	ebfffdd0 	bl	700077f4 <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
700080b0:	e1a00000 	nop			; (mov r0, r0)

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
700080b4:	e24bd004 	sub	sp, fp, #4
700080b8:	e8bd8800 	pop	{fp, pc}

700080bc <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
700080bc:	e92d4800 	push	{fp, lr}
700080c0:	e28db004 	add	fp, sp, #4
700080c4:	e24dd028 	sub	sp, sp, #40	; 0x28
700080c8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
700080cc:	eb00185d 	bl	7000e248 <rt_hw_interrupt_disable>
700080d0:	e50b000c 	str	r0, [fp, #-12]
700080d4:	ebfff776 	bl	70005eb4 <rt_interrupt_get_nest>
700080d8:	e1a03000 	mov	r3, r0
700080dc:	e3530000 	cmp	r3, #0
700080e0:	0a000022 	beq	70008170 <rt_malloc+0xb4>
700080e4:	e306085c 	movw	r0, #26716	; 0x685c
700080e8:	e3470002 	movt	r0, #28674	; 0x7002
700080ec:	e3061afc 	movw	r1, #27388	; 0x6afc
700080f0:	e3471002 	movt	r1, #28674	; 0x7002
700080f4:	ebfffdbe 	bl	700077f4 <rt_kprintf>
700080f8:	e3a03000 	mov	r3, #0
700080fc:	e54b3019 	strb	r3, [fp, #-25]
70008100:	e30a3b74 	movw	r3, #43892	; 0xab74
70008104:	e3473002 	movt	r3, #28674	; 0x7002
70008108:	e5933000 	ldr	r3, [r3]
7000810c:	e3530000 	cmp	r3, #0
70008110:	1a00000d 	bne	7000814c <rt_malloc+0x90>
70008114:	e30607e0 	movw	r0, #26592	; 0x67e0
70008118:	e3470002 	movt	r0, #28674	; 0x7002
7000811c:	e3061880 	movw	r1, #26752	; 0x6880
70008120:	e3471002 	movt	r1, #28674	; 0x7002
70008124:	e3062afc 	movw	r2, #27388	; 0x6afc
70008128:	e3472002 	movt	r2, #28674	; 0x7002
7000812c:	e3a030fb 	mov	r3, #251	; 0xfb
70008130:	ebfffdaf 	bl	700077f4 <rt_kprintf>
70008134:	e1a00000 	nop			; (mov r0, r0)
70008138:	e55b3019 	ldrb	r3, [fp, #-25]
7000813c:	e6ef3073 	uxtb	r3, r3
70008140:	e3530000 	cmp	r3, #0
70008144:	0afffffb 	beq	70008138 <rt_malloc+0x7c>
70008148:	ea000008 	b	70008170 <rt_malloc+0xb4>
7000814c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008150:	e3473002 	movt	r3, #28674	; 0x7002
70008154:	e5933000 	ldr	r3, [r3]
70008158:	e3060880 	movw	r0, #26752	; 0x6880
7000815c:	e3470002 	movt	r0, #28674	; 0x7002
70008160:	e3061afc 	movw	r1, #27388	; 0x6afc
70008164:	e3471002 	movt	r1, #28674	; 0x7002
70008168:	e3a020fb 	mov	r2, #251	; 0xfb
7000816c:	e12fff33 	blx	r3
70008170:	e51b000c 	ldr	r0, [fp, #-12]
70008174:	eb001836 	bl	7000e254 <rt_hw_interrupt_enable>

    if (size == 0)
70008178:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000817c:	e3530000 	cmp	r3, #0
70008180:	1a000001 	bne	7000818c <rt_malloc+0xd0>
        return RT_NULL;
70008184:	e3a03000 	mov	r3, #0
70008188:	ea00017f 	b	7000878c <rt_malloc+0x6d0>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
7000818c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008190:	e2833003 	add	r3, r3, #3
70008194:	e3c33003 	bic	r3, r3, #3
70008198:	e50b3028 	str	r3, [fp, #-40]	; 0x28

    if (size > mem_size_aligned)
7000819c:	e30938d4 	movw	r3, #39124	; 0x98d4
700081a0:	e3473002 	movt	r3, #28674	; 0x7002
700081a4:	e5933000 	ldr	r3, [r3]
700081a8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700081ac:	e1520003 	cmp	r2, r3
700081b0:	9a000001 	bls	700081bc <rt_malloc+0x100>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
700081b4:	e3a03000 	mov	r3, #0
700081b8:	ea000173 	b	7000878c <rt_malloc+0x6d0>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
700081bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700081c0:	e353000b 	cmp	r3, #11
700081c4:	8a000001 	bhi	700081d0 <rt_malloc+0x114>
        size = MIN_SIZE_ALIGNED;
700081c8:	e3a0300c 	mov	r3, #12
700081cc:	e50b3028 	str	r3, [fp, #-40]	; 0x28

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
700081d0:	e30908b8 	movw	r0, #39096	; 0x98b8
700081d4:	e3470002 	movt	r0, #28674	; 0x7002
700081d8:	e3e01000 	mvn	r1, #0
700081dc:	ebffe6ff 	bl	70001de0 <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
700081e0:	e30938b4 	movw	r3, #39092	; 0x98b4
700081e4:	e3473002 	movt	r3, #28674	; 0x7002
700081e8:	e5933000 	ldr	r3, [r3]
700081ec:	e1a02003 	mov	r2, r3
700081f0:	e30938ac 	movw	r3, #39084	; 0x98ac
700081f4:	e3473002 	movt	r3, #28674	; 0x7002
700081f8:	e5933000 	ldr	r3, [r3]
700081fc:	e0633002 	rsb	r3, r3, r2
70008200:	e50b3008 	str	r3, [fp, #-8]
70008204:	ea000154 	b	7000875c <rt_malloc+0x6a0>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
70008208:	e30938ac 	movw	r3, #39084	; 0x98ac
7000820c:	e3473002 	movt	r3, #28674	; 0x7002
70008210:	e5932000 	ldr	r2, [r3]
70008214:	e51b3008 	ldr	r3, [fp, #-8]
70008218:	e0823003 	add	r3, r2, r3
7000821c:	e50b3010 	str	r3, [fp, #-16]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
70008220:	e51b3010 	ldr	r3, [fp, #-16]
70008224:	e1d330b2 	ldrh	r3, [r3, #2]
70008228:	e3530000 	cmp	r3, #0
7000822c:	1a000143 	bne	70008740 <rt_malloc+0x684>
70008230:	e51b3010 	ldr	r3, [fp, #-16]
70008234:	e5932004 	ldr	r2, [r3, #4]
70008238:	e51b3008 	ldr	r3, [fp, #-8]
7000823c:	e0633002 	rsb	r3, r3, r2
70008240:	e243200c 	sub	r2, r3, #12
70008244:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008248:	e1520003 	cmp	r2, r3
7000824c:	3a00013b 	bcc	70008740 <rt_malloc+0x684>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
70008250:	e51b3010 	ldr	r3, [fp, #-16]
70008254:	e5932004 	ldr	r2, [r3, #4]
70008258:	e51b3008 	ldr	r3, [fp, #-8]
7000825c:	e0633002 	rsb	r3, r3, r2
70008260:	e243200c 	sub	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
70008264:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008268:	e2833018 	add	r3, r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
7000826c:	e1520003 	cmp	r2, r3
70008270:	3a000042 	bcc	70008380 <rt_malloc+0x2c4>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
70008274:	e51b2008 	ldr	r2, [fp, #-8]
70008278:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000827c:	e0823003 	add	r3, r2, r3
70008280:	e283300c 	add	r3, r3, #12
70008284:	e50b3014 	str	r3, [fp, #-20]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
70008288:	e30938ac 	movw	r3, #39084	; 0x98ac
7000828c:	e3473002 	movt	r3, #28674	; 0x7002
70008290:	e5932000 	ldr	r2, [r3]
70008294:	e51b3014 	ldr	r3, [fp, #-20]
70008298:	e0823003 	add	r3, r2, r3
7000829c:	e50b3018 	str	r3, [fp, #-24]
                mem2->used = 0;
700082a0:	e51b3018 	ldr	r3, [fp, #-24]
700082a4:	e3a02000 	mov	r2, #0
700082a8:	e1c320b2 	strh	r2, [r3, #2]
                mem2->next = mem->next;
700082ac:	e51b3010 	ldr	r3, [fp, #-16]
700082b0:	e5932004 	ldr	r2, [r3, #4]
700082b4:	e51b3018 	ldr	r3, [fp, #-24]
700082b8:	e5832004 	str	r2, [r3, #4]
                mem2->prev = ptr;
700082bc:	e51b3018 	ldr	r3, [fp, #-24]
700082c0:	e51b2008 	ldr	r2, [fp, #-8]
700082c4:	e5832008 	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
700082c8:	e51b3010 	ldr	r3, [fp, #-16]
700082cc:	e51b2014 	ldr	r2, [fp, #-20]
700082d0:	e5832004 	str	r2, [r3, #4]
                mem->used = 1;
700082d4:	e51b3010 	ldr	r3, [fp, #-16]
700082d8:	e3a02001 	mov	r2, #1
700082dc:	e1c320b2 	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
700082e0:	e51b3018 	ldr	r3, [fp, #-24]
700082e4:	e5932004 	ldr	r2, [r3, #4]
700082e8:	e30938d4 	movw	r3, #39124	; 0x98d4
700082ec:	e3473002 	movt	r3, #28674	; 0x7002
700082f0:	e5933000 	ldr	r3, [r3]
700082f4:	e283300c 	add	r3, r3, #12
700082f8:	e1520003 	cmp	r2, r3
700082fc:	0a000007 	beq	70008320 <rt_malloc+0x264>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
70008300:	e30938ac 	movw	r3, #39084	; 0x98ac
70008304:	e3473002 	movt	r3, #28674	; 0x7002
70008308:	e5932000 	ldr	r2, [r3]
7000830c:	e51b3018 	ldr	r3, [fp, #-24]
70008310:	e5933004 	ldr	r3, [r3, #4]
70008314:	e0823003 	add	r3, r2, r3
70008318:	e51b2014 	ldr	r2, [fp, #-20]
7000831c:	e5832008 	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
70008320:	e30938d8 	movw	r3, #39128	; 0x98d8
70008324:	e3473002 	movt	r3, #28674	; 0x7002
70008328:	e5932000 	ldr	r2, [r3]
7000832c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008330:	e0823003 	add	r3, r2, r3
70008334:	e283200c 	add	r2, r3, #12
70008338:	e30938d8 	movw	r3, #39128	; 0x98d8
7000833c:	e3473002 	movt	r3, #28674	; 0x7002
70008340:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
70008344:	e30938dc 	movw	r3, #39132	; 0x98dc
70008348:	e3473002 	movt	r3, #28674	; 0x7002
7000834c:	e5932000 	ldr	r2, [r3]
70008350:	e30938d8 	movw	r3, #39128	; 0x98d8
70008354:	e3473002 	movt	r3, #28674	; 0x7002
70008358:	e5933000 	ldr	r3, [r3]
7000835c:	e1520003 	cmp	r2, r3
70008360:	2a000027 	bcs	70008404 <rt_malloc+0x348>
                    max_mem = used_mem;
70008364:	e30938d8 	movw	r3, #39128	; 0x98d8
70008368:	e3473002 	movt	r3, #28674	; 0x7002
7000836c:	e5932000 	ldr	r2, [r3]
70008370:	e30938dc 	movw	r3, #39132	; 0x98dc
70008374:	e3473002 	movt	r3, #28674	; 0x7002
70008378:	e5832000 	str	r2, [r3]
7000837c:	ea000020 	b	70008404 <rt_malloc+0x348>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
70008380:	e51b3010 	ldr	r3, [fp, #-16]
70008384:	e3a02001 	mov	r2, #1
70008388:	e1c320b2 	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
7000838c:	e51b3010 	ldr	r3, [fp, #-16]
70008390:	e5932004 	ldr	r2, [r3, #4]
70008394:	e30938ac 	movw	r3, #39084	; 0x98ac
70008398:	e3473002 	movt	r3, #28674	; 0x7002
7000839c:	e5933000 	ldr	r3, [r3]
700083a0:	e1a01003 	mov	r1, r3
700083a4:	e51b3010 	ldr	r3, [fp, #-16]
700083a8:	e0633001 	rsb	r3, r3, r1
700083ac:	e0822003 	add	r2, r2, r3
700083b0:	e30938d8 	movw	r3, #39128	; 0x98d8
700083b4:	e3473002 	movt	r3, #28674	; 0x7002
700083b8:	e5933000 	ldr	r3, [r3]
700083bc:	e0822003 	add	r2, r2, r3
700083c0:	e30938d8 	movw	r3, #39128	; 0x98d8
700083c4:	e3473002 	movt	r3, #28674	; 0x7002
700083c8:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
700083cc:	e30938dc 	movw	r3, #39132	; 0x98dc
700083d0:	e3473002 	movt	r3, #28674	; 0x7002
700083d4:	e5932000 	ldr	r2, [r3]
700083d8:	e30938d8 	movw	r3, #39128	; 0x98d8
700083dc:	e3473002 	movt	r3, #28674	; 0x7002
700083e0:	e5933000 	ldr	r3, [r3]
700083e4:	e1520003 	cmp	r2, r3
700083e8:	2a000005 	bcs	70008404 <rt_malloc+0x348>
                    max_mem = used_mem;
700083ec:	e30938d8 	movw	r3, #39128	; 0x98d8
700083f0:	e3473002 	movt	r3, #28674	; 0x7002
700083f4:	e5932000 	ldr	r2, [r3]
700083f8:	e30938dc 	movw	r3, #39132	; 0x98dc
700083fc:	e3473002 	movt	r3, #28674	; 0x7002
70008400:	e5832000 	str	r2, [r3]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
70008404:	e51b3010 	ldr	r3, [fp, #-16]
70008408:	e3012ea0 	movw	r2, #7840	; 0x1ea0
7000840c:	e1c320b0 	strh	r2, [r3]

            if (mem == lfree)
70008410:	e30938b4 	movw	r3, #39092	; 0x98b4
70008414:	e3473002 	movt	r3, #28674	; 0x7002
70008418:	e5933000 	ldr	r3, [r3]
7000841c:	e51b2010 	ldr	r2, [fp, #-16]
70008420:	e1520003 	cmp	r2, r3
70008424:	1a000045 	bne	70008540 <rt_malloc+0x484>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
70008428:	ea00000a 	b	70008458 <rt_malloc+0x39c>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
7000842c:	e30938ac 	movw	r3, #39084	; 0x98ac
70008430:	e3473002 	movt	r3, #28674	; 0x7002
70008434:	e5932000 	ldr	r2, [r3]
70008438:	e30938b4 	movw	r3, #39092	; 0x98b4
7000843c:	e3473002 	movt	r3, #28674	; 0x7002
70008440:	e5933000 	ldr	r3, [r3]
70008444:	e5933004 	ldr	r3, [r3, #4]
70008448:	e0822003 	add	r2, r2, r3
7000844c:	e30938b4 	movw	r3, #39092	; 0x98b4
70008450:	e3473002 	movt	r3, #28674	; 0x7002
70008454:	e5832000 	str	r2, [r3]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
70008458:	e30938b4 	movw	r3, #39092	; 0x98b4
7000845c:	e3473002 	movt	r3, #28674	; 0x7002
70008460:	e5933000 	ldr	r3, [r3]
70008464:	e1d330b2 	ldrh	r3, [r3, #2]
70008468:	e3530000 	cmp	r3, #0
7000846c:	0a000007 	beq	70008490 <rt_malloc+0x3d4>
70008470:	e30938b4 	movw	r3, #39092	; 0x98b4
70008474:	e3473002 	movt	r3, #28674	; 0x7002
70008478:	e5932000 	ldr	r2, [r3]
7000847c:	e30938b0 	movw	r3, #39088	; 0x98b0
70008480:	e3473002 	movt	r3, #28674	; 0x7002
70008484:	e5933000 	ldr	r3, [r3]
70008488:	e1520003 	cmp	r2, r3
7000848c:	1affffe6 	bne	7000842c <rt_malloc+0x370>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
70008490:	e30938b4 	movw	r3, #39092	; 0x98b4
70008494:	e3473002 	movt	r3, #28674	; 0x7002
70008498:	e5932000 	ldr	r2, [r3]
7000849c:	e30938b0 	movw	r3, #39088	; 0x98b0
700084a0:	e3473002 	movt	r3, #28674	; 0x7002
700084a4:	e5933000 	ldr	r3, [r3]
700084a8:	e1520003 	cmp	r2, r3
700084ac:	0a000023 	beq	70008540 <rt_malloc+0x484>
700084b0:	e30938b4 	movw	r3, #39092	; 0x98b4
700084b4:	e3473002 	movt	r3, #28674	; 0x7002
700084b8:	e5933000 	ldr	r3, [r3]
700084bc:	e1d330b2 	ldrh	r3, [r3, #2]
700084c0:	e3530000 	cmp	r3, #0
700084c4:	0a00001d 	beq	70008540 <rt_malloc+0x484>
700084c8:	e3a03000 	mov	r3, #0
700084cc:	e54b301a 	strb	r3, [fp, #-26]
700084d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700084d4:	e3473002 	movt	r3, #28674	; 0x7002
700084d8:	e5933000 	ldr	r3, [r3]
700084dc:	e3530000 	cmp	r3, #0
700084e0:	1a00000d 	bne	7000851c <rt_malloc+0x460>
700084e4:	e30607e0 	movw	r0, #26592	; 0x67e0
700084e8:	e3470002 	movt	r0, #28674	; 0x7002
700084ec:	e30618c8 	movw	r1, #26824	; 0x68c8
700084f0:	e3471002 	movt	r1, #28674	; 0x7002
700084f4:	e3062afc 	movw	r2, #27388	; 0x6afc
700084f8:	e3472002 	movt	r2, #28674	; 0x7002
700084fc:	e300315e 	movw	r3, #350	; 0x15e
70008500:	ebfffcbb 	bl	700077f4 <rt_kprintf>
70008504:	e1a00000 	nop			; (mov r0, r0)
70008508:	e55b301a 	ldrb	r3, [fp, #-26]
7000850c:	e6ef3073 	uxtb	r3, r3
70008510:	e3530000 	cmp	r3, #0
70008514:	0afffffb 	beq	70008508 <rt_malloc+0x44c>
70008518:	ea000008 	b	70008540 <rt_malloc+0x484>
7000851c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008520:	e3473002 	movt	r3, #28674	; 0x7002
70008524:	e5933000 	ldr	r3, [r3]
70008528:	e30608c8 	movw	r0, #26824	; 0x68c8
7000852c:	e3470002 	movt	r0, #28674	; 0x7002
70008530:	e3061afc 	movw	r1, #27388	; 0x6afc
70008534:	e3471002 	movt	r1, #28674	; 0x7002
70008538:	e300215e 	movw	r2, #350	; 0x15e
7000853c:	e12fff33 	blx	r3
            }

            rt_sem_release(&heap_sem);
70008540:	e30908b8 	movw	r0, #39096	; 0x98b8
70008544:	e3470002 	movt	r0, #28674	; 0x7002
70008548:	ebffe700 	bl	70002150 <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
7000854c:	e51b2010 	ldr	r2, [fp, #-16]
70008550:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008554:	e0823003 	add	r3, r2, r3
70008558:	e283200c 	add	r2, r3, #12
7000855c:	e30938b0 	movw	r3, #39088	; 0x98b0
70008560:	e3473002 	movt	r3, #28674	; 0x7002
70008564:	e5933000 	ldr	r3, [r3]
70008568:	e1520003 	cmp	r2, r3
7000856c:	9a00001d 	bls	700085e8 <rt_malloc+0x52c>
70008570:	e3a03000 	mov	r3, #0
70008574:	e54b301b 	strb	r3, [fp, #-27]
70008578:	e30a3b74 	movw	r3, #43892	; 0xab74
7000857c:	e3473002 	movt	r3, #28674	; 0x7002
70008580:	e5933000 	ldr	r3, [r3]
70008584:	e3530000 	cmp	r3, #0
70008588:	1a00000d 	bne	700085c4 <rt_malloc+0x508>
7000858c:	e30607e0 	movw	r0, #26592	; 0x67e0
70008590:	e3470002 	movt	r0, #28674	; 0x7002
70008594:	e30618f0 	movw	r1, #26864	; 0x68f0
70008598:	e3471002 	movt	r1, #28674	; 0x7002
7000859c:	e3062afc 	movw	r2, #27388	; 0x6afc
700085a0:	e3472002 	movt	r2, #28674	; 0x7002
700085a4:	e3003162 	movw	r3, #354	; 0x162
700085a8:	ebfffc91 	bl	700077f4 <rt_kprintf>
700085ac:	e1a00000 	nop			; (mov r0, r0)
700085b0:	e55b301b 	ldrb	r3, [fp, #-27]
700085b4:	e6ef3073 	uxtb	r3, r3
700085b8:	e3530000 	cmp	r3, #0
700085bc:	0afffffb 	beq	700085b0 <rt_malloc+0x4f4>
700085c0:	ea000008 	b	700085e8 <rt_malloc+0x52c>
700085c4:	e30a3b74 	movw	r3, #43892	; 0xab74
700085c8:	e3473002 	movt	r3, #28674	; 0x7002
700085cc:	e5933000 	ldr	r3, [r3]
700085d0:	e30608f0 	movw	r0, #26864	; 0x68f0
700085d4:	e3470002 	movt	r0, #28674	; 0x7002
700085d8:	e3061afc 	movw	r1, #27388	; 0x6afc
700085dc:	e3471002 	movt	r1, #28674	; 0x7002
700085e0:	e3002162 	movw	r2, #354	; 0x162
700085e4:	e12fff33 	blx	r3
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
700085e8:	e51b3010 	ldr	r3, [fp, #-16]
700085ec:	e283300c 	add	r3, r3, #12
700085f0:	e2033003 	and	r3, r3, #3
700085f4:	e3530000 	cmp	r3, #0
700085f8:	0a00001d 	beq	70008674 <rt_malloc+0x5b8>
700085fc:	e3a03000 	mov	r3, #0
70008600:	e54b301c 	strb	r3, [fp, #-28]
70008604:	e30a3b74 	movw	r3, #43892	; 0xab74
70008608:	e3473002 	movt	r3, #28674	; 0x7002
7000860c:	e5933000 	ldr	r3, [r3]
70008610:	e3530000 	cmp	r3, #0
70008614:	1a00000d 	bne	70008650 <rt_malloc+0x594>
70008618:	e30607e0 	movw	r0, #26592	; 0x67e0
7000861c:	e3470002 	movt	r0, #28674	; 0x7002
70008620:	e3061938 	movw	r1, #26936	; 0x6938
70008624:	e3471002 	movt	r1, #28674	; 0x7002
70008628:	e3062afc 	movw	r2, #27388	; 0x6afc
7000862c:	e3472002 	movt	r2, #28674	; 0x7002
70008630:	e3003163 	movw	r3, #355	; 0x163
70008634:	ebfffc6e 	bl	700077f4 <rt_kprintf>
70008638:	e1a00000 	nop			; (mov r0, r0)
7000863c:	e55b301c 	ldrb	r3, [fp, #-28]
70008640:	e6ef3073 	uxtb	r3, r3
70008644:	e3530000 	cmp	r3, #0
70008648:	0afffffb 	beq	7000863c <rt_malloc+0x580>
7000864c:	ea000008 	b	70008674 <rt_malloc+0x5b8>
70008650:	e30a3b74 	movw	r3, #43892	; 0xab74
70008654:	e3473002 	movt	r3, #28674	; 0x7002
70008658:	e5933000 	ldr	r3, [r3]
7000865c:	e3060938 	movw	r0, #26936	; 0x6938
70008660:	e3470002 	movt	r0, #28674	; 0x7002
70008664:	e3061afc 	movw	r1, #27388	; 0x6afc
70008668:	e3471002 	movt	r1, #28674	; 0x7002
7000866c:	e3002163 	movw	r2, #355	; 0x163
70008670:	e12fff33 	blx	r3
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
70008674:	e51b3010 	ldr	r3, [fp, #-16]
70008678:	e2033003 	and	r3, r3, #3
7000867c:	e3530000 	cmp	r3, #0
70008680:	0a00001e 	beq	70008700 <rt_malloc+0x644>
70008684:	e3a03000 	mov	r3, #0
70008688:	e54b301d 	strb	r3, [fp, #-29]
7000868c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008690:	e3473002 	movt	r3, #28674	; 0x7002
70008694:	e5933000 	ldr	r3, [r3]
70008698:	e3530000 	cmp	r3, #0
7000869c:	1a00000d 	bne	700086d8 <rt_malloc+0x61c>
700086a0:	e30607e0 	movw	r0, #26592	; 0x67e0
700086a4:	e3470002 	movt	r0, #28674	; 0x7002
700086a8:	e3061984 	movw	r1, #27012	; 0x6984
700086ac:	e3471002 	movt	r1, #28674	; 0x7002
700086b0:	e3062afc 	movw	r2, #27388	; 0x6afc
700086b4:	e3472002 	movt	r2, #28674	; 0x7002
700086b8:	e3a03f59 	mov	r3, #356	; 0x164
700086bc:	ebfffc4c 	bl	700077f4 <rt_kprintf>
700086c0:	e1a00000 	nop			; (mov r0, r0)
700086c4:	e55b301d 	ldrb	r3, [fp, #-29]
700086c8:	e6ef3073 	uxtb	r3, r3
700086cc:	e3530000 	cmp	r3, #0
700086d0:	0afffffb 	beq	700086c4 <rt_malloc+0x608>
700086d4:	ea000009 	b	70008700 <rt_malloc+0x644>
700086d8:	e30a3b74 	movw	r3, #43892	; 0xab74
700086dc:	e3473002 	movt	r3, #28674	; 0x7002
700086e0:	e5933000 	ldr	r3, [r3]
700086e4:	e3060984 	movw	r0, #27012	; 0x6984
700086e8:	e3470002 	movt	r0, #28674	; 0x7002
700086ec:	e3061afc 	movw	r1, #27388	; 0x6afc
700086f0:	e3471002 	movt	r1, #28674	; 0x7002
700086f4:	e3a02f59 	mov	r2, #356	; 0x164
700086f8:	e12fff33 	blx	r3
700086fc:	eaffffff 	b	70008700 <rt_malloc+0x644>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
70008700:	e30938a4 	movw	r3, #39076	; 0x98a4
70008704:	e3473002 	movt	r3, #28674	; 0x7002
70008708:	e5933000 	ldr	r3, [r3]
7000870c:	e3530000 	cmp	r3, #0
70008710:	0a000007 	beq	70008734 <rt_malloc+0x678>
70008714:	e30938a4 	movw	r3, #39076	; 0x98a4
70008718:	e3473002 	movt	r3, #28674	; 0x7002
7000871c:	e5933000 	ldr	r3, [r3]
70008720:	e51b2010 	ldr	r2, [fp, #-16]
70008724:	e282200c 	add	r2, r2, #12
70008728:	e1a00002 	mov	r0, r2
7000872c:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
70008730:	e12fff33 	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
70008734:	e51b3010 	ldr	r3, [fp, #-16]
70008738:	e283300c 	add	r3, r3, #12
7000873c:	ea000012 	b	7000878c <rt_malloc+0x6d0>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
70008740:	e30938ac 	movw	r3, #39084	; 0x98ac
70008744:	e3473002 	movt	r3, #28674	; 0x7002
70008748:	e5932000 	ldr	r2, [r3]
7000874c:	e51b3008 	ldr	r3, [fp, #-8]
70008750:	e0823003 	add	r3, r2, r3
70008754:	e5933004 	ldr	r3, [r3, #4]
70008758:	e50b3008 	str	r3, [fp, #-8]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
7000875c:	e30938d4 	movw	r3, #39124	; 0x98d4
70008760:	e3473002 	movt	r3, #28674	; 0x7002
70008764:	e5932000 	ldr	r2, [r3]
70008768:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000876c:	e0632002 	rsb	r2, r3, r2
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
70008770:	e51b3008 	ldr	r3, [fp, #-8]
70008774:	e1520003 	cmp	r2, r3
70008778:	8afffea2 	bhi	70008208 <rt_malloc+0x14c>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
7000877c:	e30908b8 	movw	r0, #39096	; 0x98b8
70008780:	e3470002 	movt	r0, #28674	; 0x7002
70008784:	ebffe671 	bl	70002150 <rt_sem_release>

    return RT_NULL;
70008788:	e3a03000 	mov	r3, #0
}
7000878c:	e1a00003 	mov	r0, r3
70008790:	e24bd004 	sub	sp, fp, #4
70008794:	e8bd8800 	pop	{fp, pc}

70008798 <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
70008798:	e92d4800 	push	{fp, lr}
7000879c:	e28db004 	add	fp, sp, #4
700087a0:	e24dd028 	sub	sp, sp, #40	; 0x28
700087a4:	e50b0028 	str	r0, [fp, #-40]	; 0x28
700087a8:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
700087ac:	eb0016a5 	bl	7000e248 <rt_hw_interrupt_disable>
700087b0:	e50b0008 	str	r0, [fp, #-8]
700087b4:	ebfff5be 	bl	70005eb4 <rt_interrupt_get_nest>
700087b8:	e1a03000 	mov	r3, r0
700087bc:	e3530000 	cmp	r3, #0
700087c0:	0a000022 	beq	70008850 <rt_realloc+0xb8>
700087c4:	e306085c 	movw	r0, #26716	; 0x685c
700087c8:	e3470002 	movt	r0, #28674	; 0x7002
700087cc:	e3061b08 	movw	r1, #27400	; 0x6b08
700087d0:	e3471002 	movt	r1, #28674	; 0x7002
700087d4:	ebfffc06 	bl	700077f4 <rt_kprintf>
700087d8:	e3a03000 	mov	r3, #0
700087dc:	e54b3021 	strb	r3, [fp, #-33]	; 0x21
700087e0:	e30a3b74 	movw	r3, #43892	; 0xab74
700087e4:	e3473002 	movt	r3, #28674	; 0x7002
700087e8:	e5933000 	ldr	r3, [r3]
700087ec:	e3530000 	cmp	r3, #0
700087f0:	1a00000d 	bne	7000882c <rt_realloc+0x94>
700087f4:	e30607e0 	movw	r0, #26592	; 0x67e0
700087f8:	e3470002 	movt	r0, #28674	; 0x7002
700087fc:	e3061880 	movw	r1, #26752	; 0x6880
70008800:	e3471002 	movt	r1, #28674	; 0x7002
70008804:	e3062b08 	movw	r2, #27400	; 0x6b08
70008808:	e3472002 	movt	r2, #28674	; 0x7002
7000880c:	e3a03f62 	mov	r3, #392	; 0x188
70008810:	ebfffbf7 	bl	700077f4 <rt_kprintf>
70008814:	e1a00000 	nop			; (mov r0, r0)
70008818:	e55b3021 	ldrb	r3, [fp, #-33]	; 0x21
7000881c:	e6ef3073 	uxtb	r3, r3
70008820:	e3530000 	cmp	r3, #0
70008824:	0afffffb 	beq	70008818 <rt_realloc+0x80>
70008828:	ea000008 	b	70008850 <rt_realloc+0xb8>
7000882c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008830:	e3473002 	movt	r3, #28674	; 0x7002
70008834:	e5933000 	ldr	r3, [r3]
70008838:	e3060880 	movw	r0, #26752	; 0x6880
7000883c:	e3470002 	movt	r0, #28674	; 0x7002
70008840:	e3061b08 	movw	r1, #27400	; 0x6b08
70008844:	e3471002 	movt	r1, #28674	; 0x7002
70008848:	e3a02f62 	mov	r2, #392	; 0x188
7000884c:	e12fff33 	blx	r3
70008850:	e51b0008 	ldr	r0, [fp, #-8]
70008854:	eb00167e 	bl	7000e254 <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
70008858:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
7000885c:	e2833003 	add	r3, r3, #3
70008860:	e3c33003 	bic	r3, r3, #3
70008864:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    if (newsize > mem_size_aligned)
70008868:	e30938d4 	movw	r3, #39124	; 0x98d4
7000886c:	e3473002 	movt	r3, #28674	; 0x7002
70008870:	e5933000 	ldr	r3, [r3]
70008874:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
70008878:	e1520003 	cmp	r2, r3
7000887c:	9a000001 	bls	70008888 <rt_realloc+0xf0>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
70008880:	e3a03000 	mov	r3, #0
70008884:	ea000088 	b	70008aac <rt_realloc+0x314>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
70008888:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7000888c:	e3530000 	cmp	r3, #0
70008890:	1a000003 	bne	700088a4 <rt_realloc+0x10c>
        return rt_malloc(newsize);
70008894:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
70008898:	ebfffe07 	bl	700080bc <rt_malloc>
7000889c:	e1a03000 	mov	r3, r0
700088a0:	ea000081 	b	70008aac <rt_realloc+0x314>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
700088a4:	e30908b8 	movw	r0, #39096	; 0x98b8
700088a8:	e3470002 	movt	r0, #28674	; 0x7002
700088ac:	e3e01000 	mvn	r1, #0
700088b0:	ebffe54a 	bl	70001de0 <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
700088b4:	e30938ac 	movw	r3, #39084	; 0x98ac
700088b8:	e3473002 	movt	r3, #28674	; 0x7002
700088bc:	e5933000 	ldr	r3, [r3]
700088c0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700088c4:	e1520003 	cmp	r2, r3
700088c8:	3a000005 	bcc	700088e4 <rt_realloc+0x14c>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
700088cc:	e30938b0 	movw	r3, #39088	; 0x98b0
700088d0:	e3473002 	movt	r3, #28674	; 0x7002
700088d4:	e5933000 	ldr	r3, [r3]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
700088d8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700088dc:	e1520003 	cmp	r2, r3
700088e0:	3a000004 	bcc	700088f8 <rt_realloc+0x160>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
700088e4:	e30908b8 	movw	r0, #39096	; 0x98b8
700088e8:	e3470002 	movt	r0, #28674	; 0x7002
700088ec:	ebffe617 	bl	70002150 <rt_sem_release>

        return rmem;
700088f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700088f4:	ea00006c 	b	70008aac <rt_realloc+0x314>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
700088f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700088fc:	e243300c 	sub	r3, r3, #12
70008900:	e50b300c 	str	r3, [fp, #-12]

    ptr = (rt_uint8_t *)mem - heap_ptr;
70008904:	e51b200c 	ldr	r2, [fp, #-12]
70008908:	e30938ac 	movw	r3, #39084	; 0x98ac
7000890c:	e3473002 	movt	r3, #28674	; 0x7002
70008910:	e5933000 	ldr	r3, [r3]
70008914:	e0633002 	rsb	r3, r3, r2
70008918:	e50b3010 	str	r3, [fp, #-16]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
7000891c:	e51b300c 	ldr	r3, [fp, #-12]
70008920:	e5932004 	ldr	r2, [r3, #4]
70008924:	e51b3010 	ldr	r3, [fp, #-16]
70008928:	e0633002 	rsb	r3, r3, r2
7000892c:	e243300c 	sub	r3, r3, #12
70008930:	e50b3014 	str	r3, [fp, #-20]
    if (size == newsize)
70008934:	e51b2014 	ldr	r2, [fp, #-20]
70008938:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
7000893c:	e1520003 	cmp	r2, r3
70008940:	1a000004 	bne	70008958 <rt_realloc+0x1c0>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
70008944:	e30908b8 	movw	r0, #39096	; 0x98b8
70008948:	e3470002 	movt	r0, #28674	; 0x7002
7000894c:	ebffe5ff 	bl	70002150 <rt_sem_release>

        return rmem;
70008950:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008954:	ea000054 	b	70008aac <rt_realloc+0x314>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
70008958:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
7000895c:	e2832018 	add	r2, r3, #24
70008960:	e51b3014 	ldr	r3, [fp, #-20]
70008964:	e1520003 	cmp	r2, r3
70008968:	2a00003b 	bcs	70008a5c <rt_realloc+0x2c4>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
7000896c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
70008970:	e51b3014 	ldr	r3, [fp, #-20]
70008974:	e0632002 	rsb	r2, r3, r2
70008978:	e30938d8 	movw	r3, #39128	; 0x98d8
7000897c:	e3473002 	movt	r3, #28674	; 0x7002
70008980:	e5933000 	ldr	r3, [r3]
70008984:	e0822003 	add	r2, r2, r3
70008988:	e30938d8 	movw	r3, #39128	; 0x98d8
7000898c:	e3473002 	movt	r3, #28674	; 0x7002
70008990:	e5832000 	str	r2, [r3]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
70008994:	e51b2010 	ldr	r2, [fp, #-16]
70008998:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
7000899c:	e0823003 	add	r3, r2, r3
700089a0:	e283300c 	add	r3, r3, #12
700089a4:	e50b3018 	str	r3, [fp, #-24]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
700089a8:	e30938ac 	movw	r3, #39084	; 0x98ac
700089ac:	e3473002 	movt	r3, #28674	; 0x7002
700089b0:	e5932000 	ldr	r2, [r3]
700089b4:	e51b3018 	ldr	r3, [fp, #-24]
700089b8:	e0823003 	add	r3, r2, r3
700089bc:	e50b301c 	str	r3, [fp, #-28]
        mem2->magic= HEAP_MAGIC;
700089c0:	e51b301c 	ldr	r3, [fp, #-28]
700089c4:	e3012ea0 	movw	r2, #7840	; 0x1ea0
700089c8:	e1c320b0 	strh	r2, [r3]
        mem2->used = 0;
700089cc:	e51b301c 	ldr	r3, [fp, #-28]
700089d0:	e3a02000 	mov	r2, #0
700089d4:	e1c320b2 	strh	r2, [r3, #2]
        mem2->next = mem->next;
700089d8:	e51b300c 	ldr	r3, [fp, #-12]
700089dc:	e5932004 	ldr	r2, [r3, #4]
700089e0:	e51b301c 	ldr	r3, [fp, #-28]
700089e4:	e5832004 	str	r2, [r3, #4]
        mem2->prev = ptr;
700089e8:	e51b301c 	ldr	r3, [fp, #-28]
700089ec:	e51b2010 	ldr	r2, [fp, #-16]
700089f0:	e5832008 	str	r2, [r3, #8]
        mem->next = ptr2;
700089f4:	e51b300c 	ldr	r3, [fp, #-12]
700089f8:	e51b2018 	ldr	r2, [fp, #-24]
700089fc:	e5832004 	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
70008a00:	e51b301c 	ldr	r3, [fp, #-28]
70008a04:	e5932004 	ldr	r2, [r3, #4]
70008a08:	e30938d4 	movw	r3, #39124	; 0x98d4
70008a0c:	e3473002 	movt	r3, #28674	; 0x7002
70008a10:	e5933000 	ldr	r3, [r3]
70008a14:	e283300c 	add	r3, r3, #12
70008a18:	e1520003 	cmp	r2, r3
70008a1c:	0a000007 	beq	70008a40 <rt_realloc+0x2a8>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
70008a20:	e30938ac 	movw	r3, #39084	; 0x98ac
70008a24:	e3473002 	movt	r3, #28674	; 0x7002
70008a28:	e5932000 	ldr	r2, [r3]
70008a2c:	e51b301c 	ldr	r3, [fp, #-28]
70008a30:	e5933004 	ldr	r3, [r3, #4]
70008a34:	e0823003 	add	r3, r2, r3
70008a38:	e51b2018 	ldr	r2, [fp, #-24]
70008a3c:	e5832008 	str	r2, [r3, #8]
        }

        plug_holes(mem2);
70008a40:	e51b001c 	ldr	r0, [fp, #-28]
70008a44:	ebfffc3c 	bl	70007b3c <plug_holes>

        rt_sem_release(&heap_sem);
70008a48:	e30908b8 	movw	r0, #39096	; 0x98b8
70008a4c:	e3470002 	movt	r0, #28674	; 0x7002
70008a50:	ebffe5be 	bl	70002150 <rt_sem_release>

        return rmem;
70008a54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70008a58:	ea000013 	b	70008aac <rt_realloc+0x314>
    }
    rt_sem_release(&heap_sem);
70008a5c:	e30908b8 	movw	r0, #39096	; 0x98b8
70008a60:	e3470002 	movt	r0, #28674	; 0x7002
70008a64:	ebffe5b9 	bl	70002150 <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
70008a68:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
70008a6c:	ebfffd92 	bl	700080bc <rt_malloc>
70008a70:	e50b0020 	str	r0, [fp, #-32]
    if (nmem != RT_NULL) /* check memory */
70008a74:	e51b3020 	ldr	r3, [fp, #-32]
70008a78:	e3530000 	cmp	r3, #0
70008a7c:	0a000009 	beq	70008aa8 <rt_realloc+0x310>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
70008a80:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
70008a84:	e51b3014 	ldr	r3, [fp, #-20]
70008a88:	e1520003 	cmp	r2, r3
70008a8c:	31a03002 	movcc	r3, r2
70008a90:	e51b0020 	ldr	r0, [fp, #-32]
70008a94:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
70008a98:	e1a02003 	mov	r2, r3
70008a9c:	ebfff5b3 	bl	70006170 <rt_memcpy>
        rt_free(rmem);
70008aa0:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70008aa4:	eb000047 	bl	70008bc8 <rt_free>
    }

    return nmem;
70008aa8:	e51b3020 	ldr	r3, [fp, #-32]
}
70008aac:	e1a00003 	mov	r0, r3
70008ab0:	e24bd004 	sub	sp, fp, #4
70008ab4:	e8bd8800 	pop	{fp, pc}

70008ab8 <rt_calloc>:
 * @param size size of the objects to allocate
 *
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *rt_calloc(rt_size_t count, rt_size_t size)
{
70008ab8:	e92d4800 	push	{fp, lr}
70008abc:	e28db004 	add	fp, sp, #4
70008ac0:	e24dd018 	sub	sp, sp, #24
70008ac4:	e50b0018 	str	r0, [fp, #-24]
70008ac8:	e50b101c 	str	r1, [fp, #-28]
    void *p;

    RT_DEBUG_NOT_IN_INTERRUPT;
70008acc:	eb0015dd 	bl	7000e248 <rt_hw_interrupt_disable>
70008ad0:	e50b0008 	str	r0, [fp, #-8]
70008ad4:	ebfff4f6 	bl	70005eb4 <rt_interrupt_get_nest>
70008ad8:	e1a03000 	mov	r3, r0
70008adc:	e3530000 	cmp	r3, #0
70008ae0:	0a000022 	beq	70008b70 <rt_calloc+0xb8>
70008ae4:	e306085c 	movw	r0, #26716	; 0x685c
70008ae8:	e3470002 	movt	r0, #28674	; 0x7002
70008aec:	e3061b14 	movw	r1, #27412	; 0x6b14
70008af0:	e3471002 	movt	r1, #28674	; 0x7002
70008af4:	ebfffb3e 	bl	700077f4 <rt_kprintf>
70008af8:	e3a03000 	mov	r3, #0
70008afc:	e54b300d 	strb	r3, [fp, #-13]
70008b00:	e30a3b74 	movw	r3, #43892	; 0xab74
70008b04:	e3473002 	movt	r3, #28674	; 0x7002
70008b08:	e5933000 	ldr	r3, [r3]
70008b0c:	e3530000 	cmp	r3, #0
70008b10:	1a00000d 	bne	70008b4c <rt_calloc+0x94>
70008b14:	e30607e0 	movw	r0, #26592	; 0x67e0
70008b18:	e3470002 	movt	r0, #28674	; 0x7002
70008b1c:	e3061880 	movw	r1, #26752	; 0x6880
70008b20:	e3471002 	movt	r1, #28674	; 0x7002
70008b24:	e3062b14 	movw	r2, #27412	; 0x6b14
70008b28:	e3472002 	movt	r2, #28674	; 0x7002
70008b2c:	e30031e5 	movw	r3, #485	; 0x1e5
70008b30:	ebfffb2f 	bl	700077f4 <rt_kprintf>
70008b34:	e1a00000 	nop			; (mov r0, r0)
70008b38:	e55b300d 	ldrb	r3, [fp, #-13]
70008b3c:	e6ef3073 	uxtb	r3, r3
70008b40:	e3530000 	cmp	r3, #0
70008b44:	0afffffb 	beq	70008b38 <rt_calloc+0x80>
70008b48:	ea000008 	b	70008b70 <rt_calloc+0xb8>
70008b4c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008b50:	e3473002 	movt	r3, #28674	; 0x7002
70008b54:	e5933000 	ldr	r3, [r3]
70008b58:	e3060880 	movw	r0, #26752	; 0x6880
70008b5c:	e3470002 	movt	r0, #28674	; 0x7002
70008b60:	e3061b14 	movw	r1, #27412	; 0x6b14
70008b64:	e3471002 	movt	r1, #28674	; 0x7002
70008b68:	e30021e5 	movw	r2, #485	; 0x1e5
70008b6c:	e12fff33 	blx	r3
70008b70:	e51b0008 	ldr	r0, [fp, #-8]
70008b74:	eb0015b6 	bl	7000e254 <rt_hw_interrupt_enable>

    /* allocate 'count' objects of size 'size' */
    p = rt_malloc(count * size);
70008b78:	e51b3018 	ldr	r3, [fp, #-24]
70008b7c:	e51b201c 	ldr	r2, [fp, #-28]
70008b80:	e0030392 	mul	r3, r2, r3
70008b84:	e1a00003 	mov	r0, r3
70008b88:	ebfffd4b 	bl	700080bc <rt_malloc>
70008b8c:	e50b000c 	str	r0, [fp, #-12]

    /* zero the memory */
    if (p)
70008b90:	e51b300c 	ldr	r3, [fp, #-12]
70008b94:	e3530000 	cmp	r3, #0
70008b98:	0a000006 	beq	70008bb8 <rt_calloc+0x100>
        rt_memset(p, 0, count * size);
70008b9c:	e51b3018 	ldr	r3, [fp, #-24]
70008ba0:	e51b201c 	ldr	r2, [fp, #-28]
70008ba4:	e0030392 	mul	r3, r2, r3
70008ba8:	e51b000c 	ldr	r0, [fp, #-12]
70008bac:	e3a01000 	mov	r1, #0
70008bb0:	e1a02003 	mov	r2, r3
70008bb4:	ebfff514 	bl	7000600c <rt_memset>

    return p;
70008bb8:	e51b300c 	ldr	r3, [fp, #-12]
}
70008bbc:	e1a00003 	mov	r0, r3
70008bc0:	e24bd004 	sub	sp, fp, #4
70008bc4:	e8bd8800 	pop	{fp, pc}

70008bc8 <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
70008bc8:	e92d4800 	push	{fp, lr}
70008bcc:	e28db004 	add	fp, sp, #4
70008bd0:	e24dd018 	sub	sp, sp, #24
70008bd4:	e50b0018 	str	r0, [fp, #-24]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
70008bd8:	eb00159a 	bl	7000e248 <rt_hw_interrupt_disable>
70008bdc:	e50b0008 	str	r0, [fp, #-8]
70008be0:	ebfff4b3 	bl	70005eb4 <rt_interrupt_get_nest>
70008be4:	e1a03000 	mov	r3, r0
70008be8:	e3530000 	cmp	r3, #0
70008bec:	0a000022 	beq	70008c7c <rt_free+0xb4>
70008bf0:	e306085c 	movw	r0, #26716	; 0x685c
70008bf4:	e3470002 	movt	r0, #28674	; 0x7002
70008bf8:	e3061b20 	movw	r1, #27424	; 0x6b20
70008bfc:	e3471002 	movt	r1, #28674	; 0x7002
70008c00:	ebfffafb 	bl	700077f4 <rt_kprintf>
70008c04:	e3a03000 	mov	r3, #0
70008c08:	e54b300d 	strb	r3, [fp, #-13]
70008c0c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008c10:	e3473002 	movt	r3, #28674	; 0x7002
70008c14:	e5933000 	ldr	r3, [r3]
70008c18:	e3530000 	cmp	r3, #0
70008c1c:	1a00000d 	bne	70008c58 <rt_free+0x90>
70008c20:	e30607e0 	movw	r0, #26592	; 0x67e0
70008c24:	e3470002 	movt	r0, #28674	; 0x7002
70008c28:	e3061880 	movw	r1, #26752	; 0x6880
70008c2c:	e3471002 	movt	r1, #28674	; 0x7002
70008c30:	e3062b20 	movw	r2, #27424	; 0x6b20
70008c34:	e3472002 	movt	r2, #28674	; 0x7002
70008c38:	e3a03f7f 	mov	r3, #508	; 0x1fc
70008c3c:	ebfffaec 	bl	700077f4 <rt_kprintf>
70008c40:	e1a00000 	nop			; (mov r0, r0)
70008c44:	e55b300d 	ldrb	r3, [fp, #-13]
70008c48:	e6ef3073 	uxtb	r3, r3
70008c4c:	e3530000 	cmp	r3, #0
70008c50:	0afffffb 	beq	70008c44 <rt_free+0x7c>
70008c54:	ea000008 	b	70008c7c <rt_free+0xb4>
70008c58:	e30a3b74 	movw	r3, #43892	; 0xab74
70008c5c:	e3473002 	movt	r3, #28674	; 0x7002
70008c60:	e5933000 	ldr	r3, [r3]
70008c64:	e3060880 	movw	r0, #26752	; 0x6880
70008c68:	e3470002 	movt	r0, #28674	; 0x7002
70008c6c:	e3061b20 	movw	r1, #27424	; 0x6b20
70008c70:	e3471002 	movt	r1, #28674	; 0x7002
70008c74:	e3a02f7f 	mov	r2, #508	; 0x1fc
70008c78:	e12fff33 	blx	r3
70008c7c:	e51b0008 	ldr	r0, [fp, #-8]
70008c80:	eb001573 	bl	7000e254 <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
70008c84:	e51b3018 	ldr	r3, [fp, #-24]
70008c88:	e3530000 	cmp	r3, #0
70008c8c:	1a000000 	bne	70008c94 <rt_free+0xcc>
        return;
70008c90:	ea0000d3 	b	70008fe4 <rt_free+0x41c>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
70008c94:	e51b3018 	ldr	r3, [fp, #-24]
70008c98:	e2033003 	and	r3, r3, #3
70008c9c:	e3530000 	cmp	r3, #0
70008ca0:	0a00001d 	beq	70008d1c <rt_free+0x154>
70008ca4:	e3a03000 	mov	r3, #0
70008ca8:	e54b300e 	strb	r3, [fp, #-14]
70008cac:	e30a3b74 	movw	r3, #43892	; 0xab74
70008cb0:	e3473002 	movt	r3, #28674	; 0x7002
70008cb4:	e5933000 	ldr	r3, [r3]
70008cb8:	e3530000 	cmp	r3, #0
70008cbc:	1a00000d 	bne	70008cf8 <rt_free+0x130>
70008cc0:	e30607e0 	movw	r0, #26592	; 0x67e0
70008cc4:	e3470002 	movt	r0, #28674	; 0x7002
70008cc8:	e30619b4 	movw	r1, #27060	; 0x69b4
70008ccc:	e3471002 	movt	r1, #28674	; 0x7002
70008cd0:	e3062b20 	movw	r2, #27424	; 0x6b20
70008cd4:	e3472002 	movt	r2, #28674	; 0x7002
70008cd8:	e3a03c02 	mov	r3, #512	; 0x200
70008cdc:	ebfffac4 	bl	700077f4 <rt_kprintf>
70008ce0:	e1a00000 	nop			; (mov r0, r0)
70008ce4:	e55b300e 	ldrb	r3, [fp, #-14]
70008ce8:	e6ef3073 	uxtb	r3, r3
70008cec:	e3530000 	cmp	r3, #0
70008cf0:	0afffffb 	beq	70008ce4 <rt_free+0x11c>
70008cf4:	ea000008 	b	70008d1c <rt_free+0x154>
70008cf8:	e30a3b74 	movw	r3, #43892	; 0xab74
70008cfc:	e3473002 	movt	r3, #28674	; 0x7002
70008d00:	e5933000 	ldr	r3, [r3]
70008d04:	e30609b4 	movw	r0, #27060	; 0x69b4
70008d08:	e3470002 	movt	r0, #28674	; 0x7002
70008d0c:	e3061b20 	movw	r1, #27424	; 0x6b20
70008d10:	e3471002 	movt	r1, #28674	; 0x7002
70008d14:	e3a02c02 	mov	r2, #512	; 0x200
70008d18:	e12fff33 	blx	r3
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
70008d1c:	e30938ac 	movw	r3, #39084	; 0x98ac
70008d20:	e3473002 	movt	r3, #28674	; 0x7002
70008d24:	e5933000 	ldr	r3, [r3]
70008d28:	e51b2018 	ldr	r2, [fp, #-24]
70008d2c:	e1520003 	cmp	r2, r3
70008d30:	3a000005 	bcc	70008d4c <rt_free+0x184>
70008d34:	e30938b0 	movw	r3, #39088	; 0x98b0
70008d38:	e3473002 	movt	r3, #28674	; 0x7002
70008d3c:	e5933000 	ldr	r3, [r3]
70008d40:	e51b2018 	ldr	r2, [fp, #-24]
70008d44:	e1520003 	cmp	r2, r3
70008d48:	3a00001d 	bcc	70008dc4 <rt_free+0x1fc>
70008d4c:	e3a03000 	mov	r3, #0
70008d50:	e54b300f 	strb	r3, [fp, #-15]
70008d54:	e30a3b74 	movw	r3, #43892	; 0xab74
70008d58:	e3473002 	movt	r3, #28674	; 0x7002
70008d5c:	e5933000 	ldr	r3, [r3]
70008d60:	e3530000 	cmp	r3, #0
70008d64:	1a00000d 	bne	70008da0 <rt_free+0x1d8>
70008d68:	e30607e0 	movw	r0, #26592	; 0x67e0
70008d6c:	e3470002 	movt	r0, #28674	; 0x7002
70008d70:	e30619e4 	movw	r1, #27108	; 0x69e4
70008d74:	e3471002 	movt	r1, #28674	; 0x7002
70008d78:	e3062b20 	movw	r2, #27424	; 0x6b20
70008d7c:	e3472002 	movt	r2, #28674	; 0x7002
70008d80:	e3003202 	movw	r3, #514	; 0x202
70008d84:	ebfffa9a 	bl	700077f4 <rt_kprintf>
70008d88:	e1a00000 	nop			; (mov r0, r0)
70008d8c:	e55b300f 	ldrb	r3, [fp, #-15]
70008d90:	e6ef3073 	uxtb	r3, r3
70008d94:	e3530000 	cmp	r3, #0
70008d98:	0afffffb 	beq	70008d8c <rt_free+0x1c4>
70008d9c:	ea000008 	b	70008dc4 <rt_free+0x1fc>
70008da0:	e30a3b74 	movw	r3, #43892	; 0xab74
70008da4:	e3473002 	movt	r3, #28674	; 0x7002
70008da8:	e5933000 	ldr	r3, [r3]
70008dac:	e30609e4 	movw	r0, #27108	; 0x69e4
70008db0:	e3470002 	movt	r0, #28674	; 0x7002
70008db4:	e3061b20 	movw	r1, #27424	; 0x6b20
70008db8:	e3471002 	movt	r1, #28674	; 0x7002
70008dbc:	e3002202 	movw	r2, #514	; 0x202
70008dc0:	e12fff33 	blx	r3
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
70008dc4:	e30938a8 	movw	r3, #39080	; 0x98a8
70008dc8:	e3473002 	movt	r3, #28674	; 0x7002
70008dcc:	e5933000 	ldr	r3, [r3]
70008dd0:	e3530000 	cmp	r3, #0
70008dd4:	0a000004 	beq	70008dec <rt_free+0x224>
70008dd8:	e30938a8 	movw	r3, #39080	; 0x98a8
70008ddc:	e3473002 	movt	r3, #28674	; 0x7002
70008de0:	e5933000 	ldr	r3, [r3]
70008de4:	e51b0018 	ldr	r0, [fp, #-24]
70008de8:	e12fff33 	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
70008dec:	e30938ac 	movw	r3, #39084	; 0x98ac
70008df0:	e3473002 	movt	r3, #28674	; 0x7002
70008df4:	e5933000 	ldr	r3, [r3]
70008df8:	e51b2018 	ldr	r2, [fp, #-24]
70008dfc:	e1520003 	cmp	r2, r3
70008e00:	3a000005 	bcc	70008e1c <rt_free+0x254>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
70008e04:	e30938b0 	movw	r3, #39088	; 0x98b0
70008e08:	e3473002 	movt	r3, #28674	; 0x7002
70008e0c:	e5933000 	ldr	r3, [r3]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
70008e10:	e51b2018 	ldr	r2, [fp, #-24]
70008e14:	e1520003 	cmp	r2, r3
70008e18:	3a000000 	bcc	70008e20 <rt_free+0x258>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
70008e1c:	ea000070 	b	70008fe4 <rt_free+0x41c>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
70008e20:	e51b3018 	ldr	r3, [fp, #-24]
70008e24:	e243300c 	sub	r3, r3, #12
70008e28:	e50b300c 	str	r3, [fp, #-12]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
70008e2c:	e30908b8 	movw	r0, #39096	; 0x98b8
70008e30:	e3470002 	movt	r0, #28674	; 0x7002
70008e34:	e3e01000 	mvn	r1, #0
70008e38:	ebffe3e8 	bl	70001de0 <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
70008e3c:	e51b300c 	ldr	r3, [fp, #-12]
70008e40:	e1d330b2 	ldrh	r3, [r3, #2]
70008e44:	e3530000 	cmp	r3, #0
70008e48:	1a00001d 	bne	70008ec4 <rt_free+0x2fc>
70008e4c:	e3a03000 	mov	r3, #0
70008e50:	e54b3010 	strb	r3, [fp, #-16]
70008e54:	e30a3b74 	movw	r3, #43892	; 0xab74
70008e58:	e3473002 	movt	r3, #28674	; 0x7002
70008e5c:	e5933000 	ldr	r3, [r3]
70008e60:	e3530000 	cmp	r3, #0
70008e64:	1a00000d 	bne	70008ea0 <rt_free+0x2d8>
70008e68:	e30607e0 	movw	r0, #26592	; 0x67e0
70008e6c:	e3470002 	movt	r0, #28674	; 0x7002
70008e70:	e3061a40 	movw	r1, #27200	; 0x6a40
70008e74:	e3471002 	movt	r1, #28674	; 0x7002
70008e78:	e3062b20 	movw	r2, #27424	; 0x6b20
70008e7c:	e3472002 	movt	r2, #28674	; 0x7002
70008e80:	e300321b 	movw	r3, #539	; 0x21b
70008e84:	ebfffa5a 	bl	700077f4 <rt_kprintf>
70008e88:	e1a00000 	nop			; (mov r0, r0)
70008e8c:	e55b3010 	ldrb	r3, [fp, #-16]
70008e90:	e6ef3073 	uxtb	r3, r3
70008e94:	e3530000 	cmp	r3, #0
70008e98:	0afffffb 	beq	70008e8c <rt_free+0x2c4>
70008e9c:	ea000008 	b	70008ec4 <rt_free+0x2fc>
70008ea0:	e30a3b74 	movw	r3, #43892	; 0xab74
70008ea4:	e3473002 	movt	r3, #28674	; 0x7002
70008ea8:	e5933000 	ldr	r3, [r3]
70008eac:	e3060a40 	movw	r0, #27200	; 0x6a40
70008eb0:	e3470002 	movt	r0, #28674	; 0x7002
70008eb4:	e3061b20 	movw	r1, #27424	; 0x6b20
70008eb8:	e3471002 	movt	r1, #28674	; 0x7002
70008ebc:	e300221b 	movw	r2, #539	; 0x21b
70008ec0:	e12fff33 	blx	r3
    RT_ASSERT(mem->magic == HEAP_MAGIC);
70008ec4:	e51b300c 	ldr	r3, [fp, #-12]
70008ec8:	e1d320b0 	ldrh	r2, [r3]
70008ecc:	e3013ea0 	movw	r3, #7840	; 0x1ea0
70008ed0:	e1520003 	cmp	r2, r3
70008ed4:	0a00001d 	beq	70008f50 <rt_free+0x388>
70008ed8:	e3a03000 	mov	r3, #0
70008edc:	e54b3011 	strb	r3, [fp, #-17]
70008ee0:	e30a3b74 	movw	r3, #43892	; 0xab74
70008ee4:	e3473002 	movt	r3, #28674	; 0x7002
70008ee8:	e5933000 	ldr	r3, [r3]
70008eec:	e3530000 	cmp	r3, #0
70008ef0:	1a00000d 	bne	70008f2c <rt_free+0x364>
70008ef4:	e30607e0 	movw	r0, #26592	; 0x67e0
70008ef8:	e3470002 	movt	r0, #28674	; 0x7002
70008efc:	e3061a4c 	movw	r1, #27212	; 0x6a4c
70008f00:	e3471002 	movt	r1, #28674	; 0x7002
70008f04:	e3062b20 	movw	r2, #27424	; 0x6b20
70008f08:	e3472002 	movt	r2, #28674	; 0x7002
70008f0c:	e3a03f87 	mov	r3, #540	; 0x21c
70008f10:	ebfffa37 	bl	700077f4 <rt_kprintf>
70008f14:	e1a00000 	nop			; (mov r0, r0)
70008f18:	e55b3011 	ldrb	r3, [fp, #-17]
70008f1c:	e6ef3073 	uxtb	r3, r3
70008f20:	e3530000 	cmp	r3, #0
70008f24:	0afffffb 	beq	70008f18 <rt_free+0x350>
70008f28:	ea000008 	b	70008f50 <rt_free+0x388>
70008f2c:	e30a3b74 	movw	r3, #43892	; 0xab74
70008f30:	e3473002 	movt	r3, #28674	; 0x7002
70008f34:	e5933000 	ldr	r3, [r3]
70008f38:	e3060a4c 	movw	r0, #27212	; 0x6a4c
70008f3c:	e3470002 	movt	r0, #28674	; 0x7002
70008f40:	e3061b20 	movw	r1, #27424	; 0x6b20
70008f44:	e3471002 	movt	r1, #28674	; 0x7002
70008f48:	e3a02f87 	mov	r2, #540	; 0x21c
70008f4c:	e12fff33 	blx	r3
    /* ... and is now unused. */
    mem->used  = 0;
70008f50:	e51b300c 	ldr	r3, [fp, #-12]
70008f54:	e3a02000 	mov	r2, #0
70008f58:	e1c320b2 	strh	r2, [r3, #2]
    mem->magic = 0;
70008f5c:	e51b300c 	ldr	r3, [fp, #-12]
70008f60:	e3a02000 	mov	r2, #0
70008f64:	e1c320b0 	strh	r2, [r3]

    if (mem < lfree)
70008f68:	e30938b4 	movw	r3, #39092	; 0x98b4
70008f6c:	e3473002 	movt	r3, #28674	; 0x7002
70008f70:	e5933000 	ldr	r3, [r3]
70008f74:	e51b200c 	ldr	r2, [fp, #-12]
70008f78:	e1520003 	cmp	r2, r3
70008f7c:	2a000003 	bcs	70008f90 <rt_free+0x3c8>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
70008f80:	e30938b4 	movw	r3, #39092	; 0x98b4
70008f84:	e3473002 	movt	r3, #28674	; 0x7002
70008f88:	e51b200c 	ldr	r2, [fp, #-12]
70008f8c:	e5832000 	str	r2, [r3]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
70008f90:	e30938d8 	movw	r3, #39128	; 0x98d8
70008f94:	e3473002 	movt	r3, #28674	; 0x7002
70008f98:	e5932000 	ldr	r2, [r3]
70008f9c:	e51b300c 	ldr	r3, [fp, #-12]
70008fa0:	e5931004 	ldr	r1, [r3, #4]
70008fa4:	e30938ac 	movw	r3, #39084	; 0x98ac
70008fa8:	e3473002 	movt	r3, #28674	; 0x7002
70008fac:	e5933000 	ldr	r3, [r3]
70008fb0:	e1a00003 	mov	r0, r3
70008fb4:	e51b300c 	ldr	r3, [fp, #-12]
70008fb8:	e0633000 	rsb	r3, r3, r0
70008fbc:	e0813003 	add	r3, r1, r3
70008fc0:	e0632002 	rsb	r2, r3, r2
70008fc4:	e30938d8 	movw	r3, #39128	; 0x98d8
70008fc8:	e3473002 	movt	r3, #28674	; 0x7002
70008fcc:	e5832000 	str	r2, [r3]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
70008fd0:	e51b000c 	ldr	r0, [fp, #-12]
70008fd4:	ebfffad8 	bl	70007b3c <plug_holes>
    rt_sem_release(&heap_sem);
70008fd8:	e30908b8 	movw	r0, #39096	; 0x98b8
70008fdc:	e3470002 	movt	r0, #28674	; 0x7002
70008fe0:	ebffe45a 	bl	70002150 <rt_sem_release>
}
70008fe4:	e24bd004 	sub	sp, fp, #4
70008fe8:	e8bd8800 	pop	{fp, pc}

70008fec <rt_memory_info>:

#ifdef RT_MEM_STATS
void rt_memory_info(rt_uint32_t *total,
                    rt_uint32_t *used,
                    rt_uint32_t *max_used)
{
70008fec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70008ff0:	e28db000 	add	fp, sp, #0
70008ff4:	e24dd014 	sub	sp, sp, #20
70008ff8:	e50b0008 	str	r0, [fp, #-8]
70008ffc:	e50b100c 	str	r1, [fp, #-12]
70009000:	e50b2010 	str	r2, [fp, #-16]
    if (total != RT_NULL)
70009004:	e51b3008 	ldr	r3, [fp, #-8]
70009008:	e3530000 	cmp	r3, #0
7000900c:	0a000004 	beq	70009024 <rt_memory_info+0x38>
        *total = mem_size_aligned;
70009010:	e30938d4 	movw	r3, #39124	; 0x98d4
70009014:	e3473002 	movt	r3, #28674	; 0x7002
70009018:	e5932000 	ldr	r2, [r3]
7000901c:	e51b3008 	ldr	r3, [fp, #-8]
70009020:	e5832000 	str	r2, [r3]
    if (used  != RT_NULL)
70009024:	e51b300c 	ldr	r3, [fp, #-12]
70009028:	e3530000 	cmp	r3, #0
7000902c:	0a000004 	beq	70009044 <rt_memory_info+0x58>
        *used = used_mem;
70009030:	e30938d8 	movw	r3, #39128	; 0x98d8
70009034:	e3473002 	movt	r3, #28674	; 0x7002
70009038:	e5932000 	ldr	r2, [r3]
7000903c:	e51b300c 	ldr	r3, [fp, #-12]
70009040:	e5832000 	str	r2, [r3]
    if (max_used != RT_NULL)
70009044:	e51b3010 	ldr	r3, [fp, #-16]
70009048:	e3530000 	cmp	r3, #0
7000904c:	0a000004 	beq	70009064 <rt_memory_info+0x78>
        *max_used = max_mem;
70009050:	e30938dc 	movw	r3, #39132	; 0x98dc
70009054:	e3473002 	movt	r3, #28674	; 0x7002
70009058:	e5932000 	ldr	r2, [r3]
7000905c:	e51b3010 	ldr	r3, [fp, #-16]
70009060:	e5832000 	str	r2, [r3]
}
70009064:	e24bd000 	sub	sp, fp, #0
70009068:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000906c:	e12fff1e 	bx	lr

70009070 <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
70009070:	e92d4800 	push	{fp, lr}
70009074:	e28db004 	add	fp, sp, #4
    rt_kprintf("total memory: %d\n", mem_size_aligned);
70009078:	e30938d4 	movw	r3, #39124	; 0x98d4
7000907c:	e3473002 	movt	r3, #28674	; 0x7002
70009080:	e5933000 	ldr	r3, [r3]
70009084:	e3060a68 	movw	r0, #27240	; 0x6a68
70009088:	e3470002 	movt	r0, #28674	; 0x7002
7000908c:	e1a01003 	mov	r1, r3
70009090:	ebfff9d7 	bl	700077f4 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
70009094:	e30938d8 	movw	r3, #39128	; 0x98d8
70009098:	e3473002 	movt	r3, #28674	; 0x7002
7000909c:	e5933000 	ldr	r3, [r3]
700090a0:	e3060a7c 	movw	r0, #27260	; 0x6a7c
700090a4:	e3470002 	movt	r0, #28674	; 0x7002
700090a8:	e1a01003 	mov	r1, r3
700090ac:	ebfff9d0 	bl	700077f4 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
700090b0:	e30938dc 	movw	r3, #39132	; 0x98dc
700090b4:	e3473002 	movt	r3, #28674	; 0x7002
700090b8:	e5933000 	ldr	r3, [r3]
700090bc:	e3060a90 	movw	r0, #27280	; 0x6a90
700090c0:	e3470002 	movt	r0, #28674	; 0x7002
700090c4:	e1a01003 	mov	r1, r3
700090c8:	ebfff9c9 	bl	700077f4 <rt_kprintf>
}
700090cc:	e8bd8800 	pop	{fp, pc}

700090d0 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
700090d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700090d4:	e28db000 	add	fp, sp, #0
700090d8:	e24dd00c 	sub	sp, sp, #12
700090dc:	e50b0008 	str	r0, [fp, #-8]
700090e0:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
700090e4:	e51b3008 	ldr	r3, [fp, #-8]
700090e8:	e5933000 	ldr	r3, [r3]
700090ec:	e51b200c 	ldr	r2, [fp, #-12]
700090f0:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
700090f4:	e51b3008 	ldr	r3, [fp, #-8]
700090f8:	e5932000 	ldr	r2, [r3]
700090fc:	e51b300c 	ldr	r3, [fp, #-12]
70009100:	e5832000 	str	r2, [r3]

    l->next = n;
70009104:	e51b3008 	ldr	r3, [fp, #-8]
70009108:	e51b200c 	ldr	r2, [fp, #-12]
7000910c:	e5832000 	str	r2, [r3]
    n->prev = l;
70009110:	e51b300c 	ldr	r3, [fp, #-12]
70009114:	e51b2008 	ldr	r2, [fp, #-8]
70009118:	e5832004 	str	r2, [r3, #4]
}
7000911c:	e24bd000 	sub	sp, fp, #0
70009120:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009124:	e12fff1e 	bx	lr

70009128 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
70009128:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000912c:	e28db000 	add	fp, sp, #0
70009130:	e24dd00c 	sub	sp, sp, #12
70009134:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
70009138:	e51b3008 	ldr	r3, [fp, #-8]
7000913c:	e5933000 	ldr	r3, [r3]
70009140:	e51b2008 	ldr	r2, [fp, #-8]
70009144:	e5922004 	ldr	r2, [r2, #4]
70009148:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
7000914c:	e51b3008 	ldr	r3, [fp, #-8]
70009150:	e5933004 	ldr	r3, [r3, #4]
70009154:	e51b2008 	ldr	r2, [fp, #-8]
70009158:	e5922000 	ldr	r2, [r2]
7000915c:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
70009160:	e51b3008 	ldr	r3, [fp, #-8]
70009164:	e51b2008 	ldr	r2, [fp, #-8]
70009168:	e5832004 	str	r2, [r3, #4]
7000916c:	e51b3008 	ldr	r3, [fp, #-8]
70009170:	e5932004 	ldr	r2, [r3, #4]
70009174:	e51b3008 	ldr	r3, [fp, #-8]
70009178:	e5832000 	str	r2, [r3]
}
7000917c:	e24bd000 	sub	sp, fp, #0
70009180:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009184:	e12fff1e 	bx	lr

70009188 <rt_object_attach_sethook>:
 * attaches to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
{
70009188:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000918c:	e28db000 	add	fp, sp, #0
70009190:	e24dd00c 	sub	sp, sp, #12
70009194:	e50b0008 	str	r0, [fp, #-8]
    rt_object_attach_hook = hook;
70009198:	e30938e0 	movw	r3, #39136	; 0x98e0
7000919c:	e3473002 	movt	r3, #28674	; 0x7002
700091a0:	e51b2008 	ldr	r2, [fp, #-8]
700091a4:	e5832000 	str	r2, [r3]
}
700091a8:	e24bd000 	sub	sp, fp, #0
700091ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700091b0:	e12fff1e 	bx	lr

700091b4 <rt_object_detach_sethook>:
 * detaches from kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
{
700091b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700091b8:	e28db000 	add	fp, sp, #0
700091bc:	e24dd00c 	sub	sp, sp, #12
700091c0:	e50b0008 	str	r0, [fp, #-8]
    rt_object_detach_hook = hook;
700091c4:	e30938e4 	movw	r3, #39140	; 0x98e4
700091c8:	e3473002 	movt	r3, #28674	; 0x7002
700091cc:	e51b2008 	ldr	r2, [fp, #-8]
700091d0:	e5832000 	str	r2, [r3]
}
700091d4:	e24bd000 	sub	sp, fp, #0
700091d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700091dc:	e12fff1e 	bx	lr

700091e0 <rt_object_trytake_sethook>:
 * message queue - message is received by thread
 *
 * @param hook the hook function
 */
void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
{
700091e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700091e4:	e28db000 	add	fp, sp, #0
700091e8:	e24dd00c 	sub	sp, sp, #12
700091ec:	e50b0008 	str	r0, [fp, #-8]
    rt_object_trytake_hook = hook;
700091f0:	e30a3b80 	movw	r3, #43904	; 0xab80
700091f4:	e3473002 	movt	r3, #28674	; 0x7002
700091f8:	e51b2008 	ldr	r2, [fp, #-8]
700091fc:	e5832000 	str	r2, [r3]
}
70009200:	e24bd000 	sub	sp, fp, #0
70009204:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009208:	e12fff1e 	bx	lr

7000920c <rt_object_take_sethook>:
 * timer - timer is started
 *
 * @param hook the hook function
 */
void rt_object_take_sethook(void (*hook)(struct rt_object *object))
{
7000920c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009210:	e28db000 	add	fp, sp, #0
70009214:	e24dd00c 	sub	sp, sp, #12
70009218:	e50b0008 	str	r0, [fp, #-8]
    rt_object_take_hook = hook;
7000921c:	e30a3b7c 	movw	r3, #43900	; 0xab7c
70009220:	e3473002 	movt	r3, #28674	; 0x7002
70009224:	e51b2008 	ldr	r2, [fp, #-8]
70009228:	e5832000 	str	r2, [r3]
}
7000922c:	e24bd000 	sub	sp, fp, #0
70009230:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009234:	e12fff1e 	bx	lr

70009238 <rt_object_put_sethook>:
 * is put to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_put_sethook(void (*hook)(struct rt_object *object))
{
70009238:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000923c:	e28db000 	add	fp, sp, #0
70009240:	e24dd00c 	sub	sp, sp, #12
70009244:	e50b0008 	str	r0, [fp, #-8]
    rt_object_put_hook = hook;
70009248:	e30a3b78 	movw	r3, #43896	; 0xab78
7000924c:	e3473002 	movt	r3, #28674	; 0x7002
70009250:	e51b2008 	ldr	r2, [fp, #-8]
70009254:	e5832000 	str	r2, [r3]
}
70009258:	e24bd000 	sub	sp, fp, #0
7000925c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009260:	e12fff1e 	bx	lr

70009264 <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
70009264:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009268:	e28db000 	add	fp, sp, #0
}
7000926c:	e24bd000 	sub	sp, fp, #0
70009270:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009274:	e12fff1e 	bx	lr

70009278 <rt_object_get_information>:
 * @param type the type of object
 * @return the object type information or RT_NULL
 */
struct rt_object_information *
rt_object_get_information(enum rt_object_class_type type)
{
70009278:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000927c:	e28db000 	add	fp, sp, #0
70009280:	e24dd00c 	sub	sp, sp, #12
70009284:	e1a03000 	mov	r3, r0
70009288:	e54b3005 	strb	r3, [fp, #-5]
    return &rt_object_container[type];
7000928c:	e55b3005 	ldrb	r3, [fp, #-5]
70009290:	e1a02203 	lsl	r2, r3, #4
70009294:	e3083d88 	movw	r3, #36232	; 0x8d88
70009298:	e3473002 	movt	r3, #28674	; 0x7002
7000929c:	e0823003 	add	r3, r2, r3
}
700092a0:	e1a00003 	mov	r0, r3
700092a4:	e24bd000 	sub	sp, fp, #0
700092a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700092ac:	e12fff1e 	bx	lr

700092b0 <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
700092b0:	e92d4810 	push	{r4, fp, lr}
700092b4:	e28db008 	add	fp, sp, #8
700092b8:	e24dd01c 	sub	sp, sp, #28
700092bc:	e50b0018 	str	r0, [fp, #-24]
700092c0:	e1a03001 	mov	r3, r1
700092c4:	e50b2020 	str	r2, [fp, #-32]
700092c8:	e54b3019 	strb	r3, [fp, #-25]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
700092cc:	e55b3019 	ldrb	r3, [fp, #-25]
700092d0:	e1a02203 	lsl	r2, r3, #4
700092d4:	e3083d88 	movw	r3, #36232	; 0x8d88
700092d8:	e3473002 	movt	r3, #28674	; 0x7002
700092dc:	e0823003 	add	r3, r2, r3
700092e0:	e50b3010 	str	r3, [fp, #-16]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
700092e4:	e55b3019 	ldrb	r3, [fp, #-25]
700092e8:	e1e03c83 	mvn	r3, r3, lsl #25
700092ec:	e1e03ca3 	mvn	r3, r3, lsr #25
700092f0:	e6ef2073 	uxtb	r2, r3
700092f4:	e51b3018 	ldr	r3, [fp, #-24]
700092f8:	e5c32006 	strb	r2, [r3, #6]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
700092fc:	e51b3018 	ldr	r3, [fp, #-24]
70009300:	e1a00003 	mov	r0, r3
70009304:	e51b1020 	ldr	r1, [fp, #-32]
70009308:	e3a02006 	mov	r2, #6
7000930c:	ebfff4c1 	bl	70006618 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
70009310:	e30938e0 	movw	r3, #39136	; 0x98e0
70009314:	e3473002 	movt	r3, #28674	; 0x7002
70009318:	e5933000 	ldr	r3, [r3]
7000931c:	e3530000 	cmp	r3, #0
70009320:	0a000004 	beq	70009338 <rt_object_init+0x88>
70009324:	e30938e0 	movw	r3, #39136	; 0x98e0
70009328:	e3473002 	movt	r3, #28674	; 0x7002
7000932c:	e5933000 	ldr	r3, [r3]
70009330:	e51b0018 	ldr	r0, [fp, #-24]
70009334:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
70009338:	eb0013c2 	bl	7000e248 <rt_hw_interrupt_disable>
7000933c:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
70009340:	e51b3010 	ldr	r3, [fp, #-16]
70009344:	e2832004 	add	r2, r3, #4
70009348:	e51b3018 	ldr	r3, [fp, #-24]
7000934c:	e2833008 	add	r3, r3, #8
70009350:	e1a00002 	mov	r0, r2
70009354:	e1a01003 	mov	r1, r3
70009358:	ebffff5c 	bl	700090d0 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
7000935c:	e1a00004 	mov	r0, r4
70009360:	eb0013bb 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009364:	e24bd008 	sub	sp, fp, #8
70009368:	e8bd8810 	pop	{r4, fp, pc}

7000936c <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
7000936c:	e92d4810 	push	{r4, fp, lr}
70009370:	e28db008 	add	fp, sp, #8
70009374:	e24dd014 	sub	sp, sp, #20
70009378:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
7000937c:	e51b3018 	ldr	r3, [fp, #-24]
70009380:	e3530000 	cmp	r3, #0
70009384:	1a00001d 	bne	70009400 <rt_object_detach+0x94>
70009388:	e3a03000 	mov	r3, #0
7000938c:	e54b300d 	strb	r3, [fp, #-13]
70009390:	e30a3b74 	movw	r3, #43892	; 0xab74
70009394:	e3473002 	movt	r3, #28674	; 0x7002
70009398:	e5933000 	ldr	r3, [r3]
7000939c:	e3530000 	cmp	r3, #0
700093a0:	1a00000d 	bne	700093dc <rt_object_detach+0x70>
700093a4:	e3060b28 	movw	r0, #27432	; 0x6b28
700093a8:	e3470002 	movt	r0, #28674	; 0x7002
700093ac:	e3061b48 	movw	r1, #27464	; 0x6b48
700093b0:	e3471002 	movt	r1, #28674	; 0x7002
700093b4:	e3062bb0 	movw	r2, #27568	; 0x6bb0
700093b8:	e3472002 	movt	r2, #28674	; 0x7002
700093bc:	e3a030fb 	mov	r3, #251	; 0xfb
700093c0:	ebfff90b 	bl	700077f4 <rt_kprintf>
700093c4:	e1a00000 	nop			; (mov r0, r0)
700093c8:	e55b300d 	ldrb	r3, [fp, #-13]
700093cc:	e6ef3073 	uxtb	r3, r3
700093d0:	e3530000 	cmp	r3, #0
700093d4:	0afffffb 	beq	700093c8 <rt_object_detach+0x5c>
700093d8:	ea000008 	b	70009400 <rt_object_detach+0x94>
700093dc:	e30a3b74 	movw	r3, #43892	; 0xab74
700093e0:	e3473002 	movt	r3, #28674	; 0x7002
700093e4:	e5933000 	ldr	r3, [r3]
700093e8:	e3060b48 	movw	r0, #27464	; 0x6b48
700093ec:	e3470002 	movt	r0, #28674	; 0x7002
700093f0:	e3061bb0 	movw	r1, #27568	; 0x6bb0
700093f4:	e3471002 	movt	r1, #28674	; 0x7002
700093f8:	e3a020fb 	mov	r2, #251	; 0xfb
700093fc:	e12fff33 	blx	r3

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
70009400:	e30938e4 	movw	r3, #39140	; 0x98e4
70009404:	e3473002 	movt	r3, #28674	; 0x7002
70009408:	e5933000 	ldr	r3, [r3]
7000940c:	e3530000 	cmp	r3, #0
70009410:	0a000004 	beq	70009428 <rt_object_detach+0xbc>
70009414:	e30938e4 	movw	r3, #39140	; 0x98e4
70009418:	e3473002 	movt	r3, #28674	; 0x7002
7000941c:	e5933000 	ldr	r3, [r3]
70009420:	e51b0018 	ldr	r0, [fp, #-24]
70009424:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
70009428:	eb001386 	bl	7000e248 <rt_hw_interrupt_disable>
7000942c:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
70009430:	e51b3018 	ldr	r3, [fp, #-24]
70009434:	e2833008 	add	r3, r3, #8
70009438:	e1a00003 	mov	r0, r3
7000943c:	ebffff39 	bl	70009128 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
70009440:	e1a00004 	mov	r0, r4
70009444:	eb001382 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009448:	e24bd008 	sub	sp, fp, #8
7000944c:	e8bd8810 	pop	{r4, fp, pc}

70009450 <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
70009450:	e92d4810 	push	{r4, fp, lr}
70009454:	e28db008 	add	fp, sp, #8
70009458:	e24dd01c 	sub	sp, sp, #28
7000945c:	e1a03000 	mov	r3, r0
70009460:	e50b1024 	str	r1, [fp, #-36]	; 0x24
70009464:	e54b301d 	strb	r3, [fp, #-29]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
70009468:	eb001376 	bl	7000e248 <rt_hw_interrupt_disable>
7000946c:	e50b0010 	str	r0, [fp, #-16]
70009470:	ebfff28f 	bl	70005eb4 <rt_interrupt_get_nest>
70009474:	e1a03000 	mov	r3, r0
70009478:	e3530000 	cmp	r3, #0
7000947c:	0a000022 	beq	7000950c <rt_object_allocate+0xbc>
70009480:	e3060b5c 	movw	r0, #27484	; 0x6b5c
70009484:	e3470002 	movt	r0, #28674	; 0x7002
70009488:	e3061bc4 	movw	r1, #27588	; 0x6bc4
7000948c:	e3471002 	movt	r1, #28674	; 0x7002
70009490:	ebfff8d7 	bl	700077f4 <rt_kprintf>
70009494:	e3a03000 	mov	r3, #0
70009498:	e54b3019 	strb	r3, [fp, #-25]
7000949c:	e30a3b74 	movw	r3, #43892	; 0xab74
700094a0:	e3473002 	movt	r3, #28674	; 0x7002
700094a4:	e5933000 	ldr	r3, [r3]
700094a8:	e3530000 	cmp	r3, #0
700094ac:	1a00000d 	bne	700094e8 <rt_object_allocate+0x98>
700094b0:	e3060b28 	movw	r0, #27432	; 0x6b28
700094b4:	e3470002 	movt	r0, #28674	; 0x7002
700094b8:	e3061b80 	movw	r1, #27520	; 0x6b80
700094bc:	e3471002 	movt	r1, #28674	; 0x7002
700094c0:	e3062bc4 	movw	r2, #27588	; 0x6bc4
700094c4:	e3472002 	movt	r2, #28674	; 0x7002
700094c8:	e3a03f46 	mov	r3, #280	; 0x118
700094cc:	ebfff8c8 	bl	700077f4 <rt_kprintf>
700094d0:	e1a00000 	nop			; (mov r0, r0)
700094d4:	e55b3019 	ldrb	r3, [fp, #-25]
700094d8:	e6ef3073 	uxtb	r3, r3
700094dc:	e3530000 	cmp	r3, #0
700094e0:	0afffffb 	beq	700094d4 <rt_object_allocate+0x84>
700094e4:	ea000008 	b	7000950c <rt_object_allocate+0xbc>
700094e8:	e30a3b74 	movw	r3, #43892	; 0xab74
700094ec:	e3473002 	movt	r3, #28674	; 0x7002
700094f0:	e5933000 	ldr	r3, [r3]
700094f4:	e3060b80 	movw	r0, #27520	; 0x6b80
700094f8:	e3470002 	movt	r0, #28674	; 0x7002
700094fc:	e3061bc4 	movw	r1, #27588	; 0x6bc4
70009500:	e3471002 	movt	r1, #28674	; 0x7002
70009504:	e3a02f46 	mov	r2, #280	; 0x118
70009508:	e12fff33 	blx	r3
7000950c:	e51b0010 	ldr	r0, [fp, #-16]
70009510:	eb00134f 	bl	7000e254 <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
70009514:	e55b301d 	ldrb	r3, [fp, #-29]
70009518:	e1a02203 	lsl	r2, r3, #4
7000951c:	e3083d88 	movw	r3, #36232	; 0x8d88
70009520:	e3473002 	movt	r3, #28674	; 0x7002
70009524:	e0823003 	add	r3, r2, r3
70009528:	e50b3014 	str	r3, [fp, #-20]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
7000952c:	e51b3014 	ldr	r3, [fp, #-20]
70009530:	e593300c 	ldr	r3, [r3, #12]
70009534:	e1a00003 	mov	r0, r3
70009538:	ebfffadf 	bl	700080bc <rt_malloc>
7000953c:	e50b0018 	str	r0, [fp, #-24]
    if (object == RT_NULL)
70009540:	e51b3018 	ldr	r3, [fp, #-24]
70009544:	e3530000 	cmp	r3, #0
70009548:	1a000001 	bne	70009554 <rt_object_allocate+0x104>
    {
        /* no memory can be allocated */
        return RT_NULL;
7000954c:	e3a03000 	mov	r3, #0
70009550:	ea000020 	b	700095d8 <rt_object_allocate+0x188>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
70009554:	e51b3018 	ldr	r3, [fp, #-24]
70009558:	e55b201d 	ldrb	r2, [fp, #-29]
7000955c:	e5c32006 	strb	r2, [r3, #6]

    /* set object flag */
    object->flag = 0;
70009560:	e51b3018 	ldr	r3, [fp, #-24]
70009564:	e3a02000 	mov	r2, #0
70009568:	e5c32007 	strb	r2, [r3, #7]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
7000956c:	e51b3018 	ldr	r3, [fp, #-24]
70009570:	e1a00003 	mov	r0, r3
70009574:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
70009578:	e3a02006 	mov	r2, #6
7000957c:	ebfff425 	bl	70006618 <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
70009580:	e30938e0 	movw	r3, #39136	; 0x98e0
70009584:	e3473002 	movt	r3, #28674	; 0x7002
70009588:	e5933000 	ldr	r3, [r3]
7000958c:	e3530000 	cmp	r3, #0
70009590:	0a000004 	beq	700095a8 <rt_object_allocate+0x158>
70009594:	e30938e0 	movw	r3, #39136	; 0x98e0
70009598:	e3473002 	movt	r3, #28674	; 0x7002
7000959c:	e5933000 	ldr	r3, [r3]
700095a0:	e51b0018 	ldr	r0, [fp, #-24]
700095a4:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
700095a8:	eb001326 	bl	7000e248 <rt_hw_interrupt_disable>
700095ac:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
700095b0:	e51b3014 	ldr	r3, [fp, #-20]
700095b4:	e2832004 	add	r2, r3, #4
700095b8:	e51b3018 	ldr	r3, [fp, #-24]
700095bc:	e2833008 	add	r3, r3, #8
700095c0:	e1a00002 	mov	r0, r2
700095c4:	e1a01003 	mov	r1, r3
700095c8:	ebfffec0 	bl	700090d0 <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
700095cc:	e1a00004 	mov	r0, r4
700095d0:	eb00131f 	bl	7000e254 <rt_hw_interrupt_enable>

    /* return object */
    return object;
700095d4:	e51b3018 	ldr	r3, [fp, #-24]
}
700095d8:	e1a00003 	mov	r0, r3
700095dc:	e24bd008 	sub	sp, fp, #8
700095e0:	e8bd8810 	pop	{r4, fp, pc}

700095e4 <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
700095e4:	e92d4810 	push	{r4, fp, lr}
700095e8:	e28db008 	add	fp, sp, #8
700095ec:	e24dd014 	sub	sp, sp, #20
700095f0:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
700095f4:	e51b3018 	ldr	r3, [fp, #-24]
700095f8:	e3530000 	cmp	r3, #0
700095fc:	1a00001d 	bne	70009678 <rt_object_delete+0x94>
70009600:	e3a03000 	mov	r3, #0
70009604:	e54b300d 	strb	r3, [fp, #-13]
70009608:	e30a3b74 	movw	r3, #43892	; 0xab74
7000960c:	e3473002 	movt	r3, #28674	; 0x7002
70009610:	e5933000 	ldr	r3, [r3]
70009614:	e3530000 	cmp	r3, #0
70009618:	1a00000d 	bne	70009654 <rt_object_delete+0x70>
7000961c:	e3060b28 	movw	r0, #27432	; 0x6b28
70009620:	e3470002 	movt	r0, #28674	; 0x7002
70009624:	e3061b48 	movw	r1, #27464	; 0x6b48
70009628:	e3471002 	movt	r1, #28674	; 0x7002
7000962c:	e3062bd8 	movw	r2, #27608	; 0x6bd8
70009630:	e3472002 	movt	r2, #28674	; 0x7002
70009634:	e3003159 	movw	r3, #345	; 0x159
70009638:	ebfff86d 	bl	700077f4 <rt_kprintf>
7000963c:	e1a00000 	nop			; (mov r0, r0)
70009640:	e55b300d 	ldrb	r3, [fp, #-13]
70009644:	e6ef3073 	uxtb	r3, r3
70009648:	e3530000 	cmp	r3, #0
7000964c:	0afffffb 	beq	70009640 <rt_object_delete+0x5c>
70009650:	ea000008 	b	70009678 <rt_object_delete+0x94>
70009654:	e30a3b74 	movw	r3, #43892	; 0xab74
70009658:	e3473002 	movt	r3, #28674	; 0x7002
7000965c:	e5933000 	ldr	r3, [r3]
70009660:	e3060b48 	movw	r0, #27464	; 0x6b48
70009664:	e3470002 	movt	r0, #28674	; 0x7002
70009668:	e3061bd8 	movw	r1, #27608	; 0x6bd8
7000966c:	e3471002 	movt	r1, #28674	; 0x7002
70009670:	e3002159 	movw	r2, #345	; 0x159
70009674:	e12fff33 	blx	r3
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
70009678:	e51b3018 	ldr	r3, [fp, #-24]
7000967c:	e5d33006 	ldrb	r3, [r3, #6]
70009680:	e6ef3073 	uxtb	r3, r3
70009684:	e6af3073 	sxtb	r3, r3
70009688:	e3530000 	cmp	r3, #0
7000968c:	aa00001d 	bge	70009708 <rt_object_delete+0x124>
70009690:	e3a03000 	mov	r3, #0
70009694:	e54b300e 	strb	r3, [fp, #-14]
70009698:	e30a3b74 	movw	r3, #43892	; 0xab74
7000969c:	e3473002 	movt	r3, #28674	; 0x7002
700096a0:	e5933000 	ldr	r3, [r3]
700096a4:	e3530000 	cmp	r3, #0
700096a8:	1a00000d 	bne	700096e4 <rt_object_delete+0x100>
700096ac:	e3060b28 	movw	r0, #27432	; 0x6b28
700096b0:	e3470002 	movt	r0, #28674	; 0x7002
700096b4:	e3061b84 	movw	r1, #27524	; 0x6b84
700096b8:	e3471002 	movt	r1, #28674	; 0x7002
700096bc:	e3062bd8 	movw	r2, #27608	; 0x6bd8
700096c0:	e3472002 	movt	r2, #28674	; 0x7002
700096c4:	e300315a 	movw	r3, #346	; 0x15a
700096c8:	ebfff849 	bl	700077f4 <rt_kprintf>
700096cc:	e1a00000 	nop			; (mov r0, r0)
700096d0:	e55b300e 	ldrb	r3, [fp, #-14]
700096d4:	e6ef3073 	uxtb	r3, r3
700096d8:	e3530000 	cmp	r3, #0
700096dc:	0afffffb 	beq	700096d0 <rt_object_delete+0xec>
700096e0:	ea000008 	b	70009708 <rt_object_delete+0x124>
700096e4:	e30a3b74 	movw	r3, #43892	; 0xab74
700096e8:	e3473002 	movt	r3, #28674	; 0x7002
700096ec:	e5933000 	ldr	r3, [r3]
700096f0:	e3060b84 	movw	r0, #27524	; 0x6b84
700096f4:	e3470002 	movt	r0, #28674	; 0x7002
700096f8:	e3061bd8 	movw	r1, #27608	; 0x6bd8
700096fc:	e3471002 	movt	r1, #28674	; 0x7002
70009700:	e300215a 	movw	r2, #346	; 0x15a
70009704:	e12fff33 	blx	r3

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
70009708:	e30938e4 	movw	r3, #39140	; 0x98e4
7000970c:	e3473002 	movt	r3, #28674	; 0x7002
70009710:	e5933000 	ldr	r3, [r3]
70009714:	e3530000 	cmp	r3, #0
70009718:	0a000004 	beq	70009730 <rt_object_delete+0x14c>
7000971c:	e30938e4 	movw	r3, #39140	; 0x98e4
70009720:	e3473002 	movt	r3, #28674	; 0x7002
70009724:	e5933000 	ldr	r3, [r3]
70009728:	e51b0018 	ldr	r0, [fp, #-24]
7000972c:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
70009730:	eb0012c4 	bl	7000e248 <rt_hw_interrupt_disable>
70009734:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
70009738:	e51b3018 	ldr	r3, [fp, #-24]
7000973c:	e2833008 	add	r3, r3, #8
70009740:	e1a00003 	mov	r0, r3
70009744:	ebfffe77 	bl	70009128 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
70009748:	e1a00004 	mov	r0, r4
7000974c:	eb0012c0 	bl	7000e254 <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
70009750:	e51b0018 	ldr	r0, [fp, #-24]
70009754:	ebfffd1b 	bl	70008bc8 <rt_free>
}
70009758:	e24bd008 	sub	sp, fp, #8
7000975c:	e8bd8810 	pop	{r4, fp, pc}

70009760 <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
70009760:	e92d4800 	push	{fp, lr}
70009764:	e28db004 	add	fp, sp, #4
70009768:	e24dd010 	sub	sp, sp, #16
7000976c:	e50b0010 	str	r0, [fp, #-16]
    /* object check */
    RT_ASSERT(object != RT_NULL);
70009770:	e51b3010 	ldr	r3, [fp, #-16]
70009774:	e3530000 	cmp	r3, #0
70009778:	1a00001d 	bne	700097f4 <rt_object_is_systemobject+0x94>
7000977c:	e3a03000 	mov	r3, #0
70009780:	e54b3005 	strb	r3, [fp, #-5]
70009784:	e30a3b74 	movw	r3, #43892	; 0xab74
70009788:	e3473002 	movt	r3, #28674	; 0x7002
7000978c:	e5933000 	ldr	r3, [r3]
70009790:	e3530000 	cmp	r3, #0
70009794:	1a00000d 	bne	700097d0 <rt_object_is_systemobject+0x70>
70009798:	e3060b28 	movw	r0, #27432	; 0x6b28
7000979c:	e3470002 	movt	r0, #28674	; 0x7002
700097a0:	e3061b48 	movw	r1, #27464	; 0x6b48
700097a4:	e3471002 	movt	r1, #28674	; 0x7002
700097a8:	e3062bec 	movw	r2, #27628	; 0x6bec
700097ac:	e3472002 	movt	r2, #28674	; 0x7002
700097b0:	e300317e 	movw	r3, #382	; 0x17e
700097b4:	ebfff80e 	bl	700077f4 <rt_kprintf>
700097b8:	e1a00000 	nop			; (mov r0, r0)
700097bc:	e55b3005 	ldrb	r3, [fp, #-5]
700097c0:	e6ef3073 	uxtb	r3, r3
700097c4:	e3530000 	cmp	r3, #0
700097c8:	0afffffb 	beq	700097bc <rt_object_is_systemobject+0x5c>
700097cc:	ea000008 	b	700097f4 <rt_object_is_systemobject+0x94>
700097d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700097d4:	e3473002 	movt	r3, #28674	; 0x7002
700097d8:	e5933000 	ldr	r3, [r3]
700097dc:	e3060b48 	movw	r0, #27464	; 0x6b48
700097e0:	e3470002 	movt	r0, #28674	; 0x7002
700097e4:	e3061bec 	movw	r1, #27628	; 0x6bec
700097e8:	e3471002 	movt	r1, #28674	; 0x7002
700097ec:	e300217e 	movw	r2, #382	; 0x17e
700097f0:	e12fff33 	blx	r3

    if (object->type & RT_Object_Class_Static)
700097f4:	e51b3010 	ldr	r3, [fp, #-16]
700097f8:	e5d33006 	ldrb	r3, [r3, #6]
700097fc:	e6ef3073 	uxtb	r3, r3
70009800:	e6af3073 	sxtb	r3, r3
70009804:	e3530000 	cmp	r3, #0
70009808:	aa000001 	bge	70009814 <rt_object_is_systemobject+0xb4>
        return RT_TRUE;
7000980c:	e3a03001 	mov	r3, #1
70009810:	ea000000 	b	70009818 <rt_object_is_systemobject+0xb8>

    return RT_FALSE;
70009814:	e3a03000 	mov	r3, #0
}
70009818:	e1a00003 	mov	r0, r3
7000981c:	e24bd004 	sub	sp, fp, #4
70009820:	e8bd8800 	pop	{fp, pc}

70009824 <rt_object_find>:
 * in object container.
 *
 * @note this function shall not be invoked in interrupt status.
 */
rt_object_t rt_object_find(const char *name, rt_uint8_t type)
{
70009824:	e92d4800 	push	{fp, lr}
70009828:	e28db004 	add	fp, sp, #4
7000982c:	e24dd020 	sub	sp, sp, #32
70009830:	e50b0020 	str	r0, [fp, #-32]
70009834:	e1a03001 	mov	r3, r1
70009838:	e54b3021 	strb	r3, [fp, #-33]	; 0x21
    struct rt_object *object;
    struct rt_list_node *node;
    struct rt_object_information *information = RT_NULL;
7000983c:	e3a03000 	mov	r3, #0
70009840:	e50b300c 	str	r3, [fp, #-12]

    /* parameter check */
    if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
70009844:	e51b3020 	ldr	r3, [fp, #-32]
70009848:	e3530000 	cmp	r3, #0
7000984c:	0a000002 	beq	7000985c <rt_object_find+0x38>
70009850:	e55b3021 	ldrb	r3, [fp, #-33]	; 0x21
70009854:	e3530009 	cmp	r3, #9
70009858:	9a000001 	bls	70009864 <rt_object_find+0x40>
        return RT_NULL;
7000985c:	e3a03000 	mov	r3, #0
70009860:	ea000050 	b	700099a8 <rt_object_find+0x184>

    /* which is invoke in interrupt status */
    RT_DEBUG_NOT_IN_INTERRUPT;
70009864:	eb001277 	bl	7000e248 <rt_hw_interrupt_disable>
70009868:	e50b0010 	str	r0, [fp, #-16]
7000986c:	ebfff190 	bl	70005eb4 <rt_interrupt_get_nest>
70009870:	e1a03000 	mov	r3, r0
70009874:	e3530000 	cmp	r3, #0
70009878:	0a000022 	beq	70009908 <rt_object_find+0xe4>
7000987c:	e3060b5c 	movw	r0, #27484	; 0x6b5c
70009880:	e3470002 	movt	r0, #28674	; 0x7002
70009884:	e3061c08 	movw	r1, #27656	; 0x6c08
70009888:	e3471002 	movt	r1, #28674	; 0x7002
7000988c:	ebfff7d8 	bl	700077f4 <rt_kprintf>
70009890:	e3a03000 	mov	r3, #0
70009894:	e54b3015 	strb	r3, [fp, #-21]
70009898:	e30a3b74 	movw	r3, #43892	; 0xab74
7000989c:	e3473002 	movt	r3, #28674	; 0x7002
700098a0:	e5933000 	ldr	r3, [r3]
700098a4:	e3530000 	cmp	r3, #0
700098a8:	1a00000d 	bne	700098e4 <rt_object_find+0xc0>
700098ac:	e3060b28 	movw	r0, #27432	; 0x6b28
700098b0:	e3470002 	movt	r0, #28674	; 0x7002
700098b4:	e3061b80 	movw	r1, #27520	; 0x6b80
700098b8:	e3471002 	movt	r1, #28674	; 0x7002
700098bc:	e3062c08 	movw	r2, #27656	; 0x6c08
700098c0:	e3472002 	movt	r2, #28674	; 0x7002
700098c4:	e300319d 	movw	r3, #413	; 0x19d
700098c8:	ebfff7c9 	bl	700077f4 <rt_kprintf>
700098cc:	e1a00000 	nop			; (mov r0, r0)
700098d0:	e55b3015 	ldrb	r3, [fp, #-21]
700098d4:	e6ef3073 	uxtb	r3, r3
700098d8:	e3530000 	cmp	r3, #0
700098dc:	0afffffb 	beq	700098d0 <rt_object_find+0xac>
700098e0:	ea000008 	b	70009908 <rt_object_find+0xe4>
700098e4:	e30a3b74 	movw	r3, #43892	; 0xab74
700098e8:	e3473002 	movt	r3, #28674	; 0x7002
700098ec:	e5933000 	ldr	r3, [r3]
700098f0:	e3060b80 	movw	r0, #27520	; 0x6b80
700098f4:	e3470002 	movt	r0, #28674	; 0x7002
700098f8:	e3061c08 	movw	r1, #27656	; 0x6c08
700098fc:	e3471002 	movt	r1, #28674	; 0x7002
70009900:	e300219d 	movw	r2, #413	; 0x19d
70009904:	e12fff33 	blx	r3
70009908:	e51b0010 	ldr	r0, [fp, #-16]
7000990c:	eb001250 	bl	7000e254 <rt_hw_interrupt_enable>
        }
    }
#endif

    /* enter critical */
    rt_enter_critical();
70009910:	eb000188 	bl	70009f38 <rt_enter_critical>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
70009914:	e51b300c 	ldr	r3, [fp, #-12]
70009918:	e3530000 	cmp	r3, #0
7000991c:	1a000005 	bne	70009938 <rt_object_find+0x114>
70009920:	e55b3021 	ldrb	r3, [fp, #-33]	; 0x21
70009924:	e1a02203 	lsl	r2, r3, #4
70009928:	e3083d88 	movw	r3, #36232	; 0x8d88
7000992c:	e3473002 	movt	r3, #28674	; 0x7002
70009930:	e0823003 	add	r3, r2, r3
70009934:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
70009938:	e51b300c 	ldr	r3, [fp, #-12]
7000993c:	e5933004 	ldr	r3, [r3, #4]
70009940:	e50b3008 	str	r3, [fp, #-8]
70009944:	ea000010 	b	7000998c <rt_object_find+0x168>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
70009948:	e51b3008 	ldr	r3, [fp, #-8]
7000994c:	e2433008 	sub	r3, r3, #8
70009950:	e50b3014 	str	r3, [fp, #-20]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
70009954:	e51b3014 	ldr	r3, [fp, #-20]
70009958:	e1a00003 	mov	r0, r3
7000995c:	e51b1020 	ldr	r1, [fp, #-32]
70009960:	e3a02006 	mov	r2, #6
70009964:	ebfff35b 	bl	700066d8 <rt_strncmp>
70009968:	e1a03000 	mov	r3, r0
7000996c:	e3530000 	cmp	r3, #0
70009970:	1a000002 	bne	70009980 <rt_object_find+0x15c>
        {
            /* leave critical */
            rt_exit_critical();
70009974:	eb00017f 	bl	70009f78 <rt_exit_critical>

            return object;
70009978:	e51b3014 	ldr	r3, [fp, #-20]
7000997c:	ea000009 	b	700099a8 <rt_object_find+0x184>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
70009980:	e51b3008 	ldr	r3, [fp, #-8]
70009984:	e5933000 	ldr	r3, [r3]
70009988:	e50b3008 	str	r3, [fp, #-8]
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
7000998c:	e51b300c 	ldr	r3, [fp, #-12]
70009990:	e2832004 	add	r2, r3, #4
    /* enter critical */
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
70009994:	e51b3008 	ldr	r3, [fp, #-8]
70009998:	e1520003 	cmp	r2, r3
7000999c:	1affffe9 	bne	70009948 <rt_object_find+0x124>
            return object;
        }
    }

    /* leave critical */
    rt_exit_critical();
700099a0:	eb000174 	bl	70009f78 <rt_exit_critical>

    return RT_NULL;
700099a4:	e3a03000 	mov	r3, #0
}
700099a8:	e1a00003 	mov	r0, r3
700099ac:	e24bd004 	sub	sp, fp, #4
700099b0:	e8bd8800 	pop	{fp, pc}

700099b4 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
700099b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700099b8:	e28db000 	add	fp, sp, #0
700099bc:	e24dd00c 	sub	sp, sp, #12
700099c0:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
700099c4:	e51b3008 	ldr	r3, [fp, #-8]
700099c8:	e51b2008 	ldr	r2, [fp, #-8]
700099cc:	e5832004 	str	r2, [r3, #4]
700099d0:	e51b3008 	ldr	r3, [fp, #-8]
700099d4:	e5932004 	ldr	r2, [r3, #4]
700099d8:	e51b3008 	ldr	r3, [fp, #-8]
700099dc:	e5832000 	str	r2, [r3]
}
700099e0:	e24bd000 	sub	sp, fp, #0
700099e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700099e8:	e12fff1e 	bx	lr

700099ec <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
700099ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700099f0:	e28db000 	add	fp, sp, #0
700099f4:	e24dd00c 	sub	sp, sp, #12
700099f8:	e50b0008 	str	r0, [fp, #-8]
700099fc:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
70009a00:	e51b3008 	ldr	r3, [fp, #-8]
70009a04:	e5933004 	ldr	r3, [r3, #4]
70009a08:	e51b200c 	ldr	r2, [fp, #-12]
70009a0c:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
70009a10:	e51b3008 	ldr	r3, [fp, #-8]
70009a14:	e5932004 	ldr	r2, [r3, #4]
70009a18:	e51b300c 	ldr	r3, [fp, #-12]
70009a1c:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
70009a20:	e51b3008 	ldr	r3, [fp, #-8]
70009a24:	e51b200c 	ldr	r2, [fp, #-12]
70009a28:	e5832004 	str	r2, [r3, #4]
    n->next = l;
70009a2c:	e51b300c 	ldr	r3, [fp, #-12]
70009a30:	e51b2008 	ldr	r2, [fp, #-8]
70009a34:	e5832000 	str	r2, [r3]
}
70009a38:	e24bd000 	sub	sp, fp, #0
70009a3c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009a40:	e12fff1e 	bx	lr

70009a44 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
70009a44:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009a48:	e28db000 	add	fp, sp, #0
70009a4c:	e24dd00c 	sub	sp, sp, #12
70009a50:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
70009a54:	e51b3008 	ldr	r3, [fp, #-8]
70009a58:	e5933000 	ldr	r3, [r3]
70009a5c:	e51b2008 	ldr	r2, [fp, #-8]
70009a60:	e5922004 	ldr	r2, [r2, #4]
70009a64:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
70009a68:	e51b3008 	ldr	r3, [fp, #-8]
70009a6c:	e5933004 	ldr	r3, [r3, #4]
70009a70:	e51b2008 	ldr	r2, [fp, #-8]
70009a74:	e5922000 	ldr	r2, [r2]
70009a78:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
70009a7c:	e51b3008 	ldr	r3, [fp, #-8]
70009a80:	e51b2008 	ldr	r2, [fp, #-8]
70009a84:	e5832004 	str	r2, [r3, #4]
70009a88:	e51b3008 	ldr	r3, [fp, #-8]
70009a8c:	e5932004 	ldr	r2, [r3, #4]
70009a90:	e51b3008 	ldr	r3, [fp, #-8]
70009a94:	e5832000 	str	r2, [r3]
}
70009a98:	e24bd000 	sub	sp, fp, #0
70009a9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009aa0:	e12fff1e 	bx	lr

70009aa4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
70009aa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009aa8:	e28db000 	add	fp, sp, #0
70009aac:	e24dd00c 	sub	sp, sp, #12
70009ab0:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
70009ab4:	e51b3008 	ldr	r3, [fp, #-8]
70009ab8:	e5932000 	ldr	r2, [r3]
70009abc:	e51b3008 	ldr	r3, [fp, #-8]
70009ac0:	e1520003 	cmp	r2, r3
70009ac4:	13a03000 	movne	r3, #0
70009ac8:	03a03001 	moveq	r3, #1
70009acc:	e6ef3073 	uxtb	r3, r3
}
70009ad0:	e1a00003 	mov	r0, r3
70009ad4:	e24bd000 	sub	sp, fp, #0
70009ad8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009adc:	e12fff1e 	bx	lr

70009ae0 <rt_scheduler_sethook>:
 *
 * @param hook the hook function
 */
void
rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
{
70009ae0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009ae4:	e28db000 	add	fp, sp, #0
70009ae8:	e24dd00c 	sub	sp, sp, #12
70009aec:	e50b0008 	str	r0, [fp, #-8]
    rt_scheduler_hook = hook;
70009af0:	e30938ec 	movw	r3, #39148	; 0x98ec
70009af4:	e3473002 	movt	r3, #28674	; 0x7002
70009af8:	e51b2008 	ldr	r2, [fp, #-8]
70009afc:	e5832000 	str	r2, [r3]
}
70009b00:	e24bd000 	sub	sp, fp, #0
70009b04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70009b08:	e12fff1e 	bx	lr

70009b0c <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
70009b0c:	e92d4818 	push	{r3, r4, fp, lr}
70009b10:	e28db00c 	add	fp, sp, #12
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
70009b14:	e30938e8 	movw	r3, #39144	; 0x98e8
70009b18:	e3473002 	movt	r3, #28674	; 0x7002
70009b1c:	e3a02000 	mov	r2, #0
70009b20:	e1c320b0 	strh	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
70009b24:	e3a04000 	mov	r4, #0
70009b28:	ea000006 	b	70009b48 <rt_system_scheduler_init+0x3c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
70009b2c:	e1a02184 	lsl	r2, r4, #3
70009b30:	e30a3b84 	movw	r3, #43908	; 0xab84
70009b34:	e3473002 	movt	r3, #28674	; 0x7002
70009b38:	e0823003 	add	r3, r2, r3
70009b3c:	e1a00003 	mov	r0, r3
70009b40:	ebffff9b 	bl	700099b4 <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
70009b44:	e2844001 	add	r4, r4, #1
70009b48:	e354001f 	cmp	r4, #31
70009b4c:	dafffff6 	ble	70009b2c <rt_system_scheduler_init+0x20>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
70009b50:	e30a3c84 	movw	r3, #44164	; 0xac84
70009b54:	e3473002 	movt	r3, #28674	; 0x7002
70009b58:	e3a0201f 	mov	r2, #31
70009b5c:	e5c32000 	strb	r2, [r3]
    rt_current_thread = RT_NULL;
70009b60:	e30a3c88 	movw	r3, #44168	; 0xac88
70009b64:	e3473002 	movt	r3, #28674	; 0x7002
70009b68:	e3a02000 	mov	r2, #0
70009b6c:	e5832000 	str	r2, [r3]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
70009b70:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009b74:	e3473002 	movt	r3, #28674	; 0x7002
70009b78:	e3a02000 	mov	r2, #0
70009b7c:	e5832000 	str	r2, [r3]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
70009b80:	e30a0c90 	movw	r0, #44176	; 0xac90
70009b84:	e3470002 	movt	r0, #28674	; 0x7002
70009b88:	ebffff89 	bl	700099b4 <rt_list_init>
}
70009b8c:	e8bd8818 	pop	{r3, r4, fp, pc}

70009b90 <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
70009b90:	e92d4818 	push	{r3, r4, fp, lr}
70009b94:	e28db00c 	add	fp, sp, #12
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
70009b98:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009b9c:	e3473002 	movt	r3, #28674	; 0x7002
70009ba0:	e5933000 	ldr	r3, [r3]
70009ba4:	e1a00003 	mov	r0, r3
70009ba8:	ebfff78c 	bl	700079e0 <__rt_ffs>
70009bac:	e1a03000 	mov	r3, r0
70009bb0:	e2433001 	sub	r3, r3, #1
70009bb4:	e1a04003 	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
70009bb8:	e30a3b84 	movw	r3, #43908	; 0xab84
70009bbc:	e3473002 	movt	r3, #28674	; 0x7002
70009bc0:	e7933184 	ldr	r3, [r3, r4, lsl #3]
70009bc4:	e2434010 	sub	r4, r3, #16
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
70009bc8:	e30a3c88 	movw	r3, #44168	; 0xac88
70009bcc:	e3473002 	movt	r3, #28674	; 0x7002
70009bd0:	e5834000 	str	r4, [r3]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
70009bd4:	e2843018 	add	r3, r4, #24
70009bd8:	e1a00003 	mov	r0, r3
70009bdc:	eb00119e 	bl	7000e25c <rt_hw_context_switch_to>

    /* never come back */
}
70009be0:	e8bd8818 	pop	{r3, r4, fp, pc}

70009be4 <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
70009be4:	e92d4810 	push	{r4, fp, lr}
70009be8:	e28db008 	add	fp, sp, #8
70009bec:	e24dd014 	sub	sp, sp, #20
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
70009bf0:	eb001194 	bl	7000e248 <rt_hw_interrupt_disable>
70009bf4:	e50b0010 	str	r0, [fp, #-16]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
70009bf8:	e30938e8 	movw	r3, #39144	; 0x98e8
70009bfc:	e3473002 	movt	r3, #28674	; 0x7002
70009c00:	e1d330b0 	ldrh	r3, [r3]
70009c04:	e3530000 	cmp	r3, #0
70009c08:	1a000040 	bne	70009d10 <rt_schedule+0x12c>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
70009c0c:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009c10:	e3473002 	movt	r3, #28674	; 0x7002
70009c14:	e5933000 	ldr	r3, [r3]
70009c18:	e1a00003 	mov	r0, r3
70009c1c:	ebfff76f 	bl	700079e0 <__rt_ffs>
70009c20:	e1a03000 	mov	r3, r0
70009c24:	e2433001 	sub	r3, r3, #1
70009c28:	e1a04003 	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
70009c2c:	e30a3b84 	movw	r3, #43908	; 0xab84
70009c30:	e3473002 	movt	r3, #28674	; 0x7002
70009c34:	e7933184 	ldr	r3, [r3, r4, lsl #3]
70009c38:	e2433010 	sub	r3, r3, #16
70009c3c:	e50b3014 	str	r3, [fp, #-20]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
70009c40:	e30a3c88 	movw	r3, #44168	; 0xac88
70009c44:	e3473002 	movt	r3, #28674	; 0x7002
70009c48:	e5933000 	ldr	r3, [r3]
70009c4c:	e51b2014 	ldr	r2, [fp, #-20]
70009c50:	e1520003 	cmp	r2, r3
70009c54:	0a00002d 	beq	70009d10 <rt_schedule+0x12c>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
70009c58:	e6ef2074 	uxtb	r2, r4
70009c5c:	e30a3c84 	movw	r3, #44164	; 0xac84
70009c60:	e3473002 	movt	r3, #28674	; 0x7002
70009c64:	e5c32000 	strb	r2, [r3]
            from_thread         = rt_current_thread;
70009c68:	e30a3c88 	movw	r3, #44168	; 0xac88
70009c6c:	e3473002 	movt	r3, #28674	; 0x7002
70009c70:	e5933000 	ldr	r3, [r3]
70009c74:	e50b3018 	str	r3, [fp, #-24]
            rt_current_thread   = to_thread;
70009c78:	e30a3c88 	movw	r3, #44168	; 0xac88
70009c7c:	e3473002 	movt	r3, #28674	; 0x7002
70009c80:	e51b2014 	ldr	r2, [fp, #-20]
70009c84:	e5832000 	str	r2, [r3]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
70009c88:	e30938ec 	movw	r3, #39148	; 0x98ec
70009c8c:	e3473002 	movt	r3, #28674	; 0x7002
70009c90:	e5933000 	ldr	r3, [r3]
70009c94:	e3530000 	cmp	r3, #0
70009c98:	0a000005 	beq	70009cb4 <rt_schedule+0xd0>
70009c9c:	e30938ec 	movw	r3, #39148	; 0x98ec
70009ca0:	e3473002 	movt	r3, #28674	; 0x7002
70009ca4:	e5933000 	ldr	r3, [r3]
70009ca8:	e51b0018 	ldr	r0, [fp, #-24]
70009cac:	e51b1014 	ldr	r1, [fp, #-20]
70009cb0:	e12fff33 	blx	r3

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
70009cb4:	e30a3b70 	movw	r3, #43888	; 0xab70
70009cb8:	e3473002 	movt	r3, #28674	; 0x7002
70009cbc:	e5d33000 	ldrb	r3, [r3]
70009cc0:	e6ef3073 	uxtb	r3, r3
70009cc4:	e3530000 	cmp	r3, #0
70009cc8:	1a000008 	bne	70009cf0 <rt_schedule+0x10c>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
70009ccc:	e51b3018 	ldr	r3, [fp, #-24]
70009cd0:	e2833018 	add	r3, r3, #24
70009cd4:	e1a02003 	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
70009cd8:	e51b3014 	ldr	r3, [fp, #-20]
70009cdc:	e2833018 	add	r3, r3, #24
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
70009ce0:	e1a00002 	mov	r0, r2
70009ce4:	e1a01003 	mov	r1, r3
70009ce8:	eb0067d7 	bl	70023c4c <rt_hw_context_switch>
70009cec:	ea000007 	b	70009d10 <rt_schedule+0x12c>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
70009cf0:	e51b3018 	ldr	r3, [fp, #-24]
70009cf4:	e2833018 	add	r3, r3, #24
70009cf8:	e1a02003 	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
70009cfc:	e51b3014 	ldr	r3, [fp, #-20]
70009d00:	e2833018 	add	r3, r3, #24
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
70009d04:	e1a00002 	mov	r0, r2
70009d08:	e1a01003 	mov	r1, r3
70009d0c:	eb0067d9 	bl	70023c78 <rt_hw_context_switch_interrupt>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
70009d10:	e51b0010 	ldr	r0, [fp, #-16]
70009d14:	eb00114e 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009d18:	e24bd008 	sub	sp, fp, #8
70009d1c:	e8bd8810 	pop	{r4, fp, pc}

70009d20 <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
70009d20:	e92d4810 	push	{r4, fp, lr}
70009d24:	e28db008 	add	fp, sp, #8
70009d28:	e24dd014 	sub	sp, sp, #20
70009d2c:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
70009d30:	e51b3018 	ldr	r3, [fp, #-24]
70009d34:	e3530000 	cmp	r3, #0
70009d38:	1a00001d 	bne	70009db4 <rt_schedule_insert_thread+0x94>
70009d3c:	e3a03000 	mov	r3, #0
70009d40:	e54b300d 	strb	r3, [fp, #-13]
70009d44:	e30a3b74 	movw	r3, #43892	; 0xab74
70009d48:	e3473002 	movt	r3, #28674	; 0x7002
70009d4c:	e5933000 	ldr	r3, [r3]
70009d50:	e3530000 	cmp	r3, #0
70009d54:	1a00000d 	bne	70009d90 <rt_schedule_insert_thread+0x70>
70009d58:	e3060c18 	movw	r0, #27672	; 0x6c18
70009d5c:	e3470002 	movt	r0, #28674	; 0x7002
70009d60:	e3061c38 	movw	r1, #27704	; 0x6c38
70009d64:	e3471002 	movt	r1, #28674	; 0x7002
70009d68:	e3062c4c 	movw	r2, #27724	; 0x6c4c
70009d6c:	e3472002 	movt	r2, #28674	; 0x7002
70009d70:	e300310f 	movw	r3, #271	; 0x10f
70009d74:	ebfff69e 	bl	700077f4 <rt_kprintf>
70009d78:	e1a00000 	nop			; (mov r0, r0)
70009d7c:	e55b300d 	ldrb	r3, [fp, #-13]
70009d80:	e6ef3073 	uxtb	r3, r3
70009d84:	e3530000 	cmp	r3, #0
70009d88:	0afffffb 	beq	70009d7c <rt_schedule_insert_thread+0x5c>
70009d8c:	ea000008 	b	70009db4 <rt_schedule_insert_thread+0x94>
70009d90:	e30a3b74 	movw	r3, #43892	; 0xab74
70009d94:	e3473002 	movt	r3, #28674	; 0x7002
70009d98:	e5933000 	ldr	r3, [r3]
70009d9c:	e3060c38 	movw	r0, #27704	; 0x6c38
70009da0:	e3470002 	movt	r0, #28674	; 0x7002
70009da4:	e3061c4c 	movw	r1, #27724	; 0x6c4c
70009da8:	e3471002 	movt	r1, #28674	; 0x7002
70009dac:	e300210f 	movw	r2, #271	; 0x10f
70009db0:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70009db4:	eb001123 	bl	7000e248 <rt_hw_interrupt_disable>
70009db8:	e1a04000 	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
70009dbc:	e51b3018 	ldr	r3, [fp, #-24]
70009dc0:	e3a02001 	mov	r2, #1
70009dc4:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
70009dc8:	e51b3018 	ldr	r3, [fp, #-24]
70009dcc:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
70009dd0:	e1a02183 	lsl	r2, r3, #3
70009dd4:	e30a3b84 	movw	r3, #43908	; 0xab84
70009dd8:	e3473002 	movt	r3, #28674	; 0x7002
70009ddc:	e0822003 	add	r2, r2, r3
70009de0:	e51b3018 	ldr	r3, [fp, #-24]
70009de4:	e2833010 	add	r3, r3, #16
70009de8:	e1a00002 	mov	r0, r2
70009dec:	e1a01003 	mov	r1, r3
70009df0:	ebfffefd 	bl	700099ec <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
70009df4:	e51b3018 	ldr	r3, [fp, #-24]
70009df8:	e5932034 	ldr	r2, [r3, #52]	; 0x34
70009dfc:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009e00:	e3473002 	movt	r3, #28674	; 0x7002
70009e04:	e5933000 	ldr	r3, [r3]
70009e08:	e1822003 	orr	r2, r2, r3
70009e0c:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009e10:	e3473002 	movt	r3, #28674	; 0x7002
70009e14:	e5832000 	str	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70009e18:	e1a00004 	mov	r0, r4
70009e1c:	eb00110c 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009e20:	e24bd008 	sub	sp, fp, #8
70009e24:	e8bd8810 	pop	{r4, fp, pc}

70009e28 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
70009e28:	e92d4810 	push	{r4, fp, lr}
70009e2c:	e28db008 	add	fp, sp, #8
70009e30:	e24dd014 	sub	sp, sp, #20
70009e34:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
70009e38:	e51b3018 	ldr	r3, [fp, #-24]
70009e3c:	e3530000 	cmp	r3, #0
70009e40:	1a00001d 	bne	70009ebc <rt_schedule_remove_thread+0x94>
70009e44:	e3a03000 	mov	r3, #0
70009e48:	e54b300d 	strb	r3, [fp, #-13]
70009e4c:	e30a3b74 	movw	r3, #43892	; 0xab74
70009e50:	e3473002 	movt	r3, #28674	; 0x7002
70009e54:	e5933000 	ldr	r3, [r3]
70009e58:	e3530000 	cmp	r3, #0
70009e5c:	1a00000d 	bne	70009e98 <rt_schedule_remove_thread+0x70>
70009e60:	e3060c18 	movw	r0, #27672	; 0x6c18
70009e64:	e3470002 	movt	r0, #28674	; 0x7002
70009e68:	e3061c38 	movw	r1, #27704	; 0x6c38
70009e6c:	e3471002 	movt	r1, #28674	; 0x7002
70009e70:	e3062c68 	movw	r2, #27752	; 0x6c68
70009e74:	e3472002 	movt	r2, #28674	; 0x7002
70009e78:	e300313d 	movw	r3, #317	; 0x13d
70009e7c:	ebfff65c 	bl	700077f4 <rt_kprintf>
70009e80:	e1a00000 	nop			; (mov r0, r0)
70009e84:	e55b300d 	ldrb	r3, [fp, #-13]
70009e88:	e6ef3073 	uxtb	r3, r3
70009e8c:	e3530000 	cmp	r3, #0
70009e90:	0afffffb 	beq	70009e84 <rt_schedule_remove_thread+0x5c>
70009e94:	ea000008 	b	70009ebc <rt_schedule_remove_thread+0x94>
70009e98:	e30a3b74 	movw	r3, #43892	; 0xab74
70009e9c:	e3473002 	movt	r3, #28674	; 0x7002
70009ea0:	e5933000 	ldr	r3, [r3]
70009ea4:	e3060c38 	movw	r0, #27704	; 0x6c38
70009ea8:	e3470002 	movt	r0, #28674	; 0x7002
70009eac:	e3061c68 	movw	r1, #27752	; 0x6c68
70009eb0:	e3471002 	movt	r1, #28674	; 0x7002
70009eb4:	e300213d 	movw	r2, #317	; 0x13d
70009eb8:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
70009ebc:	eb0010e1 	bl	7000e248 <rt_hw_interrupt_disable>
70009ec0:	e1a04000 	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
70009ec4:	e51b3018 	ldr	r3, [fp, #-24]
70009ec8:	e2833010 	add	r3, r3, #16
70009ecc:	e1a00003 	mov	r0, r3
70009ed0:	ebfffedb 	bl	70009a44 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
70009ed4:	e51b3018 	ldr	r3, [fp, #-24]
70009ed8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
70009edc:	e1a02183 	lsl	r2, r3, #3
70009ee0:	e30a3b84 	movw	r3, #43908	; 0xab84
70009ee4:	e3473002 	movt	r3, #28674	; 0x7002
70009ee8:	e0823003 	add	r3, r2, r3
70009eec:	e1a00003 	mov	r0, r3
70009ef0:	ebfffeeb 	bl	70009aa4 <rt_list_isempty>
70009ef4:	e1a03000 	mov	r3, r0
70009ef8:	e3530000 	cmp	r3, #0
70009efc:	0a000009 	beq	70009f28 <rt_schedule_remove_thread+0x100>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
70009f00:	e51b3018 	ldr	r3, [fp, #-24]
70009f04:	e5933034 	ldr	r3, [r3, #52]	; 0x34
70009f08:	e1e02003 	mvn	r2, r3
70009f0c:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009f10:	e3473002 	movt	r3, #28674	; 0x7002
70009f14:	e5933000 	ldr	r3, [r3]
70009f18:	e0022003 	and	r2, r2, r3
70009f1c:	e30a3c8c 	movw	r3, #44172	; 0xac8c
70009f20:	e3473002 	movt	r3, #28674	; 0x7002
70009f24:	e5832000 	str	r2, [r3]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
70009f28:	e1a00004 	mov	r0, r4
70009f2c:	eb0010c8 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009f30:	e24bd008 	sub	sp, fp, #8
70009f34:	e8bd8810 	pop	{r4, fp, pc}

70009f38 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
70009f38:	e92d4818 	push	{r3, r4, fp, lr}
70009f3c:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
70009f40:	eb0010c0 	bl	7000e248 <rt_hw_interrupt_disable>
70009f44:	e1a04000 	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
70009f48:	e30938e8 	movw	r3, #39144	; 0x98e8
70009f4c:	e3473002 	movt	r3, #28674	; 0x7002
70009f50:	e1d330b0 	ldrh	r3, [r3]
70009f54:	e6ff3073 	uxth	r3, r3
70009f58:	e2833001 	add	r3, r3, #1
70009f5c:	e6ff2073 	uxth	r2, r3
70009f60:	e30938e8 	movw	r3, #39144	; 0x98e8
70009f64:	e3473002 	movt	r3, #28674	; 0x7002
70009f68:	e1c320b0 	strh	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
70009f6c:	e1a00004 	mov	r0, r4
70009f70:	eb0010b7 	bl	7000e254 <rt_hw_interrupt_enable>
}
70009f74:	e8bd8818 	pop	{r3, r4, fp, pc}

70009f78 <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
70009f78:	e92d4818 	push	{r3, r4, fp, lr}
70009f7c:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
70009f80:	eb0010b0 	bl	7000e248 <rt_hw_interrupt_disable>
70009f84:	e1a04000 	mov	r4, r0

    rt_scheduler_lock_nest --;
70009f88:	e30938e8 	movw	r3, #39144	; 0x98e8
70009f8c:	e3473002 	movt	r3, #28674	; 0x7002
70009f90:	e1d330b0 	ldrh	r3, [r3]
70009f94:	e6ff3073 	uxth	r3, r3
70009f98:	e2433001 	sub	r3, r3, #1
70009f9c:	e6ff2073 	uxth	r2, r3
70009fa0:	e30938e8 	movw	r3, #39144	; 0x98e8
70009fa4:	e3473002 	movt	r3, #28674	; 0x7002
70009fa8:	e1c320b0 	strh	r2, [r3]

    if (rt_scheduler_lock_nest <= 0)
70009fac:	e30938e8 	movw	r3, #39144	; 0x98e8
70009fb0:	e3473002 	movt	r3, #28674	; 0x7002
70009fb4:	e1d330b0 	ldrh	r3, [r3]
70009fb8:	e6bf3073 	sxth	r3, r3
70009fbc:	e3530000 	cmp	r3, #0
70009fc0:	ca000007 	bgt	70009fe4 <rt_exit_critical+0x6c>
    {
        rt_scheduler_lock_nest = 0;
70009fc4:	e30938e8 	movw	r3, #39144	; 0x98e8
70009fc8:	e3473002 	movt	r3, #28674	; 0x7002
70009fcc:	e3a02000 	mov	r2, #0
70009fd0:	e1c320b0 	strh	r2, [r3]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70009fd4:	e1a00004 	mov	r0, r4
70009fd8:	eb00109d 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
70009fdc:	ebffff00 	bl	70009be4 <rt_schedule>
70009fe0:	ea000001 	b	70009fec <rt_exit_critical+0x74>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70009fe4:	e1a00004 	mov	r0, r4
70009fe8:	eb001099 	bl	7000e254 <rt_hw_interrupt_enable>
    }
}
70009fec:	e8bd8818 	pop	{r3, r4, fp, pc}

70009ff0 <rt_critical_level>:
 * Get the scheduler lock level
 *
 * @return the level of the scheduler lock. 0 means unlocked.
 */
rt_uint16_t rt_critical_level(void)
{
70009ff0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70009ff4:	e28db000 	add	fp, sp, #0
    return rt_scheduler_lock_nest;
70009ff8:	e30938e8 	movw	r3, #39144	; 0x98e8
70009ffc:	e3473002 	movt	r3, #28674	; 0x7002
7000a000:	e1d330b0 	ldrh	r3, [r3]
7000a004:	e6ff3073 	uxth	r3, r3
}
7000a008:	e1a00003 	mov	r0, r3
7000a00c:	e24bd000 	sub	sp, fp, #0
7000a010:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a014:	e12fff1e 	bx	lr

7000a018 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
7000a018:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000a01c:	e28db000 	add	fp, sp, #0
7000a020:	e24dd00c 	sub	sp, sp, #12
7000a024:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
7000a028:	e51b3008 	ldr	r3, [fp, #-8]
7000a02c:	e51b2008 	ldr	r2, [fp, #-8]
7000a030:	e5832004 	str	r2, [r3, #4]
7000a034:	e51b3008 	ldr	r3, [fp, #-8]
7000a038:	e5932004 	ldr	r2, [r3, #4]
7000a03c:	e51b3008 	ldr	r3, [fp, #-8]
7000a040:	e5832000 	str	r2, [r3]
}
7000a044:	e24bd000 	sub	sp, fp, #0
7000a048:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a04c:	e12fff1e 	bx	lr

7000a050 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
7000a050:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000a054:	e28db000 	add	fp, sp, #0
7000a058:	e24dd00c 	sub	sp, sp, #12
7000a05c:	e50b0008 	str	r0, [fp, #-8]
7000a060:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
7000a064:	e51b3008 	ldr	r3, [fp, #-8]
7000a068:	e5933000 	ldr	r3, [r3]
7000a06c:	e51b200c 	ldr	r2, [fp, #-12]
7000a070:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
7000a074:	e51b3008 	ldr	r3, [fp, #-8]
7000a078:	e5932000 	ldr	r2, [r3]
7000a07c:	e51b300c 	ldr	r3, [fp, #-12]
7000a080:	e5832000 	str	r2, [r3]

    l->next = n;
7000a084:	e51b3008 	ldr	r3, [fp, #-8]
7000a088:	e51b200c 	ldr	r2, [fp, #-12]
7000a08c:	e5832000 	str	r2, [r3]
    n->prev = l;
7000a090:	e51b300c 	ldr	r3, [fp, #-12]
7000a094:	e51b2008 	ldr	r2, [fp, #-8]
7000a098:	e5832004 	str	r2, [r3, #4]
}
7000a09c:	e24bd000 	sub	sp, fp, #0
7000a0a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a0a4:	e12fff1e 	bx	lr

7000a0a8 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
7000a0a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000a0ac:	e28db000 	add	fp, sp, #0
7000a0b0:	e24dd00c 	sub	sp, sp, #12
7000a0b4:	e50b0008 	str	r0, [fp, #-8]
7000a0b8:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
7000a0bc:	e51b3008 	ldr	r3, [fp, #-8]
7000a0c0:	e5933004 	ldr	r3, [r3, #4]
7000a0c4:	e51b200c 	ldr	r2, [fp, #-12]
7000a0c8:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
7000a0cc:	e51b3008 	ldr	r3, [fp, #-8]
7000a0d0:	e5932004 	ldr	r2, [r3, #4]
7000a0d4:	e51b300c 	ldr	r3, [fp, #-12]
7000a0d8:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
7000a0dc:	e51b3008 	ldr	r3, [fp, #-8]
7000a0e0:	e51b200c 	ldr	r2, [fp, #-12]
7000a0e4:	e5832004 	str	r2, [r3, #4]
    n->next = l;
7000a0e8:	e51b300c 	ldr	r3, [fp, #-12]
7000a0ec:	e51b2008 	ldr	r2, [fp, #-8]
7000a0f0:	e5832000 	str	r2, [r3]
}
7000a0f4:	e24bd000 	sub	sp, fp, #0
7000a0f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a0fc:	e12fff1e 	bx	lr

7000a100 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
7000a100:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000a104:	e28db000 	add	fp, sp, #0
7000a108:	e24dd00c 	sub	sp, sp, #12
7000a10c:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
7000a110:	e51b3008 	ldr	r3, [fp, #-8]
7000a114:	e5933000 	ldr	r3, [r3]
7000a118:	e51b2008 	ldr	r2, [fp, #-8]
7000a11c:	e5922004 	ldr	r2, [r2, #4]
7000a120:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
7000a124:	e51b3008 	ldr	r3, [fp, #-8]
7000a128:	e5933004 	ldr	r3, [r3, #4]
7000a12c:	e51b2008 	ldr	r2, [fp, #-8]
7000a130:	e5922000 	ldr	r2, [r2]
7000a134:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
7000a138:	e51b3008 	ldr	r3, [fp, #-8]
7000a13c:	e51b2008 	ldr	r2, [fp, #-8]
7000a140:	e5832004 	str	r2, [r3, #4]
7000a144:	e51b3008 	ldr	r3, [fp, #-8]
7000a148:	e5932004 	ldr	r2, [r3, #4]
7000a14c:	e51b3008 	ldr	r3, [fp, #-8]
7000a150:	e5832000 	str	r2, [r3]
}
7000a154:	e24bd000 	sub	sp, fp, #0
7000a158:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a15c:	e12fff1e 	bx	lr

7000a160 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
7000a160:	e92d4810 	push	{r4, fp, lr}
7000a164:	e28db008 	add	fp, sp, #8
7000a168:	e24dd00c 	sub	sp, sp, #12
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
7000a16c:	e30a3c88 	movw	r3, #44168	; 0xac88
7000a170:	e3473002 	movt	r3, #28674	; 0x7002
7000a174:	e5933000 	ldr	r3, [r3]
7000a178:	e50b3010 	str	r3, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000a17c:	eb001031 	bl	7000e248 <rt_hw_interrupt_disable>
7000a180:	e1a04000 	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
7000a184:	e51b0010 	ldr	r0, [fp, #-16]
7000a188:	ebffff26 	bl	70009e28 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
7000a18c:	e51b3010 	ldr	r3, [fp, #-16]
7000a190:	e3a02004 	mov	r2, #4
7000a194:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
7000a198:	e51b3010 	ldr	r3, [fp, #-16]
7000a19c:	e2833048 	add	r3, r3, #72	; 0x48
7000a1a0:	e1a00003 	mov	r0, r3
7000a1a4:	eb0004c6 	bl	7000b4c4 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
7000a1a8:	e51b0010 	ldr	r0, [fp, #-16]
7000a1ac:	ebfffd6b 	bl	70009760 <rt_object_is_systemobject>
7000a1b0:	e1a03000 	mov	r3, r0
7000a1b4:	e3530001 	cmp	r3, #1
7000a1b8:	1a000006 	bne	7000a1d8 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
7000a1bc:	e51b3010 	ldr	r3, [fp, #-16]
7000a1c0:	e5933070 	ldr	r3, [r3, #112]	; 0x70
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
7000a1c4:	e3530000 	cmp	r3, #0
7000a1c8:	1a000002 	bne	7000a1d8 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
7000a1cc:	e51b0010 	ldr	r0, [fp, #-16]
7000a1d0:	ebfffc65 	bl	7000936c <rt_object_detach>
7000a1d4:	ea000005 	b	7000a1f0 <rt_thread_exit+0x90>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
7000a1d8:	e51b3010 	ldr	r3, [fp, #-16]
7000a1dc:	e2833010 	add	r3, r3, #16
7000a1e0:	e30a0c90 	movw	r0, #44176	; 0xac90
7000a1e4:	e3470002 	movt	r0, #28674	; 0x7002
7000a1e8:	e1a01003 	mov	r1, r3
7000a1ec:	ebffff97 	bl	7000a050 <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000a1f0:	e1a00004 	mov	r0, r4
7000a1f4:	eb001016 	bl	7000e254 <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
7000a1f8:	ebfffe79 	bl	70009be4 <rt_schedule>
}
7000a1fc:	e24bd008 	sub	sp, fp, #8
7000a200:	e8bd8810 	pop	{r4, fp, pc}

7000a204 <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
7000a204:	e92d4800 	push	{fp, lr}
7000a208:	e28db004 	add	fp, sp, #4
7000a20c:	e24dd020 	sub	sp, sp, #32
7000a210:	e50b0010 	str	r0, [fp, #-16]
7000a214:	e50b1014 	str	r1, [fp, #-20]
7000a218:	e50b2018 	str	r2, [fp, #-24]
7000a21c:	e50b301c 	str	r3, [fp, #-28]
    /* init thread list */
    rt_list_init(&(thread->tlist));
7000a220:	e51b3010 	ldr	r3, [fp, #-16]
7000a224:	e2833010 	add	r3, r3, #16
7000a228:	e1a00003 	mov	r0, r3
7000a22c:	ebffff79 	bl	7000a018 <rt_list_init>

    thread->entry = (void *)entry;
7000a230:	e51b3010 	ldr	r3, [fp, #-16]
7000a234:	e51b2018 	ldr	r2, [fp, #-24]
7000a238:	e583201c 	str	r2, [r3, #28]
    thread->parameter = parameter;
7000a23c:	e51b3010 	ldr	r3, [fp, #-16]
7000a240:	e51b201c 	ldr	r2, [fp, #-28]
7000a244:	e5832020 	str	r2, [r3, #32]

    /* stack init */
    thread->stack_addr = stack_start;
7000a248:	e51b3010 	ldr	r3, [fp, #-16]
7000a24c:	e59b2004 	ldr	r2, [fp, #4]
7000a250:	e5832024 	str	r2, [r3, #36]	; 0x24
    thread->stack_size = (rt_uint16_t)stack_size;
7000a254:	e59b3008 	ldr	r3, [fp, #8]
7000a258:	e6ff2073 	uxth	r2, r3
7000a25c:	e51b3010 	ldr	r3, [fp, #-16]
7000a260:	e1c322b8 	strh	r2, [r3, #40]	; 0x28

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
7000a264:	e51b3010 	ldr	r3, [fp, #-16]
7000a268:	e5932024 	ldr	r2, [r3, #36]	; 0x24
7000a26c:	e51b3010 	ldr	r3, [fp, #-16]
7000a270:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
7000a274:	e1a00002 	mov	r0, r2
7000a278:	e3a01023 	mov	r1, #35	; 0x23
7000a27c:	e1a02003 	mov	r2, r3
7000a280:	ebffef61 	bl	7000600c <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
7000a284:	e51b3010 	ldr	r3, [fp, #-16]
7000a288:	e593101c 	ldr	r1, [r3, #28]
7000a28c:	e51b3010 	ldr	r3, [fp, #-16]
7000a290:	e5932020 	ldr	r2, [r3, #32]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
7000a294:	e51b3010 	ldr	r3, [fp, #-16]
7000a298:	e5930024 	ldr	r0, [r3, #36]	; 0x24
7000a29c:	e51b3010 	ldr	r3, [fp, #-16]
7000a2a0:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
7000a2a4:	e2433004 	sub	r3, r3, #4
7000a2a8:	e0803003 	add	r3, r0, r3
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
7000a2ac:	e1a00001 	mov	r0, r1
7000a2b0:	e1a01002 	mov	r1, r2
7000a2b4:	e1a02003 	mov	r2, r3
7000a2b8:	e30a3160 	movw	r3, #41312	; 0xa160
7000a2bc:	e3473000 	movt	r3, #28672	; 0x7000
7000a2c0:	eb000e72 	bl	7000dc90 <rt_hw_stack_init>
7000a2c4:	e1a02000 	mov	r2, r0
7000a2c8:	e51b3010 	ldr	r3, [fp, #-16]
7000a2cc:	e5832018 	str	r2, [r3, #24]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
7000a2d0:	e5db300c 	ldrb	r3, [fp, #12]
7000a2d4:	e353001f 	cmp	r3, #31
7000a2d8:	9a00001d 	bls	7000a354 <_rt_thread_init+0x150>
7000a2dc:	e3a03000 	mov	r3, #0
7000a2e0:	e54b3005 	strb	r3, [fp, #-5]
7000a2e4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a2e8:	e3473002 	movt	r3, #28674	; 0x7002
7000a2ec:	e5933000 	ldr	r3, [r3]
7000a2f0:	e3530000 	cmp	r3, #0
7000a2f4:	1a00000d 	bne	7000a330 <_rt_thread_init+0x12c>
7000a2f8:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a2fc:	e3470002 	movt	r0, #28674	; 0x7002
7000a300:	e3061ca4 	movw	r1, #27812	; 0x6ca4
7000a304:	e3471002 	movt	r1, #28674	; 0x7002
7000a308:	e3062d38 	movw	r2, #27960	; 0x6d38
7000a30c:	e3472002 	movt	r2, #28674	; 0x7002
7000a310:	e3a0306e 	mov	r3, #110	; 0x6e
7000a314:	ebfff536 	bl	700077f4 <rt_kprintf>
7000a318:	e1a00000 	nop			; (mov r0, r0)
7000a31c:	e55b3005 	ldrb	r3, [fp, #-5]
7000a320:	e6ef3073 	uxtb	r3, r3
7000a324:	e3530000 	cmp	r3, #0
7000a328:	0afffffb 	beq	7000a31c <_rt_thread_init+0x118>
7000a32c:	ea000008 	b	7000a354 <_rt_thread_init+0x150>
7000a330:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a334:	e3473002 	movt	r3, #28674	; 0x7002
7000a338:	e5933000 	ldr	r3, [r3]
7000a33c:	e3060ca4 	movw	r0, #27812	; 0x6ca4
7000a340:	e3470002 	movt	r0, #28674	; 0x7002
7000a344:	e3061d38 	movw	r1, #27960	; 0x6d38
7000a348:	e3471002 	movt	r1, #28674	; 0x7002
7000a34c:	e3a0206e 	mov	r2, #110	; 0x6e
7000a350:	e12fff33 	blx	r3
    thread->init_priority    = priority;
7000a354:	e51b3010 	ldr	r3, [fp, #-16]
7000a358:	e5db200c 	ldrb	r2, [fp, #12]
7000a35c:	e5c32032 	strb	r2, [r3, #50]	; 0x32
    thread->current_priority = priority;
7000a360:	e51b3010 	ldr	r3, [fp, #-16]
7000a364:	e5db200c 	ldrb	r2, [fp, #12]
7000a368:	e5c32031 	strb	r2, [r3, #49]	; 0x31

    /* tick init */
    thread->init_tick      = tick;
7000a36c:	e51b3010 	ldr	r3, [fp, #-16]
7000a370:	e59b2010 	ldr	r2, [fp, #16]
7000a374:	e5832040 	str	r2, [r3, #64]	; 0x40
    thread->remaining_tick = tick;
7000a378:	e51b3010 	ldr	r3, [fp, #-16]
7000a37c:	e59b2010 	ldr	r2, [fp, #16]
7000a380:	e5832044 	str	r2, [r3, #68]	; 0x44

    /* error and flags */
    thread->error = RT_EOK;
7000a384:	e51b3010 	ldr	r3, [fp, #-16]
7000a388:	e3a02000 	mov	r2, #0
7000a38c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    thread->stat  = RT_THREAD_INIT;
7000a390:	e51b3010 	ldr	r3, [fp, #-16]
7000a394:	e3a02000 	mov	r2, #0
7000a398:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
7000a39c:	e51b3010 	ldr	r3, [fp, #-16]
7000a3a0:	e3a02000 	mov	r2, #0
7000a3a4:	e5832070 	str	r2, [r3, #112]	; 0x70
    thread->user_data = 0;
7000a3a8:	e51b3010 	ldr	r3, [fp, #-16]
7000a3ac:	e3a02000 	mov	r2, #0
7000a3b0:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
7000a3b4:	e51b3010 	ldr	r3, [fp, #-16]
7000a3b8:	e2832048 	add	r2, r3, #72	; 0x48
                  thread->name,
7000a3bc:	e51b3010 	ldr	r3, [fp, #-16]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
7000a3c0:	e3a01000 	mov	r1, #0
7000a3c4:	e58d1000 	str	r1, [sp]
7000a3c8:	e3a01000 	mov	r1, #0
7000a3cc:	e58d1004 	str	r1, [sp, #4]
7000a3d0:	e1a00002 	mov	r0, r2
7000a3d4:	e1a01003 	mov	r1, r3
7000a3d8:	e30a2f18 	movw	r2, #44824	; 0xaf18
7000a3dc:	e3472000 	movt	r2, #28672	; 0x7000
7000a3e0:	e51b3010 	ldr	r3, [fp, #-16]
7000a3e4:	eb000401 	bl	7000b3f0 <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
7000a3e8:	e3a03000 	mov	r3, #0
}
7000a3ec:	e1a00003 	mov	r0, r3
7000a3f0:	e24bd004 	sub	sp, fp, #4
7000a3f4:	e8bd8800 	pop	{fp, pc}

7000a3f8 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
7000a3f8:	e92d4800 	push	{fp, lr}
7000a3fc:	e28db004 	add	fp, sp, #4
7000a400:	e24dd028 	sub	sp, sp, #40	; 0x28
7000a404:	e50b0010 	str	r0, [fp, #-16]
7000a408:	e50b1014 	str	r1, [fp, #-20]
7000a40c:	e50b2018 	str	r2, [fp, #-24]
7000a410:	e50b301c 	str	r3, [fp, #-28]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000a414:	e51b3010 	ldr	r3, [fp, #-16]
7000a418:	e3530000 	cmp	r3, #0
7000a41c:	1a00001d 	bne	7000a498 <rt_thread_init+0xa0>
7000a420:	e3a03000 	mov	r3, #0
7000a424:	e54b3005 	strb	r3, [fp, #-5]
7000a428:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a42c:	e3473002 	movt	r3, #28674	; 0x7002
7000a430:	e5933000 	ldr	r3, [r3]
7000a434:	e3530000 	cmp	r3, #0
7000a438:	1a00000d 	bne	7000a474 <rt_thread_init+0x7c>
7000a43c:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a440:	e3470002 	movt	r0, #28674	; 0x7002
7000a444:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000a448:	e3471002 	movt	r1, #28674	; 0x7002
7000a44c:	e3062d48 	movw	r2, #27976	; 0x6d48
7000a450:	e3472002 	movt	r2, #28674	; 0x7002
7000a454:	e3a030a8 	mov	r3, #168	; 0xa8
7000a458:	ebfff4e5 	bl	700077f4 <rt_kprintf>
7000a45c:	e1a00000 	nop			; (mov r0, r0)
7000a460:	e55b3005 	ldrb	r3, [fp, #-5]
7000a464:	e6ef3073 	uxtb	r3, r3
7000a468:	e3530000 	cmp	r3, #0
7000a46c:	0afffffb 	beq	7000a460 <rt_thread_init+0x68>
7000a470:	ea000008 	b	7000a498 <rt_thread_init+0xa0>
7000a474:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a478:	e3473002 	movt	r3, #28674	; 0x7002
7000a47c:	e5933000 	ldr	r3, [r3]
7000a480:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000a484:	e3470002 	movt	r0, #28674	; 0x7002
7000a488:	e3061d48 	movw	r1, #27976	; 0x6d48
7000a48c:	e3471002 	movt	r1, #28674	; 0x7002
7000a490:	e3a020a8 	mov	r2, #168	; 0xa8
7000a494:	e12fff33 	blx	r3
    RT_ASSERT(stack_start != RT_NULL);
7000a498:	e59b3004 	ldr	r3, [fp, #4]
7000a49c:	e3530000 	cmp	r3, #0
7000a4a0:	1a00001d 	bne	7000a51c <rt_thread_init+0x124>
7000a4a4:	e3a03000 	mov	r3, #0
7000a4a8:	e54b3006 	strb	r3, [fp, #-6]
7000a4ac:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a4b0:	e3473002 	movt	r3, #28674	; 0x7002
7000a4b4:	e5933000 	ldr	r3, [r3]
7000a4b8:	e3530000 	cmp	r3, #0
7000a4bc:	1a00000d 	bne	7000a4f8 <rt_thread_init+0x100>
7000a4c0:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a4c4:	e3470002 	movt	r0, #28674	; 0x7002
7000a4c8:	e3061cdc 	movw	r1, #27868	; 0x6cdc
7000a4cc:	e3471002 	movt	r1, #28674	; 0x7002
7000a4d0:	e3062d48 	movw	r2, #27976	; 0x6d48
7000a4d4:	e3472002 	movt	r2, #28674	; 0x7002
7000a4d8:	e3a030a9 	mov	r3, #169	; 0xa9
7000a4dc:	ebfff4c4 	bl	700077f4 <rt_kprintf>
7000a4e0:	e1a00000 	nop			; (mov r0, r0)
7000a4e4:	e55b3006 	ldrb	r3, [fp, #-6]
7000a4e8:	e6ef3073 	uxtb	r3, r3
7000a4ec:	e3530000 	cmp	r3, #0
7000a4f0:	0afffffb 	beq	7000a4e4 <rt_thread_init+0xec>
7000a4f4:	ea000008 	b	7000a51c <rt_thread_init+0x124>
7000a4f8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a4fc:	e3473002 	movt	r3, #28674	; 0x7002
7000a500:	e5933000 	ldr	r3, [r3]
7000a504:	e3060cdc 	movw	r0, #27868	; 0x6cdc
7000a508:	e3470002 	movt	r0, #28674	; 0x7002
7000a50c:	e3061d48 	movw	r1, #27976	; 0x6d48
7000a510:	e3471002 	movt	r1, #28674	; 0x7002
7000a514:	e3a020a9 	mov	r2, #169	; 0xa9
7000a518:	e12fff33 	blx	r3

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
7000a51c:	e51b0010 	ldr	r0, [fp, #-16]
7000a520:	e3a01000 	mov	r1, #0
7000a524:	e51b2014 	ldr	r2, [fp, #-20]
7000a528:	ebfffb60 	bl	700092b0 <rt_object_init>

    return _rt_thread_init(thread,
7000a52c:	e59b3004 	ldr	r3, [fp, #4]
7000a530:	e58d3000 	str	r3, [sp]
7000a534:	e59b3008 	ldr	r3, [fp, #8]
7000a538:	e58d3004 	str	r3, [sp, #4]
7000a53c:	e5db300c 	ldrb	r3, [fp, #12]
7000a540:	e58d3008 	str	r3, [sp, #8]
7000a544:	e59b3010 	ldr	r3, [fp, #16]
7000a548:	e58d300c 	str	r3, [sp, #12]
7000a54c:	e51b0010 	ldr	r0, [fp, #-16]
7000a550:	e51b1014 	ldr	r1, [fp, #-20]
7000a554:	e51b2018 	ldr	r2, [fp, #-24]
7000a558:	e51b301c 	ldr	r3, [fp, #-28]
7000a55c:	ebffff28 	bl	7000a204 <_rt_thread_init>
7000a560:	e1a03000 	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
7000a564:	e1a00003 	mov	r0, r3
7000a568:	e24bd004 	sub	sp, fp, #4
7000a56c:	e8bd8800 	pop	{fp, pc}

7000a570 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
7000a570:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000a574:	e28db000 	add	fp, sp, #0
    return rt_current_thread;
7000a578:	e30a3c88 	movw	r3, #44168	; 0xac88
7000a57c:	e3473002 	movt	r3, #28674	; 0x7002
7000a580:	e5933000 	ldr	r3, [r3]
}
7000a584:	e1a00003 	mov	r0, r3
7000a588:	e24bd000 	sub	sp, fp, #0
7000a58c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000a590:	e12fff1e 	bx	lr

7000a594 <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
7000a594:	e92d4800 	push	{fp, lr}
7000a598:	e28db004 	add	fp, sp, #4
7000a59c:	e24dd010 	sub	sp, sp, #16
7000a5a0:	e50b0010 	str	r0, [fp, #-16]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000a5a4:	e51b3010 	ldr	r3, [fp, #-16]
7000a5a8:	e3530000 	cmp	r3, #0
7000a5ac:	1a00001d 	bne	7000a628 <rt_thread_startup+0x94>
7000a5b0:	e3a03000 	mov	r3, #0
7000a5b4:	e54b3005 	strb	r3, [fp, #-5]
7000a5b8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a5bc:	e3473002 	movt	r3, #28674	; 0x7002
7000a5c0:	e5933000 	ldr	r3, [r3]
7000a5c4:	e3530000 	cmp	r3, #0
7000a5c8:	1a00000d 	bne	7000a604 <rt_thread_startup+0x70>
7000a5cc:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a5d0:	e3470002 	movt	r0, #28674	; 0x7002
7000a5d4:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000a5d8:	e3471002 	movt	r1, #28674	; 0x7002
7000a5dc:	e3062d58 	movw	r2, #27992	; 0x6d58
7000a5e0:	e3472002 	movt	r2, #28674	; 0x7002
7000a5e4:	e3a030ce 	mov	r3, #206	; 0xce
7000a5e8:	ebfff481 	bl	700077f4 <rt_kprintf>
7000a5ec:	e1a00000 	nop			; (mov r0, r0)
7000a5f0:	e55b3005 	ldrb	r3, [fp, #-5]
7000a5f4:	e6ef3073 	uxtb	r3, r3
7000a5f8:	e3530000 	cmp	r3, #0
7000a5fc:	0afffffb 	beq	7000a5f0 <rt_thread_startup+0x5c>
7000a600:	ea000008 	b	7000a628 <rt_thread_startup+0x94>
7000a604:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a608:	e3473002 	movt	r3, #28674	; 0x7002
7000a60c:	e5933000 	ldr	r3, [r3]
7000a610:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000a614:	e3470002 	movt	r0, #28674	; 0x7002
7000a618:	e3061d58 	movw	r1, #27992	; 0x6d58
7000a61c:	e3471002 	movt	r1, #28674	; 0x7002
7000a620:	e3a020ce 	mov	r2, #206	; 0xce
7000a624:	e12fff33 	blx	r3
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
7000a628:	e51b3010 	ldr	r3, [fp, #-16]
7000a62c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000a630:	e3530000 	cmp	r3, #0
7000a634:	0a00001d 	beq	7000a6b0 <rt_thread_startup+0x11c>
7000a638:	e3a03000 	mov	r3, #0
7000a63c:	e54b3006 	strb	r3, [fp, #-6]
7000a640:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a644:	e3473002 	movt	r3, #28674	; 0x7002
7000a648:	e5933000 	ldr	r3, [r3]
7000a64c:	e3530000 	cmp	r3, #0
7000a650:	1a00000d 	bne	7000a68c <rt_thread_startup+0xf8>
7000a654:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a658:	e3470002 	movt	r0, #28674	; 0x7002
7000a65c:	e3061cf4 	movw	r1, #27892	; 0x6cf4
7000a660:	e3471002 	movt	r1, #28674	; 0x7002
7000a664:	e3062d58 	movw	r2, #27992	; 0x6d58
7000a668:	e3472002 	movt	r2, #28674	; 0x7002
7000a66c:	e3a030cf 	mov	r3, #207	; 0xcf
7000a670:	ebfff45f 	bl	700077f4 <rt_kprintf>
7000a674:	e1a00000 	nop			; (mov r0, r0)
7000a678:	e55b3006 	ldrb	r3, [fp, #-6]
7000a67c:	e6ef3073 	uxtb	r3, r3
7000a680:	e3530000 	cmp	r3, #0
7000a684:	0afffffb 	beq	7000a678 <rt_thread_startup+0xe4>
7000a688:	ea000008 	b	7000a6b0 <rt_thread_startup+0x11c>
7000a68c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a690:	e3473002 	movt	r3, #28674	; 0x7002
7000a694:	e5933000 	ldr	r3, [r3]
7000a698:	e3060cf4 	movw	r0, #27892	; 0x6cf4
7000a69c:	e3470002 	movt	r0, #28674	; 0x7002
7000a6a0:	e3061d58 	movw	r1, #27992	; 0x6d58
7000a6a4:	e3471002 	movt	r1, #28674	; 0x7002
7000a6a8:	e3a020cf 	mov	r2, #207	; 0xcf
7000a6ac:	e12fff33 	blx	r3

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
7000a6b0:	e51b3010 	ldr	r3, [fp, #-16]
7000a6b4:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
7000a6b8:	e51b3010 	ldr	r3, [fp, #-16]
7000a6bc:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
7000a6c0:	e51b3010 	ldr	r3, [fp, #-16]
7000a6c4:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
7000a6c8:	e3a02001 	mov	r2, #1
7000a6cc:	e1a03312 	lsl	r3, r2, r3
7000a6d0:	e1a02003 	mov	r2, r3
7000a6d4:	e51b3010 	ldr	r3, [fp, #-16]
7000a6d8:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
7000a6dc:	e51b3010 	ldr	r3, [fp, #-16]
7000a6e0:	e3a02002 	mov	r2, #2
7000a6e4:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    /* then resume it */
    rt_thread_resume(thread);
7000a6e8:	e51b0010 	ldr	r0, [fp, #-16]
7000a6ec:	eb0001cb 	bl	7000ae20 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
7000a6f0:	ebffff9e 	bl	7000a570 <rt_thread_self>
7000a6f4:	e1a03000 	mov	r3, r0
7000a6f8:	e3530000 	cmp	r3, #0
7000a6fc:	0a000000 	beq	7000a704 <rt_thread_startup+0x170>
    {
        /* do a scheduling */
        rt_schedule();
7000a700:	ebfffd37 	bl	70009be4 <rt_schedule>
    }

    return RT_EOK;
7000a704:	e3a03000 	mov	r3, #0
}
7000a708:	e1a00003 	mov	r0, r3
7000a70c:	e24bd004 	sub	sp, fp, #4
7000a710:	e8bd8800 	pop	{fp, pc}

7000a714 <rt_thread_detach>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_detach(rt_thread_t thread)
{
7000a714:	e92d4800 	push	{fp, lr}
7000a718:	e28db004 	add	fp, sp, #4
7000a71c:	e24dd010 	sub	sp, sp, #16
7000a720:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000a724:	e51b3010 	ldr	r3, [fp, #-16]
7000a728:	e3530000 	cmp	r3, #0
7000a72c:	1a00001d 	bne	7000a7a8 <rt_thread_detach+0x94>
7000a730:	e3a03000 	mov	r3, #0
7000a734:	e54b3009 	strb	r3, [fp, #-9]
7000a738:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a73c:	e3473002 	movt	r3, #28674	; 0x7002
7000a740:	e5933000 	ldr	r3, [r3]
7000a744:	e3530000 	cmp	r3, #0
7000a748:	1a00000d 	bne	7000a784 <rt_thread_detach+0x70>
7000a74c:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a750:	e3470002 	movt	r0, #28674	; 0x7002
7000a754:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000a758:	e3471002 	movt	r1, #28674	; 0x7002
7000a75c:	e3062d6c 	movw	r2, #28012	; 0x6d6c
7000a760:	e3472002 	movt	r2, #28674	; 0x7002
7000a764:	e3a030fa 	mov	r3, #250	; 0xfa
7000a768:	ebfff421 	bl	700077f4 <rt_kprintf>
7000a76c:	e1a00000 	nop			; (mov r0, r0)
7000a770:	e55b3009 	ldrb	r3, [fp, #-9]
7000a774:	e6ef3073 	uxtb	r3, r3
7000a778:	e3530000 	cmp	r3, #0
7000a77c:	0afffffb 	beq	7000a770 <rt_thread_detach+0x5c>
7000a780:	ea000008 	b	7000a7a8 <rt_thread_detach+0x94>
7000a784:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a788:	e3473002 	movt	r3, #28674	; 0x7002
7000a78c:	e5933000 	ldr	r3, [r3]
7000a790:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000a794:	e3470002 	movt	r0, #28674	; 0x7002
7000a798:	e3061d6c 	movw	r1, #28012	; 0x6d6c
7000a79c:	e3471002 	movt	r1, #28674	; 0x7002
7000a7a0:	e3a020fa 	mov	r2, #250	; 0xfa
7000a7a4:	e12fff33 	blx	r3

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
7000a7a8:	e51b0010 	ldr	r0, [fp, #-16]
7000a7ac:	ebfffd9d 	bl	70009e28 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
7000a7b0:	e51b3010 	ldr	r3, [fp, #-16]
7000a7b4:	e2833048 	add	r3, r3, #72	; 0x48
7000a7b8:	e1a00003 	mov	r0, r3
7000a7bc:	eb000340 	bl	7000b4c4 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
7000a7c0:	e51b3010 	ldr	r3, [fp, #-16]
7000a7c4:	e3a02004 	mov	r2, #4
7000a7c8:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* detach object */
    rt_object_detach((rt_object_t)thread);
7000a7cc:	e51b0010 	ldr	r0, [fp, #-16]
7000a7d0:	ebfffae5 	bl	7000936c <rt_object_detach>

    if (thread->cleanup != RT_NULL)
7000a7d4:	e51b3010 	ldr	r3, [fp, #-16]
7000a7d8:	e5933070 	ldr	r3, [r3, #112]	; 0x70
7000a7dc:	e3530000 	cmp	r3, #0
7000a7e0:	0a000009 	beq	7000a80c <rt_thread_detach+0xf8>
    {
        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
7000a7e4:	eb000e97 	bl	7000e248 <rt_hw_interrupt_disable>
7000a7e8:	e50b0008 	str	r0, [fp, #-8]

        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
7000a7ec:	e51b3010 	ldr	r3, [fp, #-16]
7000a7f0:	e2833010 	add	r3, r3, #16
7000a7f4:	e30a0c90 	movw	r0, #44176	; 0xac90
7000a7f8:	e3470002 	movt	r0, #28674	; 0x7002
7000a7fc:	e1a01003 	mov	r1, r3
7000a800:	ebfffe12 	bl	7000a050 <rt_list_insert_after>

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
7000a804:	e51b0008 	ldr	r0, [fp, #-8]
7000a808:	eb000e91 	bl	7000e254 <rt_hw_interrupt_enable>
    }

    return RT_EOK;
7000a80c:	e3a03000 	mov	r3, #0
}
7000a810:	e1a00003 	mov	r0, r3
7000a814:	e24bd004 	sub	sp, fp, #4
7000a818:	e8bd8800 	pop	{fp, pc}

7000a81c <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
7000a81c:	e92d4800 	push	{fp, lr}
7000a820:	e28db004 	add	fp, sp, #4
7000a824:	e24dd028 	sub	sp, sp, #40	; 0x28
7000a828:	e50b0010 	str	r0, [fp, #-16]
7000a82c:	e50b1014 	str	r1, [fp, #-20]
7000a830:	e50b2018 	str	r2, [fp, #-24]
7000a834:	e50b301c 	str	r3, [fp, #-28]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
7000a838:	e3a00000 	mov	r0, #0
7000a83c:	e51b1010 	ldr	r1, [fp, #-16]
7000a840:	ebfffb02 	bl	70009450 <rt_object_allocate>
7000a844:	e50b0008 	str	r0, [fp, #-8]
                                                    name);
    if (thread == RT_NULL)
7000a848:	e51b3008 	ldr	r3, [fp, #-8]
7000a84c:	e3530000 	cmp	r3, #0
7000a850:	1a000001 	bne	7000a85c <rt_thread_create+0x40>
        return RT_NULL;
7000a854:	e3a03000 	mov	r3, #0
7000a858:	ea000017 	b	7000a8bc <rt_thread_create+0xa0>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
7000a85c:	e51b001c 	ldr	r0, [fp, #-28]
7000a860:	ebfff615 	bl	700080bc <rt_malloc>
7000a864:	e50b000c 	str	r0, [fp, #-12]
    if (stack_start == RT_NULL)
7000a868:	e51b300c 	ldr	r3, [fp, #-12]
7000a86c:	e3530000 	cmp	r3, #0
7000a870:	1a000003 	bne	7000a884 <rt_thread_create+0x68>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
7000a874:	e51b0008 	ldr	r0, [fp, #-8]
7000a878:	ebfffb59 	bl	700095e4 <rt_object_delete>

        return RT_NULL;
7000a87c:	e3a03000 	mov	r3, #0
7000a880:	ea00000d 	b	7000a8bc <rt_thread_create+0xa0>
    }

    _rt_thread_init(thread,
7000a884:	e51b300c 	ldr	r3, [fp, #-12]
7000a888:	e58d3000 	str	r3, [sp]
7000a88c:	e51b301c 	ldr	r3, [fp, #-28]
7000a890:	e58d3004 	str	r3, [sp, #4]
7000a894:	e5db3004 	ldrb	r3, [fp, #4]
7000a898:	e58d3008 	str	r3, [sp, #8]
7000a89c:	e59b3008 	ldr	r3, [fp, #8]
7000a8a0:	e58d300c 	str	r3, [sp, #12]
7000a8a4:	e51b0008 	ldr	r0, [fp, #-8]
7000a8a8:	e51b1010 	ldr	r1, [fp, #-16]
7000a8ac:	e51b2014 	ldr	r2, [fp, #-20]
7000a8b0:	e51b3018 	ldr	r3, [fp, #-24]
7000a8b4:	ebfffe52 	bl	7000a204 <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
7000a8b8:	e51b3008 	ldr	r3, [fp, #-8]
}
7000a8bc:	e1a00003 	mov	r0, r3
7000a8c0:	e24bd004 	sub	sp, fp, #4
7000a8c4:	e8bd8800 	pop	{fp, pc}

7000a8c8 <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
7000a8c8:	e92d4800 	push	{fp, lr}
7000a8cc:	e28db004 	add	fp, sp, #4
7000a8d0:	e24dd010 	sub	sp, sp, #16
7000a8d4:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000a8d8:	e51b3010 	ldr	r3, [fp, #-16]
7000a8dc:	e3530000 	cmp	r3, #0
7000a8e0:	1a00001d 	bne	7000a95c <rt_thread_delete+0x94>
7000a8e4:	e3a03000 	mov	r3, #0
7000a8e8:	e54b3009 	strb	r3, [fp, #-9]
7000a8ec:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a8f0:	e3473002 	movt	r3, #28674	; 0x7002
7000a8f4:	e5933000 	ldr	r3, [r3]
7000a8f8:	e3530000 	cmp	r3, #0
7000a8fc:	1a00000d 	bne	7000a938 <rt_thread_delete+0x70>
7000a900:	e3060c84 	movw	r0, #27780	; 0x6c84
7000a904:	e3470002 	movt	r0, #28674	; 0x7002
7000a908:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000a90c:	e3471002 	movt	r1, #28674	; 0x7002
7000a910:	e3062d80 	movw	r2, #28032	; 0x6d80
7000a914:	e3472002 	movt	r2, #28674	; 0x7002
7000a918:	e3003159 	movw	r3, #345	; 0x159
7000a91c:	ebfff3b4 	bl	700077f4 <rt_kprintf>
7000a920:	e1a00000 	nop			; (mov r0, r0)
7000a924:	e55b3009 	ldrb	r3, [fp, #-9]
7000a928:	e6ef3073 	uxtb	r3, r3
7000a92c:	e3530000 	cmp	r3, #0
7000a930:	0afffffb 	beq	7000a924 <rt_thread_delete+0x5c>
7000a934:	ea000008 	b	7000a95c <rt_thread_delete+0x94>
7000a938:	e30a3b74 	movw	r3, #43892	; 0xab74
7000a93c:	e3473002 	movt	r3, #28674	; 0x7002
7000a940:	e5933000 	ldr	r3, [r3]
7000a944:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000a948:	e3470002 	movt	r0, #28674	; 0x7002
7000a94c:	e3061d80 	movw	r1, #28032	; 0x6d80
7000a950:	e3471002 	movt	r1, #28674	; 0x7002
7000a954:	e3002159 	movw	r2, #345	; 0x159
7000a958:	e12fff33 	blx	r3

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
7000a95c:	e51b0010 	ldr	r0, [fp, #-16]
7000a960:	ebfffd30 	bl	70009e28 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
7000a964:	e51b3010 	ldr	r3, [fp, #-16]
7000a968:	e2833048 	add	r3, r3, #72	; 0x48
7000a96c:	e1a00003 	mov	r0, r3
7000a970:	eb0002d3 	bl	7000b4c4 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
7000a974:	e51b3010 	ldr	r3, [fp, #-16]
7000a978:	e3a02004 	mov	r2, #4
7000a97c:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
7000a980:	eb000e30 	bl	7000e248 <rt_hw_interrupt_disable>
7000a984:	e50b0008 	str	r0, [fp, #-8]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
7000a988:	e51b3010 	ldr	r3, [fp, #-16]
7000a98c:	e2833010 	add	r3, r3, #16
7000a990:	e30a0c90 	movw	r0, #44176	; 0xac90
7000a994:	e3470002 	movt	r0, #28674	; 0x7002
7000a998:	e1a01003 	mov	r1, r3
7000a99c:	ebfffdab 	bl	7000a050 <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
7000a9a0:	e51b0008 	ldr	r0, [fp, #-8]
7000a9a4:	eb000e2a 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
7000a9a8:	e3a03000 	mov	r3, #0
}
7000a9ac:	e1a00003 	mov	r0, r3
7000a9b0:	e24bd004 	sub	sp, fp, #4
7000a9b4:	e8bd8800 	pop	{fp, pc}

7000a9b8 <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
7000a9b8:	e92d4810 	push	{r4, fp, lr}
7000a9bc:	e28db008 	add	fp, sp, #8
7000a9c0:	e24dd00c 	sub	sp, sp, #12
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000a9c4:	eb000e1f 	bl	7000e248 <rt_hw_interrupt_disable>
7000a9c8:	e1a04000 	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
7000a9cc:	e30a3c88 	movw	r3, #44168	; 0xac88
7000a9d0:	e3473002 	movt	r3, #28674	; 0x7002
7000a9d4:	e5933000 	ldr	r3, [r3]
7000a9d8:	e50b3010 	str	r3, [fp, #-16]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
7000a9dc:	e51b3010 	ldr	r3, [fp, #-16]
7000a9e0:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000a9e4:	e3530001 	cmp	r3, #1
7000a9e8:	1a000019 	bne	7000aa54 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
7000a9ec:	e51b3010 	ldr	r3, [fp, #-16]
7000a9f0:	e5932010 	ldr	r2, [r3, #16]
7000a9f4:	e51b3010 	ldr	r3, [fp, #-16]
7000a9f8:	e5933014 	ldr	r3, [r3, #20]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
7000a9fc:	e1520003 	cmp	r2, r3
7000aa00:	0a000013 	beq	7000aa54 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
7000aa04:	e51b3010 	ldr	r3, [fp, #-16]
7000aa08:	e2833010 	add	r3, r3, #16
7000aa0c:	e1a00003 	mov	r0, r3
7000aa10:	ebfffdba 	bl	7000a100 <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
7000aa14:	e51b3010 	ldr	r3, [fp, #-16]
7000aa18:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
7000aa1c:	e1a02183 	lsl	r2, r3, #3
7000aa20:	e30a3b84 	movw	r3, #43908	; 0xab84
7000aa24:	e3473002 	movt	r3, #28674	; 0x7002
7000aa28:	e0822003 	add	r2, r2, r3
7000aa2c:	e51b3010 	ldr	r3, [fp, #-16]
7000aa30:	e2833010 	add	r3, r3, #16
7000aa34:	e1a00002 	mov	r0, r2
7000aa38:	e1a01003 	mov	r1, r3
7000aa3c:	ebfffd99 	bl	7000a0a8 <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
7000aa40:	e1a00004 	mov	r0, r4
7000aa44:	eb000e02 	bl	7000e254 <rt_hw_interrupt_enable>

        rt_schedule();
7000aa48:	ebfffc65 	bl	70009be4 <rt_schedule>

        return RT_EOK;
7000aa4c:	e3a03000 	mov	r3, #0
7000aa50:	ea000002 	b	7000aa60 <rt_thread_yield+0xa8>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000aa54:	e1a00004 	mov	r0, r4
7000aa58:	eb000dfd 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
7000aa5c:	e3a03000 	mov	r3, #0
}
7000aa60:	e1a00003 	mov	r0, r3
7000aa64:	e24bd008 	sub	sp, fp, #8
7000aa68:	e8bd8810 	pop	{r4, fp, pc}

7000aa6c <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
7000aa6c:	e92d4810 	push	{r4, fp, lr}
7000aa70:	e28db008 	add	fp, sp, #8
7000aa74:	e24dd014 	sub	sp, sp, #20
7000aa78:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
7000aa7c:	eb000df1 	bl	7000e248 <rt_hw_interrupt_disable>
7000aa80:	e1a04000 	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
7000aa84:	e30a3c88 	movw	r3, #44168	; 0xac88
7000aa88:	e3473002 	movt	r3, #28674	; 0x7002
7000aa8c:	e5933000 	ldr	r3, [r3]
7000aa90:	e50b3010 	str	r3, [fp, #-16]
    RT_ASSERT(thread != RT_NULL);
7000aa94:	e51b3010 	ldr	r3, [fp, #-16]
7000aa98:	e3530000 	cmp	r3, #0
7000aa9c:	1a00001d 	bne	7000ab18 <rt_thread_sleep+0xac>
7000aaa0:	e3a03000 	mov	r3, #0
7000aaa4:	e54b3011 	strb	r3, [fp, #-17]
7000aaa8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000aaac:	e3473002 	movt	r3, #28674	; 0x7002
7000aab0:	e5933000 	ldr	r3, [r3]
7000aab4:	e3530000 	cmp	r3, #0
7000aab8:	1a00000d 	bne	7000aaf4 <rt_thread_sleep+0x88>
7000aabc:	e3060c84 	movw	r0, #27780	; 0x6c84
7000aac0:	e3470002 	movt	r0, #28674	; 0x7002
7000aac4:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000aac8:	e3471002 	movt	r1, #28674	; 0x7002
7000aacc:	e3062d94 	movw	r2, #28052	; 0x6d94
7000aad0:	e3472002 	movt	r2, #28674	; 0x7002
7000aad4:	e30031ae 	movw	r3, #430	; 0x1ae
7000aad8:	ebfff345 	bl	700077f4 <rt_kprintf>
7000aadc:	e1a00000 	nop			; (mov r0, r0)
7000aae0:	e55b3011 	ldrb	r3, [fp, #-17]
7000aae4:	e6ef3073 	uxtb	r3, r3
7000aae8:	e3530000 	cmp	r3, #0
7000aaec:	0afffffb 	beq	7000aae0 <rt_thread_sleep+0x74>
7000aaf0:	ea000008 	b	7000ab18 <rt_thread_sleep+0xac>
7000aaf4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000aaf8:	e3473002 	movt	r3, #28674	; 0x7002
7000aafc:	e5933000 	ldr	r3, [r3]
7000ab00:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000ab04:	e3470002 	movt	r0, #28674	; 0x7002
7000ab08:	e3061d94 	movw	r1, #28052	; 0x6d94
7000ab0c:	e3471002 	movt	r1, #28674	; 0x7002
7000ab10:	e30021ae 	movw	r2, #430	; 0x1ae
7000ab14:	e12fff33 	blx	r3

    /* suspend thread */
    rt_thread_suspend(thread);
7000ab18:	e51b0010 	ldr	r0, [fp, #-16]
7000ab1c:	eb000082 	bl	7000ad2c <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
7000ab20:	e51b3010 	ldr	r3, [fp, #-16]
7000ab24:	e2832048 	add	r2, r3, #72	; 0x48
7000ab28:	e24b3018 	sub	r3, fp, #24
7000ab2c:	e1a00002 	mov	r0, r2
7000ab30:	e3a01000 	mov	r1, #0
7000ab34:	e1a02003 	mov	r2, r3
7000ab38:	eb00042a 	bl	7000bbe8 <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
7000ab3c:	e51b3010 	ldr	r3, [fp, #-16]
7000ab40:	e2833048 	add	r3, r3, #72	; 0x48
7000ab44:	e1a00003 	mov	r0, r3
7000ab48:	eb0002da 	bl	7000b6b8 <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
7000ab4c:	e1a00004 	mov	r0, r4
7000ab50:	eb000dbf 	bl	7000e254 <rt_hw_interrupt_enable>

    rt_schedule();
7000ab54:	ebfffc22 	bl	70009be4 <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
7000ab58:	e51b3010 	ldr	r3, [fp, #-16]
7000ab5c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7000ab60:	e3730002 	cmn	r3, #2
7000ab64:	1a000002 	bne	7000ab74 <rt_thread_sleep+0x108>
        thread->error = RT_EOK;
7000ab68:	e51b3010 	ldr	r3, [fp, #-16]
7000ab6c:	e3a02000 	mov	r2, #0
7000ab70:	e583202c 	str	r2, [r3, #44]	; 0x2c

    return RT_EOK;
7000ab74:	e3a03000 	mov	r3, #0
}
7000ab78:	e1a00003 	mov	r0, r3
7000ab7c:	e24bd008 	sub	sp, fp, #8
7000ab80:	e8bd8810 	pop	{r4, fp, pc}

7000ab84 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
7000ab84:	e92d4800 	push	{fp, lr}
7000ab88:	e28db004 	add	fp, sp, #4
7000ab8c:	e24dd008 	sub	sp, sp, #8
7000ab90:	e50b0008 	str	r0, [fp, #-8]
    return rt_thread_sleep(tick);
7000ab94:	e51b0008 	ldr	r0, [fp, #-8]
7000ab98:	ebffffb3 	bl	7000aa6c <rt_thread_sleep>
7000ab9c:	e1a03000 	mov	r3, r0
}
7000aba0:	e1a00003 	mov	r0, r3
7000aba4:	e24bd004 	sub	sp, fp, #4
7000aba8:	e8bd8800 	pop	{fp, pc}

7000abac <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
7000abac:	e92d4810 	push	{r4, fp, lr}
7000abb0:	e28db008 	add	fp, sp, #8
7000abb4:	e24dd01c 	sub	sp, sp, #28
7000abb8:	e50b0018 	str	r0, [fp, #-24]
7000abbc:	e1a03001 	mov	r3, r1
7000abc0:	e50b2020 	str	r2, [fp, #-32]
7000abc4:	e54b3019 	strb	r3, [fp, #-25]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000abc8:	e51b3018 	ldr	r3, [fp, #-24]
7000abcc:	e3530000 	cmp	r3, #0
7000abd0:	1a00001d 	bne	7000ac4c <rt_thread_control+0xa0>
7000abd4:	e3a03000 	mov	r3, #0
7000abd8:	e54b300d 	strb	r3, [fp, #-13]
7000abdc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000abe0:	e3473002 	movt	r3, #28674	; 0x7002
7000abe4:	e5933000 	ldr	r3, [r3]
7000abe8:	e3530000 	cmp	r3, #0
7000abec:	1a00000d 	bne	7000ac28 <rt_thread_control+0x7c>
7000abf0:	e3060c84 	movw	r0, #27780	; 0x6c84
7000abf4:	e3470002 	movt	r0, #28674	; 0x7002
7000abf8:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000abfc:	e3471002 	movt	r1, #28674	; 0x7002
7000ac00:	e3062da4 	movw	r2, #28068	; 0x6da4
7000ac04:	e3472002 	movt	r2, #28674	; 0x7002
7000ac08:	e30031e1 	movw	r3, #481	; 0x1e1
7000ac0c:	ebfff2f8 	bl	700077f4 <rt_kprintf>
7000ac10:	e1a00000 	nop			; (mov r0, r0)
7000ac14:	e55b300d 	ldrb	r3, [fp, #-13]
7000ac18:	e6ef3073 	uxtb	r3, r3
7000ac1c:	e3530000 	cmp	r3, #0
7000ac20:	0afffffb 	beq	7000ac14 <rt_thread_control+0x68>
7000ac24:	ea000008 	b	7000ac4c <rt_thread_control+0xa0>
7000ac28:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ac2c:	e3473002 	movt	r3, #28674	; 0x7002
7000ac30:	e5933000 	ldr	r3, [r3]
7000ac34:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000ac38:	e3470002 	movt	r0, #28674	; 0x7002
7000ac3c:	e3061da4 	movw	r1, #28068	; 0x6da4
7000ac40:	e3471002 	movt	r1, #28674	; 0x7002
7000ac44:	e30021e1 	movw	r2, #481	; 0x1e1
7000ac48:	e12fff33 	blx	r3

    switch (cmd)
7000ac4c:	e55b3019 	ldrb	r3, [fp, #-25]
7000ac50:	e3530001 	cmp	r3, #1
7000ac54:	0a00002c 	beq	7000ad0c <rt_thread_control+0x160>
7000ac58:	e3530002 	cmp	r3, #2
7000ac5c:	0a000002 	beq	7000ac6c <rt_thread_control+0xc0>
7000ac60:	e3530000 	cmp	r3, #0
7000ac64:	0a000024 	beq	7000acfc <rt_thread_control+0x150>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
7000ac68:	ea00002b 	b	7000ad1c <rt_thread_control+0x170>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
7000ac6c:	eb000d75 	bl	7000e248 <rt_hw_interrupt_disable>
7000ac70:	e1a04000 	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
7000ac74:	e51b3018 	ldr	r3, [fp, #-24]
7000ac78:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000ac7c:	e3530001 	cmp	r3, #1
7000ac80:	1a00000f 	bne	7000acc4 <rt_thread_control+0x118>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
7000ac84:	e51b0018 	ldr	r0, [fp, #-24]
7000ac88:	ebfffc66 	bl	70009e28 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
7000ac8c:	e51b3020 	ldr	r3, [fp, #-32]
7000ac90:	e5d32000 	ldrb	r2, [r3]
7000ac94:	e51b3018 	ldr	r3, [fp, #-24]
7000ac98:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
7000ac9c:	e51b3018 	ldr	r3, [fp, #-24]
7000aca0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
7000aca4:	e3a02001 	mov	r2, #1
7000aca8:	e1a03312 	lsl	r3, r2, r3
7000acac:	e1a02003 	mov	r2, r3
7000acb0:	e51b3018 	ldr	r3, [fp, #-24]
7000acb4:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
7000acb8:	e51b0018 	ldr	r0, [fp, #-24]
7000acbc:	ebfffc17 	bl	70009d20 <rt_schedule_insert_thread>
7000acc0:	ea00000a 	b	7000acf0 <rt_thread_control+0x144>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
7000acc4:	e51b3020 	ldr	r3, [fp, #-32]
7000acc8:	e5d32000 	ldrb	r2, [r3]
7000accc:	e51b3018 	ldr	r3, [fp, #-24]
7000acd0:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
7000acd4:	e51b3018 	ldr	r3, [fp, #-24]
7000acd8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
7000acdc:	e3a02001 	mov	r2, #1
7000ace0:	e1a03312 	lsl	r3, r2, r3
7000ace4:	e1a02003 	mov	r2, r3
7000ace8:	e51b3018 	ldr	r3, [fp, #-24]
7000acec:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
7000acf0:	e1a00004 	mov	r0, r4
7000acf4:	eb000d56 	bl	7000e254 <rt_hw_interrupt_enable>
        break;
7000acf8:	ea000007 	b	7000ad1c <rt_thread_control+0x170>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
7000acfc:	e51b0018 	ldr	r0, [fp, #-24]
7000ad00:	ebfffe23 	bl	7000a594 <rt_thread_startup>
7000ad04:	e1a03000 	mov	r3, r0
7000ad08:	ea000004 	b	7000ad20 <rt_thread_control+0x174>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
7000ad0c:	e51b0018 	ldr	r0, [fp, #-24]
7000ad10:	ebfffeec 	bl	7000a8c8 <rt_thread_delete>
7000ad14:	e1a03000 	mov	r3, r0
7000ad18:	ea000000 	b	7000ad20 <rt_thread_control+0x174>

    default:
        break;
    }

    return RT_EOK;
7000ad1c:	e3a03000 	mov	r3, #0
}
7000ad20:	e1a00003 	mov	r0, r3
7000ad24:	e24bd008 	sub	sp, fp, #8
7000ad28:	e8bd8810 	pop	{r4, fp, pc}

7000ad2c <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
7000ad2c:	e92d4810 	push	{r4, fp, lr}
7000ad30:	e28db008 	add	fp, sp, #8
7000ad34:	e24dd014 	sub	sp, sp, #20
7000ad38:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000ad3c:	e51b3018 	ldr	r3, [fp, #-24]
7000ad40:	e3530000 	cmp	r3, #0
7000ad44:	1a00001e 	bne	7000adc4 <rt_thread_suspend+0x98>
7000ad48:	e3a03000 	mov	r3, #0
7000ad4c:	e54b300d 	strb	r3, [fp, #-13]
7000ad50:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ad54:	e3473002 	movt	r3, #28674	; 0x7002
7000ad58:	e5933000 	ldr	r3, [r3]
7000ad5c:	e3530000 	cmp	r3, #0
7000ad60:	1a00000d 	bne	7000ad9c <rt_thread_suspend+0x70>
7000ad64:	e3060c84 	movw	r0, #27780	; 0x6c84
7000ad68:	e3470002 	movt	r0, #28674	; 0x7002
7000ad6c:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000ad70:	e3471002 	movt	r1, #28674	; 0x7002
7000ad74:	e3062db8 	movw	r2, #28088	; 0x6db8
7000ad78:	e3472002 	movt	r2, #28674	; 0x7002
7000ad7c:	e300322f 	movw	r3, #559	; 0x22f
7000ad80:	ebfff29b 	bl	700077f4 <rt_kprintf>
7000ad84:	e1a00000 	nop			; (mov r0, r0)
7000ad88:	e55b300d 	ldrb	r3, [fp, #-13]
7000ad8c:	e6ef3073 	uxtb	r3, r3
7000ad90:	e3530000 	cmp	r3, #0
7000ad94:	0afffffb 	beq	7000ad88 <rt_thread_suspend+0x5c>
7000ad98:	ea000009 	b	7000adc4 <rt_thread_suspend+0x98>
7000ad9c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ada0:	e3473002 	movt	r3, #28674	; 0x7002
7000ada4:	e5933000 	ldr	r3, [r3]
7000ada8:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000adac:	e3470002 	movt	r0, #28674	; 0x7002
7000adb0:	e3061db8 	movw	r1, #28088	; 0x6db8
7000adb4:	e3471002 	movt	r1, #28674	; 0x7002
7000adb8:	e300222f 	movw	r2, #559	; 0x22f
7000adbc:	e12fff33 	blx	r3
7000adc0:	eaffffff 	b	7000adc4 <rt_thread_suspend+0x98>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
7000adc4:	e51b3018 	ldr	r3, [fp, #-24]
7000adc8:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000adcc:	e3530001 	cmp	r3, #1
7000add0:	0a000001 	beq	7000addc <rt_thread_suspend+0xb0>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
7000add4:	e3e03000 	mvn	r3, #0
7000add8:	ea00000d 	b	7000ae14 <rt_thread_suspend+0xe8>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
7000addc:	eb000d19 	bl	7000e248 <rt_hw_interrupt_disable>
7000ade0:	e1a04000 	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
7000ade4:	e51b3018 	ldr	r3, [fp, #-24]
7000ade8:	e3a02002 	mov	r2, #2
7000adec:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    rt_schedule_remove_thread(thread);
7000adf0:	e51b0018 	ldr	r0, [fp, #-24]
7000adf4:	ebfffc0b 	bl	70009e28 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
7000adf8:	e51b3018 	ldr	r3, [fp, #-24]
7000adfc:	e2833048 	add	r3, r3, #72	; 0x48
7000ae00:	e1a00003 	mov	r0, r3
7000ae04:	eb000330 	bl	7000bacc <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
7000ae08:	e1a00004 	mov	r0, r4
7000ae0c:	eb000d10 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
7000ae10:	e3a03000 	mov	r3, #0
}
7000ae14:	e1a00003 	mov	r0, r3
7000ae18:	e24bd008 	sub	sp, fp, #8
7000ae1c:	e8bd8810 	pop	{r4, fp, pc}

7000ae20 <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
7000ae20:	e92d4810 	push	{r4, fp, lr}
7000ae24:	e28db008 	add	fp, sp, #8
7000ae28:	e24dd014 	sub	sp, sp, #20
7000ae2c:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000ae30:	e51b3018 	ldr	r3, [fp, #-24]
7000ae34:	e3530000 	cmp	r3, #0
7000ae38:	1a00001e 	bne	7000aeb8 <rt_thread_resume+0x98>
7000ae3c:	e3a03000 	mov	r3, #0
7000ae40:	e54b300d 	strb	r3, [fp, #-13]
7000ae44:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ae48:	e3473002 	movt	r3, #28674	; 0x7002
7000ae4c:	e5933000 	ldr	r3, [r3]
7000ae50:	e3530000 	cmp	r3, #0
7000ae54:	1a00000d 	bne	7000ae90 <rt_thread_resume+0x70>
7000ae58:	e3060c84 	movw	r0, #27780	; 0x6c84
7000ae5c:	e3470002 	movt	r0, #28674	; 0x7002
7000ae60:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000ae64:	e3471002 	movt	r1, #28674	; 0x7002
7000ae68:	e3062dcc 	movw	r2, #28108	; 0x6dcc
7000ae6c:	e3472002 	movt	r2, #28674	; 0x7002
7000ae70:	e3a03f96 	mov	r3, #600	; 0x258
7000ae74:	ebfff25e 	bl	700077f4 <rt_kprintf>
7000ae78:	e1a00000 	nop			; (mov r0, r0)
7000ae7c:	e55b300d 	ldrb	r3, [fp, #-13]
7000ae80:	e6ef3073 	uxtb	r3, r3
7000ae84:	e3530000 	cmp	r3, #0
7000ae88:	0afffffb 	beq	7000ae7c <rt_thread_resume+0x5c>
7000ae8c:	ea000009 	b	7000aeb8 <rt_thread_resume+0x98>
7000ae90:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ae94:	e3473002 	movt	r3, #28674	; 0x7002
7000ae98:	e5933000 	ldr	r3, [r3]
7000ae9c:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000aea0:	e3470002 	movt	r0, #28674	; 0x7002
7000aea4:	e3061dcc 	movw	r1, #28108	; 0x6dcc
7000aea8:	e3471002 	movt	r1, #28674	; 0x7002
7000aeac:	e3a02f96 	mov	r2, #600	; 0x258
7000aeb0:	e12fff33 	blx	r3
7000aeb4:	eaffffff 	b	7000aeb8 <rt_thread_resume+0x98>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
7000aeb8:	e51b3018 	ldr	r3, [fp, #-24]
7000aebc:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000aec0:	e3530002 	cmp	r3, #2
7000aec4:	0a000001 	beq	7000aed0 <rt_thread_resume+0xb0>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
7000aec8:	e3e03000 	mvn	r3, #0
7000aecc:	ea00000e 	b	7000af0c <rt_thread_resume+0xec>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
7000aed0:	eb000cdc 	bl	7000e248 <rt_hw_interrupt_disable>
7000aed4:	e1a04000 	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
7000aed8:	e51b3018 	ldr	r3, [fp, #-24]
7000aedc:	e2833010 	add	r3, r3, #16
7000aee0:	e1a00003 	mov	r0, r3
7000aee4:	ebfffc85 	bl	7000a100 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
7000aee8:	e51b3018 	ldr	r3, [fp, #-24]
7000aeec:	e2833048 	add	r3, r3, #72	; 0x48
7000aef0:	e1a00003 	mov	r0, r3
7000aef4:	eb0002f4 	bl	7000bacc <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
7000aef8:	e1a00004 	mov	r0, r4
7000aefc:	eb000cd4 	bl	7000e254 <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
7000af00:	e51b0018 	ldr	r0, [fp, #-24]
7000af04:	ebfffb85 	bl	70009d20 <rt_schedule_insert_thread>

    return RT_EOK;
7000af08:	e3a03000 	mov	r3, #0
}
7000af0c:	e1a00003 	mov	r0, r3
7000af10:	e24bd008 	sub	sp, fp, #8
7000af14:	e8bd8810 	pop	{r4, fp, pc}

7000af18 <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
7000af18:	e92d4800 	push	{fp, lr}
7000af1c:	e28db004 	add	fp, sp, #4
7000af20:	e24dd010 	sub	sp, sp, #16
7000af24:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
7000af28:	e51b3010 	ldr	r3, [fp, #-16]
7000af2c:	e50b3008 	str	r3, [fp, #-8]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
7000af30:	e51b3008 	ldr	r3, [fp, #-8]
7000af34:	e3530000 	cmp	r3, #0
7000af38:	1a00001d 	bne	7000afb4 <rt_thread_timeout+0x9c>
7000af3c:	e3a03000 	mov	r3, #0
7000af40:	e54b3009 	strb	r3, [fp, #-9]
7000af44:	e30a3b74 	movw	r3, #43892	; 0xab74
7000af48:	e3473002 	movt	r3, #28674	; 0x7002
7000af4c:	e5933000 	ldr	r3, [r3]
7000af50:	e3530000 	cmp	r3, #0
7000af54:	1a00000d 	bne	7000af90 <rt_thread_timeout+0x78>
7000af58:	e3060c84 	movw	r0, #27780	; 0x6c84
7000af5c:	e3470002 	movt	r0, #28674	; 0x7002
7000af60:	e3061cc8 	movw	r1, #27848	; 0x6cc8
7000af64:	e3471002 	movt	r1, #28674	; 0x7002
7000af68:	e3062de0 	movw	r2, #28128	; 0x6de0
7000af6c:	e3472002 	movt	r2, #28674	; 0x7002
7000af70:	e3003283 	movw	r3, #643	; 0x283
7000af74:	ebfff21e 	bl	700077f4 <rt_kprintf>
7000af78:	e1a00000 	nop			; (mov r0, r0)
7000af7c:	e55b3009 	ldrb	r3, [fp, #-9]
7000af80:	e6ef3073 	uxtb	r3, r3
7000af84:	e3530000 	cmp	r3, #0
7000af88:	0afffffb 	beq	7000af7c <rt_thread_timeout+0x64>
7000af8c:	ea000008 	b	7000afb4 <rt_thread_timeout+0x9c>
7000af90:	e30a3b74 	movw	r3, #43892	; 0xab74
7000af94:	e3473002 	movt	r3, #28674	; 0x7002
7000af98:	e5933000 	ldr	r3, [r3]
7000af9c:	e3060cc8 	movw	r0, #27848	; 0x6cc8
7000afa0:	e3470002 	movt	r0, #28674	; 0x7002
7000afa4:	e3061de0 	movw	r1, #28128	; 0x6de0
7000afa8:	e3471002 	movt	r1, #28674	; 0x7002
7000afac:	e3002283 	movw	r2, #643	; 0x283
7000afb0:	e12fff33 	blx	r3
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
7000afb4:	e51b3008 	ldr	r3, [fp, #-8]
7000afb8:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000afbc:	e3530002 	cmp	r3, #2
7000afc0:	0a00001d 	beq	7000b03c <rt_thread_timeout+0x124>
7000afc4:	e3a03000 	mov	r3, #0
7000afc8:	e54b300a 	strb	r3, [fp, #-10]
7000afcc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000afd0:	e3473002 	movt	r3, #28674	; 0x7002
7000afd4:	e5933000 	ldr	r3, [r3]
7000afd8:	e3530000 	cmp	r3, #0
7000afdc:	1a00000d 	bne	7000b018 <rt_thread_timeout+0x100>
7000afe0:	e3060c84 	movw	r0, #27780	; 0x6c84
7000afe4:	e3470002 	movt	r0, #28674	; 0x7002
7000afe8:	e3061d14 	movw	r1, #27924	; 0x6d14
7000afec:	e3471002 	movt	r1, #28674	; 0x7002
7000aff0:	e3062de0 	movw	r2, #28128	; 0x6de0
7000aff4:	e3472002 	movt	r2, #28674	; 0x7002
7000aff8:	e3a03fa1 	mov	r3, #644	; 0x284
7000affc:	ebfff1fc 	bl	700077f4 <rt_kprintf>
7000b000:	e1a00000 	nop			; (mov r0, r0)
7000b004:	e55b300a 	ldrb	r3, [fp, #-10]
7000b008:	e6ef3073 	uxtb	r3, r3
7000b00c:	e3530000 	cmp	r3, #0
7000b010:	0afffffb 	beq	7000b004 <rt_thread_timeout+0xec>
7000b014:	ea000008 	b	7000b03c <rt_thread_timeout+0x124>
7000b018:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b01c:	e3473002 	movt	r3, #28674	; 0x7002
7000b020:	e5933000 	ldr	r3, [r3]
7000b024:	e3060d14 	movw	r0, #27924	; 0x6d14
7000b028:	e3470002 	movt	r0, #28674	; 0x7002
7000b02c:	e3061de0 	movw	r1, #28128	; 0x6de0
7000b030:	e3471002 	movt	r1, #28674	; 0x7002
7000b034:	e3a02fa1 	mov	r2, #644	; 0x284
7000b038:	e12fff33 	blx	r3

    /* set error number */
    thread->error = -RT_ETIMEOUT;
7000b03c:	e51b3008 	ldr	r3, [fp, #-8]
7000b040:	e3e02001 	mvn	r2, #1
7000b044:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
7000b048:	e51b3008 	ldr	r3, [fp, #-8]
7000b04c:	e2833010 	add	r3, r3, #16
7000b050:	e1a00003 	mov	r0, r3
7000b054:	ebfffc29 	bl	7000a100 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
7000b058:	e51b0008 	ldr	r0, [fp, #-8]
7000b05c:	ebfffb2f 	bl	70009d20 <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
7000b060:	ebfffadf 	bl	70009be4 <rt_schedule>
}
7000b064:	e24bd004 	sub	sp, fp, #4
7000b068:	e8bd8800 	pop	{fp, pc}

7000b06c <rt_thread_find>:
 * @return the found thread
 *
 * @note please don't invoke this function in interrupt status.
 */
rt_thread_t rt_thread_find(char *name)
{
7000b06c:	e92d4800 	push	{fp, lr}
7000b070:	e28db004 	add	fp, sp, #4
7000b074:	e24dd018 	sub	sp, sp, #24
7000b078:	e50b0018 	str	r0, [fp, #-24]
    struct rt_list_node *node;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
7000b07c:	ebfffd3b 	bl	7000a570 <rt_thread_self>
7000b080:	e1a03000 	mov	r3, r0
7000b084:	e3530000 	cmp	r3, #0
7000b088:	0a000000 	beq	7000b090 <rt_thread_find+0x24>
        rt_enter_critical();
7000b08c:	ebfffba9 	bl	70009f38 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
7000b090:	e3083d88 	movw	r3, #36232	; 0x8d88
7000b094:	e3473002 	movt	r3, #28674	; 0x7002
7000b098:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
7000b09c:	e51b300c 	ldr	r3, [fp, #-12]
7000b0a0:	e5933004 	ldr	r3, [r3, #4]
7000b0a4:	e50b3008 	str	r3, [fp, #-8]
7000b0a8:	ea000014 	b	7000b100 <rt_thread_find+0x94>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
7000b0ac:	e51b3008 	ldr	r3, [fp, #-8]
7000b0b0:	e2433008 	sub	r3, r3, #8
7000b0b4:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
7000b0b8:	e51b3010 	ldr	r3, [fp, #-16]
7000b0bc:	e1a00003 	mov	r0, r3
7000b0c0:	e51b1018 	ldr	r1, [fp, #-24]
7000b0c4:	e3a02006 	mov	r2, #6
7000b0c8:	ebffed82 	bl	700066d8 <rt_strncmp>
7000b0cc:	e1a03000 	mov	r3, r0
7000b0d0:	e3530000 	cmp	r3, #0
7000b0d4:	1a000006 	bne	7000b0f4 <rt_thread_find+0x88>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
7000b0d8:	ebfffd24 	bl	7000a570 <rt_thread_self>
7000b0dc:	e1a03000 	mov	r3, r0
7000b0e0:	e3530000 	cmp	r3, #0
7000b0e4:	0a000000 	beq	7000b0ec <rt_thread_find+0x80>
                rt_exit_critical();
7000b0e8:	ebfffba2 	bl	70009f78 <rt_exit_critical>

            return (rt_thread_t)object;
7000b0ec:	e51b3010 	ldr	r3, [fp, #-16]
7000b0f0:	ea00000d 	b	7000b12c <rt_thread_find+0xc0>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
7000b0f4:	e51b3008 	ldr	r3, [fp, #-8]
7000b0f8:	e5933000 	ldr	r3, [r3]
7000b0fc:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
7000b100:	e51b300c 	ldr	r3, [fp, #-12]
7000b104:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
7000b108:	e51b3008 	ldr	r3, [fp, #-8]
7000b10c:	e1520003 	cmp	r2, r3
7000b110:	1affffe5 	bne	7000b0ac <rt_thread_find+0x40>
            return (rt_thread_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
7000b114:	ebfffd15 	bl	7000a570 <rt_thread_self>
7000b118:	e1a03000 	mov	r3, r0
7000b11c:	e3530000 	cmp	r3, #0
7000b120:	0a000000 	beq	7000b128 <rt_thread_find+0xbc>
        rt_exit_critical();
7000b124:	ebfffb93 	bl	70009f78 <rt_exit_critical>

    /* not found */
    return RT_NULL;
7000b128:	e3a03000 	mov	r3, #0
}
7000b12c:	e1a00003 	mov	r0, r3
7000b130:	e24bd004 	sub	sp, fp, #4
7000b134:	e8bd8800 	pop	{fp, pc}

7000b138 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
7000b138:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000b13c:	e28db000 	add	fp, sp, #0
7000b140:	e24dd00c 	sub	sp, sp, #12
7000b144:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
7000b148:	e51b3008 	ldr	r3, [fp, #-8]
7000b14c:	e51b2008 	ldr	r2, [fp, #-8]
7000b150:	e5832004 	str	r2, [r3, #4]
7000b154:	e51b3008 	ldr	r3, [fp, #-8]
7000b158:	e5932004 	ldr	r2, [r3, #4]
7000b15c:	e51b3008 	ldr	r3, [fp, #-8]
7000b160:	e5832000 	str	r2, [r3]
}
7000b164:	e24bd000 	sub	sp, fp, #0
7000b168:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000b16c:	e12fff1e 	bx	lr

7000b170 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
7000b170:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000b174:	e28db000 	add	fp, sp, #0
7000b178:	e24dd00c 	sub	sp, sp, #12
7000b17c:	e50b0008 	str	r0, [fp, #-8]
7000b180:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
7000b184:	e51b3008 	ldr	r3, [fp, #-8]
7000b188:	e5933000 	ldr	r3, [r3]
7000b18c:	e51b200c 	ldr	r2, [fp, #-12]
7000b190:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
7000b194:	e51b3008 	ldr	r3, [fp, #-8]
7000b198:	e5932000 	ldr	r2, [r3]
7000b19c:	e51b300c 	ldr	r3, [fp, #-12]
7000b1a0:	e5832000 	str	r2, [r3]

    l->next = n;
7000b1a4:	e51b3008 	ldr	r3, [fp, #-8]
7000b1a8:	e51b200c 	ldr	r2, [fp, #-12]
7000b1ac:	e5832000 	str	r2, [r3]
    n->prev = l;
7000b1b0:	e51b300c 	ldr	r3, [fp, #-12]
7000b1b4:	e51b2008 	ldr	r2, [fp, #-8]
7000b1b8:	e5832004 	str	r2, [r3, #4]
}
7000b1bc:	e24bd000 	sub	sp, fp, #0
7000b1c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000b1c4:	e12fff1e 	bx	lr

7000b1c8 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
7000b1c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000b1cc:	e28db000 	add	fp, sp, #0
7000b1d0:	e24dd00c 	sub	sp, sp, #12
7000b1d4:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
7000b1d8:	e51b3008 	ldr	r3, [fp, #-8]
7000b1dc:	e5933000 	ldr	r3, [r3]
7000b1e0:	e51b2008 	ldr	r2, [fp, #-8]
7000b1e4:	e5922004 	ldr	r2, [r2, #4]
7000b1e8:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
7000b1ec:	e51b3008 	ldr	r3, [fp, #-8]
7000b1f0:	e5933004 	ldr	r3, [r3, #4]
7000b1f4:	e51b2008 	ldr	r2, [fp, #-8]
7000b1f8:	e5922000 	ldr	r2, [r2]
7000b1fc:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
7000b200:	e51b3008 	ldr	r3, [fp, #-8]
7000b204:	e51b2008 	ldr	r2, [fp, #-8]
7000b208:	e5832004 	str	r2, [r3, #4]
7000b20c:	e51b3008 	ldr	r3, [fp, #-8]
7000b210:	e5932004 	ldr	r2, [r3, #4]
7000b214:	e51b3008 	ldr	r3, [fp, #-8]
7000b218:	e5832000 	str	r2, [r3]
}
7000b21c:	e24bd000 	sub	sp, fp, #0
7000b220:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000b224:	e12fff1e 	bx	lr

7000b228 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
7000b228:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000b22c:	e28db000 	add	fp, sp, #0
7000b230:	e24dd00c 	sub	sp, sp, #12
7000b234:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
7000b238:	e51b3008 	ldr	r3, [fp, #-8]
7000b23c:	e5932000 	ldr	r2, [r3]
7000b240:	e51b3008 	ldr	r3, [fp, #-8]
7000b244:	e1520003 	cmp	r2, r3
7000b248:	13a03000 	movne	r3, #0
7000b24c:	03a03001 	moveq	r3, #1
7000b250:	e6ef3073 	uxtb	r3, r3
}
7000b254:	e1a00003 	mov	r0, r3
7000b258:	e24bd000 	sub	sp, fp, #0
7000b25c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000b260:	e12fff1e 	bx	lr

7000b264 <rt_timer_timeout_sethook>:
 * is timeout.
 *
 * @param hook the hook function
 */
void rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer))
{
7000b264:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000b268:	e28db000 	add	fp, sp, #0
7000b26c:	e24dd00c 	sub	sp, sp, #12
7000b270:	e50b0008 	str	r0, [fp, #-8]
    rt_timer_timeout_hook = hook;
7000b274:	e30938f8 	movw	r3, #39160	; 0x98f8
7000b278:	e3473002 	movt	r3, #28674	; 0x7002
7000b27c:	e51b2008 	ldr	r2, [fp, #-8]
7000b280:	e5832000 	str	r2, [r3]
}
7000b284:	e24bd000 	sub	sp, fp, #0
7000b288:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000b28c:	e12fff1e 	bx	lr

7000b290 <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
7000b290:	e92d4800 	push	{fp, lr}
7000b294:	e28db004 	add	fp, sp, #4
7000b298:	e24dd018 	sub	sp, sp, #24
7000b29c:	e50b0010 	str	r0, [fp, #-16]
7000b2a0:	e50b1014 	str	r1, [fp, #-20]
7000b2a4:	e50b2018 	str	r2, [fp, #-24]
7000b2a8:	e50b301c 	str	r3, [fp, #-28]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
7000b2ac:	e51b3010 	ldr	r3, [fp, #-16]
7000b2b0:	e5db2004 	ldrb	r2, [fp, #4]
7000b2b4:	e5c32007 	strb	r2, [r3, #7]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
7000b2b8:	e51b3010 	ldr	r3, [fp, #-16]
7000b2bc:	e5d33007 	ldrb	r3, [r3, #7]
7000b2c0:	e3c33001 	bic	r3, r3, #1
7000b2c4:	e6ef2073 	uxtb	r2, r3
7000b2c8:	e51b3010 	ldr	r3, [fp, #-16]
7000b2cc:	e5c32007 	strb	r2, [r3, #7]

    timer->timeout_func = timeout;
7000b2d0:	e51b3010 	ldr	r3, [fp, #-16]
7000b2d4:	e51b2014 	ldr	r2, [fp, #-20]
7000b2d8:	e5832018 	str	r2, [r3, #24]
    timer->parameter    = parameter;
7000b2dc:	e51b3010 	ldr	r3, [fp, #-16]
7000b2e0:	e51b2018 	ldr	r2, [fp, #-24]
7000b2e4:	e583201c 	str	r2, [r3, #28]

    timer->timeout_tick = 0;
7000b2e8:	e51b3010 	ldr	r3, [fp, #-16]
7000b2ec:	e3a02000 	mov	r2, #0
7000b2f0:	e5832024 	str	r2, [r3, #36]	; 0x24
    timer->init_tick    = time;
7000b2f4:	e51b3010 	ldr	r3, [fp, #-16]
7000b2f8:	e51b201c 	ldr	r2, [fp, #-28]
7000b2fc:	e5832020 	str	r2, [r3, #32]

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
7000b300:	e3a03000 	mov	r3, #0
7000b304:	e50b3008 	str	r3, [fp, #-8]
7000b308:	ea000009 	b	7000b334 <_rt_timer_init+0xa4>
    {
        rt_list_init(&(timer->row[i]));
7000b30c:	e51b3008 	ldr	r3, [fp, #-8]
7000b310:	e2833002 	add	r3, r3, #2
7000b314:	e1a03183 	lsl	r3, r3, #3
7000b318:	e51b2010 	ldr	r2, [fp, #-16]
7000b31c:	e0823003 	add	r3, r2, r3
7000b320:	e1a00003 	mov	r0, r3
7000b324:	ebffff83 	bl	7000b138 <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
7000b328:	e51b3008 	ldr	r3, [fp, #-8]
7000b32c:	e2833001 	add	r3, r3, #1
7000b330:	e50b3008 	str	r3, [fp, #-8]
7000b334:	e51b3008 	ldr	r3, [fp, #-8]
7000b338:	e3530000 	cmp	r3, #0
7000b33c:	dafffff2 	ble	7000b30c <_rt_timer_init+0x7c>
    {
        rt_list_init(&(timer->row[i]));
    }
}
7000b340:	e24bd004 	sub	sp, fp, #4
7000b344:	e8bd8800 	pop	{fp, pc}

7000b348 <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
7000b348:	e92d4800 	push	{fp, lr}
7000b34c:	e28db004 	add	fp, sp, #4
7000b350:	e24dd010 	sub	sp, sp, #16
7000b354:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
7000b358:	e51b0010 	ldr	r0, [fp, #-16]
7000b35c:	ebffffb1 	bl	7000b228 <rt_list_isempty>
7000b360:	e1a03000 	mov	r3, r0
7000b364:	e3530000 	cmp	r3, #0
7000b368:	0a000001 	beq	7000b374 <rt_timer_list_next_timeout+0x2c>
        return RT_TICK_MAX;
7000b36c:	e3e03000 	mvn	r3, #0
7000b370:	ea000005 	b	7000b38c <rt_timer_list_next_timeout+0x44>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
7000b374:	e51b3010 	ldr	r3, [fp, #-16]
7000b378:	e5933000 	ldr	r3, [r3]
7000b37c:	e2433010 	sub	r3, r3, #16
7000b380:	e50b3008 	str	r3, [fp, #-8]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
7000b384:	e51b3008 	ldr	r3, [fp, #-8]
7000b388:	e5933024 	ldr	r3, [r3, #36]	; 0x24
}
7000b38c:	e1a00003 	mov	r0, r3
7000b390:	e24bd004 	sub	sp, fp, #4
7000b394:	e8bd8800 	pop	{fp, pc}

7000b398 <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
7000b398:	e92d4800 	push	{fp, lr}
7000b39c:	e28db004 	add	fp, sp, #4
7000b3a0:	e24dd010 	sub	sp, sp, #16
7000b3a4:	e50b0010 	str	r0, [fp, #-16]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
7000b3a8:	e3a03000 	mov	r3, #0
7000b3ac:	e50b3008 	str	r3, [fp, #-8]
7000b3b0:	ea000009 	b	7000b3dc <_rt_timer_remove+0x44>
    {
        rt_list_remove(&timer->row[i]);
7000b3b4:	e51b3008 	ldr	r3, [fp, #-8]
7000b3b8:	e2833002 	add	r3, r3, #2
7000b3bc:	e1a03183 	lsl	r3, r3, #3
7000b3c0:	e51b2010 	ldr	r2, [fp, #-16]
7000b3c4:	e0823003 	add	r3, r2, r3
7000b3c8:	e1a00003 	mov	r0, r3
7000b3cc:	ebffff7d 	bl	7000b1c8 <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
7000b3d0:	e51b3008 	ldr	r3, [fp, #-8]
7000b3d4:	e2833001 	add	r3, r3, #1
7000b3d8:	e50b3008 	str	r3, [fp, #-8]
7000b3dc:	e51b3008 	ldr	r3, [fp, #-8]
7000b3e0:	e3530000 	cmp	r3, #0
7000b3e4:	dafffff2 	ble	7000b3b4 <_rt_timer_remove+0x1c>
    {
        rt_list_remove(&timer->row[i]);
    }
}
7000b3e8:	e24bd004 	sub	sp, fp, #4
7000b3ec:	e8bd8800 	pop	{fp, pc}

7000b3f0 <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
7000b3f0:	e92d4800 	push	{fp, lr}
7000b3f4:	e28db004 	add	fp, sp, #4
7000b3f8:	e24dd020 	sub	sp, sp, #32
7000b3fc:	e50b0010 	str	r0, [fp, #-16]
7000b400:	e50b1014 	str	r1, [fp, #-20]
7000b404:	e50b2018 	str	r2, [fp, #-24]
7000b408:	e50b301c 	str	r3, [fp, #-28]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000b40c:	e51b3010 	ldr	r3, [fp, #-16]
7000b410:	e3530000 	cmp	r3, #0
7000b414:	1a00001d 	bne	7000b490 <rt_timer_init+0xa0>
7000b418:	e3a03000 	mov	r3, #0
7000b41c:	e54b3005 	strb	r3, [fp, #-5]
7000b420:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b424:	e3473002 	movt	r3, #28674	; 0x7002
7000b428:	e5933000 	ldr	r3, [r3]
7000b42c:	e3530000 	cmp	r3, #0
7000b430:	1a00000d 	bne	7000b46c <rt_timer_init+0x7c>
7000b434:	e3060df4 	movw	r0, #28148	; 0x6df4
7000b438:	e3470002 	movt	r0, #28674	; 0x7002
7000b43c:	e3061e14 	movw	r1, #28180	; 0x6e14
7000b440:	e3471002 	movt	r1, #28674	; 0x7002
7000b444:	e3062e4c 	movw	r2, #28236	; 0x6e4c
7000b448:	e3472002 	movt	r2, #28674	; 0x7002
7000b44c:	e3a030bc 	mov	r3, #188	; 0xbc
7000b450:	ebfff0e7 	bl	700077f4 <rt_kprintf>
7000b454:	e1a00000 	nop			; (mov r0, r0)
7000b458:	e55b3005 	ldrb	r3, [fp, #-5]
7000b45c:	e6ef3073 	uxtb	r3, r3
7000b460:	e3530000 	cmp	r3, #0
7000b464:	0afffffb 	beq	7000b458 <rt_timer_init+0x68>
7000b468:	ea000008 	b	7000b490 <rt_timer_init+0xa0>
7000b46c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b470:	e3473002 	movt	r3, #28674	; 0x7002
7000b474:	e5933000 	ldr	r3, [r3]
7000b478:	e3060e14 	movw	r0, #28180	; 0x6e14
7000b47c:	e3470002 	movt	r0, #28674	; 0x7002
7000b480:	e3061e4c 	movw	r1, #28236	; 0x6e4c
7000b484:	e3471002 	movt	r1, #28674	; 0x7002
7000b488:	e3a020bc 	mov	r2, #188	; 0xbc
7000b48c:	e12fff33 	blx	r3

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
7000b490:	e51b0010 	ldr	r0, [fp, #-16]
7000b494:	e3a01008 	mov	r1, #8
7000b498:	e51b2014 	ldr	r2, [fp, #-20]
7000b49c:	ebfff783 	bl	700092b0 <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
7000b4a0:	e5db3008 	ldrb	r3, [fp, #8]
7000b4a4:	e58d3000 	str	r3, [sp]
7000b4a8:	e51b0010 	ldr	r0, [fp, #-16]
7000b4ac:	e51b1018 	ldr	r1, [fp, #-24]
7000b4b0:	e51b201c 	ldr	r2, [fp, #-28]
7000b4b4:	e59b3004 	ldr	r3, [fp, #4]
7000b4b8:	ebffff74 	bl	7000b290 <_rt_timer_init>
}
7000b4bc:	e24bd004 	sub	sp, fp, #4
7000b4c0:	e8bd8800 	pop	{fp, pc}

7000b4c4 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
7000b4c4:	e92d4810 	push	{r4, fp, lr}
7000b4c8:	e28db008 	add	fp, sp, #8
7000b4cc:	e24dd014 	sub	sp, sp, #20
7000b4d0:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000b4d4:	e51b3018 	ldr	r3, [fp, #-24]
7000b4d8:	e3530000 	cmp	r3, #0
7000b4dc:	1a00001d 	bne	7000b558 <rt_timer_detach+0x94>
7000b4e0:	e3a03000 	mov	r3, #0
7000b4e4:	e54b300d 	strb	r3, [fp, #-13]
7000b4e8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b4ec:	e3473002 	movt	r3, #28674	; 0x7002
7000b4f0:	e5933000 	ldr	r3, [r3]
7000b4f4:	e3530000 	cmp	r3, #0
7000b4f8:	1a00000d 	bne	7000b534 <rt_timer_detach+0x70>
7000b4fc:	e3060df4 	movw	r0, #28148	; 0x6df4
7000b500:	e3470002 	movt	r0, #28674	; 0x7002
7000b504:	e3061e14 	movw	r1, #28180	; 0x6e14
7000b508:	e3471002 	movt	r1, #28674	; 0x7002
7000b50c:	e3062e5c 	movw	r2, #28252	; 0x6e5c
7000b510:	e3472002 	movt	r2, #28674	; 0x7002
7000b514:	e3a030d1 	mov	r3, #209	; 0xd1
7000b518:	ebfff0b5 	bl	700077f4 <rt_kprintf>
7000b51c:	e1a00000 	nop			; (mov r0, r0)
7000b520:	e55b300d 	ldrb	r3, [fp, #-13]
7000b524:	e6ef3073 	uxtb	r3, r3
7000b528:	e3530000 	cmp	r3, #0
7000b52c:	0afffffb 	beq	7000b520 <rt_timer_detach+0x5c>
7000b530:	ea000008 	b	7000b558 <rt_timer_detach+0x94>
7000b534:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b538:	e3473002 	movt	r3, #28674	; 0x7002
7000b53c:	e5933000 	ldr	r3, [r3]
7000b540:	e3060e14 	movw	r0, #28180	; 0x6e14
7000b544:	e3470002 	movt	r0, #28674	; 0x7002
7000b548:	e3061e5c 	movw	r1, #28252	; 0x6e5c
7000b54c:	e3471002 	movt	r1, #28674	; 0x7002
7000b550:	e3a020d1 	mov	r2, #209	; 0xd1
7000b554:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000b558:	eb000b3a 	bl	7000e248 <rt_hw_interrupt_disable>
7000b55c:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
7000b560:	e51b0018 	ldr	r0, [fp, #-24]
7000b564:	ebffff8b 	bl	7000b398 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000b568:	e1a00004 	mov	r0, r4
7000b56c:	eb000b38 	bl	7000e254 <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
7000b570:	e51b0018 	ldr	r0, [fp, #-24]
7000b574:	ebfff77c 	bl	7000936c <rt_object_detach>

    return -RT_EOK;
7000b578:	e3a03000 	mov	r3, #0
}
7000b57c:	e1a00003 	mov	r0, r3
7000b580:	e24bd008 	sub	sp, fp, #8
7000b584:	e8bd8810 	pop	{r4, fp, pc}

7000b588 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
7000b588:	e92d4800 	push	{fp, lr}
7000b58c:	e28db004 	add	fp, sp, #4
7000b590:	e24dd020 	sub	sp, sp, #32
7000b594:	e50b0010 	str	r0, [fp, #-16]
7000b598:	e50b1014 	str	r1, [fp, #-20]
7000b59c:	e50b2018 	str	r2, [fp, #-24]
7000b5a0:	e50b301c 	str	r3, [fp, #-28]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
7000b5a4:	e3a00008 	mov	r0, #8
7000b5a8:	e51b1010 	ldr	r1, [fp, #-16]
7000b5ac:	ebfff7a7 	bl	70009450 <rt_object_allocate>
7000b5b0:	e50b0008 	str	r0, [fp, #-8]
    if (timer == RT_NULL)
7000b5b4:	e51b3008 	ldr	r3, [fp, #-8]
7000b5b8:	e3530000 	cmp	r3, #0
7000b5bc:	1a000001 	bne	7000b5c8 <rt_timer_create+0x40>
    {
        return RT_NULL;
7000b5c0:	e3a03000 	mov	r3, #0
7000b5c4:	ea000007 	b	7000b5e8 <rt_timer_create+0x60>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
7000b5c8:	e5db3004 	ldrb	r3, [fp, #4]
7000b5cc:	e58d3000 	str	r3, [sp]
7000b5d0:	e51b0008 	ldr	r0, [fp, #-8]
7000b5d4:	e51b1014 	ldr	r1, [fp, #-20]
7000b5d8:	e51b2018 	ldr	r2, [fp, #-24]
7000b5dc:	e51b301c 	ldr	r3, [fp, #-28]
7000b5e0:	ebffff2a 	bl	7000b290 <_rt_timer_init>

    return timer;
7000b5e4:	e51b3008 	ldr	r3, [fp, #-8]
}
7000b5e8:	e1a00003 	mov	r0, r3
7000b5ec:	e24bd004 	sub	sp, fp, #4
7000b5f0:	e8bd8800 	pop	{fp, pc}

7000b5f4 <rt_timer_delete>:
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
{
7000b5f4:	e92d4810 	push	{r4, fp, lr}
7000b5f8:	e28db008 	add	fp, sp, #8
7000b5fc:	e24dd014 	sub	sp, sp, #20
7000b600:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000b604:	e51b3018 	ldr	r3, [fp, #-24]
7000b608:	e3530000 	cmp	r3, #0
7000b60c:	1a00001d 	bne	7000b688 <rt_timer_delete+0x94>
7000b610:	e3a03000 	mov	r3, #0
7000b614:	e54b300d 	strb	r3, [fp, #-13]
7000b618:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b61c:	e3473002 	movt	r3, #28674	; 0x7002
7000b620:	e5933000 	ldr	r3, [r3]
7000b624:	e3530000 	cmp	r3, #0
7000b628:	1a00000d 	bne	7000b664 <rt_timer_delete+0x70>
7000b62c:	e3060df4 	movw	r0, #28148	; 0x6df4
7000b630:	e3470002 	movt	r0, #28674	; 0x7002
7000b634:	e3061e14 	movw	r1, #28180	; 0x6e14
7000b638:	e3471002 	movt	r1, #28674	; 0x7002
7000b63c:	e3062e6c 	movw	r2, #28268	; 0x6e6c
7000b640:	e3472002 	movt	r2, #28674	; 0x7002
7000b644:	e300310e 	movw	r3, #270	; 0x10e
7000b648:	ebfff069 	bl	700077f4 <rt_kprintf>
7000b64c:	e1a00000 	nop			; (mov r0, r0)
7000b650:	e55b300d 	ldrb	r3, [fp, #-13]
7000b654:	e6ef3073 	uxtb	r3, r3
7000b658:	e3530000 	cmp	r3, #0
7000b65c:	0afffffb 	beq	7000b650 <rt_timer_delete+0x5c>
7000b660:	ea000008 	b	7000b688 <rt_timer_delete+0x94>
7000b664:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b668:	e3473002 	movt	r3, #28674	; 0x7002
7000b66c:	e5933000 	ldr	r3, [r3]
7000b670:	e3060e14 	movw	r0, #28180	; 0x6e14
7000b674:	e3470002 	movt	r0, #28674	; 0x7002
7000b678:	e3061e6c 	movw	r1, #28268	; 0x6e6c
7000b67c:	e3471002 	movt	r1, #28674	; 0x7002
7000b680:	e300210e 	movw	r2, #270	; 0x10e
7000b684:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000b688:	eb000aee 	bl	7000e248 <rt_hw_interrupt_disable>
7000b68c:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
7000b690:	e51b0018 	ldr	r0, [fp, #-24]
7000b694:	ebffff3f 	bl	7000b398 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000b698:	e1a00004 	mov	r0, r4
7000b69c:	eb000aec 	bl	7000e254 <rt_hw_interrupt_enable>

    rt_object_delete((rt_object_t)timer);
7000b6a0:	e51b0018 	ldr	r0, [fp, #-24]
7000b6a4:	ebfff7ce 	bl	700095e4 <rt_object_delete>

    return -RT_EOK;
7000b6a8:	e3a03000 	mov	r3, #0
}
7000b6ac:	e1a00003 	mov	r0, r3
7000b6b0:	e24bd008 	sub	sp, fp, #8
7000b6b4:	e8bd8810 	pop	{r4, fp, pc}

7000b6b8 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
7000b6b8:	e92d4810 	push	{r4, fp, lr}
7000b6bc:	e28db008 	add	fp, sp, #8
7000b6c0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
7000b6c4:	e50b0030 	str	r0, [fp, #-48]	; 0x30
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000b6c8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b6cc:	e3530000 	cmp	r3, #0
7000b6d0:	1a00001d 	bne	7000b74c <rt_timer_start+0x94>
7000b6d4:	e3a03000 	mov	r3, #0
7000b6d8:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
7000b6dc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b6e0:	e3473002 	movt	r3, #28674	; 0x7002
7000b6e4:	e5933000 	ldr	r3, [r3]
7000b6e8:	e3530000 	cmp	r3, #0
7000b6ec:	1a00000d 	bne	7000b728 <rt_timer_start+0x70>
7000b6f0:	e3060df4 	movw	r0, #28148	; 0x6df4
7000b6f4:	e3470002 	movt	r0, #28674	; 0x7002
7000b6f8:	e3061e14 	movw	r1, #28180	; 0x6e14
7000b6fc:	e3471002 	movt	r1, #28674	; 0x7002
7000b700:	e3062e7c 	movw	r2, #28284	; 0x6e7c
7000b704:	e3472002 	movt	r2, #28674	; 0x7002
7000b708:	e3a03e13 	mov	r3, #304	; 0x130
7000b70c:	ebfff038 	bl	700077f4 <rt_kprintf>
7000b710:	e1a00000 	nop			; (mov r0, r0)
7000b714:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
7000b718:	e6ef3073 	uxtb	r3, r3
7000b71c:	e3530000 	cmp	r3, #0
7000b720:	0afffffb 	beq	7000b714 <rt_timer_start+0x5c>
7000b724:	ea000008 	b	7000b74c <rt_timer_start+0x94>
7000b728:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b72c:	e3473002 	movt	r3, #28674	; 0x7002
7000b730:	e5933000 	ldr	r3, [r3]
7000b734:	e3060e14 	movw	r0, #28180	; 0x6e14
7000b738:	e3470002 	movt	r0, #28674	; 0x7002
7000b73c:	e3061e7c 	movw	r1, #28284	; 0x6e7c
7000b740:	e3471002 	movt	r1, #28674	; 0x7002
7000b744:	e3a02e13 	mov	r2, #304	; 0x130
7000b748:	e12fff33 	blx	r3

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
7000b74c:	eb000abd 	bl	7000e248 <rt_hw_interrupt_disable>
7000b750:	e1a04000 	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
7000b754:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
7000b758:	ebffff0e 	bl	7000b398 <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
7000b75c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b760:	e5d33007 	ldrb	r3, [r3, #7]
7000b764:	e3c33001 	bic	r3, r3, #1
7000b768:	e6ef2073 	uxtb	r2, r3
7000b76c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b770:	e5c32007 	strb	r2, [r3, #7]
    rt_hw_interrupt_enable(level);
7000b774:	e1a00004 	mov	r0, r4
7000b778:	eb000ab5 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
7000b77c:	e30a3b7c 	movw	r3, #43900	; 0xab7c
7000b780:	e3473002 	movt	r3, #28674	; 0x7002
7000b784:	e5933000 	ldr	r3, [r3]
7000b788:	e3530000 	cmp	r3, #0
7000b78c:	0a000005 	beq	7000b7a8 <rt_timer_start+0xf0>
7000b790:	e30a3b7c 	movw	r3, #43900	; 0xab7c
7000b794:	e3473002 	movt	r3, #28674	; 0x7002
7000b798:	e5933000 	ldr	r3, [r3]
7000b79c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
7000b7a0:	e1a00002 	mov	r0, r2
7000b7a4:	e12fff33 	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
7000b7a8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b7ac:	e5933020 	ldr	r3, [r3, #32]
7000b7b0:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
7000b7b4:	9a00001d 	bls	7000b830 <rt_timer_start+0x178>
7000b7b8:	e3a03000 	mov	r3, #0
7000b7bc:	e54b3026 	strb	r3, [fp, #-38]	; 0x26
7000b7c0:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b7c4:	e3473002 	movt	r3, #28674	; 0x7002
7000b7c8:	e5933000 	ldr	r3, [r3]
7000b7cc:	e3530000 	cmp	r3, #0
7000b7d0:	1a00000d 	bne	7000b80c <rt_timer_start+0x154>
7000b7d4:	e3060df4 	movw	r0, #28148	; 0x6df4
7000b7d8:	e3470002 	movt	r0, #28674	; 0x7002
7000b7dc:	e3061e28 	movw	r1, #28200	; 0x6e28
7000b7e0:	e3471002 	movt	r1, #28674	; 0x7002
7000b7e4:	e3062e7c 	movw	r2, #28284	; 0x6e7c
7000b7e8:	e3472002 	movt	r2, #28674	; 0x7002
7000b7ec:	e3a03d05 	mov	r3, #320	; 0x140
7000b7f0:	ebffefff 	bl	700077f4 <rt_kprintf>
7000b7f4:	e1a00000 	nop			; (mov r0, r0)
7000b7f8:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
7000b7fc:	e6ef3073 	uxtb	r3, r3
7000b800:	e3530000 	cmp	r3, #0
7000b804:	0afffffb 	beq	7000b7f8 <rt_timer_start+0x140>
7000b808:	ea000008 	b	7000b830 <rt_timer_start+0x178>
7000b80c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000b810:	e3473002 	movt	r3, #28674	; 0x7002
7000b814:	e5933000 	ldr	r3, [r3]
7000b818:	e3060e28 	movw	r0, #28200	; 0x6e28
7000b81c:	e3470002 	movt	r0, #28674	; 0x7002
7000b820:	e3061e7c 	movw	r1, #28284	; 0x6e7c
7000b824:	e3471002 	movt	r1, #28674	; 0x7002
7000b828:	e3a02d05 	mov	r2, #320	; 0x140
7000b82c:	e12fff33 	blx	r3
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
7000b830:	ebffd3a5 	bl	700006cc <rt_tick_get>
7000b834:	e1a02000 	mov	r2, r0
7000b838:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b83c:	e5933020 	ldr	r3, [r3, #32]
7000b840:	e0822003 	add	r2, r2, r3
7000b844:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b848:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000b84c:	eb000a7d 	bl	7000e248 <rt_hw_interrupt_disable>
7000b850:	e1a04000 	mov	r4, r0
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
7000b854:	e30938f0 	movw	r3, #39152	; 0x98f0
7000b858:	e3473002 	movt	r3, #28674	; 0x7002
7000b85c:	e50b3018 	str	r3, [fp, #-24]
    }

    row_head[0]  = &timer_list[0];
7000b860:	e51b3018 	ldr	r3, [fp, #-24]
7000b864:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
7000b868:	e3a03000 	mov	r3, #0
7000b86c:	e50b3010 	str	r3, [fp, #-16]
7000b870:	ea000052 	b	7000b9c0 <rt_timer_start+0x308>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
7000b874:	ea00002d 	b	7000b930 <rt_timer_start+0x278>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
7000b878:	e51b2010 	ldr	r2, [fp, #-16]
7000b87c:	e3e03017 	mvn	r3, #23
7000b880:	e1a02102 	lsl	r2, r2, #2
7000b884:	e24b000c 	sub	r0, fp, #12
7000b888:	e0802002 	add	r2, r0, r2
7000b88c:	e0823003 	add	r3, r2, r3
7000b890:	e5933000 	ldr	r3, [r3]
7000b894:	e5933000 	ldr	r3, [r3]
7000b898:	e50b301c 	str	r3, [fp, #-28]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
7000b89c:	e51b3010 	ldr	r3, [fp, #-16]
7000b8a0:	e1a03183 	lsl	r3, r3, #3
7000b8a4:	e2833010 	add	r3, r3, #16
7000b8a8:	e2633000 	rsb	r3, r3, #0
7000b8ac:	e51b201c 	ldr	r2, [fp, #-28]
7000b8b0:	e0823003 	add	r3, r2, r3
7000b8b4:	e50b3020 	str	r3, [fp, #-32]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
7000b8b8:	e51b3020 	ldr	r3, [fp, #-32]
7000b8bc:	e5932024 	ldr	r2, [r3, #36]	; 0x24
7000b8c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b8c4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000b8c8:	e1520003 	cmp	r2, r3
7000b8cc:	1a000000 	bne	7000b8d4 <rt_timer_start+0x21c>
            {
                continue;
7000b8d0:	ea000007 	b	7000b8f4 <rt_timer_start+0x23c>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
7000b8d4:	e51b3020 	ldr	r3, [fp, #-32]
7000b8d8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
7000b8dc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000b8e0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000b8e4:	e0633002 	rsb	r3, r3, r2
7000b8e8:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
7000b8ec:	8a000000 	bhi	7000b8f4 <rt_timer_start+0x23c>
            {
                break;
7000b8f0:	ea00001c 	b	7000b968 <rt_timer_start+0x2b0>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
7000b8f4:	e51b2010 	ldr	r2, [fp, #-16]
7000b8f8:	e3e03017 	mvn	r3, #23
7000b8fc:	e1a02102 	lsl	r2, r2, #2
7000b900:	e24b100c 	sub	r1, fp, #12
7000b904:	e0812002 	add	r2, r1, r2
7000b908:	e0823003 	add	r3, r2, r3
7000b90c:	e5933000 	ldr	r3, [r3]
7000b910:	e5932000 	ldr	r2, [r3]
7000b914:	e51b1010 	ldr	r1, [fp, #-16]
7000b918:	e3e03017 	mvn	r3, #23
7000b91c:	e1a01101 	lsl	r1, r1, #2
7000b920:	e24b000c 	sub	r0, fp, #12
7000b924:	e0801001 	add	r1, r0, r1
7000b928:	e0813003 	add	r3, r1, r3
7000b92c:	e5832000 	str	r2, [r3]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
7000b930:	e51b2010 	ldr	r2, [fp, #-16]
7000b934:	e3e03017 	mvn	r3, #23
7000b938:	e1a02102 	lsl	r2, r2, #2
7000b93c:	e24b100c 	sub	r1, fp, #12
7000b940:	e0812002 	add	r2, r1, r2
7000b944:	e0823003 	add	r3, r2, r3
7000b948:	e5932000 	ldr	r2, [r3]
7000b94c:	e51b3010 	ldr	r3, [fp, #-16]
7000b950:	e1a03183 	lsl	r3, r3, #3
7000b954:	e51b1018 	ldr	r1, [fp, #-24]
7000b958:	e0813003 	add	r3, r1, r3
7000b95c:	e5933004 	ldr	r3, [r3, #4]
7000b960:	e1520003 	cmp	r2, r3
7000b964:	1affffc3 	bne	7000b878 <rt_timer_start+0x1c0>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
7000b968:	e51b3010 	ldr	r3, [fp, #-16]
7000b96c:	e3530000 	cmp	r3, #0
7000b970:	0a00000f 	beq	7000b9b4 <rt_timer_start+0x2fc>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
7000b974:	e51b3010 	ldr	r3, [fp, #-16]
7000b978:	e2831001 	add	r1, r3, #1
7000b97c:	e51b2010 	ldr	r2, [fp, #-16]
7000b980:	e3e03017 	mvn	r3, #23
7000b984:	e1a02102 	lsl	r2, r2, #2
7000b988:	e24b000c 	sub	r0, fp, #12
7000b98c:	e0802002 	add	r2, r0, r2
7000b990:	e0823003 	add	r3, r2, r3
7000b994:	e5933000 	ldr	r3, [r3]
7000b998:	e2832008 	add	r2, r3, #8
7000b99c:	e3e03017 	mvn	r3, #23
7000b9a0:	e1a01101 	lsl	r1, r1, #2
7000b9a4:	e24b000c 	sub	r0, fp, #12
7000b9a8:	e0801001 	add	r1, r0, r1
7000b9ac:	e0813003 	add	r3, r1, r3
7000b9b0:	e5832000 	str	r2, [r3]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
7000b9b4:	e51b3010 	ldr	r3, [fp, #-16]
7000b9b8:	e2833001 	add	r3, r3, #1
7000b9bc:	e50b3010 	str	r3, [fp, #-16]
7000b9c0:	e51b3010 	ldr	r3, [fp, #-16]
7000b9c4:	e3530000 	cmp	r3, #0
7000b9c8:	0affffa9 	beq	7000b874 <rt_timer_start+0x1bc>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
7000b9cc:	e30938fc 	movw	r3, #39164	; 0x98fc
7000b9d0:	e3473002 	movt	r3, #28674	; 0x7002
7000b9d4:	e5933000 	ldr	r3, [r3]
7000b9d8:	e2832001 	add	r2, r3, #1
7000b9dc:	e30938fc 	movw	r3, #39164	; 0x98fc
7000b9e0:	e3473002 	movt	r3, #28674	; 0x7002
7000b9e4:	e5832000 	str	r2, [r3]
    tst_nr = random_nr;
7000b9e8:	e30938fc 	movw	r3, #39164	; 0x98fc
7000b9ec:	e3473002 	movt	r3, #28674	; 0x7002
7000b9f0:	e5933000 	ldr	r3, [r3]
7000b9f4:	e50b3014 	str	r3, [fp, #-20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
7000b9f8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
7000b9fc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000ba00:	e2833010 	add	r3, r3, #16
7000ba04:	e1a00002 	mov	r0, r2
7000ba08:	e1a01003 	mov	r1, r3
7000ba0c:	ebfffdd7 	bl	7000b170 <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
7000ba10:	e3a03002 	mov	r3, #2
7000ba14:	e50b3010 	str	r3, [fp, #-16]
7000ba18:	ea00001c 	b	7000ba90 <rt_timer_start+0x3d8>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
7000ba1c:	e51b3014 	ldr	r3, [fp, #-20]
7000ba20:	e2033003 	and	r3, r3, #3
7000ba24:	e3530000 	cmp	r3, #0
7000ba28:	1a000017 	bne	7000ba8c <rt_timer_start+0x3d4>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
7000ba2c:	e51b3010 	ldr	r3, [fp, #-16]
7000ba30:	e2632001 	rsb	r2, r3, #1
7000ba34:	e3e03017 	mvn	r3, #23
7000ba38:	e1a02102 	lsl	r2, r2, #2
7000ba3c:	e24b100c 	sub	r1, fp, #12
7000ba40:	e0812002 	add	r2, r1, r2
7000ba44:	e0823003 	add	r3, r2, r3
7000ba48:	e5932000 	ldr	r2, [r3]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
7000ba4c:	e51b3010 	ldr	r3, [fp, #-16]
7000ba50:	e2633001 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
7000ba54:	e2833002 	add	r3, r3, #2
7000ba58:	e1a03183 	lsl	r3, r3, #3
7000ba5c:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
7000ba60:	e0813003 	add	r3, r1, r3
7000ba64:	e1a00002 	mov	r0, r2
7000ba68:	e1a01003 	mov	r1, r3
7000ba6c:	ebfffdbf 	bl	7000b170 <rt_list_insert_after>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
7000ba70:	e51b3014 	ldr	r3, [fp, #-20]
7000ba74:	e1a03123 	lsr	r3, r3, #2
7000ba78:	e50b3014 	str	r3, [fp, #-20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
7000ba7c:	e51b3010 	ldr	r3, [fp, #-16]
7000ba80:	e2833001 	add	r3, r3, #1
7000ba84:	e50b3010 	str	r3, [fp, #-16]
7000ba88:	ea000000 	b	7000ba90 <rt_timer_start+0x3d8>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
7000ba8c:	ea000002 	b	7000ba9c <rt_timer_start+0x3e4>
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
7000ba90:	e51b3010 	ldr	r3, [fp, #-16]
7000ba94:	e3530001 	cmp	r3, #1
7000ba98:	9affffdf 	bls	7000ba1c <rt_timer_start+0x364>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
7000ba9c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000baa0:	e5d33007 	ldrb	r3, [r3, #7]
7000baa4:	e3833001 	orr	r3, r3, #1
7000baa8:	e6ef2073 	uxtb	r2, r3
7000baac:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7000bab0:	e5c32007 	strb	r2, [r3, #7]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000bab4:	e1a00004 	mov	r0, r4
7000bab8:	eb0009e5 	bl	7000e254 <rt_hw_interrupt_enable>
            rt_schedule();
        }
    }
#endif

    return -RT_EOK;
7000babc:	e3a03000 	mov	r3, #0
}
7000bac0:	e1a00003 	mov	r0, r3
7000bac4:	e24bd008 	sub	sp, fp, #8
7000bac8:	e8bd8810 	pop	{r4, fp, pc}

7000bacc <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
7000bacc:	e92d4810 	push	{r4, fp, lr}
7000bad0:	e28db008 	add	fp, sp, #8
7000bad4:	e24dd014 	sub	sp, sp, #20
7000bad8:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000badc:	e51b3018 	ldr	r3, [fp, #-24]
7000bae0:	e3530000 	cmp	r3, #0
7000bae4:	1a00001d 	bne	7000bb60 <rt_timer_stop+0x94>
7000bae8:	e3a03000 	mov	r3, #0
7000baec:	e54b300d 	strb	r3, [fp, #-13]
7000baf0:	e30a3b74 	movw	r3, #43892	; 0xab74
7000baf4:	e3473002 	movt	r3, #28674	; 0x7002
7000baf8:	e5933000 	ldr	r3, [r3]
7000bafc:	e3530000 	cmp	r3, #0
7000bb00:	1a00000d 	bne	7000bb3c <rt_timer_stop+0x70>
7000bb04:	e3060df4 	movw	r0, #28148	; 0x6df4
7000bb08:	e3470002 	movt	r0, #28674	; 0x7002
7000bb0c:	e3061e14 	movw	r1, #28180	; 0x6e14
7000bb10:	e3471002 	movt	r1, #28674	; 0x7002
7000bb14:	e3062e8c 	movw	r2, #28300	; 0x6e8c
7000bb18:	e3472002 	movt	r2, #28674	; 0x7002
7000bb1c:	e3a03f6a 	mov	r3, #424	; 0x1a8
7000bb20:	ebffef33 	bl	700077f4 <rt_kprintf>
7000bb24:	e1a00000 	nop			; (mov r0, r0)
7000bb28:	e55b300d 	ldrb	r3, [fp, #-13]
7000bb2c:	e6ef3073 	uxtb	r3, r3
7000bb30:	e3530000 	cmp	r3, #0
7000bb34:	0afffffb 	beq	7000bb28 <rt_timer_stop+0x5c>
7000bb38:	ea000008 	b	7000bb60 <rt_timer_stop+0x94>
7000bb3c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bb40:	e3473002 	movt	r3, #28674	; 0x7002
7000bb44:	e5933000 	ldr	r3, [r3]
7000bb48:	e3060e14 	movw	r0, #28180	; 0x6e14
7000bb4c:	e3470002 	movt	r0, #28674	; 0x7002
7000bb50:	e3061e8c 	movw	r1, #28300	; 0x6e8c
7000bb54:	e3471002 	movt	r1, #28674	; 0x7002
7000bb58:	e3a02f6a 	mov	r2, #424	; 0x1a8
7000bb5c:	e12fff33 	blx	r3
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
7000bb60:	e51b3018 	ldr	r3, [fp, #-24]
7000bb64:	e5d33007 	ldrb	r3, [r3, #7]
7000bb68:	e2033001 	and	r3, r3, #1
7000bb6c:	e3530000 	cmp	r3, #0
7000bb70:	1a000001 	bne	7000bb7c <rt_timer_stop+0xb0>
        return -RT_ERROR;
7000bb74:	e3e03000 	mvn	r3, #0
7000bb78:	ea000017 	b	7000bbdc <rt_timer_stop+0x110>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
7000bb7c:	e30a3b78 	movw	r3, #43896	; 0xab78
7000bb80:	e3473002 	movt	r3, #28674	; 0x7002
7000bb84:	e5933000 	ldr	r3, [r3]
7000bb88:	e3530000 	cmp	r3, #0
7000bb8c:	0a000005 	beq	7000bba8 <rt_timer_stop+0xdc>
7000bb90:	e30a3b78 	movw	r3, #43896	; 0xab78
7000bb94:	e3473002 	movt	r3, #28674	; 0x7002
7000bb98:	e5933000 	ldr	r3, [r3]
7000bb9c:	e51b2018 	ldr	r2, [fp, #-24]
7000bba0:	e1a00002 	mov	r0, r2
7000bba4:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000bba8:	eb0009a6 	bl	7000e248 <rt_hw_interrupt_disable>
7000bbac:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
7000bbb0:	e51b0018 	ldr	r0, [fp, #-24]
7000bbb4:	ebfffdf7 	bl	7000b398 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000bbb8:	e1a00004 	mov	r0, r4
7000bbbc:	eb0009a4 	bl	7000e254 <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
7000bbc0:	e51b3018 	ldr	r3, [fp, #-24]
7000bbc4:	e5d33007 	ldrb	r3, [r3, #7]
7000bbc8:	e3c33001 	bic	r3, r3, #1
7000bbcc:	e6ef2073 	uxtb	r2, r3
7000bbd0:	e51b3018 	ldr	r3, [fp, #-24]
7000bbd4:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
7000bbd8:	e3a03000 	mov	r3, #0
}
7000bbdc:	e1a00003 	mov	r0, r3
7000bbe0:	e24bd008 	sub	sp, fp, #8
7000bbe4:	e8bd8810 	pop	{r4, fp, pc}

7000bbe8 <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
7000bbe8:	e92d4800 	push	{fp, lr}
7000bbec:	e28db004 	add	fp, sp, #4
7000bbf0:	e24dd018 	sub	sp, sp, #24
7000bbf4:	e50b0010 	str	r0, [fp, #-16]
7000bbf8:	e1a03001 	mov	r3, r1
7000bbfc:	e50b2018 	str	r2, [fp, #-24]
7000bc00:	e54b3011 	strb	r3, [fp, #-17]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
7000bc04:	e51b3010 	ldr	r3, [fp, #-16]
7000bc08:	e3530000 	cmp	r3, #0
7000bc0c:	1a00001d 	bne	7000bc88 <rt_timer_control+0xa0>
7000bc10:	e3a03000 	mov	r3, #0
7000bc14:	e54b3005 	strb	r3, [fp, #-5]
7000bc18:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bc1c:	e3473002 	movt	r3, #28674	; 0x7002
7000bc20:	e5933000 	ldr	r3, [r3]
7000bc24:	e3530000 	cmp	r3, #0
7000bc28:	1a00000d 	bne	7000bc64 <rt_timer_control+0x7c>
7000bc2c:	e3060df4 	movw	r0, #28148	; 0x6df4
7000bc30:	e3470002 	movt	r0, #28674	; 0x7002
7000bc34:	e3061e14 	movw	r1, #28180	; 0x6e14
7000bc38:	e3471002 	movt	r1, #28674	; 0x7002
7000bc3c:	e3062e9c 	movw	r2, #28316	; 0x6e9c
7000bc40:	e3472002 	movt	r2, #28674	; 0x7002
7000bc44:	e30031c9 	movw	r3, #457	; 0x1c9
7000bc48:	ebffeee9 	bl	700077f4 <rt_kprintf>
7000bc4c:	e1a00000 	nop			; (mov r0, r0)
7000bc50:	e55b3005 	ldrb	r3, [fp, #-5]
7000bc54:	e6ef3073 	uxtb	r3, r3
7000bc58:	e3530000 	cmp	r3, #0
7000bc5c:	0afffffb 	beq	7000bc50 <rt_timer_control+0x68>
7000bc60:	ea000008 	b	7000bc88 <rt_timer_control+0xa0>
7000bc64:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bc68:	e3473002 	movt	r3, #28674	; 0x7002
7000bc6c:	e5933000 	ldr	r3, [r3]
7000bc70:	e3060e14 	movw	r0, #28180	; 0x6e14
7000bc74:	e3470002 	movt	r0, #28674	; 0x7002
7000bc78:	e3061e9c 	movw	r1, #28316	; 0x6e9c
7000bc7c:	e3471002 	movt	r1, #28674	; 0x7002
7000bc80:	e30021c9 	movw	r2, #457	; 0x1c9
7000bc84:	e12fff33 	blx	r3

    switch (cmd)
7000bc88:	e55b3011 	ldrb	r3, [fp, #-17]
7000bc8c:	e3530003 	cmp	r3, #3
7000bc90:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
7000bc94:	ea00001b 	b	7000bd08 <rt_timer_control+0x120>
7000bc98:	7000bcbc 	.word	0x7000bcbc
7000bc9c:	7000bca8 	.word	0x7000bca8
7000bca0:	7000bcd0 	.word	0x7000bcd0
7000bca4:	7000bcec 	.word	0x7000bcec
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
7000bca8:	e51b3010 	ldr	r3, [fp, #-16]
7000bcac:	e5932020 	ldr	r2, [r3, #32]
7000bcb0:	e51b3018 	ldr	r3, [fp, #-24]
7000bcb4:	e5832000 	str	r2, [r3]
        break;
7000bcb8:	ea000012 	b	7000bd08 <rt_timer_control+0x120>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
7000bcbc:	e51b3018 	ldr	r3, [fp, #-24]
7000bcc0:	e5932000 	ldr	r2, [r3]
7000bcc4:	e51b3010 	ldr	r3, [fp, #-16]
7000bcc8:	e5832020 	str	r2, [r3, #32]
        break;
7000bccc:	ea00000d 	b	7000bd08 <rt_timer_control+0x120>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
7000bcd0:	e51b3010 	ldr	r3, [fp, #-16]
7000bcd4:	e5d33007 	ldrb	r3, [r3, #7]
7000bcd8:	e3c33002 	bic	r3, r3, #2
7000bcdc:	e6ef2073 	uxtb	r2, r3
7000bce0:	e51b3010 	ldr	r3, [fp, #-16]
7000bce4:	e5c32007 	strb	r2, [r3, #7]
        break;
7000bce8:	ea000006 	b	7000bd08 <rt_timer_control+0x120>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
7000bcec:	e51b3010 	ldr	r3, [fp, #-16]
7000bcf0:	e5d33007 	ldrb	r3, [r3, #7]
7000bcf4:	e3833002 	orr	r3, r3, #2
7000bcf8:	e6ef2073 	uxtb	r2, r3
7000bcfc:	e51b3010 	ldr	r3, [fp, #-16]
7000bd00:	e5c32007 	strb	r2, [r3, #7]
        break;
7000bd04:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
7000bd08:	e3a03000 	mov	r3, #0
}
7000bd0c:	e1a00003 	mov	r0, r3
7000bd10:	e24bd004 	sub	sp, fp, #4
7000bd14:	e8bd8800 	pop	{fp, pc}

7000bd18 <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
7000bd18:	e92d4810 	push	{r4, fp, lr}
7000bd1c:	e28db008 	add	fp, sp, #8
7000bd20:	e24dd00c 	sub	sp, sp, #12
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
7000bd24:	ebffd268 	bl	700006cc <rt_tick_get>
7000bd28:	e50b0010 	str	r0, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
7000bd2c:	eb000945 	bl	7000e248 <rt_hw_interrupt_disable>
7000bd30:	e1a04000 	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
7000bd34:	ea000039 	b	7000be20 <rt_timer_check+0x108>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
7000bd38:	e30938f0 	movw	r3, #39152	; 0x98f0
7000bd3c:	e3473002 	movt	r3, #28674	; 0x7002
7000bd40:	e5933000 	ldr	r3, [r3]
7000bd44:	e2433010 	sub	r3, r3, #16
7000bd48:	e50b3014 	str	r3, [fp, #-20]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
7000bd4c:	e51b3014 	ldr	r3, [fp, #-20]
7000bd50:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000bd54:	e51b2010 	ldr	r2, [fp, #-16]
7000bd58:	e0633002 	rsb	r3, r3, r2
7000bd5c:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
7000bd60:	8a00002d 	bhi	7000be1c <rt_timer_check+0x104>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
7000bd64:	e30938f8 	movw	r3, #39160	; 0x98f8
7000bd68:	e3473002 	movt	r3, #28674	; 0x7002
7000bd6c:	e5933000 	ldr	r3, [r3]
7000bd70:	e3530000 	cmp	r3, #0
7000bd74:	0a000004 	beq	7000bd8c <rt_timer_check+0x74>
7000bd78:	e30938f8 	movw	r3, #39160	; 0x98f8
7000bd7c:	e3473002 	movt	r3, #28674	; 0x7002
7000bd80:	e5933000 	ldr	r3, [r3]
7000bd84:	e51b0014 	ldr	r0, [fp, #-20]
7000bd88:	e12fff33 	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
7000bd8c:	e51b0014 	ldr	r0, [fp, #-20]
7000bd90:	ebfffd80 	bl	7000b398 <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
7000bd94:	e51b3014 	ldr	r3, [fp, #-20]
7000bd98:	e5933018 	ldr	r3, [r3, #24]
7000bd9c:	e51b2014 	ldr	r2, [fp, #-20]
7000bda0:	e592201c 	ldr	r2, [r2, #28]
7000bda4:	e1a00002 	mov	r0, r2
7000bda8:	e12fff33 	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
7000bdac:	ebffd246 	bl	700006cc <rt_tick_get>
7000bdb0:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
7000bdb4:	e51b3014 	ldr	r3, [fp, #-20]
7000bdb8:	e5d33007 	ldrb	r3, [r3, #7]
7000bdbc:	e2033002 	and	r3, r3, #2
7000bdc0:	e3530000 	cmp	r3, #0
7000bdc4:	0a00000d 	beq	7000be00 <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
7000bdc8:	e51b3014 	ldr	r3, [fp, #-20]
7000bdcc:	e5d33007 	ldrb	r3, [r3, #7]
7000bdd0:	e2033001 	and	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
7000bdd4:	e3530000 	cmp	r3, #0
7000bdd8:	0a000008 	beq	7000be00 <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
7000bddc:	e51b3014 	ldr	r3, [fp, #-20]
7000bde0:	e5d33007 	ldrb	r3, [r3, #7]
7000bde4:	e3c33001 	bic	r3, r3, #1
7000bde8:	e6ef2073 	uxtb	r2, r3
7000bdec:	e51b3014 	ldr	r3, [fp, #-20]
7000bdf0:	e5c32007 	strb	r2, [r3, #7]
                rt_timer_start(t);
7000bdf4:	e51b0014 	ldr	r0, [fp, #-20]
7000bdf8:	ebfffe2e 	bl	7000b6b8 <rt_timer_start>
7000bdfc:	ea000007 	b	7000be20 <rt_timer_check+0x108>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
7000be00:	e51b3014 	ldr	r3, [fp, #-20]
7000be04:	e5d33007 	ldrb	r3, [r3, #7]
7000be08:	e3c33001 	bic	r3, r3, #1
7000be0c:	e6ef2073 	uxtb	r2, r3
7000be10:	e51b3014 	ldr	r3, [fp, #-20]
7000be14:	e5c32007 	strb	r2, [r3, #7]
7000be18:	ea000000 	b	7000be20 <rt_timer_check+0x108>
            }
        }
        else
            break;
7000be1c:	ea000005 	b	7000be38 <rt_timer_check+0x120>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
7000be20:	e30908f0 	movw	r0, #39152	; 0x98f0
7000be24:	e3470002 	movt	r0, #28674	; 0x7002
7000be28:	ebfffcfe 	bl	7000b228 <rt_list_isempty>
7000be2c:	e1a03000 	mov	r3, r0
7000be30:	e3530000 	cmp	r3, #0
7000be34:	0affffbf 	beq	7000bd38 <rt_timer_check+0x20>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
7000be38:	e1a00004 	mov	r0, r4
7000be3c:	eb000904 	bl	7000e254 <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
7000be40:	e24bd008 	sub	sp, fp, #8
7000be44:	e8bd8810 	pop	{r4, fp, pc}

7000be48 <rt_timer_next_timeout_tick>:
 * This function will return the next timeout tick in the system.
 *
 * @return the next timeout tick in the system
 */
rt_tick_t rt_timer_next_timeout_tick(void)
{
7000be48:	e92d4800 	push	{fp, lr}
7000be4c:	e28db004 	add	fp, sp, #4
    return rt_timer_list_next_timeout(rt_timer_list);
7000be50:	e30908f0 	movw	r0, #39152	; 0x98f0
7000be54:	e3470002 	movt	r0, #28674	; 0x7002
7000be58:	ebfffd3a 	bl	7000b348 <rt_timer_list_next_timeout>
7000be5c:	e1a03000 	mov	r3, r0
}
7000be60:	e1a00003 	mov	r0, r3
7000be64:	e8bd8800 	pop	{fp, pc}

7000be68 <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
7000be68:	e92d4800 	push	{fp, lr}
7000be6c:	e28db004 	add	fp, sp, #4
7000be70:	e24dd008 	sub	sp, sp, #8
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
7000be74:	e3a03000 	mov	r3, #0
7000be78:	e50b3008 	str	r3, [fp, #-8]
7000be7c:	ea000009 	b	7000bea8 <rt_system_timer_init+0x40>
    {
        rt_list_init(rt_timer_list+i);
7000be80:	e51b3008 	ldr	r3, [fp, #-8]
7000be84:	e1a02183 	lsl	r2, r3, #3
7000be88:	e30938f0 	movw	r3, #39152	; 0x98f0
7000be8c:	e3473002 	movt	r3, #28674	; 0x7002
7000be90:	e0823003 	add	r3, r2, r3
7000be94:	e1a00003 	mov	r0, r3
7000be98:	ebfffca6 	bl	7000b138 <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
7000be9c:	e51b3008 	ldr	r3, [fp, #-8]
7000bea0:	e2833001 	add	r3, r3, #1
7000bea4:	e50b3008 	str	r3, [fp, #-8]
7000bea8:	e51b3008 	ldr	r3, [fp, #-8]
7000beac:	e3530000 	cmp	r3, #0
7000beb0:	0afffff2 	beq	7000be80 <rt_system_timer_init+0x18>
    {
        rt_list_init(rt_timer_list+i);
    }
}
7000beb4:	e24bd004 	sub	sp, fp, #4
7000beb8:	e8bd8800 	pop	{fp, pc}

7000bebc <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
7000bebc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000bec0:	e28db000 	add	fp, sp, #0
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
#endif
}
7000bec4:	e24bd000 	sub	sp, fp, #0
7000bec8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000becc:	e12fff1e 	bx	lr

7000bed0 <rt_hw_cpu_shutdown>:
 */
/*@{*/

/** shutdown CPU */
void rt_hw_cpu_shutdown()
{
7000bed0:	e92d4800 	push	{fp, lr}
7000bed4:	e28db004 	add	fp, sp, #4
7000bed8:	e24dd008 	sub	sp, sp, #8
	rt_uint32_t level;
	rt_kprintf("shutdown...\n");
7000bedc:	e3060eb0 	movw	r0, #28336	; 0x6eb0
7000bee0:	e3470002 	movt	r0, #28674	; 0x7002
7000bee4:	ebffee42 	bl	700077f4 <rt_kprintf>

	level = rt_hw_interrupt_disable();
7000bee8:	eb0008d6 	bl	7000e248 <rt_hw_interrupt_disable>
7000beec:	e1a03000 	mov	r3, r0
7000bef0:	e50b3008 	str	r3, [fp, #-8]
	while (level)
7000bef4:	ea00001d 	b	7000bf70 <rt_hw_cpu_shutdown+0xa0>
	{
		RT_ASSERT(0);
7000bef8:	e3a03000 	mov	r3, #0
7000befc:	e54b3009 	strb	r3, [fp, #-9]
7000bf00:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bf04:	e3473002 	movt	r3, #28674	; 0x7002
7000bf08:	e5933000 	ldr	r3, [r3]
7000bf0c:	e3530000 	cmp	r3, #0
7000bf10:	1a00000d 	bne	7000bf4c <rt_hw_cpu_shutdown+0x7c>
7000bf14:	e3060ec0 	movw	r0, #28352	; 0x6ec0
7000bf18:	e3470002 	movt	r0, #28674	; 0x7002
7000bf1c:	e3061ee0 	movw	r1, #28384	; 0x6ee0
7000bf20:	e3471002 	movt	r1, #28674	; 0x7002
7000bf24:	e3062ee4 	movw	r2, #28388	; 0x6ee4
7000bf28:	e3472002 	movt	r2, #28674	; 0x7002
7000bf2c:	e3a03021 	mov	r3, #33	; 0x21
7000bf30:	ebffee2f 	bl	700077f4 <rt_kprintf>
7000bf34:	e1a00000 	nop			; (mov r0, r0)
7000bf38:	e55b3009 	ldrb	r3, [fp, #-9]
7000bf3c:	e6ef3073 	uxtb	r3, r3
7000bf40:	e3530000 	cmp	r3, #0
7000bf44:	0afffffb 	beq	7000bf38 <rt_hw_cpu_shutdown+0x68>
7000bf48:	ea000008 	b	7000bf70 <rt_hw_cpu_shutdown+0xa0>
7000bf4c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bf50:	e3473002 	movt	r3, #28674	; 0x7002
7000bf54:	e5933000 	ldr	r3, [r3]
7000bf58:	e3060ee0 	movw	r0, #28384	; 0x6ee0
7000bf5c:	e3470002 	movt	r0, #28674	; 0x7002
7000bf60:	e3061ee4 	movw	r1, #28388	; 0x6ee4
7000bf64:	e3471002 	movt	r1, #28674	; 0x7002
7000bf68:	e3a02021 	mov	r2, #33	; 0x21
7000bf6c:	e12fff33 	blx	r3
{
	rt_uint32_t level;
	rt_kprintf("shutdown...\n");

	level = rt_hw_interrupt_disable();
	while (level)
7000bf70:	e51b3008 	ldr	r3, [fp, #-8]
7000bf74:	e3530000 	cmp	r3, #0
7000bf78:	1affffde 	bne	7000bef8 <rt_hw_cpu_shutdown+0x28>
	{
		RT_ASSERT(0);
	}
}
7000bf7c:	e24bd004 	sub	sp, fp, #4
7000bf80:	e8bd8800 	pop	{fp, pc}

7000bf84 <arm_gic_get_active_irq>:
#define GIC_DIST_ICPIDR2(hw_base)           __REG32((hw_base) + 0xfe8)

static unsigned int _gic_max_irq;

int arm_gic_get_active_irq(rt_uint32_t index)
{
7000bf84:	e92d4800 	push	{fp, lr}
7000bf88:	e28db004 	add	fp, sp, #4
7000bf8c:	e24dd010 	sub	sp, sp, #16
7000bf90:	e50b0010 	str	r0, [fp, #-16]
    int irq;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000bf94:	e51b3010 	ldr	r3, [fp, #-16]
7000bf98:	e3530000 	cmp	r3, #0
7000bf9c:	0a00001d 	beq	7000c018 <arm_gic_get_active_irq+0x94>
7000bfa0:	e3a03000 	mov	r3, #0
7000bfa4:	e54b3009 	strb	r3, [fp, #-9]
7000bfa8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bfac:	e3473002 	movt	r3, #28674	; 0x7002
7000bfb0:	e5933000 	ldr	r3, [r3]
7000bfb4:	e3530000 	cmp	r3, #0
7000bfb8:	1a00000d 	bne	7000bff4 <arm_gic_get_active_irq+0x70>
7000bfbc:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000bfc0:	e3470002 	movt	r0, #28674	; 0x7002
7000bfc4:	e3061f18 	movw	r1, #28440	; 0x6f18
7000bfc8:	e3471002 	movt	r1, #28674	; 0x7002
7000bfcc:	e3072050 	movw	r2, #28752	; 0x7050
7000bfd0:	e3472002 	movt	r2, #28674	; 0x7002
7000bfd4:	e3a0303d 	mov	r3, #61	; 0x3d
7000bfd8:	ebffee05 	bl	700077f4 <rt_kprintf>
7000bfdc:	e1a00000 	nop			; (mov r0, r0)
7000bfe0:	e55b3009 	ldrb	r3, [fp, #-9]
7000bfe4:	e6ef3073 	uxtb	r3, r3
7000bfe8:	e3530000 	cmp	r3, #0
7000bfec:	0afffffb 	beq	7000bfe0 <arm_gic_get_active_irq+0x5c>
7000bff0:	ea000008 	b	7000c018 <arm_gic_get_active_irq+0x94>
7000bff4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000bff8:	e3473002 	movt	r3, #28674	; 0x7002
7000bffc:	e5933000 	ldr	r3, [r3]
7000c000:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c004:	e3470002 	movt	r0, #28674	; 0x7002
7000c008:	e3071050 	movw	r1, #28752	; 0x7050
7000c00c:	e3471002 	movt	r1, #28674	; 0x7002
7000c010:	e3a0203d 	mov	r2, #61	; 0x3d
7000c014:	e12fff33 	blx	r3

    irq = GIC_CPU_INTACK(_gic_table[index].cpu_hw_base);
7000c018:	e3092900 	movw	r2, #39168	; 0x9900
7000c01c:	e3472002 	movt	r2, #28674	; 0x7002
7000c020:	e51b1010 	ldr	r1, [fp, #-16]
7000c024:	e3a00008 	mov	r0, #8
7000c028:	e1a03001 	mov	r3, r1
7000c02c:	e1a03083 	lsl	r3, r3, #1
7000c030:	e0833001 	add	r3, r3, r1
7000c034:	e1a03103 	lsl	r3, r3, #2
7000c038:	e0823003 	add	r3, r2, r3
7000c03c:	e0833000 	add	r3, r3, r0
7000c040:	e5933000 	ldr	r3, [r3]
7000c044:	e283300c 	add	r3, r3, #12
7000c048:	e5933000 	ldr	r3, [r3]
7000c04c:	e50b3008 	str	r3, [fp, #-8]
    irq += _gic_table[index].offset;
7000c050:	e3092900 	movw	r2, #39168	; 0x9900
7000c054:	e3472002 	movt	r2, #28674	; 0x7002
7000c058:	e51b1010 	ldr	r1, [fp, #-16]
7000c05c:	e1a03001 	mov	r3, r1
7000c060:	e1a03083 	lsl	r3, r3, #1
7000c064:	e0833001 	add	r3, r3, r1
7000c068:	e1a03103 	lsl	r3, r3, #2
7000c06c:	e0823003 	add	r3, r2, r3
7000c070:	e5932000 	ldr	r2, [r3]
7000c074:	e51b3008 	ldr	r3, [fp, #-8]
7000c078:	e0823003 	add	r3, r2, r3
7000c07c:	e50b3008 	str	r3, [fp, #-8]
    return irq;
7000c080:	e51b3008 	ldr	r3, [fp, #-8]
}
7000c084:	e1a00003 	mov	r0, r3
7000c088:	e24bd004 	sub	sp, fp, #4
7000c08c:	e8bd8800 	pop	{fp, pc}

7000c090 <arm_gic_ack>:

void arm_gic_ack(rt_uint32_t index, int irq)
{
7000c090:	e92d4800 	push	{fp, lr}
7000c094:	e28db004 	add	fp, sp, #4
7000c098:	e24dd010 	sub	sp, sp, #16
7000c09c:	e50b0010 	str	r0, [fp, #-16]
7000c0a0:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
7000c0a4:	e51b2014 	ldr	r2, [fp, #-20]
7000c0a8:	e1a03fc2 	asr	r3, r2, #31
7000c0ac:	e1a03da3 	lsr	r3, r3, #27
7000c0b0:	e0822003 	add	r2, r2, r3
7000c0b4:	e202201f 	and	r2, r2, #31
7000c0b8:	e0633002 	rsb	r3, r3, r2
7000c0bc:	e3a02001 	mov	r2, #1
7000c0c0:	e1a03312 	lsl	r3, r2, r3
7000c0c4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000c0c8:	e51b3010 	ldr	r3, [fp, #-16]
7000c0cc:	e3530000 	cmp	r3, #0
7000c0d0:	0a00001d 	beq	7000c14c <arm_gic_ack+0xbc>
7000c0d4:	e3a03000 	mov	r3, #0
7000c0d8:	e54b3009 	strb	r3, [fp, #-9]
7000c0dc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c0e0:	e3473002 	movt	r3, #28674	; 0x7002
7000c0e4:	e5933000 	ldr	r3, [r3]
7000c0e8:	e3530000 	cmp	r3, #0
7000c0ec:	1a00000d 	bne	7000c128 <arm_gic_ack+0x98>
7000c0f0:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c0f4:	e3470002 	movt	r0, #28674	; 0x7002
7000c0f8:	e3061f18 	movw	r1, #28440	; 0x6f18
7000c0fc:	e3471002 	movt	r1, #28674	; 0x7002
7000c100:	e3072068 	movw	r2, #28776	; 0x7068
7000c104:	e3472002 	movt	r2, #28674	; 0x7002
7000c108:	e3a03048 	mov	r3, #72	; 0x48
7000c10c:	ebffedb8 	bl	700077f4 <rt_kprintf>
7000c110:	e1a00000 	nop			; (mov r0, r0)
7000c114:	e55b3009 	ldrb	r3, [fp, #-9]
7000c118:	e6ef3073 	uxtb	r3, r3
7000c11c:	e3530000 	cmp	r3, #0
7000c120:	0afffffb 	beq	7000c114 <arm_gic_ack+0x84>
7000c124:	ea000008 	b	7000c14c <arm_gic_ack+0xbc>
7000c128:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c12c:	e3473002 	movt	r3, #28674	; 0x7002
7000c130:	e5933000 	ldr	r3, [r3]
7000c134:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c138:	e3470002 	movt	r0, #28674	; 0x7002
7000c13c:	e3071068 	movw	r1, #28776	; 0x7068
7000c140:	e3471002 	movt	r1, #28674	; 0x7002
7000c144:	e3a02048 	mov	r2, #72	; 0x48
7000c148:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000c14c:	e51b0014 	ldr	r0, [fp, #-20]
7000c150:	e3092900 	movw	r2, #39168	; 0x9900
7000c154:	e3472002 	movt	r2, #28674	; 0x7002
7000c158:	e51b1010 	ldr	r1, [fp, #-16]
7000c15c:	e1a03001 	mov	r3, r1
7000c160:	e1a03083 	lsl	r3, r3, #1
7000c164:	e0833001 	add	r3, r3, r1
7000c168:	e1a03103 	lsl	r3, r3, #2
7000c16c:	e0823003 	add	r3, r2, r3
7000c170:	e5933000 	ldr	r3, [r3]
7000c174:	e0633000 	rsb	r3, r3, r0
7000c178:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000c17c:	e51b3014 	ldr	r3, [fp, #-20]
7000c180:	e3530000 	cmp	r3, #0
7000c184:	aa00001d 	bge	7000c200 <arm_gic_ack+0x170>
7000c188:	e3a03000 	mov	r3, #0
7000c18c:	e54b300a 	strb	r3, [fp, #-10]
7000c190:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c194:	e3473002 	movt	r3, #28674	; 0x7002
7000c198:	e5933000 	ldr	r3, [r3]
7000c19c:	e3530000 	cmp	r3, #0
7000c1a0:	1a00000d 	bne	7000c1dc <arm_gic_ack+0x14c>
7000c1a4:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c1a8:	e3470002 	movt	r0, #28674	; 0x7002
7000c1ac:	e3061f30 	movw	r1, #28464	; 0x6f30
7000c1b0:	e3471002 	movt	r1, #28674	; 0x7002
7000c1b4:	e3072068 	movw	r2, #28776	; 0x7068
7000c1b8:	e3472002 	movt	r2, #28674	; 0x7002
7000c1bc:	e3a0304b 	mov	r3, #75	; 0x4b
7000c1c0:	ebffed8b 	bl	700077f4 <rt_kprintf>
7000c1c4:	e1a00000 	nop			; (mov r0, r0)
7000c1c8:	e55b300a 	ldrb	r3, [fp, #-10]
7000c1cc:	e6ef3073 	uxtb	r3, r3
7000c1d0:	e3530000 	cmp	r3, #0
7000c1d4:	0afffffb 	beq	7000c1c8 <arm_gic_ack+0x138>
7000c1d8:	ea000008 	b	7000c200 <arm_gic_ack+0x170>
7000c1dc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c1e0:	e3473002 	movt	r3, #28674	; 0x7002
7000c1e4:	e5933000 	ldr	r3, [r3]
7000c1e8:	e3060f30 	movw	r0, #28464	; 0x6f30
7000c1ec:	e3470002 	movt	r0, #28674	; 0x7002
7000c1f0:	e3071068 	movw	r1, #28776	; 0x7068
7000c1f4:	e3471002 	movt	r1, #28674	; 0x7002
7000c1f8:	e3a0204b 	mov	r2, #75	; 0x4b
7000c1fc:	e12fff33 	blx	r3

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
7000c200:	e3092900 	movw	r2, #39168	; 0x9900
7000c204:	e3472002 	movt	r2, #28674	; 0x7002
7000c208:	e51b1010 	ldr	r1, [fp, #-16]
7000c20c:	e3a00004 	mov	r0, #4
7000c210:	e1a03001 	mov	r3, r1
7000c214:	e1a03083 	lsl	r3, r3, #1
7000c218:	e0833001 	add	r3, r3, r1
7000c21c:	e1a03103 	lsl	r3, r3, #2
7000c220:	e0823003 	add	r3, r2, r3
7000c224:	e0833000 	add	r3, r3, r0
7000c228:	e5932000 	ldr	r2, [r3]
7000c22c:	e51b3014 	ldr	r3, [fp, #-20]
7000c230:	e283101f 	add	r1, r3, #31
7000c234:	e3530000 	cmp	r3, #0
7000c238:	b1a03001 	movlt	r3, r1
7000c23c:	e1a032c3 	asr	r3, r3, #5
7000c240:	e1a03103 	lsl	r3, r3, #2
7000c244:	e0823003 	add	r3, r2, r3
7000c248:	e2833d06 	add	r3, r3, #384	; 0x180
7000c24c:	e51b2008 	ldr	r2, [fp, #-8]
7000c250:	e5832000 	str	r2, [r3]
    GIC_CPU_EOI(_gic_table[index].cpu_hw_base) = irq;
7000c254:	e3092900 	movw	r2, #39168	; 0x9900
7000c258:	e3472002 	movt	r2, #28674	; 0x7002
7000c25c:	e51b1010 	ldr	r1, [fp, #-16]
7000c260:	e3a00008 	mov	r0, #8
7000c264:	e1a03001 	mov	r3, r1
7000c268:	e1a03083 	lsl	r3, r3, #1
7000c26c:	e0833001 	add	r3, r3, r1
7000c270:	e1a03103 	lsl	r3, r3, #2
7000c274:	e0823003 	add	r3, r2, r3
7000c278:	e0833000 	add	r3, r3, r0
7000c27c:	e5933000 	ldr	r3, [r3]
7000c280:	e2833010 	add	r3, r3, #16
7000c284:	e51b2014 	ldr	r2, [fp, #-20]
7000c288:	e5832000 	str	r2, [r3]
    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
7000c28c:	e3092900 	movw	r2, #39168	; 0x9900
7000c290:	e3472002 	movt	r2, #28674	; 0x7002
7000c294:	e51b1010 	ldr	r1, [fp, #-16]
7000c298:	e3a00004 	mov	r0, #4
7000c29c:	e1a03001 	mov	r3, r1
7000c2a0:	e1a03083 	lsl	r3, r3, #1
7000c2a4:	e0833001 	add	r3, r3, r1
7000c2a8:	e1a03103 	lsl	r3, r3, #2
7000c2ac:	e0823003 	add	r3, r2, r3
7000c2b0:	e0833000 	add	r3, r3, r0
7000c2b4:	e5932000 	ldr	r2, [r3]
7000c2b8:	e51b3014 	ldr	r3, [fp, #-20]
7000c2bc:	e283101f 	add	r1, r3, #31
7000c2c0:	e3530000 	cmp	r3, #0
7000c2c4:	b1a03001 	movlt	r3, r1
7000c2c8:	e1a032c3 	asr	r3, r3, #5
7000c2cc:	e1a03103 	lsl	r3, r3, #2
7000c2d0:	e0823003 	add	r3, r2, r3
7000c2d4:	e2833c01 	add	r3, r3, #256	; 0x100
7000c2d8:	e51b2008 	ldr	r2, [fp, #-8]
7000c2dc:	e5832000 	str	r2, [r3]
}
7000c2e0:	e24bd004 	sub	sp, fp, #4
7000c2e4:	e8bd8800 	pop	{fp, pc}

7000c2e8 <arm_gic_mask>:

void arm_gic_mask(rt_uint32_t index, int irq)
{
7000c2e8:	e92d4800 	push	{fp, lr}
7000c2ec:	e28db004 	add	fp, sp, #4
7000c2f0:	e24dd010 	sub	sp, sp, #16
7000c2f4:	e50b0010 	str	r0, [fp, #-16]
7000c2f8:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
7000c2fc:	e51b2014 	ldr	r2, [fp, #-20]
7000c300:	e1a03fc2 	asr	r3, r2, #31
7000c304:	e1a03da3 	lsr	r3, r3, #27
7000c308:	e0822003 	add	r2, r2, r3
7000c30c:	e202201f 	and	r2, r2, #31
7000c310:	e0633002 	rsb	r3, r3, r2
7000c314:	e3a02001 	mov	r2, #1
7000c318:	e1a03312 	lsl	r3, r2, r3
7000c31c:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000c320:	e51b3010 	ldr	r3, [fp, #-16]
7000c324:	e3530000 	cmp	r3, #0
7000c328:	0a00001d 	beq	7000c3a4 <arm_gic_mask+0xbc>
7000c32c:	e3a03000 	mov	r3, #0
7000c330:	e54b3009 	strb	r3, [fp, #-9]
7000c334:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c338:	e3473002 	movt	r3, #28674	; 0x7002
7000c33c:	e5933000 	ldr	r3, [r3]
7000c340:	e3530000 	cmp	r3, #0
7000c344:	1a00000d 	bne	7000c380 <arm_gic_mask+0x98>
7000c348:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c34c:	e3470002 	movt	r0, #28674	; 0x7002
7000c350:	e3061f18 	movw	r1, #28440	; 0x6f18
7000c354:	e3471002 	movt	r1, #28674	; 0x7002
7000c358:	e3072074 	movw	r2, #28788	; 0x7074
7000c35c:	e3472002 	movt	r2, #28674	; 0x7002
7000c360:	e3a03056 	mov	r3, #86	; 0x56
7000c364:	ebffed22 	bl	700077f4 <rt_kprintf>
7000c368:	e1a00000 	nop			; (mov r0, r0)
7000c36c:	e55b3009 	ldrb	r3, [fp, #-9]
7000c370:	e6ef3073 	uxtb	r3, r3
7000c374:	e3530000 	cmp	r3, #0
7000c378:	0afffffb 	beq	7000c36c <arm_gic_mask+0x84>
7000c37c:	ea000008 	b	7000c3a4 <arm_gic_mask+0xbc>
7000c380:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c384:	e3473002 	movt	r3, #28674	; 0x7002
7000c388:	e5933000 	ldr	r3, [r3]
7000c38c:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c390:	e3470002 	movt	r0, #28674	; 0x7002
7000c394:	e3071074 	movw	r1, #28788	; 0x7074
7000c398:	e3471002 	movt	r1, #28674	; 0x7002
7000c39c:	e3a02056 	mov	r2, #86	; 0x56
7000c3a0:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000c3a4:	e51b0014 	ldr	r0, [fp, #-20]
7000c3a8:	e3092900 	movw	r2, #39168	; 0x9900
7000c3ac:	e3472002 	movt	r2, #28674	; 0x7002
7000c3b0:	e51b1010 	ldr	r1, [fp, #-16]
7000c3b4:	e1a03001 	mov	r3, r1
7000c3b8:	e1a03083 	lsl	r3, r3, #1
7000c3bc:	e0833001 	add	r3, r3, r1
7000c3c0:	e1a03103 	lsl	r3, r3, #2
7000c3c4:	e0823003 	add	r3, r2, r3
7000c3c8:	e5933000 	ldr	r3, [r3]
7000c3cc:	e0633000 	rsb	r3, r3, r0
7000c3d0:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000c3d4:	e51b3014 	ldr	r3, [fp, #-20]
7000c3d8:	e3530000 	cmp	r3, #0
7000c3dc:	aa00001d 	bge	7000c458 <arm_gic_mask+0x170>
7000c3e0:	e3a03000 	mov	r3, #0
7000c3e4:	e54b300a 	strb	r3, [fp, #-10]
7000c3e8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c3ec:	e3473002 	movt	r3, #28674	; 0x7002
7000c3f0:	e5933000 	ldr	r3, [r3]
7000c3f4:	e3530000 	cmp	r3, #0
7000c3f8:	1a00000d 	bne	7000c434 <arm_gic_mask+0x14c>
7000c3fc:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c400:	e3470002 	movt	r0, #28674	; 0x7002
7000c404:	e3061f30 	movw	r1, #28464	; 0x6f30
7000c408:	e3471002 	movt	r1, #28674	; 0x7002
7000c40c:	e3072074 	movw	r2, #28788	; 0x7074
7000c410:	e3472002 	movt	r2, #28674	; 0x7002
7000c414:	e3a03059 	mov	r3, #89	; 0x59
7000c418:	ebffecf5 	bl	700077f4 <rt_kprintf>
7000c41c:	e1a00000 	nop			; (mov r0, r0)
7000c420:	e55b300a 	ldrb	r3, [fp, #-10]
7000c424:	e6ef3073 	uxtb	r3, r3
7000c428:	e3530000 	cmp	r3, #0
7000c42c:	0afffffb 	beq	7000c420 <arm_gic_mask+0x138>
7000c430:	ea000008 	b	7000c458 <arm_gic_mask+0x170>
7000c434:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c438:	e3473002 	movt	r3, #28674	; 0x7002
7000c43c:	e5933000 	ldr	r3, [r3]
7000c440:	e3060f30 	movw	r0, #28464	; 0x6f30
7000c444:	e3470002 	movt	r0, #28674	; 0x7002
7000c448:	e3071074 	movw	r1, #28788	; 0x7074
7000c44c:	e3471002 	movt	r1, #28674	; 0x7002
7000c450:	e3a02059 	mov	r2, #89	; 0x59
7000c454:	e12fff33 	blx	r3

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
7000c458:	e3092900 	movw	r2, #39168	; 0x9900
7000c45c:	e3472002 	movt	r2, #28674	; 0x7002
7000c460:	e51b1010 	ldr	r1, [fp, #-16]
7000c464:	e3a00004 	mov	r0, #4
7000c468:	e1a03001 	mov	r3, r1
7000c46c:	e1a03083 	lsl	r3, r3, #1
7000c470:	e0833001 	add	r3, r3, r1
7000c474:	e1a03103 	lsl	r3, r3, #2
7000c478:	e0823003 	add	r3, r2, r3
7000c47c:	e0833000 	add	r3, r3, r0
7000c480:	e5932000 	ldr	r2, [r3]
7000c484:	e51b3014 	ldr	r3, [fp, #-20]
7000c488:	e283101f 	add	r1, r3, #31
7000c48c:	e3530000 	cmp	r3, #0
7000c490:	b1a03001 	movlt	r3, r1
7000c494:	e1a032c3 	asr	r3, r3, #5
7000c498:	e1a03103 	lsl	r3, r3, #2
7000c49c:	e0823003 	add	r3, r2, r3
7000c4a0:	e2833d06 	add	r3, r3, #384	; 0x180
7000c4a4:	e51b2008 	ldr	r2, [fp, #-8]
7000c4a8:	e5832000 	str	r2, [r3]
}
7000c4ac:	e24bd004 	sub	sp, fp, #4
7000c4b0:	e8bd8800 	pop	{fp, pc}

7000c4b4 <arm_gic_clear_pending>:

void arm_gic_clear_pending(rt_uint32_t index, int irq)
{
7000c4b4:	e92d4800 	push	{fp, lr}
7000c4b8:	e28db004 	add	fp, sp, #4
7000c4bc:	e24dd010 	sub	sp, sp, #16
7000c4c0:	e50b0010 	str	r0, [fp, #-16]
7000c4c4:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
7000c4c8:	e51b2014 	ldr	r2, [fp, #-20]
7000c4cc:	e1a03fc2 	asr	r3, r2, #31
7000c4d0:	e1a03da3 	lsr	r3, r3, #27
7000c4d4:	e0822003 	add	r2, r2, r3
7000c4d8:	e202201f 	and	r2, r2, #31
7000c4dc:	e0633002 	rsb	r3, r3, r2
7000c4e0:	e3a02001 	mov	r2, #1
7000c4e4:	e1a03312 	lsl	r3, r2, r3
7000c4e8:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000c4ec:	e51b3010 	ldr	r3, [fp, #-16]
7000c4f0:	e3530000 	cmp	r3, #0
7000c4f4:	0a00001d 	beq	7000c570 <arm_gic_clear_pending+0xbc>
7000c4f8:	e3a03000 	mov	r3, #0
7000c4fc:	e54b3009 	strb	r3, [fp, #-9]
7000c500:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c504:	e3473002 	movt	r3, #28674	; 0x7002
7000c508:	e5933000 	ldr	r3, [r3]
7000c50c:	e3530000 	cmp	r3, #0
7000c510:	1a00000d 	bne	7000c54c <arm_gic_clear_pending+0x98>
7000c514:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c518:	e3470002 	movt	r0, #28674	; 0x7002
7000c51c:	e3061f18 	movw	r1, #28440	; 0x6f18
7000c520:	e3471002 	movt	r1, #28674	; 0x7002
7000c524:	e3072084 	movw	r2, #28804	; 0x7084
7000c528:	e3472002 	movt	r2, #28674	; 0x7002
7000c52c:	e3a03062 	mov	r3, #98	; 0x62
7000c530:	ebffecaf 	bl	700077f4 <rt_kprintf>
7000c534:	e1a00000 	nop			; (mov r0, r0)
7000c538:	e55b3009 	ldrb	r3, [fp, #-9]
7000c53c:	e6ef3073 	uxtb	r3, r3
7000c540:	e3530000 	cmp	r3, #0
7000c544:	0afffffb 	beq	7000c538 <arm_gic_clear_pending+0x84>
7000c548:	ea000008 	b	7000c570 <arm_gic_clear_pending+0xbc>
7000c54c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c550:	e3473002 	movt	r3, #28674	; 0x7002
7000c554:	e5933000 	ldr	r3, [r3]
7000c558:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c55c:	e3470002 	movt	r0, #28674	; 0x7002
7000c560:	e3071084 	movw	r1, #28804	; 0x7084
7000c564:	e3471002 	movt	r1, #28674	; 0x7002
7000c568:	e3a02062 	mov	r2, #98	; 0x62
7000c56c:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000c570:	e51b0014 	ldr	r0, [fp, #-20]
7000c574:	e3092900 	movw	r2, #39168	; 0x9900
7000c578:	e3472002 	movt	r2, #28674	; 0x7002
7000c57c:	e51b1010 	ldr	r1, [fp, #-16]
7000c580:	e1a03001 	mov	r3, r1
7000c584:	e1a03083 	lsl	r3, r3, #1
7000c588:	e0833001 	add	r3, r3, r1
7000c58c:	e1a03103 	lsl	r3, r3, #2
7000c590:	e0823003 	add	r3, r2, r3
7000c594:	e5933000 	ldr	r3, [r3]
7000c598:	e0633000 	rsb	r3, r3, r0
7000c59c:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000c5a0:	e51b3014 	ldr	r3, [fp, #-20]
7000c5a4:	e3530000 	cmp	r3, #0
7000c5a8:	aa00001d 	bge	7000c624 <arm_gic_clear_pending+0x170>
7000c5ac:	e3a03000 	mov	r3, #0
7000c5b0:	e54b300a 	strb	r3, [fp, #-10]
7000c5b4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c5b8:	e3473002 	movt	r3, #28674	; 0x7002
7000c5bc:	e5933000 	ldr	r3, [r3]
7000c5c0:	e3530000 	cmp	r3, #0
7000c5c4:	1a00000d 	bne	7000c600 <arm_gic_clear_pending+0x14c>
7000c5c8:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c5cc:	e3470002 	movt	r0, #28674	; 0x7002
7000c5d0:	e3061f30 	movw	r1, #28464	; 0x6f30
7000c5d4:	e3471002 	movt	r1, #28674	; 0x7002
7000c5d8:	e3072084 	movw	r2, #28804	; 0x7084
7000c5dc:	e3472002 	movt	r2, #28674	; 0x7002
7000c5e0:	e3a03065 	mov	r3, #101	; 0x65
7000c5e4:	ebffec82 	bl	700077f4 <rt_kprintf>
7000c5e8:	e1a00000 	nop			; (mov r0, r0)
7000c5ec:	e55b300a 	ldrb	r3, [fp, #-10]
7000c5f0:	e6ef3073 	uxtb	r3, r3
7000c5f4:	e3530000 	cmp	r3, #0
7000c5f8:	0afffffb 	beq	7000c5ec <arm_gic_clear_pending+0x138>
7000c5fc:	ea000008 	b	7000c624 <arm_gic_clear_pending+0x170>
7000c600:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c604:	e3473002 	movt	r3, #28674	; 0x7002
7000c608:	e5933000 	ldr	r3, [r3]
7000c60c:	e3060f30 	movw	r0, #28464	; 0x6f30
7000c610:	e3470002 	movt	r0, #28674	; 0x7002
7000c614:	e3071084 	movw	r1, #28804	; 0x7084
7000c618:	e3471002 	movt	r1, #28674	; 0x7002
7000c61c:	e3a02065 	mov	r2, #101	; 0x65
7000c620:	e12fff33 	blx	r3

    GIC_DIST_PENDING_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
7000c624:	e3092900 	movw	r2, #39168	; 0x9900
7000c628:	e3472002 	movt	r2, #28674	; 0x7002
7000c62c:	e51b1010 	ldr	r1, [fp, #-16]
7000c630:	e3a00004 	mov	r0, #4
7000c634:	e1a03001 	mov	r3, r1
7000c638:	e1a03083 	lsl	r3, r3, #1
7000c63c:	e0833001 	add	r3, r3, r1
7000c640:	e1a03103 	lsl	r3, r3, #2
7000c644:	e0823003 	add	r3, r2, r3
7000c648:	e0833000 	add	r3, r3, r0
7000c64c:	e5932000 	ldr	r2, [r3]
7000c650:	e51b3014 	ldr	r3, [fp, #-20]
7000c654:	e283101f 	add	r1, r3, #31
7000c658:	e3530000 	cmp	r3, #0
7000c65c:	b1a03001 	movlt	r3, r1
7000c660:	e1a032c3 	asr	r3, r3, #5
7000c664:	e1a03103 	lsl	r3, r3, #2
7000c668:	e0823003 	add	r3, r2, r3
7000c66c:	e2833d0a 	add	r3, r3, #640	; 0x280
7000c670:	e51b2008 	ldr	r2, [fp, #-8]
7000c674:	e5832000 	str	r2, [r3]
}
7000c678:	e24bd004 	sub	sp, fp, #4
7000c67c:	e8bd8800 	pop	{fp, pc}

7000c680 <arm_gic_clear_active>:

void arm_gic_clear_active(rt_uint32_t index, int irq)
{
7000c680:	e92d4800 	push	{fp, lr}
7000c684:	e28db004 	add	fp, sp, #4
7000c688:	e24dd010 	sub	sp, sp, #16
7000c68c:	e50b0010 	str	r0, [fp, #-16]
7000c690:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
7000c694:	e51b2014 	ldr	r2, [fp, #-20]
7000c698:	e1a03fc2 	asr	r3, r2, #31
7000c69c:	e1a03da3 	lsr	r3, r3, #27
7000c6a0:	e0822003 	add	r2, r2, r3
7000c6a4:	e202201f 	and	r2, r2, #31
7000c6a8:	e0633002 	rsb	r3, r3, r2
7000c6ac:	e3a02001 	mov	r2, #1
7000c6b0:	e1a03312 	lsl	r3, r2, r3
7000c6b4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000c6b8:	e51b3010 	ldr	r3, [fp, #-16]
7000c6bc:	e3530000 	cmp	r3, #0
7000c6c0:	0a00001d 	beq	7000c73c <arm_gic_clear_active+0xbc>
7000c6c4:	e3a03000 	mov	r3, #0
7000c6c8:	e54b3009 	strb	r3, [fp, #-9]
7000c6cc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c6d0:	e3473002 	movt	r3, #28674	; 0x7002
7000c6d4:	e5933000 	ldr	r3, [r3]
7000c6d8:	e3530000 	cmp	r3, #0
7000c6dc:	1a00000d 	bne	7000c718 <arm_gic_clear_active+0x98>
7000c6e0:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c6e4:	e3470002 	movt	r0, #28674	; 0x7002
7000c6e8:	e3061f18 	movw	r1, #28440	; 0x6f18
7000c6ec:	e3471002 	movt	r1, #28674	; 0x7002
7000c6f0:	e307209c 	movw	r2, #28828	; 0x709c
7000c6f4:	e3472002 	movt	r2, #28674	; 0x7002
7000c6f8:	e3a0306e 	mov	r3, #110	; 0x6e
7000c6fc:	ebffec3c 	bl	700077f4 <rt_kprintf>
7000c700:	e1a00000 	nop			; (mov r0, r0)
7000c704:	e55b3009 	ldrb	r3, [fp, #-9]
7000c708:	e6ef3073 	uxtb	r3, r3
7000c70c:	e3530000 	cmp	r3, #0
7000c710:	0afffffb 	beq	7000c704 <arm_gic_clear_active+0x84>
7000c714:	ea000008 	b	7000c73c <arm_gic_clear_active+0xbc>
7000c718:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c71c:	e3473002 	movt	r3, #28674	; 0x7002
7000c720:	e5933000 	ldr	r3, [r3]
7000c724:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c728:	e3470002 	movt	r0, #28674	; 0x7002
7000c72c:	e307109c 	movw	r1, #28828	; 0x709c
7000c730:	e3471002 	movt	r1, #28674	; 0x7002
7000c734:	e3a0206e 	mov	r2, #110	; 0x6e
7000c738:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000c73c:	e51b0014 	ldr	r0, [fp, #-20]
7000c740:	e3092900 	movw	r2, #39168	; 0x9900
7000c744:	e3472002 	movt	r2, #28674	; 0x7002
7000c748:	e51b1010 	ldr	r1, [fp, #-16]
7000c74c:	e1a03001 	mov	r3, r1
7000c750:	e1a03083 	lsl	r3, r3, #1
7000c754:	e0833001 	add	r3, r3, r1
7000c758:	e1a03103 	lsl	r3, r3, #2
7000c75c:	e0823003 	add	r3, r2, r3
7000c760:	e5933000 	ldr	r3, [r3]
7000c764:	e0633000 	rsb	r3, r3, r0
7000c768:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000c76c:	e51b3014 	ldr	r3, [fp, #-20]
7000c770:	e3530000 	cmp	r3, #0
7000c774:	aa00001d 	bge	7000c7f0 <arm_gic_clear_active+0x170>
7000c778:	e3a03000 	mov	r3, #0
7000c77c:	e54b300a 	strb	r3, [fp, #-10]
7000c780:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c784:	e3473002 	movt	r3, #28674	; 0x7002
7000c788:	e5933000 	ldr	r3, [r3]
7000c78c:	e3530000 	cmp	r3, #0
7000c790:	1a00000d 	bne	7000c7cc <arm_gic_clear_active+0x14c>
7000c794:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c798:	e3470002 	movt	r0, #28674	; 0x7002
7000c79c:	e3061f30 	movw	r1, #28464	; 0x6f30
7000c7a0:	e3471002 	movt	r1, #28674	; 0x7002
7000c7a4:	e307209c 	movw	r2, #28828	; 0x709c
7000c7a8:	e3472002 	movt	r2, #28674	; 0x7002
7000c7ac:	e3a03071 	mov	r3, #113	; 0x71
7000c7b0:	ebffec0f 	bl	700077f4 <rt_kprintf>
7000c7b4:	e1a00000 	nop			; (mov r0, r0)
7000c7b8:	e55b300a 	ldrb	r3, [fp, #-10]
7000c7bc:	e6ef3073 	uxtb	r3, r3
7000c7c0:	e3530000 	cmp	r3, #0
7000c7c4:	0afffffb 	beq	7000c7b8 <arm_gic_clear_active+0x138>
7000c7c8:	ea000008 	b	7000c7f0 <arm_gic_clear_active+0x170>
7000c7cc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c7d0:	e3473002 	movt	r3, #28674	; 0x7002
7000c7d4:	e5933000 	ldr	r3, [r3]
7000c7d8:	e3060f30 	movw	r0, #28464	; 0x6f30
7000c7dc:	e3470002 	movt	r0, #28674	; 0x7002
7000c7e0:	e307109c 	movw	r1, #28828	; 0x709c
7000c7e4:	e3471002 	movt	r1, #28674	; 0x7002
7000c7e8:	e3a02071 	mov	r2, #113	; 0x71
7000c7ec:	e12fff33 	blx	r3

    GIC_DIST_ACTIVE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
7000c7f0:	e3092900 	movw	r2, #39168	; 0x9900
7000c7f4:	e3472002 	movt	r2, #28674	; 0x7002
7000c7f8:	e51b1010 	ldr	r1, [fp, #-16]
7000c7fc:	e3a00004 	mov	r0, #4
7000c800:	e1a03001 	mov	r3, r1
7000c804:	e1a03083 	lsl	r3, r3, #1
7000c808:	e0833001 	add	r3, r3, r1
7000c80c:	e1a03103 	lsl	r3, r3, #2
7000c810:	e0823003 	add	r3, r2, r3
7000c814:	e0833000 	add	r3, r3, r0
7000c818:	e5932000 	ldr	r2, [r3]
7000c81c:	e51b3014 	ldr	r3, [fp, #-20]
7000c820:	e283101f 	add	r1, r3, #31
7000c824:	e3530000 	cmp	r3, #0
7000c828:	b1a03001 	movlt	r3, r1
7000c82c:	e1a032c3 	asr	r3, r3, #5
7000c830:	e1a03103 	lsl	r3, r3, #2
7000c834:	e0823003 	add	r3, r2, r3
7000c838:	e2833d0e 	add	r3, r3, #896	; 0x380
7000c83c:	e51b2008 	ldr	r2, [fp, #-8]
7000c840:	e5832000 	str	r2, [r3]
}
7000c844:	e24bd004 	sub	sp, fp, #4
7000c848:	e8bd8800 	pop	{fp, pc}

7000c84c <arm_gic_set_cpu>:

void arm_gic_set_cpu(rt_uint32_t index, int irq, unsigned int cpumask)
{
7000c84c:	e92d4800 	push	{fp, lr}
7000c850:	e28db004 	add	fp, sp, #4
7000c854:	e24dd018 	sub	sp, sp, #24
7000c858:	e50b0010 	str	r0, [fp, #-16]
7000c85c:	e50b1014 	str	r1, [fp, #-20]
7000c860:	e50b2018 	str	r2, [fp, #-24]
    rt_uint32_t old_tgt;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000c864:	e51b3010 	ldr	r3, [fp, #-16]
7000c868:	e3530000 	cmp	r3, #0
7000c86c:	0a00001d 	beq	7000c8e8 <arm_gic_set_cpu+0x9c>
7000c870:	e3a03000 	mov	r3, #0
7000c874:	e54b3009 	strb	r3, [fp, #-9]
7000c878:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c87c:	e3473002 	movt	r3, #28674	; 0x7002
7000c880:	e5933000 	ldr	r3, [r3]
7000c884:	e3530000 	cmp	r3, #0
7000c888:	1a00000d 	bne	7000c8c4 <arm_gic_set_cpu+0x78>
7000c88c:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c890:	e3470002 	movt	r0, #28674	; 0x7002
7000c894:	e3061f18 	movw	r1, #28440	; 0x6f18
7000c898:	e3471002 	movt	r1, #28674	; 0x7002
7000c89c:	e30720b4 	movw	r2, #28852	; 0x70b4
7000c8a0:	e3472002 	movt	r2, #28674	; 0x7002
7000c8a4:	e3a0307a 	mov	r3, #122	; 0x7a
7000c8a8:	ebffebd1 	bl	700077f4 <rt_kprintf>
7000c8ac:	e1a00000 	nop			; (mov r0, r0)
7000c8b0:	e55b3009 	ldrb	r3, [fp, #-9]
7000c8b4:	e6ef3073 	uxtb	r3, r3
7000c8b8:	e3530000 	cmp	r3, #0
7000c8bc:	0afffffb 	beq	7000c8b0 <arm_gic_set_cpu+0x64>
7000c8c0:	ea000008 	b	7000c8e8 <arm_gic_set_cpu+0x9c>
7000c8c4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c8c8:	e3473002 	movt	r3, #28674	; 0x7002
7000c8cc:	e5933000 	ldr	r3, [r3]
7000c8d0:	e3060f18 	movw	r0, #28440	; 0x6f18
7000c8d4:	e3470002 	movt	r0, #28674	; 0x7002
7000c8d8:	e30710b4 	movw	r1, #28852	; 0x70b4
7000c8dc:	e3471002 	movt	r1, #28674	; 0x7002
7000c8e0:	e3a0207a 	mov	r2, #122	; 0x7a
7000c8e4:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000c8e8:	e51b0014 	ldr	r0, [fp, #-20]
7000c8ec:	e3092900 	movw	r2, #39168	; 0x9900
7000c8f0:	e3472002 	movt	r2, #28674	; 0x7002
7000c8f4:	e51b1010 	ldr	r1, [fp, #-16]
7000c8f8:	e1a03001 	mov	r3, r1
7000c8fc:	e1a03083 	lsl	r3, r3, #1
7000c900:	e0833001 	add	r3, r3, r1
7000c904:	e1a03103 	lsl	r3, r3, #2
7000c908:	e0823003 	add	r3, r2, r3
7000c90c:	e5933000 	ldr	r3, [r3]
7000c910:	e0633000 	rsb	r3, r3, r0
7000c914:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000c918:	e51b3014 	ldr	r3, [fp, #-20]
7000c91c:	e3530000 	cmp	r3, #0
7000c920:	aa00001d 	bge	7000c99c <arm_gic_set_cpu+0x150>
7000c924:	e3a03000 	mov	r3, #0
7000c928:	e54b300a 	strb	r3, [fp, #-10]
7000c92c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c930:	e3473002 	movt	r3, #28674	; 0x7002
7000c934:	e5933000 	ldr	r3, [r3]
7000c938:	e3530000 	cmp	r3, #0
7000c93c:	1a00000d 	bne	7000c978 <arm_gic_set_cpu+0x12c>
7000c940:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000c944:	e3470002 	movt	r0, #28674	; 0x7002
7000c948:	e3061f30 	movw	r1, #28464	; 0x6f30
7000c94c:	e3471002 	movt	r1, #28674	; 0x7002
7000c950:	e30720b4 	movw	r2, #28852	; 0x70b4
7000c954:	e3472002 	movt	r2, #28674	; 0x7002
7000c958:	e3a0307d 	mov	r3, #125	; 0x7d
7000c95c:	ebffeba4 	bl	700077f4 <rt_kprintf>
7000c960:	e1a00000 	nop			; (mov r0, r0)
7000c964:	e55b300a 	ldrb	r3, [fp, #-10]
7000c968:	e6ef3073 	uxtb	r3, r3
7000c96c:	e3530000 	cmp	r3, #0
7000c970:	0afffffb 	beq	7000c964 <arm_gic_set_cpu+0x118>
7000c974:	ea000008 	b	7000c99c <arm_gic_set_cpu+0x150>
7000c978:	e30a3b74 	movw	r3, #43892	; 0xab74
7000c97c:	e3473002 	movt	r3, #28674	; 0x7002
7000c980:	e5933000 	ldr	r3, [r3]
7000c984:	e3060f30 	movw	r0, #28464	; 0x6f30
7000c988:	e3470002 	movt	r0, #28674	; 0x7002
7000c98c:	e30710b4 	movw	r1, #28852	; 0x70b4
7000c990:	e3471002 	movt	r1, #28674	; 0x7002
7000c994:	e3a0207d 	mov	r2, #125	; 0x7d
7000c998:	e12fff33 	blx	r3

    old_tgt = GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq);
7000c99c:	e3092900 	movw	r2, #39168	; 0x9900
7000c9a0:	e3472002 	movt	r2, #28674	; 0x7002
7000c9a4:	e51b1010 	ldr	r1, [fp, #-16]
7000c9a8:	e3a00004 	mov	r0, #4
7000c9ac:	e1a03001 	mov	r3, r1
7000c9b0:	e1a03083 	lsl	r3, r3, #1
7000c9b4:	e0833001 	add	r3, r3, r1
7000c9b8:	e1a03103 	lsl	r3, r3, #2
7000c9bc:	e0823003 	add	r3, r2, r3
7000c9c0:	e0833000 	add	r3, r3, r0
7000c9c4:	e5932000 	ldr	r2, [r3]
7000c9c8:	e51b3014 	ldr	r3, [fp, #-20]
7000c9cc:	e2831003 	add	r1, r3, #3
7000c9d0:	e3530000 	cmp	r3, #0
7000c9d4:	b1a03001 	movlt	r3, r1
7000c9d8:	e1a03143 	asr	r3, r3, #2
7000c9dc:	e1a03103 	lsl	r3, r3, #2
7000c9e0:	e0823003 	add	r3, r2, r3
7000c9e4:	e2833b02 	add	r3, r3, #2048	; 0x800
7000c9e8:	e5933000 	ldr	r3, [r3]
7000c9ec:	e50b3008 	str	r3, [fp, #-8]

    old_tgt &= ~(0x0FFUL << ((irq % 4)*8));
7000c9f0:	e51b2014 	ldr	r2, [fp, #-20]
7000c9f4:	e1a03fc2 	asr	r3, r2, #31
7000c9f8:	e1a03f23 	lsr	r3, r3, #30
7000c9fc:	e0822003 	add	r2, r2, r3
7000ca00:	e2022003 	and	r2, r2, #3
7000ca04:	e0633002 	rsb	r3, r3, r2
7000ca08:	e1a03183 	lsl	r3, r3, #3
7000ca0c:	e3a020ff 	mov	r2, #255	; 0xff
7000ca10:	e1a03312 	lsl	r3, r2, r3
7000ca14:	e1e03003 	mvn	r3, r3
7000ca18:	e51b2008 	ldr	r2, [fp, #-8]
7000ca1c:	e0023003 	and	r3, r2, r3
7000ca20:	e50b3008 	str	r3, [fp, #-8]
    old_tgt |=   cpumask << ((irq % 4)*8);
7000ca24:	e51b2014 	ldr	r2, [fp, #-20]
7000ca28:	e1a03fc2 	asr	r3, r2, #31
7000ca2c:	e1a03f23 	lsr	r3, r3, #30
7000ca30:	e0822003 	add	r2, r2, r3
7000ca34:	e2022003 	and	r2, r2, #3
7000ca38:	e0633002 	rsb	r3, r3, r2
7000ca3c:	e1a03183 	lsl	r3, r3, #3
7000ca40:	e51b2018 	ldr	r2, [fp, #-24]
7000ca44:	e1a03312 	lsl	r3, r2, r3
7000ca48:	e51b2008 	ldr	r2, [fp, #-8]
7000ca4c:	e1823003 	orr	r3, r2, r3
7000ca50:	e50b3008 	str	r3, [fp, #-8]

    GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq) = old_tgt;
7000ca54:	e3092900 	movw	r2, #39168	; 0x9900
7000ca58:	e3472002 	movt	r2, #28674	; 0x7002
7000ca5c:	e51b1010 	ldr	r1, [fp, #-16]
7000ca60:	e3a00004 	mov	r0, #4
7000ca64:	e1a03001 	mov	r3, r1
7000ca68:	e1a03083 	lsl	r3, r3, #1
7000ca6c:	e0833001 	add	r3, r3, r1
7000ca70:	e1a03103 	lsl	r3, r3, #2
7000ca74:	e0823003 	add	r3, r2, r3
7000ca78:	e0833000 	add	r3, r3, r0
7000ca7c:	e5932000 	ldr	r2, [r3]
7000ca80:	e51b3014 	ldr	r3, [fp, #-20]
7000ca84:	e2831003 	add	r1, r3, #3
7000ca88:	e3530000 	cmp	r3, #0
7000ca8c:	b1a03001 	movlt	r3, r1
7000ca90:	e1a03143 	asr	r3, r3, #2
7000ca94:	e1a03103 	lsl	r3, r3, #2
7000ca98:	e0823003 	add	r3, r2, r3
7000ca9c:	e2833b02 	add	r3, r3, #2048	; 0x800
7000caa0:	e51b2008 	ldr	r2, [fp, #-8]
7000caa4:	e5832000 	str	r2, [r3]
}
7000caa8:	e24bd004 	sub	sp, fp, #4
7000caac:	e8bd8800 	pop	{fp, pc}

7000cab0 <arm_gic_umask>:

void arm_gic_umask(rt_uint32_t index, int irq)
{
7000cab0:	e92d4800 	push	{fp, lr}
7000cab4:	e28db004 	add	fp, sp, #4
7000cab8:	e24dd010 	sub	sp, sp, #16
7000cabc:	e50b0010 	str	r0, [fp, #-16]
7000cac0:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
7000cac4:	e51b2014 	ldr	r2, [fp, #-20]
7000cac8:	e1a03fc2 	asr	r3, r2, #31
7000cacc:	e1a03da3 	lsr	r3, r3, #27
7000cad0:	e0822003 	add	r2, r2, r3
7000cad4:	e202201f 	and	r2, r2, #31
7000cad8:	e0633002 	rsb	r3, r3, r2
7000cadc:	e3a02001 	mov	r2, #1
7000cae0:	e1a03312 	lsl	r3, r2, r3
7000cae4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000cae8:	e51b3010 	ldr	r3, [fp, #-16]
7000caec:	e3530000 	cmp	r3, #0
7000caf0:	0a00001d 	beq	7000cb6c <arm_gic_umask+0xbc>
7000caf4:	e3a03000 	mov	r3, #0
7000caf8:	e54b3009 	strb	r3, [fp, #-9]
7000cafc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000cb00:	e3473002 	movt	r3, #28674	; 0x7002
7000cb04:	e5933000 	ldr	r3, [r3]
7000cb08:	e3530000 	cmp	r3, #0
7000cb0c:	1a00000d 	bne	7000cb48 <arm_gic_umask+0x98>
7000cb10:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000cb14:	e3470002 	movt	r0, #28674	; 0x7002
7000cb18:	e3061f18 	movw	r1, #28440	; 0x6f18
7000cb1c:	e3471002 	movt	r1, #28674	; 0x7002
7000cb20:	e30720c4 	movw	r2, #28868	; 0x70c4
7000cb24:	e3472002 	movt	r2, #28674	; 0x7002
7000cb28:	e3a0308b 	mov	r3, #139	; 0x8b
7000cb2c:	ebffeb30 	bl	700077f4 <rt_kprintf>
7000cb30:	e1a00000 	nop			; (mov r0, r0)
7000cb34:	e55b3009 	ldrb	r3, [fp, #-9]
7000cb38:	e6ef3073 	uxtb	r3, r3
7000cb3c:	e3530000 	cmp	r3, #0
7000cb40:	0afffffb 	beq	7000cb34 <arm_gic_umask+0x84>
7000cb44:	ea000008 	b	7000cb6c <arm_gic_umask+0xbc>
7000cb48:	e30a3b74 	movw	r3, #43892	; 0xab74
7000cb4c:	e3473002 	movt	r3, #28674	; 0x7002
7000cb50:	e5933000 	ldr	r3, [r3]
7000cb54:	e3060f18 	movw	r0, #28440	; 0x6f18
7000cb58:	e3470002 	movt	r0, #28674	; 0x7002
7000cb5c:	e30710c4 	movw	r1, #28868	; 0x70c4
7000cb60:	e3471002 	movt	r1, #28674	; 0x7002
7000cb64:	e3a0208b 	mov	r2, #139	; 0x8b
7000cb68:	e12fff33 	blx	r3

    irq = irq - _gic_table[index].offset;
7000cb6c:	e51b0014 	ldr	r0, [fp, #-20]
7000cb70:	e3092900 	movw	r2, #39168	; 0x9900
7000cb74:	e3472002 	movt	r2, #28674	; 0x7002
7000cb78:	e51b1010 	ldr	r1, [fp, #-16]
7000cb7c:	e1a03001 	mov	r3, r1
7000cb80:	e1a03083 	lsl	r3, r3, #1
7000cb84:	e0833001 	add	r3, r3, r1
7000cb88:	e1a03103 	lsl	r3, r3, #2
7000cb8c:	e0823003 	add	r3, r2, r3
7000cb90:	e5933000 	ldr	r3, [r3]
7000cb94:	e0633000 	rsb	r3, r3, r0
7000cb98:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
7000cb9c:	e51b3014 	ldr	r3, [fp, #-20]
7000cba0:	e3530000 	cmp	r3, #0
7000cba4:	aa00001d 	bge	7000cc20 <arm_gic_umask+0x170>
7000cba8:	e3a03000 	mov	r3, #0
7000cbac:	e54b300a 	strb	r3, [fp, #-10]
7000cbb0:	e30a3b74 	movw	r3, #43892	; 0xab74
7000cbb4:	e3473002 	movt	r3, #28674	; 0x7002
7000cbb8:	e5933000 	ldr	r3, [r3]
7000cbbc:	e3530000 	cmp	r3, #0
7000cbc0:	1a00000d 	bne	7000cbfc <arm_gic_umask+0x14c>
7000cbc4:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000cbc8:	e3470002 	movt	r0, #28674	; 0x7002
7000cbcc:	e3061f30 	movw	r1, #28464	; 0x6f30
7000cbd0:	e3471002 	movt	r1, #28674	; 0x7002
7000cbd4:	e30720c4 	movw	r2, #28868	; 0x70c4
7000cbd8:	e3472002 	movt	r2, #28674	; 0x7002
7000cbdc:	e3a0308e 	mov	r3, #142	; 0x8e
7000cbe0:	ebffeb03 	bl	700077f4 <rt_kprintf>
7000cbe4:	e1a00000 	nop			; (mov r0, r0)
7000cbe8:	e55b300a 	ldrb	r3, [fp, #-10]
7000cbec:	e6ef3073 	uxtb	r3, r3
7000cbf0:	e3530000 	cmp	r3, #0
7000cbf4:	0afffffb 	beq	7000cbe8 <arm_gic_umask+0x138>
7000cbf8:	ea000008 	b	7000cc20 <arm_gic_umask+0x170>
7000cbfc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000cc00:	e3473002 	movt	r3, #28674	; 0x7002
7000cc04:	e5933000 	ldr	r3, [r3]
7000cc08:	e3060f30 	movw	r0, #28464	; 0x6f30
7000cc0c:	e3470002 	movt	r0, #28674	; 0x7002
7000cc10:	e30710c4 	movw	r1, #28868	; 0x70c4
7000cc14:	e3471002 	movt	r1, #28674	; 0x7002
7000cc18:	e3a0208e 	mov	r2, #142	; 0x8e
7000cc1c:	e12fff33 	blx	r3

    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
7000cc20:	e3092900 	movw	r2, #39168	; 0x9900
7000cc24:	e3472002 	movt	r2, #28674	; 0x7002
7000cc28:	e51b1010 	ldr	r1, [fp, #-16]
7000cc2c:	e3a00004 	mov	r0, #4
7000cc30:	e1a03001 	mov	r3, r1
7000cc34:	e1a03083 	lsl	r3, r3, #1
7000cc38:	e0833001 	add	r3, r3, r1
7000cc3c:	e1a03103 	lsl	r3, r3, #2
7000cc40:	e0823003 	add	r3, r2, r3
7000cc44:	e0833000 	add	r3, r3, r0
7000cc48:	e5932000 	ldr	r2, [r3]
7000cc4c:	e51b3014 	ldr	r3, [fp, #-20]
7000cc50:	e283101f 	add	r1, r3, #31
7000cc54:	e3530000 	cmp	r3, #0
7000cc58:	b1a03001 	movlt	r3, r1
7000cc5c:	e1a032c3 	asr	r3, r3, #5
7000cc60:	e1a03103 	lsl	r3, r3, #2
7000cc64:	e0823003 	add	r3, r2, r3
7000cc68:	e2833c01 	add	r3, r3, #256	; 0x100
7000cc6c:	e51b2008 	ldr	r2, [fp, #-8]
7000cc70:	e5832000 	str	r2, [r3]
}
7000cc74:	e24bd004 	sub	sp, fp, #4
7000cc78:	e8bd8800 	pop	{fp, pc}

7000cc7c <arm_gic_dump_type>:

void arm_gic_dump_type(rt_uint32_t index)
{
7000cc7c:	e92d4800 	push	{fp, lr}
7000cc80:	e28db004 	add	fp, sp, #4
7000cc84:	e24dd018 	sub	sp, sp, #24
7000cc88:	e50b0010 	str	r0, [fp, #-16]
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
7000cc8c:	e3092900 	movw	r2, #39168	; 0x9900
7000cc90:	e3472002 	movt	r2, #28674	; 0x7002
7000cc94:	e51b1010 	ldr	r1, [fp, #-16]
7000cc98:	e3a00004 	mov	r0, #4
7000cc9c:	e1a03001 	mov	r3, r1
7000cca0:	e1a03083 	lsl	r3, r3, #1
7000cca4:	e0833001 	add	r3, r3, r1
7000cca8:	e1a03103 	lsl	r3, r3, #2
7000ccac:	e0823003 	add	r3, r2, r3
7000ccb0:	e0833000 	add	r3, r3, r0
7000ccb4:	e5933000 	ldr	r3, [r3]
7000ccb8:	e2833004 	add	r3, r3, #4
7000ccbc:	e5933000 	ldr	r3, [r3]
7000ccc0:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
7000ccc4:	e3092900 	movw	r2, #39168	; 0x9900
7000ccc8:	e3472002 	movt	r2, #28674	; 0x7002
7000cccc:	e51b1010 	ldr	r1, [fp, #-16]
7000ccd0:	e3a00004 	mov	r0, #4
7000ccd4:	e1a03001 	mov	r3, r1
7000ccd8:	e1a03083 	lsl	r3, r3, #1
7000ccdc:	e0833001 	add	r3, r3, r1
7000cce0:	e1a03103 	lsl	r3, r3, #2
7000cce4:	e0823003 	add	r3, r2, r3
7000cce8:	e0833000 	add	r3, r3, r0
7000ccec:	e5933000 	ldr	r3, [r3]
7000ccf0:	e2833efe 	add	r3, r3, #4064	; 0xfe0
7000ccf4:	e2833008 	add	r3, r3, #8
7000ccf8:	e5933000 	ldr	r3, [r3]
7000ccfc:	e1a03223 	lsr	r3, r3, #4
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
7000cd00:	e203e00f 	and	lr, r3, #15
7000cd04:	e3092900 	movw	r2, #39168	; 0x9900
7000cd08:	e3472002 	movt	r2, #28674	; 0x7002
7000cd0c:	e51b1010 	ldr	r1, [fp, #-16]
7000cd10:	e3a00004 	mov	r0, #4
7000cd14:	e1a03001 	mov	r3, r1
7000cd18:	e1a03083 	lsl	r3, r3, #1
7000cd1c:	e0833001 	add	r3, r3, r1
7000cd20:	e1a03103 	lsl	r3, r3, #2
7000cd24:	e0823003 	add	r3, r2, r3
7000cd28:	e0833000 	add	r3, r3, r0
7000cd2c:	e5932000 	ldr	r2, [r3]
7000cd30:	e309390c 	movw	r3, #39180	; 0x990c
7000cd34:	e3473002 	movt	r3, #28674	; 0x7002
7000cd38:	e593c000 	ldr	ip, [r3]
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
7000cd3c:	e51b3008 	ldr	r3, [fp, #-8]
7000cd40:	e2033b01 	and	r3, r3, #1024	; 0x400
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
7000cd44:	e3530000 	cmp	r3, #0
7000cd48:	0a000002 	beq	7000cd58 <arm_gic_dump_type+0xdc>
7000cd4c:	e3063f3c 	movw	r3, #28476	; 0x6f3c
7000cd50:	e3473002 	movt	r3, #28674	; 0x7002
7000cd54:	ea000001 	b	7000cd60 <arm_gic_dump_type+0xe4>
7000cd58:	e3063f40 	movw	r3, #28480	; 0x6f40
7000cd5c:	e3473002 	movt	r3, #28674	; 0x7002
7000cd60:	e58d3000 	str	r3, [sp]
7000cd64:	e51b3008 	ldr	r3, [fp, #-8]
7000cd68:	e58d3004 	str	r3, [sp, #4]
7000cd6c:	e3060f44 	movw	r0, #28484	; 0x6f44
7000cd70:	e3470002 	movt	r0, #28674	; 0x7002
7000cd74:	e1a0100e 	mov	r1, lr
7000cd78:	e1a0300c 	mov	r3, ip
7000cd7c:	ebffea9c 	bl	700077f4 <rt_kprintf>
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
               gic_type);
}
7000cd80:	e24bd004 	sub	sp, fp, #4
7000cd84:	e8bd8800 	pop	{fp, pc}

7000cd88 <arm_gic_dump>:

void arm_gic_dump(rt_uint32_t index)
{
7000cd88:	e92d4800 	push	{fp, lr}
7000cd8c:	e28db004 	add	fp, sp, #4
7000cd90:	e24dd010 	sub	sp, sp, #16
7000cd94:	e50b0010 	str	r0, [fp, #-16]
    unsigned int i, k;

    k = GIC_CPU_HIGHPRI(_gic_table[index].cpu_hw_base);
7000cd98:	e3092900 	movw	r2, #39168	; 0x9900
7000cd9c:	e3472002 	movt	r2, #28674	; 0x7002
7000cda0:	e51b1010 	ldr	r1, [fp, #-16]
7000cda4:	e3a00008 	mov	r0, #8
7000cda8:	e1a03001 	mov	r3, r1
7000cdac:	e1a03083 	lsl	r3, r3, #1
7000cdb0:	e0833001 	add	r3, r3, r1
7000cdb4:	e1a03103 	lsl	r3, r3, #2
7000cdb8:	e0823003 	add	r3, r2, r3
7000cdbc:	e0833000 	add	r3, r3, r0
7000cdc0:	e5933000 	ldr	r3, [r3]
7000cdc4:	e2833018 	add	r3, r3, #24
7000cdc8:	e5933000 	ldr	r3, [r3]
7000cdcc:	e50b300c 	str	r3, [fp, #-12]
    rt_kprintf("--- high pending priority: %d(%08x)\n", k, k);
7000cdd0:	e3060f80 	movw	r0, #28544	; 0x6f80
7000cdd4:	e3470002 	movt	r0, #28674	; 0x7002
7000cdd8:	e51b100c 	ldr	r1, [fp, #-12]
7000cddc:	e51b200c 	ldr	r2, [fp, #-12]
7000cde0:	ebffea83 	bl	700077f4 <rt_kprintf>
    rt_kprintf("--- hw mask ---\n");
7000cde4:	e3060fa8 	movw	r0, #28584	; 0x6fa8
7000cde8:	e3470002 	movt	r0, #28674	; 0x7002
7000cdec:	ebffea80 	bl	700077f4 <rt_kprintf>
    for (i = 0; i < _gic_max_irq / 32; i++)
7000cdf0:	e3a03000 	mov	r3, #0
7000cdf4:	e50b3008 	str	r3, [fp, #-8]
7000cdf8:	ea000018 	b	7000ce60 <arm_gic_dump+0xd8>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base,
7000cdfc:	e3092900 	movw	r2, #39168	; 0x9900
7000ce00:	e3472002 	movt	r2, #28674	; 0x7002
7000ce04:	e51b1010 	ldr	r1, [fp, #-16]
7000ce08:	e3a00004 	mov	r0, #4
7000ce0c:	e1a03001 	mov	r3, r1
7000ce10:	e1a03083 	lsl	r3, r3, #1
7000ce14:	e0833001 	add	r3, r3, r1
7000ce18:	e1a03103 	lsl	r3, r3, #2
7000ce1c:	e0823003 	add	r3, r2, r3
7000ce20:	e0833000 	add	r3, r3, r0
7000ce24:	e5932000 	ldr	r2, [r3]
7000ce28:	e51b3008 	ldr	r3, [fp, #-8]
7000ce2c:	e1a03283 	lsl	r3, r3, #5
7000ce30:	e1a032a3 	lsr	r3, r3, #5
7000ce34:	e1a03103 	lsl	r3, r3, #2
7000ce38:	e0823003 	add	r3, r2, r3
7000ce3c:	e2833c01 	add	r3, r3, #256	; 0x100
    k = GIC_CPU_HIGHPRI(_gic_table[index].cpu_hw_base);
    rt_kprintf("--- high pending priority: %d(%08x)\n", k, k);
    rt_kprintf("--- hw mask ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
    {
        rt_kprintf("0x%08x, ",
7000ce40:	e5933000 	ldr	r3, [r3]
7000ce44:	e3060fbc 	movw	r0, #28604	; 0x6fbc
7000ce48:	e3470002 	movt	r0, #28674	; 0x7002
7000ce4c:	e1a01003 	mov	r1, r3
7000ce50:	ebffea67 	bl	700077f4 <rt_kprintf>
    unsigned int i, k;

    k = GIC_CPU_HIGHPRI(_gic_table[index].cpu_hw_base);
    rt_kprintf("--- high pending priority: %d(%08x)\n", k, k);
    rt_kprintf("--- hw mask ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
7000ce54:	e51b3008 	ldr	r3, [fp, #-8]
7000ce58:	e2833001 	add	r3, r3, #1
7000ce5c:	e50b3008 	str	r3, [fp, #-8]
7000ce60:	e309390c 	movw	r3, #39180	; 0x990c
7000ce64:	e3473002 	movt	r3, #28674	; 0x7002
7000ce68:	e5933000 	ldr	r3, [r3]
7000ce6c:	e1a022a3 	lsr	r2, r3, #5
7000ce70:	e51b3008 	ldr	r3, [fp, #-8]
7000ce74:	e1520003 	cmp	r2, r3
7000ce78:	8affffdf 	bhi	7000cdfc <arm_gic_dump+0x74>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base,
                                       i * 32));
    }
    rt_kprintf("\n--- hw pending ---\n");
7000ce7c:	e3060fc8 	movw	r0, #28616	; 0x6fc8
7000ce80:	e3470002 	movt	r0, #28674	; 0x7002
7000ce84:	ebffea5a 	bl	700077f4 <rt_kprintf>
    for (i = 0; i < _gic_max_irq / 32; i++)
7000ce88:	e3a03000 	mov	r3, #0
7000ce8c:	e50b3008 	str	r3, [fp, #-8]
7000ce90:	ea000018 	b	7000cef8 <arm_gic_dump+0x170>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base,
7000ce94:	e3092900 	movw	r2, #39168	; 0x9900
7000ce98:	e3472002 	movt	r2, #28674	; 0x7002
7000ce9c:	e51b1010 	ldr	r1, [fp, #-16]
7000cea0:	e3a00004 	mov	r0, #4
7000cea4:	e1a03001 	mov	r3, r1
7000cea8:	e1a03083 	lsl	r3, r3, #1
7000ceac:	e0833001 	add	r3, r3, r1
7000ceb0:	e1a03103 	lsl	r3, r3, #2
7000ceb4:	e0823003 	add	r3, r2, r3
7000ceb8:	e0833000 	add	r3, r3, r0
7000cebc:	e5932000 	ldr	r2, [r3]
7000cec0:	e51b3008 	ldr	r3, [fp, #-8]
7000cec4:	e1a03283 	lsl	r3, r3, #5
7000cec8:	e1a032a3 	lsr	r3, r3, #5
7000cecc:	e1a03103 	lsl	r3, r3, #2
7000ced0:	e0823003 	add	r3, r2, r3
7000ced4:	e2833c02 	add	r3, r3, #512	; 0x200
                                       i * 32));
    }
    rt_kprintf("\n--- hw pending ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
    {
        rt_kprintf("0x%08x, ",
7000ced8:	e5933000 	ldr	r3, [r3]
7000cedc:	e3060fbc 	movw	r0, #28604	; 0x6fbc
7000cee0:	e3470002 	movt	r0, #28674	; 0x7002
7000cee4:	e1a01003 	mov	r1, r3
7000cee8:	ebffea41 	bl	700077f4 <rt_kprintf>
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base,
                                       i * 32));
    }
    rt_kprintf("\n--- hw pending ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
7000ceec:	e51b3008 	ldr	r3, [fp, #-8]
7000cef0:	e2833001 	add	r3, r3, #1
7000cef4:	e50b3008 	str	r3, [fp, #-8]
7000cef8:	e309390c 	movw	r3, #39180	; 0x990c
7000cefc:	e3473002 	movt	r3, #28674	; 0x7002
7000cf00:	e5933000 	ldr	r3, [r3]
7000cf04:	e1a022a3 	lsr	r2, r3, #5
7000cf08:	e51b3008 	ldr	r3, [fp, #-8]
7000cf0c:	e1520003 	cmp	r2, r3
7000cf10:	8affffdf 	bhi	7000ce94 <arm_gic_dump+0x10c>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base,
                                        i * 32));
    }
    rt_kprintf("\n--- hw active ---\n");
7000cf14:	e3060fe0 	movw	r0, #28640	; 0x6fe0
7000cf18:	e3470002 	movt	r0, #28674	; 0x7002
7000cf1c:	ebffea34 	bl	700077f4 <rt_kprintf>
    for (i = 0; i < _gic_max_irq / 32; i++)
7000cf20:	e3a03000 	mov	r3, #0
7000cf24:	e50b3008 	str	r3, [fp, #-8]
7000cf28:	ea000018 	b	7000cf90 <arm_gic_dump+0x208>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ACTIVE_SET(_gic_table[index].dist_hw_base,
7000cf2c:	e3092900 	movw	r2, #39168	; 0x9900
7000cf30:	e3472002 	movt	r2, #28674	; 0x7002
7000cf34:	e51b1010 	ldr	r1, [fp, #-16]
7000cf38:	e3a00004 	mov	r0, #4
7000cf3c:	e1a03001 	mov	r3, r1
7000cf40:	e1a03083 	lsl	r3, r3, #1
7000cf44:	e0833001 	add	r3, r3, r1
7000cf48:	e1a03103 	lsl	r3, r3, #2
7000cf4c:	e0823003 	add	r3, r2, r3
7000cf50:	e0833000 	add	r3, r3, r0
7000cf54:	e5932000 	ldr	r2, [r3]
7000cf58:	e51b3008 	ldr	r3, [fp, #-8]
7000cf5c:	e1a03283 	lsl	r3, r3, #5
7000cf60:	e1a032a3 	lsr	r3, r3, #5
7000cf64:	e1a03103 	lsl	r3, r3, #2
7000cf68:	e0823003 	add	r3, r2, r3
7000cf6c:	e2833c03 	add	r3, r3, #768	; 0x300
                                        i * 32));
    }
    rt_kprintf("\n--- hw active ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
    {
        rt_kprintf("0x%08x, ",
7000cf70:	e5933000 	ldr	r3, [r3]
7000cf74:	e3060fbc 	movw	r0, #28604	; 0x6fbc
7000cf78:	e3470002 	movt	r0, #28674	; 0x7002
7000cf7c:	e1a01003 	mov	r1, r3
7000cf80:	ebffea1b 	bl	700077f4 <rt_kprintf>
        rt_kprintf("0x%08x, ",
                   GIC_DIST_PENDING_SET(_gic_table[index].dist_hw_base,
                                        i * 32));
    }
    rt_kprintf("\n--- hw active ---\n");
    for (i = 0; i < _gic_max_irq / 32; i++)
7000cf84:	e51b3008 	ldr	r3, [fp, #-8]
7000cf88:	e2833001 	add	r3, r3, #1
7000cf8c:	e50b3008 	str	r3, [fp, #-8]
7000cf90:	e309390c 	movw	r3, #39180	; 0x990c
7000cf94:	e3473002 	movt	r3, #28674	; 0x7002
7000cf98:	e5933000 	ldr	r3, [r3]
7000cf9c:	e1a022a3 	lsr	r2, r3, #5
7000cfa0:	e51b3008 	ldr	r3, [fp, #-8]
7000cfa4:	e1520003 	cmp	r2, r3
7000cfa8:	8affffdf 	bhi	7000cf2c <arm_gic_dump+0x1a4>
    {
        rt_kprintf("0x%08x, ",
                   GIC_DIST_ACTIVE_SET(_gic_table[index].dist_hw_base,
                                       i * 32));
    }
    rt_kprintf("\n");
7000cfac:	e3060ff4 	movw	r0, #28660	; 0x6ff4
7000cfb0:	e3470002 	movt	r0, #28674	; 0x7002
7000cfb4:	ebffea0e 	bl	700077f4 <rt_kprintf>
}
7000cfb8:	e24bd004 	sub	sp, fp, #4
7000cfbc:	e8bd8800 	pop	{fp, pc}

7000cfc0 <arm_gic_dist_init>:
#include <finsh.h>
FINSH_FUNCTION_EXPORT_ALIAS(arm_gic_dump, gic, show gic status);
#endif

int arm_gic_dist_init(rt_uint32_t index, rt_uint32_t dist_base, int irq_start)
{
7000cfc0:	e92d4800 	push	{fp, lr}
7000cfc4:	e28db004 	add	fp, sp, #4
7000cfc8:	e24dd020 	sub	sp, sp, #32
7000cfcc:	e50b0018 	str	r0, [fp, #-24]
7000cfd0:	e50b101c 	str	r1, [fp, #-28]
7000cfd4:	e50b2020 	str	r2, [fp, #-32]
    unsigned int gic_type, i;
    rt_uint32_t cpumask = 1 << 0;
7000cfd8:	e3a03001 	mov	r3, #1
7000cfdc:	e50b300c 	str	r3, [fp, #-12]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000cfe0:	e51b3018 	ldr	r3, [fp, #-24]
7000cfe4:	e3530000 	cmp	r3, #0
7000cfe8:	0a00001d 	beq	7000d064 <arm_gic_dist_init+0xa4>
7000cfec:	e3a03000 	mov	r3, #0
7000cff0:	e54b3011 	strb	r3, [fp, #-17]
7000cff4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000cff8:	e3473002 	movt	r3, #28674	; 0x7002
7000cffc:	e5933000 	ldr	r3, [r3]
7000d000:	e3530000 	cmp	r3, #0
7000d004:	1a00000d 	bne	7000d040 <arm_gic_dist_init+0x80>
7000d008:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d00c:	e3470002 	movt	r0, #28674	; 0x7002
7000d010:	e3061f18 	movw	r1, #28440	; 0x6f18
7000d014:	e3471002 	movt	r1, #28674	; 0x7002
7000d018:	e30720d4 	movw	r2, #28884	; 0x70d4
7000d01c:	e3472002 	movt	r2, #28674	; 0x7002
7000d020:	e3a030c7 	mov	r3, #199	; 0xc7
7000d024:	ebffe9f2 	bl	700077f4 <rt_kprintf>
7000d028:	e1a00000 	nop			; (mov r0, r0)
7000d02c:	e55b3011 	ldrb	r3, [fp, #-17]
7000d030:	e6ef3073 	uxtb	r3, r3
7000d034:	e3530000 	cmp	r3, #0
7000d038:	0afffffb 	beq	7000d02c <arm_gic_dist_init+0x6c>
7000d03c:	ea000008 	b	7000d064 <arm_gic_dist_init+0xa4>
7000d040:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d044:	e3473002 	movt	r3, #28674	; 0x7002
7000d048:	e5933000 	ldr	r3, [r3]
7000d04c:	e3060f18 	movw	r0, #28440	; 0x6f18
7000d050:	e3470002 	movt	r0, #28674	; 0x7002
7000d054:	e30710d4 	movw	r1, #28884	; 0x70d4
7000d058:	e3471002 	movt	r1, #28674	; 0x7002
7000d05c:	e3a020c7 	mov	r2, #199	; 0xc7
7000d060:	e12fff33 	blx	r3

    _gic_table[index].dist_hw_base = dist_base;
7000d064:	e3092900 	movw	r2, #39168	; 0x9900
7000d068:	e3472002 	movt	r2, #28674	; 0x7002
7000d06c:	e51b1018 	ldr	r1, [fp, #-24]
7000d070:	e3a00004 	mov	r0, #4
7000d074:	e1a03001 	mov	r3, r1
7000d078:	e1a03083 	lsl	r3, r3, #1
7000d07c:	e0833001 	add	r3, r3, r1
7000d080:	e1a03103 	lsl	r3, r3, #2
7000d084:	e0823003 	add	r3, r2, r3
7000d088:	e0833000 	add	r3, r3, r0
7000d08c:	e51b201c 	ldr	r2, [fp, #-28]
7000d090:	e5832000 	str	r2, [r3]
    _gic_table[index].offset = irq_start;
7000d094:	e51b0020 	ldr	r0, [fp, #-32]
7000d098:	e3092900 	movw	r2, #39168	; 0x9900
7000d09c:	e3472002 	movt	r2, #28674	; 0x7002
7000d0a0:	e51b1018 	ldr	r1, [fp, #-24]
7000d0a4:	e1a03001 	mov	r3, r1
7000d0a8:	e1a03083 	lsl	r3, r3, #1
7000d0ac:	e0833001 	add	r3, r3, r1
7000d0b0:	e1a03103 	lsl	r3, r3, #2
7000d0b4:	e0823003 	add	r3, r2, r3
7000d0b8:	e5830000 	str	r0, [r3]

    /* Find out how many interrupts are supported. */
    gic_type = GIC_DIST_TYPE(dist_base);
7000d0bc:	e51b301c 	ldr	r3, [fp, #-28]
7000d0c0:	e2833004 	add	r3, r3, #4
7000d0c4:	e5933000 	ldr	r3, [r3]
7000d0c8:	e50b3010 	str	r3, [fp, #-16]
    _gic_max_irq = ((gic_type & 0x1f) + 1) * 32;
7000d0cc:	e51b3010 	ldr	r3, [fp, #-16]
7000d0d0:	e203301f 	and	r3, r3, #31
7000d0d4:	e2833001 	add	r3, r3, #1
7000d0d8:	e1a02283 	lsl	r2, r3, #5
7000d0dc:	e309390c 	movw	r3, #39180	; 0x990c
7000d0e0:	e3473002 	movt	r3, #28674	; 0x7002
7000d0e4:	e5832000 	str	r2, [r3]
    /*
     * The GIC only supports up to 1020 interrupt sources.
     * Limit this to either the architected maximum, or the
     * platform maximum.
     */
    if (_gic_max_irq > 1020)
7000d0e8:	e309390c 	movw	r3, #39180	; 0x990c
7000d0ec:	e3473002 	movt	r3, #28674	; 0x7002
7000d0f0:	e5933000 	ldr	r3, [r3]
7000d0f4:	e3530fff 	cmp	r3, #1020	; 0x3fc
7000d0f8:	9a000003 	bls	7000d10c <arm_gic_dist_init+0x14c>
        _gic_max_irq = 1020;
7000d0fc:	e309390c 	movw	r3, #39180	; 0x990c
7000d100:	e3473002 	movt	r3, #28674	; 0x7002
7000d104:	e3a02fff 	mov	r2, #1020	; 0x3fc
7000d108:	e5832000 	str	r2, [r3]
    if (_gic_max_irq > ARM_GIC_NR_IRQS)
7000d10c:	e309390c 	movw	r3, #39180	; 0x990c
7000d110:	e3473002 	movt	r3, #28674	; 0x7002
7000d114:	e5933000 	ldr	r3, [r3]
7000d118:	e3530060 	cmp	r3, #96	; 0x60
7000d11c:	9a000003 	bls	7000d130 <arm_gic_dist_init+0x170>
        _gic_max_irq = ARM_GIC_NR_IRQS;
7000d120:	e309390c 	movw	r3, #39180	; 0x990c
7000d124:	e3473002 	movt	r3, #28674	; 0x7002
7000d128:	e3a02060 	mov	r2, #96	; 0x60
7000d12c:	e5832000 	str	r2, [r3]

#ifndef RT_PRETENT_AS_CPU0
    /* If we are run on the second core, the GIC should have already been setup
     * by BootStrapProcessor. */
    if ((rt_cpu_get_smp_id() & 0xF) != 0)
7000d130:	eb00044d 	bl	7000e26c <rt_cpu_get_smp_id>
7000d134:	e1a03000 	mov	r3, r0
7000d138:	e203300f 	and	r3, r3, #15
7000d13c:	e3530000 	cmp	r3, #0
7000d140:	0a000001 	beq	7000d14c <arm_gic_dist_init+0x18c>
        return 0;
7000d144:	e3a03000 	mov	r3, #0
7000d148:	ea000076 	b	7000d328 <arm_gic_dist_init+0x368>
#endif
#ifdef RT_USING_VMM
    return 0;
#endif

    cpumask |= cpumask << 8;
7000d14c:	e51b300c 	ldr	r3, [fp, #-12]
7000d150:	e1a03403 	lsl	r3, r3, #8
7000d154:	e51b200c 	ldr	r2, [fp, #-12]
7000d158:	e1823003 	orr	r3, r2, r3
7000d15c:	e50b300c 	str	r3, [fp, #-12]
    cpumask |= cpumask << 16;
7000d160:	e51b300c 	ldr	r3, [fp, #-12]
7000d164:	e1a03803 	lsl	r3, r3, #16
7000d168:	e51b200c 	ldr	r2, [fp, #-12]
7000d16c:	e1823003 	orr	r3, r2, r3
7000d170:	e50b300c 	str	r3, [fp, #-12]

    GIC_DIST_CTRL(dist_base) = 0x0;
7000d174:	e51b301c 	ldr	r3, [fp, #-28]
7000d178:	e3a02000 	mov	r2, #0
7000d17c:	e5832000 	str	r2, [r3]

    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
7000d180:	e3a03020 	mov	r3, #32
7000d184:	e50b3008 	str	r3, [fp, #-8]
7000d188:	ea00000a 	b	7000d1b8 <arm_gic_dist_init+0x1f8>
        GIC_DIST_CONFIG(dist_base, i) = 0x0;
7000d18c:	e51b3008 	ldr	r3, [fp, #-8]
7000d190:	e1a03223 	lsr	r3, r3, #4
7000d194:	e1a02103 	lsl	r2, r3, #2
7000d198:	e51b301c 	ldr	r3, [fp, #-28]
7000d19c:	e0823003 	add	r3, r2, r3
7000d1a0:	e2833b03 	add	r3, r3, #3072	; 0xc00
7000d1a4:	e3a02000 	mov	r2, #0
7000d1a8:	e5832000 	str	r2, [r3]
    cpumask |= cpumask << 16;

    GIC_DIST_CTRL(dist_base) = 0x0;

    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
7000d1ac:	e51b3008 	ldr	r3, [fp, #-8]
7000d1b0:	e2833010 	add	r3, r3, #16
7000d1b4:	e50b3008 	str	r3, [fp, #-8]
7000d1b8:	e309390c 	movw	r3, #39180	; 0x990c
7000d1bc:	e3473002 	movt	r3, #28674	; 0x7002
7000d1c0:	e5933000 	ldr	r3, [r3]
7000d1c4:	e51b2008 	ldr	r2, [fp, #-8]
7000d1c8:	e1520003 	cmp	r2, r3
7000d1cc:	3affffee 	bcc	7000d18c <arm_gic_dist_init+0x1cc>
        GIC_DIST_CONFIG(dist_base, i) = 0x0;

    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
7000d1d0:	e3a03020 	mov	r3, #32
7000d1d4:	e50b3008 	str	r3, [fp, #-8]
7000d1d8:	ea00000a 	b	7000d208 <arm_gic_dist_init+0x248>
        GIC_DIST_TARGET(dist_base, i) = cpumask;
7000d1dc:	e51b3008 	ldr	r3, [fp, #-8]
7000d1e0:	e1a03123 	lsr	r3, r3, #2
7000d1e4:	e1a02103 	lsl	r2, r3, #2
7000d1e8:	e51b301c 	ldr	r3, [fp, #-28]
7000d1ec:	e0823003 	add	r3, r2, r3
7000d1f0:	e2833b02 	add	r3, r3, #2048	; 0x800
7000d1f4:	e51b200c 	ldr	r2, [fp, #-12]
7000d1f8:	e5832000 	str	r2, [r3]
    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
        GIC_DIST_CONFIG(dist_base, i) = 0x0;

    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
7000d1fc:	e51b3008 	ldr	r3, [fp, #-8]
7000d200:	e2833004 	add	r3, r3, #4
7000d204:	e50b3008 	str	r3, [fp, #-8]
7000d208:	e309390c 	movw	r3, #39180	; 0x990c
7000d20c:	e3473002 	movt	r3, #28674	; 0x7002
7000d210:	e5933000 	ldr	r3, [r3]
7000d214:	e51b2008 	ldr	r2, [fp, #-8]
7000d218:	e1520003 	cmp	r2, r3
7000d21c:	3affffee 	bcc	7000d1dc <arm_gic_dist_init+0x21c>
        GIC_DIST_TARGET(dist_base, i) = cpumask;

    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
7000d220:	e3a03000 	mov	r3, #0
7000d224:	e50b3008 	str	r3, [fp, #-8]
7000d228:	ea00000c 	b	7000d260 <arm_gic_dist_init+0x2a0>
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;
7000d22c:	e51b3008 	ldr	r3, [fp, #-8]
7000d230:	e1a03123 	lsr	r3, r3, #2
7000d234:	e1a02103 	lsl	r2, r3, #2
7000d238:	e51b301c 	ldr	r3, [fp, #-28]
7000d23c:	e0823003 	add	r3, r2, r3
7000d240:	e2833b01 	add	r3, r3, #1024	; 0x400
7000d244:	e1a02003 	mov	r2, r3
7000d248:	e30a30a0 	movw	r3, #41120	; 0xa0a0
7000d24c:	e34a30a0 	movt	r3, #41120	; 0xa0a0
7000d250:	e5823000 	str	r3, [r2]
    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
        GIC_DIST_TARGET(dist_base, i) = cpumask;

    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
7000d254:	e51b3008 	ldr	r3, [fp, #-8]
7000d258:	e2833004 	add	r3, r3, #4
7000d25c:	e50b3008 	str	r3, [fp, #-8]
7000d260:	e309390c 	movw	r3, #39180	; 0x990c
7000d264:	e3473002 	movt	r3, #28674	; 0x7002
7000d268:	e5933000 	ldr	r3, [r3]
7000d26c:	e51b2008 	ldr	r2, [fp, #-8]
7000d270:	e1520003 	cmp	r2, r3
7000d274:	3affffec 	bcc	7000d22c <arm_gic_dist_init+0x26c>
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;

    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
7000d278:	e3a03000 	mov	r3, #0
7000d27c:	e50b3008 	str	r3, [fp, #-8]
7000d280:	ea00000a 	b	7000d2b0 <arm_gic_dist_init+0x2f0>
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;
7000d284:	e51b3008 	ldr	r3, [fp, #-8]
7000d288:	e1a032a3 	lsr	r3, r3, #5
7000d28c:	e1a02103 	lsl	r2, r3, #2
7000d290:	e51b301c 	ldr	r3, [fp, #-28]
7000d294:	e0823003 	add	r3, r2, r3
7000d298:	e2833d06 	add	r3, r3, #384	; 0x180
7000d29c:	e3e02000 	mvn	r2, #0
7000d2a0:	e5832000 	str	r2, [r3]
    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;

    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
7000d2a4:	e51b3008 	ldr	r3, [fp, #-8]
7000d2a8:	e2833020 	add	r3, r3, #32
7000d2ac:	e50b3008 	str	r3, [fp, #-8]
7000d2b0:	e309390c 	movw	r3, #39180	; 0x990c
7000d2b4:	e3473002 	movt	r3, #28674	; 0x7002
7000d2b8:	e5933000 	ldr	r3, [r3]
7000d2bc:	e51b2008 	ldr	r2, [fp, #-8]
7000d2c0:	e1520003 	cmp	r2, r3
7000d2c4:	3affffee 	bcc	7000d284 <arm_gic_dist_init+0x2c4>
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;
    /* All interrupts defaults to IGROUP1(IRQ). */
    for (i = 0; i < _gic_max_irq; i += 32)
7000d2c8:	e3a03000 	mov	r3, #0
7000d2cc:	e50b3008 	str	r3, [fp, #-8]
7000d2d0:	ea00000a 	b	7000d300 <arm_gic_dist_init+0x340>
        GIC_DIST_IGROUP(dist_base, i) = 0xffffffff;
7000d2d4:	e51b3008 	ldr	r3, [fp, #-8]
7000d2d8:	e1a032a3 	lsr	r3, r3, #5
7000d2dc:	e1a02103 	lsl	r2, r3, #2
7000d2e0:	e51b301c 	ldr	r3, [fp, #-28]
7000d2e4:	e0823003 	add	r3, r2, r3
7000d2e8:	e2833080 	add	r3, r3, #128	; 0x80
7000d2ec:	e3e02000 	mvn	r2, #0
7000d2f0:	e5832000 	str	r2, [r3]

    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;
    /* All interrupts defaults to IGROUP1(IRQ). */
    for (i = 0; i < _gic_max_irq; i += 32)
7000d2f4:	e51b3008 	ldr	r3, [fp, #-8]
7000d2f8:	e2833020 	add	r3, r3, #32
7000d2fc:	e50b3008 	str	r3, [fp, #-8]
7000d300:	e309390c 	movw	r3, #39180	; 0x990c
7000d304:	e3473002 	movt	r3, #28674	; 0x7002
7000d308:	e5933000 	ldr	r3, [r3]
7000d30c:	e51b2008 	ldr	r2, [fp, #-8]
7000d310:	e1520003 	cmp	r2, r3
7000d314:	3affffee 	bcc	7000d2d4 <arm_gic_dist_init+0x314>
        GIC_DIST_IGROUP(dist_base, i) = 0xffffffff;

    /* Enable group0 and group1 interrupt forwarding. */
    GIC_DIST_CTRL(dist_base) = 0x03;
7000d318:	e51b301c 	ldr	r3, [fp, #-28]
7000d31c:	e3a02003 	mov	r2, #3
7000d320:	e5832000 	str	r2, [r3]

    return 0;
7000d324:	e3a03000 	mov	r3, #0
}
7000d328:	e1a00003 	mov	r0, r3
7000d32c:	e24bd004 	sub	sp, fp, #4
7000d330:	e8bd8800 	pop	{fp, pc}

7000d334 <arm_gic_cpu_init>:

int arm_gic_cpu_init(rt_uint32_t index, rt_uint32_t cpu_base)
{
7000d334:	e92d4800 	push	{fp, lr}
7000d338:	e28db004 	add	fp, sp, #4
7000d33c:	e24dd010 	sub	sp, sp, #16
7000d340:	e50b0010 	str	r0, [fp, #-16]
7000d344:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
7000d348:	e51b3010 	ldr	r3, [fp, #-16]
7000d34c:	e3530000 	cmp	r3, #0
7000d350:	0a00001d 	beq	7000d3cc <arm_gic_cpu_init+0x98>
7000d354:	e3a03000 	mov	r3, #0
7000d358:	e54b3005 	strb	r3, [fp, #-5]
7000d35c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d360:	e3473002 	movt	r3, #28674	; 0x7002
7000d364:	e5933000 	ldr	r3, [r3]
7000d368:	e3530000 	cmp	r3, #0
7000d36c:	1a00000d 	bne	7000d3a8 <arm_gic_cpu_init+0x74>
7000d370:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d374:	e3470002 	movt	r0, #28674	; 0x7002
7000d378:	e3061f18 	movw	r1, #28440	; 0x6f18
7000d37c:	e3471002 	movt	r1, #28674	; 0x7002
7000d380:	e30720e8 	movw	r2, #28904	; 0x70e8
7000d384:	e3472002 	movt	r2, #28674	; 0x7002
7000d388:	e3a03f41 	mov	r3, #260	; 0x104
7000d38c:	ebffe918 	bl	700077f4 <rt_kprintf>
7000d390:	e1a00000 	nop			; (mov r0, r0)
7000d394:	e55b3005 	ldrb	r3, [fp, #-5]
7000d398:	e6ef3073 	uxtb	r3, r3
7000d39c:	e3530000 	cmp	r3, #0
7000d3a0:	0afffffb 	beq	7000d394 <arm_gic_cpu_init+0x60>
7000d3a4:	ea000008 	b	7000d3cc <arm_gic_cpu_init+0x98>
7000d3a8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d3ac:	e3473002 	movt	r3, #28674	; 0x7002
7000d3b0:	e5933000 	ldr	r3, [r3]
7000d3b4:	e3060f18 	movw	r0, #28440	; 0x6f18
7000d3b8:	e3470002 	movt	r0, #28674	; 0x7002
7000d3bc:	e30710e8 	movw	r1, #28904	; 0x70e8
7000d3c0:	e3471002 	movt	r1, #28674	; 0x7002
7000d3c4:	e3a02f41 	mov	r2, #260	; 0x104
7000d3c8:	e12fff33 	blx	r3

    _gic_table[index].cpu_hw_base = cpu_base;
7000d3cc:	e3092900 	movw	r2, #39168	; 0x9900
7000d3d0:	e3472002 	movt	r2, #28674	; 0x7002
7000d3d4:	e51b1010 	ldr	r1, [fp, #-16]
7000d3d8:	e3a00008 	mov	r0, #8
7000d3dc:	e1a03001 	mov	r3, r1
7000d3e0:	e1a03083 	lsl	r3, r3, #1
7000d3e4:	e0833001 	add	r3, r3, r1
7000d3e8:	e1a03103 	lsl	r3, r3, #2
7000d3ec:	e0823003 	add	r3, r2, r3
7000d3f0:	e0833000 	add	r3, r3, r0
7000d3f4:	e51b2014 	ldr	r2, [fp, #-20]
7000d3f8:	e5832000 	str	r2, [r3]

#ifndef RT_PRETENT_AS_CPU0
    /* If we are run on the second core, the GIC should have already been setup
     * by BootStrapProcessor. */
    if ((rt_cpu_get_smp_id() & 0xF) != 0)
7000d3fc:	eb00039a 	bl	7000e26c <rt_cpu_get_smp_id>
7000d400:	e1a03000 	mov	r3, r0
7000d404:	e203300f 	and	r3, r3, #15
7000d408:	e3530000 	cmp	r3, #0
7000d40c:	0a000001 	beq	7000d418 <arm_gic_cpu_init+0xe4>
        return 0;
7000d410:	e3a03000 	mov	r3, #0
7000d414:	ea000007 	b	7000d438 <arm_gic_cpu_init+0x104>
#endif
#ifdef RT_USING_VMM
    return 0;
#endif

    GIC_CPU_PRIMASK(cpu_base) = 0xf0;
7000d418:	e51b3014 	ldr	r3, [fp, #-20]
7000d41c:	e2833004 	add	r3, r3, #4
7000d420:	e3a020f0 	mov	r2, #240	; 0xf0
7000d424:	e5832000 	str	r2, [r3]
    /* Enable CPU interrupt */
    GIC_CPU_CTRL(cpu_base) = 0x01;
7000d428:	e51b3014 	ldr	r3, [fp, #-20]
7000d42c:	e3a02001 	mov	r2, #1
7000d430:	e5832000 	str	r2, [r3]

    return 0;
7000d434:	e3a03000 	mov	r3, #0
}
7000d438:	e1a00003 	mov	r0, r3
7000d43c:	e24bd004 	sub	sp, fp, #4
7000d440:	e8bd8800 	pop	{fp, pc}

7000d444 <arm_gic_set_group>:

void arm_gic_set_group(rt_uint32_t index, int vector, int group)
{
7000d444:	e92d4810 	push	{r4, fp, lr}
7000d448:	e28db008 	add	fp, sp, #8
7000d44c:	e24dd01c 	sub	sp, sp, #28
7000d450:	e50b0018 	str	r0, [fp, #-24]
7000d454:	e50b101c 	str	r1, [fp, #-28]
7000d458:	e50b2020 	str	r2, [fp, #-32]
    /* As for GICv2, there are only group0 and group1. */
    RT_ASSERT(group <= 1);
7000d45c:	e51b3020 	ldr	r3, [fp, #-32]
7000d460:	e3530001 	cmp	r3, #1
7000d464:	da00001d 	ble	7000d4e0 <arm_gic_set_group+0x9c>
7000d468:	e3a03000 	mov	r3, #0
7000d46c:	e54b300d 	strb	r3, [fp, #-13]
7000d470:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d474:	e3473002 	movt	r3, #28674	; 0x7002
7000d478:	e5933000 	ldr	r3, [r3]
7000d47c:	e3530000 	cmp	r3, #0
7000d480:	1a00000d 	bne	7000d4bc <arm_gic_set_group+0x78>
7000d484:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d488:	e3470002 	movt	r0, #28674	; 0x7002
7000d48c:	e307100c 	movw	r1, #28684	; 0x700c
7000d490:	e3471002 	movt	r1, #28674	; 0x7002
7000d494:	e30720fc 	movw	r2, #28924	; 0x70fc
7000d498:	e3472002 	movt	r2, #28674	; 0x7002
7000d49c:	e3a03f47 	mov	r3, #284	; 0x11c
7000d4a0:	ebffe8d3 	bl	700077f4 <rt_kprintf>
7000d4a4:	e1a00000 	nop			; (mov r0, r0)
7000d4a8:	e55b300d 	ldrb	r3, [fp, #-13]
7000d4ac:	e6ef3073 	uxtb	r3, r3
7000d4b0:	e3530000 	cmp	r3, #0
7000d4b4:	0afffffb 	beq	7000d4a8 <arm_gic_set_group+0x64>
7000d4b8:	ea000008 	b	7000d4e0 <arm_gic_set_group+0x9c>
7000d4bc:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d4c0:	e3473002 	movt	r3, #28674	; 0x7002
7000d4c4:	e5933000 	ldr	r3, [r3]
7000d4c8:	e307000c 	movw	r0, #28684	; 0x700c
7000d4cc:	e3470002 	movt	r0, #28674	; 0x7002
7000d4d0:	e30710fc 	movw	r1, #28924	; 0x70fc
7000d4d4:	e3471002 	movt	r1, #28674	; 0x7002
7000d4d8:	e3a02f47 	mov	r2, #284	; 0x11c
7000d4dc:	e12fff33 	blx	r3
    RT_ASSERT(vector < _gic_max_irq);
7000d4e0:	e51b201c 	ldr	r2, [fp, #-28]
7000d4e4:	e309390c 	movw	r3, #39180	; 0x990c
7000d4e8:	e3473002 	movt	r3, #28674	; 0x7002
7000d4ec:	e5933000 	ldr	r3, [r3]
7000d4f0:	e1520003 	cmp	r2, r3
7000d4f4:	3a00001d 	bcc	7000d570 <arm_gic_set_group+0x12c>
7000d4f8:	e3a03000 	mov	r3, #0
7000d4fc:	e54b300e 	strb	r3, [fp, #-14]
7000d500:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d504:	e3473002 	movt	r3, #28674	; 0x7002
7000d508:	e5933000 	ldr	r3, [r3]
7000d50c:	e3530000 	cmp	r3, #0
7000d510:	1a00000d 	bne	7000d54c <arm_gic_set_group+0x108>
7000d514:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d518:	e3470002 	movt	r0, #28674	; 0x7002
7000d51c:	e3071018 	movw	r1, #28696	; 0x7018
7000d520:	e3471002 	movt	r1, #28674	; 0x7002
7000d524:	e30720fc 	movw	r2, #28924	; 0x70fc
7000d528:	e3472002 	movt	r2, #28674	; 0x7002
7000d52c:	e300311d 	movw	r3, #285	; 0x11d
7000d530:	ebffe8af 	bl	700077f4 <rt_kprintf>
7000d534:	e1a00000 	nop			; (mov r0, r0)
7000d538:	e55b300e 	ldrb	r3, [fp, #-14]
7000d53c:	e6ef3073 	uxtb	r3, r3
7000d540:	e3530000 	cmp	r3, #0
7000d544:	0afffffb 	beq	7000d538 <arm_gic_set_group+0xf4>
7000d548:	ea000008 	b	7000d570 <arm_gic_set_group+0x12c>
7000d54c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d550:	e3473002 	movt	r3, #28674	; 0x7002
7000d554:	e5933000 	ldr	r3, [r3]
7000d558:	e3070018 	movw	r0, #28696	; 0x7018
7000d55c:	e3470002 	movt	r0, #28674	; 0x7002
7000d560:	e30710fc 	movw	r1, #28924	; 0x70fc
7000d564:	e3471002 	movt	r1, #28674	; 0x7002
7000d568:	e300211d 	movw	r2, #285	; 0x11d
7000d56c:	e12fff33 	blx	r3

    if (group == 0)
7000d570:	e51b3020 	ldr	r3, [fp, #-32]
7000d574:	e3530000 	cmp	r3, #0
7000d578:	1a00002f 	bne	7000d63c <arm_gic_set_group+0x1f8>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
7000d57c:	e3092900 	movw	r2, #39168	; 0x9900
7000d580:	e3472002 	movt	r2, #28674	; 0x7002
7000d584:	e51b1018 	ldr	r1, [fp, #-24]
7000d588:	e3a00004 	mov	r0, #4
7000d58c:	e1a03001 	mov	r3, r1
7000d590:	e1a03083 	lsl	r3, r3, #1
7000d594:	e0833001 	add	r3, r3, r1
7000d598:	e1a03103 	lsl	r3, r3, #2
7000d59c:	e0823003 	add	r3, r2, r3
7000d5a0:	e0833000 	add	r3, r3, r0
7000d5a4:	e5932000 	ldr	r2, [r3]
7000d5a8:	e51b301c 	ldr	r3, [fp, #-28]
7000d5ac:	e283101f 	add	r1, r3, #31
7000d5b0:	e3530000 	cmp	r3, #0
7000d5b4:	b1a03001 	movlt	r3, r1
7000d5b8:	e1a032c3 	asr	r3, r3, #5
7000d5bc:	e1a01003 	mov	r1, r3
                        vector) &= ~(1 << (vector % 32));
7000d5c0:	e1a03101 	lsl	r3, r1, #2
7000d5c4:	e0823003 	add	r3, r2, r3
7000d5c8:	e2833080 	add	r3, r3, #128	; 0x80
7000d5cc:	e1a0c003 	mov	ip, r3
    RT_ASSERT(group <= 1);
    RT_ASSERT(vector < _gic_max_irq);

    if (group == 0)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
7000d5d0:	e3092900 	movw	r2, #39168	; 0x9900
7000d5d4:	e3472002 	movt	r2, #28674	; 0x7002
7000d5d8:	e51b0018 	ldr	r0, [fp, #-24]
7000d5dc:	e3a04004 	mov	r4, #4
7000d5e0:	e1a03000 	mov	r3, r0
7000d5e4:	e1a03083 	lsl	r3, r3, #1
7000d5e8:	e0833000 	add	r3, r3, r0
7000d5ec:	e1a03103 	lsl	r3, r3, #2
7000d5f0:	e0823003 	add	r3, r2, r3
7000d5f4:	e0833004 	add	r3, r3, r4
7000d5f8:	e5932000 	ldr	r2, [r3]
                        vector) &= ~(1 << (vector % 32));
7000d5fc:	e1a03101 	lsl	r3, r1, #2
7000d600:	e0823003 	add	r3, r2, r3
7000d604:	e2833080 	add	r3, r3, #128	; 0x80
7000d608:	e5931000 	ldr	r1, [r3]
7000d60c:	e51b201c 	ldr	r2, [fp, #-28]
7000d610:	e1a03fc2 	asr	r3, r2, #31
7000d614:	e1a03da3 	lsr	r3, r3, #27
7000d618:	e0822003 	add	r2, r2, r3
7000d61c:	e202201f 	and	r2, r2, #31
7000d620:	e0633002 	rsb	r3, r3, r2
7000d624:	e3a02001 	mov	r2, #1
7000d628:	e1a03312 	lsl	r3, r2, r3
7000d62c:	e1e03003 	mvn	r3, r3
7000d630:	e0013003 	and	r3, r1, r3
7000d634:	e58c3000 	str	r3, [ip]
7000d638:	ea000030 	b	7000d700 <arm_gic_set_group+0x2bc>
    }
    else if (group == 1)
7000d63c:	e51b3020 	ldr	r3, [fp, #-32]
7000d640:	e3530001 	cmp	r3, #1
7000d644:	1a00002d 	bne	7000d700 <arm_gic_set_group+0x2bc>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
7000d648:	e3092900 	movw	r2, #39168	; 0x9900
7000d64c:	e3472002 	movt	r2, #28674	; 0x7002
7000d650:	e51b1018 	ldr	r1, [fp, #-24]
7000d654:	e3a00004 	mov	r0, #4
7000d658:	e1a03001 	mov	r3, r1
7000d65c:	e1a03083 	lsl	r3, r3, #1
7000d660:	e0833001 	add	r3, r3, r1
7000d664:	e1a03103 	lsl	r3, r3, #2
7000d668:	e0823003 	add	r3, r2, r3
7000d66c:	e0833000 	add	r3, r3, r0
7000d670:	e5932000 	ldr	r2, [r3]
7000d674:	e51b301c 	ldr	r3, [fp, #-28]
7000d678:	e283101f 	add	r1, r3, #31
7000d67c:	e3530000 	cmp	r3, #0
7000d680:	b1a03001 	movlt	r3, r1
7000d684:	e1a032c3 	asr	r3, r3, #5
7000d688:	e1a01003 	mov	r1, r3
                        vector) |=  (1 << (vector % 32));
7000d68c:	e1a03101 	lsl	r3, r1, #2
7000d690:	e0823003 	add	r3, r2, r3
7000d694:	e2833080 	add	r3, r3, #128	; 0x80
7000d698:	e1a0c003 	mov	ip, r3
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
                        vector) &= ~(1 << (vector % 32));
    }
    else if (group == 1)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
7000d69c:	e3092900 	movw	r2, #39168	; 0x9900
7000d6a0:	e3472002 	movt	r2, #28674	; 0x7002
7000d6a4:	e51b0018 	ldr	r0, [fp, #-24]
7000d6a8:	e3a04004 	mov	r4, #4
7000d6ac:	e1a03000 	mov	r3, r0
7000d6b0:	e1a03083 	lsl	r3, r3, #1
7000d6b4:	e0833000 	add	r3, r3, r0
7000d6b8:	e1a03103 	lsl	r3, r3, #2
7000d6bc:	e0823003 	add	r3, r2, r3
7000d6c0:	e0833004 	add	r3, r3, r4
7000d6c4:	e5932000 	ldr	r2, [r3]
                        vector) |=  (1 << (vector % 32));
7000d6c8:	e1a03101 	lsl	r3, r1, #2
7000d6cc:	e0823003 	add	r3, r2, r3
7000d6d0:	e2833080 	add	r3, r3, #128	; 0x80
7000d6d4:	e5931000 	ldr	r1, [r3]
7000d6d8:	e51b201c 	ldr	r2, [fp, #-28]
7000d6dc:	e1a03fc2 	asr	r3, r2, #31
7000d6e0:	e1a03da3 	lsr	r3, r3, #27
7000d6e4:	e0822003 	add	r2, r2, r3
7000d6e8:	e202201f 	and	r2, r2, #31
7000d6ec:	e0633002 	rsb	r3, r3, r2
7000d6f0:	e3a02001 	mov	r2, #1
7000d6f4:	e1a03312 	lsl	r3, r2, r3
7000d6f8:	e1813003 	orr	r3, r1, r3
7000d6fc:	e58c3000 	str	r3, [ip]
    }
}
7000d700:	e24bd008 	sub	sp, fp, #8
7000d704:	e8bd8810 	pop	{r4, fp, pc}

7000d708 <arm_gic_trigger>:

void arm_gic_trigger(rt_uint32_t index, int target_cpu, int irq)
{
7000d708:	e92d4800 	push	{fp, lr}
7000d70c:	e28db004 	add	fp, sp, #4
7000d710:	e24dd018 	sub	sp, sp, #24
7000d714:	e50b0010 	str	r0, [fp, #-16]
7000d718:	e50b1014 	str	r1, [fp, #-20]
7000d71c:	e50b2018 	str	r2, [fp, #-24]
    unsigned int reg;

    RT_ASSERT(irq <= 15);
7000d720:	e51b3018 	ldr	r3, [fp, #-24]
7000d724:	e353000f 	cmp	r3, #15
7000d728:	da00001d 	ble	7000d7a4 <arm_gic_trigger+0x9c>
7000d72c:	e3a03000 	mov	r3, #0
7000d730:	e54b3009 	strb	r3, [fp, #-9]
7000d734:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d738:	e3473002 	movt	r3, #28674	; 0x7002
7000d73c:	e5933000 	ldr	r3, [r3]
7000d740:	e3530000 	cmp	r3, #0
7000d744:	1a00000d 	bne	7000d780 <arm_gic_trigger+0x78>
7000d748:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d74c:	e3470002 	movt	r0, #28674	; 0x7002
7000d750:	e3071030 	movw	r1, #28720	; 0x7030
7000d754:	e3471002 	movt	r1, #28674	; 0x7002
7000d758:	e3072110 	movw	r2, #28944	; 0x7110
7000d75c:	e3472002 	movt	r2, #28674	; 0x7002
7000d760:	e300312f 	movw	r3, #303	; 0x12f
7000d764:	ebffe822 	bl	700077f4 <rt_kprintf>
7000d768:	e1a00000 	nop			; (mov r0, r0)
7000d76c:	e55b3009 	ldrb	r3, [fp, #-9]
7000d770:	e6ef3073 	uxtb	r3, r3
7000d774:	e3530000 	cmp	r3, #0
7000d778:	0afffffb 	beq	7000d76c <arm_gic_trigger+0x64>
7000d77c:	ea000008 	b	7000d7a4 <arm_gic_trigger+0x9c>
7000d780:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d784:	e3473002 	movt	r3, #28674	; 0x7002
7000d788:	e5933000 	ldr	r3, [r3]
7000d78c:	e3070030 	movw	r0, #28720	; 0x7030
7000d790:	e3470002 	movt	r0, #28674	; 0x7002
7000d794:	e3071110 	movw	r1, #28944	; 0x7110
7000d798:	e3471002 	movt	r1, #28674	; 0x7002
7000d79c:	e300212f 	movw	r2, #303	; 0x12f
7000d7a0:	e12fff33 	blx	r3
    RT_ASSERT(target_cpu <= 255);
7000d7a4:	e51b3014 	ldr	r3, [fp, #-20]
7000d7a8:	e35300ff 	cmp	r3, #255	; 0xff
7000d7ac:	da00001d 	ble	7000d828 <arm_gic_trigger+0x120>
7000d7b0:	e3a03000 	mov	r3, #0
7000d7b4:	e54b300a 	strb	r3, [fp, #-10]
7000d7b8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d7bc:	e3473002 	movt	r3, #28674	; 0x7002
7000d7c0:	e5933000 	ldr	r3, [r3]
7000d7c4:	e3530000 	cmp	r3, #0
7000d7c8:	1a00000d 	bne	7000d804 <arm_gic_trigger+0xfc>
7000d7cc:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d7d0:	e3470002 	movt	r0, #28674	; 0x7002
7000d7d4:	e307103c 	movw	r1, #28732	; 0x703c
7000d7d8:	e3471002 	movt	r1, #28674	; 0x7002
7000d7dc:	e3072110 	movw	r2, #28944	; 0x7110
7000d7e0:	e3472002 	movt	r2, #28674	; 0x7002
7000d7e4:	e3a03e13 	mov	r3, #304	; 0x130
7000d7e8:	ebffe801 	bl	700077f4 <rt_kprintf>
7000d7ec:	e1a00000 	nop			; (mov r0, r0)
7000d7f0:	e55b300a 	ldrb	r3, [fp, #-10]
7000d7f4:	e6ef3073 	uxtb	r3, r3
7000d7f8:	e3530000 	cmp	r3, #0
7000d7fc:	0afffffb 	beq	7000d7f0 <arm_gic_trigger+0xe8>
7000d800:	ea000008 	b	7000d828 <arm_gic_trigger+0x120>
7000d804:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d808:	e3473002 	movt	r3, #28674	; 0x7002
7000d80c:	e5933000 	ldr	r3, [r3]
7000d810:	e307003c 	movw	r0, #28732	; 0x703c
7000d814:	e3470002 	movt	r0, #28674	; 0x7002
7000d818:	e3071110 	movw	r1, #28944	; 0x7110
7000d81c:	e3471002 	movt	r1, #28674	; 0x7002
7000d820:	e3a02e13 	mov	r2, #304	; 0x130
7000d824:	e12fff33 	blx	r3

    reg = (target_cpu << 16) | irq;
7000d828:	e51b3014 	ldr	r3, [fp, #-20]
7000d82c:	e1a02803 	lsl	r2, r3, #16
7000d830:	e51b3018 	ldr	r3, [fp, #-24]
7000d834:	e1823003 	orr	r3, r2, r3
7000d838:	e50b3008 	str	r3, [fp, #-8]
    GIC_DIST_SOFTINT(_gic_table[index].dist_hw_base) = reg;
7000d83c:	e3092900 	movw	r2, #39168	; 0x9900
7000d840:	e3472002 	movt	r2, #28674	; 0x7002
7000d844:	e51b1010 	ldr	r1, [fp, #-16]
7000d848:	e3a00004 	mov	r0, #4
7000d84c:	e1a03001 	mov	r3, r1
7000d850:	e1a03083 	lsl	r3, r3, #1
7000d854:	e0833001 	add	r3, r3, r1
7000d858:	e1a03103 	lsl	r3, r3, #2
7000d85c:	e0823003 	add	r3, r2, r3
7000d860:	e0833000 	add	r3, r3, r0
7000d864:	e5933000 	ldr	r3, [r3]
7000d868:	e2833c0f 	add	r3, r3, #3840	; 0xf00
7000d86c:	e51b2008 	ldr	r2, [fp, #-8]
7000d870:	e5832000 	str	r2, [r3]
}
7000d874:	e24bd004 	sub	sp, fp, #4
7000d878:	e8bd8800 	pop	{fp, pc}

7000d87c <arm_gic_clear_sgi>:

void arm_gic_clear_sgi(rt_uint32_t index, int target_cpu, int irq)
{
7000d87c:	e92d4800 	push	{fp, lr}
7000d880:	e28db004 	add	fp, sp, #4
7000d884:	e24dd018 	sub	sp, sp, #24
7000d888:	e50b0010 	str	r0, [fp, #-16]
7000d88c:	e50b1014 	str	r1, [fp, #-20]
7000d890:	e50b2018 	str	r2, [fp, #-24]
    RT_ASSERT(irq <= 15);
7000d894:	e51b3018 	ldr	r3, [fp, #-24]
7000d898:	e353000f 	cmp	r3, #15
7000d89c:	da00001d 	ble	7000d918 <arm_gic_clear_sgi+0x9c>
7000d8a0:	e3a03000 	mov	r3, #0
7000d8a4:	e54b3005 	strb	r3, [fp, #-5]
7000d8a8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d8ac:	e3473002 	movt	r3, #28674	; 0x7002
7000d8b0:	e5933000 	ldr	r3, [r3]
7000d8b4:	e3530000 	cmp	r3, #0
7000d8b8:	1a00000d 	bne	7000d8f4 <arm_gic_clear_sgi+0x78>
7000d8bc:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d8c0:	e3470002 	movt	r0, #28674	; 0x7002
7000d8c4:	e3071030 	movw	r1, #28720	; 0x7030
7000d8c8:	e3471002 	movt	r1, #28674	; 0x7002
7000d8cc:	e3072120 	movw	r2, #28960	; 0x7120
7000d8d0:	e3472002 	movt	r2, #28674	; 0x7002
7000d8d4:	e3a03f4e 	mov	r3, #312	; 0x138
7000d8d8:	ebffe7c5 	bl	700077f4 <rt_kprintf>
7000d8dc:	e1a00000 	nop			; (mov r0, r0)
7000d8e0:	e55b3005 	ldrb	r3, [fp, #-5]
7000d8e4:	e6ef3073 	uxtb	r3, r3
7000d8e8:	e3530000 	cmp	r3, #0
7000d8ec:	0afffffb 	beq	7000d8e0 <arm_gic_clear_sgi+0x64>
7000d8f0:	ea000008 	b	7000d918 <arm_gic_clear_sgi+0x9c>
7000d8f4:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d8f8:	e3473002 	movt	r3, #28674	; 0x7002
7000d8fc:	e5933000 	ldr	r3, [r3]
7000d900:	e3070030 	movw	r0, #28720	; 0x7030
7000d904:	e3470002 	movt	r0, #28674	; 0x7002
7000d908:	e3071120 	movw	r1, #28960	; 0x7120
7000d90c:	e3471002 	movt	r1, #28674	; 0x7002
7000d910:	e3a02f4e 	mov	r2, #312	; 0x138
7000d914:	e12fff33 	blx	r3
    RT_ASSERT(target_cpu <= 255);
7000d918:	e51b3014 	ldr	r3, [fp, #-20]
7000d91c:	e35300ff 	cmp	r3, #255	; 0xff
7000d920:	da00001d 	ble	7000d99c <arm_gic_clear_sgi+0x120>
7000d924:	e3a03000 	mov	r3, #0
7000d928:	e54b3006 	strb	r3, [fp, #-6]
7000d92c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d930:	e3473002 	movt	r3, #28674	; 0x7002
7000d934:	e5933000 	ldr	r3, [r3]
7000d938:	e3530000 	cmp	r3, #0
7000d93c:	1a00000d 	bne	7000d978 <arm_gic_clear_sgi+0xfc>
7000d940:	e3060ef8 	movw	r0, #28408	; 0x6ef8
7000d944:	e3470002 	movt	r0, #28674	; 0x7002
7000d948:	e307103c 	movw	r1, #28732	; 0x703c
7000d94c:	e3471002 	movt	r1, #28674	; 0x7002
7000d950:	e3072120 	movw	r2, #28960	; 0x7120
7000d954:	e3472002 	movt	r2, #28674	; 0x7002
7000d958:	e3003139 	movw	r3, #313	; 0x139
7000d95c:	ebffe7a4 	bl	700077f4 <rt_kprintf>
7000d960:	e1a00000 	nop			; (mov r0, r0)
7000d964:	e55b3006 	ldrb	r3, [fp, #-6]
7000d968:	e6ef3073 	uxtb	r3, r3
7000d96c:	e3530000 	cmp	r3, #0
7000d970:	0afffffb 	beq	7000d964 <arm_gic_clear_sgi+0xe8>
7000d974:	ea000008 	b	7000d99c <arm_gic_clear_sgi+0x120>
7000d978:	e30a3b74 	movw	r3, #43892	; 0xab74
7000d97c:	e3473002 	movt	r3, #28674	; 0x7002
7000d980:	e5933000 	ldr	r3, [r3]
7000d984:	e307003c 	movw	r0, #28732	; 0x703c
7000d988:	e3470002 	movt	r0, #28674	; 0x7002
7000d98c:	e3071120 	movw	r1, #28960	; 0x7120
7000d990:	e3471002 	movt	r1, #28674	; 0x7002
7000d994:	e3002139 	movw	r2, #313	; 0x139
7000d998:	e12fff33 	blx	r3

    GIC_DIST_CPENDSGI(_gic_table[index].dist_hw_base, irq) = target_cpu << (irq % 4);
7000d99c:	e3092900 	movw	r2, #39168	; 0x9900
7000d9a0:	e3472002 	movt	r2, #28674	; 0x7002
7000d9a4:	e51b1010 	ldr	r1, [fp, #-16]
7000d9a8:	e3a00004 	mov	r0, #4
7000d9ac:	e1a03001 	mov	r3, r1
7000d9b0:	e1a03083 	lsl	r3, r3, #1
7000d9b4:	e0833001 	add	r3, r3, r1
7000d9b8:	e1a03103 	lsl	r3, r3, #2
7000d9bc:	e0823003 	add	r3, r2, r3
7000d9c0:	e0833000 	add	r3, r3, r0
7000d9c4:	e5932000 	ldr	r2, [r3]
7000d9c8:	e51b3018 	ldr	r3, [fp, #-24]
7000d9cc:	e2831003 	add	r1, r3, #3
7000d9d0:	e3530000 	cmp	r3, #0
7000d9d4:	b1a03001 	movlt	r3, r1
7000d9d8:	e1a03143 	asr	r3, r3, #2
7000d9dc:	e1a03103 	lsl	r3, r3, #2
7000d9e0:	e0823003 	add	r3, r2, r3
7000d9e4:	e2833ef1 	add	r3, r3, #3856	; 0xf10
7000d9e8:	e1a01003 	mov	r1, r3
7000d9ec:	e51b2018 	ldr	r2, [fp, #-24]
7000d9f0:	e1a03fc2 	asr	r3, r2, #31
7000d9f4:	e1a03f23 	lsr	r3, r3, #30
7000d9f8:	e0822003 	add	r2, r2, r3
7000d9fc:	e2022003 	and	r2, r2, #3
7000da00:	e0633002 	rsb	r3, r3, r2
7000da04:	e51b2014 	ldr	r2, [fp, #-20]
7000da08:	e1a03312 	lsl	r3, r2, r3
7000da0c:	e5813000 	str	r3, [r1]
}
7000da10:	e24bd004 	sub	sp, fp, #4
7000da14:	e8bd8800 	pop	{fp, pc}

7000da18 <rt_hw_vector_init>:
const unsigned int VECTOR_BASE = 0x00;
extern void rt_cpu_vector_set_base(unsigned int addr);
extern int system_vectors;

static void rt_hw_vector_init(void)
{
7000da18:	e92d4800 	push	{fp, lr}
7000da1c:	e28db004 	add	fp, sp, #4
7000da20:	e24dd008 	sub	sp, sp, #8
#ifndef RT_USING_VMM
    unsigned int *dest = (unsigned int *)VECTOR_BASE;
7000da24:	e3a03000 	mov	r3, #0
7000da28:	e50b3008 	str	r3, [fp, #-8]
    unsigned int *src =  (unsigned int *)&system_vectors;
7000da2c:	e3003000 	movw	r3, #0
7000da30:	e3473000 	movt	r3, #28672	; 0x7000
7000da34:	e50b300c 	str	r3, [fp, #-12]

    rt_memcpy(dest, src, 16 * 4);
7000da38:	e51b0008 	ldr	r0, [fp, #-8]
7000da3c:	e51b100c 	ldr	r1, [fp, #-12]
7000da40:	e3a02040 	mov	r2, #64	; 0x40
7000da44:	ebffe1c9 	bl	70006170 <rt_memcpy>
    rt_cpu_vector_set_base(VECTOR_BASE);
7000da48:	e3a03000 	mov	r3, #0
7000da4c:	e1a00003 	mov	r0, r3
7000da50:	eb000207 	bl	7000e274 <rt_cpu_vector_set_base>
#endif
}
7000da54:	e24bd004 	sub	sp, fp, #4
7000da58:	e8bd8800 	pop	{fp, pc}

7000da5c <rt_hw_interrupt_init>:

/**
 * This function will initialize hardware interrupt
 */
void rt_hw_interrupt_init(void)
{
7000da5c:	e92d4800 	push	{fp, lr}
7000da60:	e28db004 	add	fp, sp, #4
7000da64:	e24dd008 	sub	sp, sp, #8
    rt_uint32_t gic_cpu_base;
    rt_uint32_t gic_dist_base;

    /* initialize vector table */
    rt_hw_vector_init();
7000da68:	ebffffea 	bl	7000da18 <rt_hw_vector_init>

    /* initialize exceptions table */
    rt_memset(isr_table, 0x00, sizeof(isr_table));
7000da6c:	e30a0c98 	movw	r0, #44184	; 0xac98
7000da70:	e3470002 	movt	r0, #28674	; 0x7002
7000da74:	e3a01000 	mov	r1, #0
7000da78:	e3a02d1e 	mov	r2, #1920	; 0x780
7000da7c:	ebffe162 	bl	7000600c <rt_memset>
    /* initialize ARM GIC */
#ifdef RT_USING_VMM
    gic_dist_base = vmm_find_iomap("GIC_DIST");
    gic_cpu_base = vmm_find_iomap("GIC_CPU");
#else
    gic_dist_base = REALVIEW_GIC_DIST_BASE;
7000da80:	e3a03a01 	mov	r3, #4096	; 0x1000
7000da84:	e3413e00 	movt	r3, #7680	; 0x1e00
7000da88:	e50b3008 	str	r3, [fp, #-8]
    gic_cpu_base = REALVIEW_GIC_CPU_BASE;
7000da8c:	e3a0341e 	mov	r3, #503316480	; 0x1e000000
7000da90:	e50b300c 	str	r3, [fp, #-12]
#endif
    arm_gic_dist_init(0, gic_dist_base, 0);
7000da94:	e3a00000 	mov	r0, #0
7000da98:	e51b1008 	ldr	r1, [fp, #-8]
7000da9c:	e3a02000 	mov	r2, #0
7000daa0:	ebfffd46 	bl	7000cfc0 <arm_gic_dist_init>
    arm_gic_cpu_init(0, gic_cpu_base);
7000daa4:	e3a00000 	mov	r0, #0
7000daa8:	e51b100c 	ldr	r1, [fp, #-12]
7000daac:	ebfffe20 	bl	7000d334 <arm_gic_cpu_init>
    /*arm_gic_dump_type(0);*/

    /* init interrupt nest, and context in thread sp */
    rt_interrupt_nest = 0;
7000dab0:	e30a3b70 	movw	r3, #43888	; 0xab70
7000dab4:	e3473002 	movt	r3, #28674	; 0x7002
7000dab8:	e3a02000 	mov	r2, #0
7000dabc:	e5c32000 	strb	r2, [r3]
    rt_interrupt_from_thread = 0;
7000dac0:	e30a3b38 	movw	r3, #43832	; 0xab38
7000dac4:	e3473002 	movt	r3, #28674	; 0x7002
7000dac8:	e3a02000 	mov	r2, #0
7000dacc:	e5832000 	str	r2, [r3]
    rt_interrupt_to_thread = 0;
7000dad0:	e30a3b3c 	movw	r3, #43836	; 0xab3c
7000dad4:	e3473002 	movt	r3, #28674	; 0x7002
7000dad8:	e3a02000 	mov	r2, #0
7000dadc:	e5832000 	str	r2, [r3]
    rt_thread_switch_interrupt_flag = 0;
7000dae0:	e30a3b40 	movw	r3, #43840	; 0xab40
7000dae4:	e3473002 	movt	r3, #28674	; 0x7002
7000dae8:	e3a02000 	mov	r2, #0
7000daec:	e5832000 	str	r2, [r3]
}
7000daf0:	e24bd004 	sub	sp, fp, #4
7000daf4:	e8bd8800 	pop	{fp, pc}

7000daf8 <rt_hw_interrupt_mask>:
/**
 * This function will mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_mask(int vector)
{
7000daf8:	e92d4800 	push	{fp, lr}
7000dafc:	e28db004 	add	fp, sp, #4
7000db00:	e24dd008 	sub	sp, sp, #8
7000db04:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_mask(0, vector);
7000db08:	e3a00000 	mov	r0, #0
7000db0c:	e51b1008 	ldr	r1, [fp, #-8]
7000db10:	ebfff9f4 	bl	7000c2e8 <arm_gic_mask>
}
7000db14:	e24bd004 	sub	sp, fp, #4
7000db18:	e8bd8800 	pop	{fp, pc}

7000db1c <rt_hw_interrupt_umask>:
/**
 * This function will un-mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_umask(int vector)
{
7000db1c:	e92d4800 	push	{fp, lr}
7000db20:	e28db004 	add	fp, sp, #4
7000db24:	e24dd008 	sub	sp, sp, #8
7000db28:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_umask(0, vector);
7000db2c:	e3a00000 	mov	r0, #0
7000db30:	e51b1008 	ldr	r1, [fp, #-8]
7000db34:	ebfffbdd 	bl	7000cab0 <arm_gic_umask>
}
7000db38:	e24bd004 	sub	sp, fp, #4
7000db3c:	e8bd8800 	pop	{fp, pc}

7000db40 <rt_hw_interrupt_install>:
 * @param new_handler the interrupt service routine to be installed
 * @param old_handler the old interrupt service routine
 */
rt_isr_handler_t rt_hw_interrupt_install(int vector, rt_isr_handler_t handler,
        void *param, char *name)
{
7000db40:	e92d4800 	push	{fp, lr}
7000db44:	e28db004 	add	fp, sp, #4
7000db48:	e24dd018 	sub	sp, sp, #24
7000db4c:	e50b0010 	str	r0, [fp, #-16]
7000db50:	e50b1014 	str	r1, [fp, #-20]
7000db54:	e50b2018 	str	r2, [fp, #-24]
7000db58:	e50b301c 	str	r3, [fp, #-28]
    rt_isr_handler_t old_handler = RT_NULL;
7000db5c:	e3a03000 	mov	r3, #0
7000db60:	e50b3008 	str	r3, [fp, #-8]

    if (vector < MAX_HANDLERS)
7000db64:	e51b3010 	ldr	r3, [fp, #-16]
7000db68:	e353005f 	cmp	r3, #95	; 0x5f
7000db6c:	ca00002f 	bgt	7000dc30 <rt_hw_interrupt_install+0xf0>
    {
        old_handler = isr_table[vector].handler;
7000db70:	e30a2c98 	movw	r2, #44184	; 0xac98
7000db74:	e3472002 	movt	r2, #28674	; 0x7002
7000db78:	e51b1010 	ldr	r1, [fp, #-16]
7000db7c:	e1a03001 	mov	r3, r1
7000db80:	e1a03103 	lsl	r3, r3, #2
7000db84:	e0833001 	add	r3, r3, r1
7000db88:	e1a03103 	lsl	r3, r3, #2
7000db8c:	e0823003 	add	r3, r2, r3
7000db90:	e5933000 	ldr	r3, [r3]
7000db94:	e50b3008 	str	r3, [fp, #-8]

        if (handler != RT_NULL)
7000db98:	e51b3014 	ldr	r3, [fp, #-20]
7000db9c:	e3530000 	cmp	r3, #0
7000dba0:	0a000022 	beq	7000dc30 <rt_hw_interrupt_install+0xf0>
        {
#ifdef RT_USING_INTERRUPT_INFO
            rt_strncpy(isr_table[vector].name, name, RT_NAME_MAX);
7000dba4:	e51b2010 	ldr	r2, [fp, #-16]
7000dba8:	e1a03002 	mov	r3, r2
7000dbac:	e1a03103 	lsl	r3, r3, #2
7000dbb0:	e0833002 	add	r3, r3, r2
7000dbb4:	e1a03103 	lsl	r3, r3, #2
7000dbb8:	e2832008 	add	r2, r3, #8
7000dbbc:	e30a3c98 	movw	r3, #44184	; 0xac98
7000dbc0:	e3473002 	movt	r3, #28674	; 0x7002
7000dbc4:	e0823003 	add	r3, r2, r3
7000dbc8:	e1a00003 	mov	r0, r3
7000dbcc:	e51b101c 	ldr	r1, [fp, #-28]
7000dbd0:	e3a02006 	mov	r2, #6
7000dbd4:	ebffe28f 	bl	70006618 <rt_strncpy>
#endif /* RT_USING_INTERRUPT_INFO */
            isr_table[vector].handler = handler;
7000dbd8:	e30a2c98 	movw	r2, #44184	; 0xac98
7000dbdc:	e3472002 	movt	r2, #28674	; 0x7002
7000dbe0:	e51b1010 	ldr	r1, [fp, #-16]
7000dbe4:	e1a03001 	mov	r3, r1
7000dbe8:	e1a03103 	lsl	r3, r3, #2
7000dbec:	e0833001 	add	r3, r3, r1
7000dbf0:	e1a03103 	lsl	r3, r3, #2
7000dbf4:	e0823003 	add	r3, r2, r3
7000dbf8:	e51b2014 	ldr	r2, [fp, #-20]
7000dbfc:	e5832000 	str	r2, [r3]
            isr_table[vector].param = param;
7000dc00:	e30a2c98 	movw	r2, #44184	; 0xac98
7000dc04:	e3472002 	movt	r2, #28674	; 0x7002
7000dc08:	e51b1010 	ldr	r1, [fp, #-16]
7000dc0c:	e3a00004 	mov	r0, #4
7000dc10:	e1a03001 	mov	r3, r1
7000dc14:	e1a03103 	lsl	r3, r3, #2
7000dc18:	e0833001 	add	r3, r3, r1
7000dc1c:	e1a03103 	lsl	r3, r3, #2
7000dc20:	e0823003 	add	r3, r2, r3
7000dc24:	e0833000 	add	r3, r3, r0
7000dc28:	e51b2018 	ldr	r2, [fp, #-24]
7000dc2c:	e5832000 	str	r2, [r3]
        }
    }

    return old_handler;
7000dc30:	e51b3008 	ldr	r3, [fp, #-8]
}
7000dc34:	e1a00003 	mov	r0, r3
7000dc38:	e24bd004 	sub	sp, fp, #4
7000dc3c:	e8bd8800 	pop	{fp, pc}

7000dc40 <rt_hw_interrupt_trigger>:
 * Trigger a software IRQ
 *
 * Since we are running in single core, the target CPU are always CPU0.
 */
void rt_hw_interrupt_trigger(int vector)
{
7000dc40:	e92d4800 	push	{fp, lr}
7000dc44:	e28db004 	add	fp, sp, #4
7000dc48:	e24dd008 	sub	sp, sp, #8
7000dc4c:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_trigger(0, 1, vector);
7000dc50:	e3a00000 	mov	r0, #0
7000dc54:	e3a01001 	mov	r1, #1
7000dc58:	e51b2008 	ldr	r2, [fp, #-8]
7000dc5c:	ebfffea9 	bl	7000d708 <arm_gic_trigger>
}
7000dc60:	e24bd004 	sub	sp, fp, #4
7000dc64:	e8bd8800 	pop	{fp, pc}

7000dc68 <rt_hw_interrupt_clear>:

void rt_hw_interrupt_clear(int vector)
{
7000dc68:	e92d4800 	push	{fp, lr}
7000dc6c:	e28db004 	add	fp, sp, #4
7000dc70:	e24dd008 	sub	sp, sp, #8
7000dc74:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_clear_sgi(0, 1, vector);
7000dc78:	e3a00000 	mov	r0, #0
7000dc7c:	e3a01001 	mov	r1, #1
7000dc80:	e51b2008 	ldr	r2, [fp, #-8]
7000dc84:	ebfffefc 	bl	7000d87c <arm_gic_clear_sgi>
}
7000dc88:	e24bd004 	sub	sp, fp, #4
7000dc8c:	e8bd8800 	pop	{fp, pc}

7000dc90 <rt_hw_stack_init>:
 *
 * @return stack address
 */
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter,
	rt_uint8_t *stack_addr, void *texit)
{
7000dc90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000dc94:	e28db000 	add	fp, sp, #0
7000dc98:	e24dd01c 	sub	sp, sp, #28
7000dc9c:	e50b0010 	str	r0, [fp, #-16]
7000dca0:	e50b1014 	str	r1, [fp, #-20]
7000dca4:	e50b2018 	str	r2, [fp, #-24]
7000dca8:	e50b301c 	str	r3, [fp, #-28]
	rt_uint32_t *stk;

	stk 	 = (rt_uint32_t*)stack_addr;
7000dcac:	e51b3018 	ldr	r3, [fp, #-24]
7000dcb0:	e50b3008 	str	r3, [fp, #-8]
	*(stk) 	 = (rt_uint32_t)tentry;			/* entry point */
7000dcb4:	e51b2010 	ldr	r2, [fp, #-16]
7000dcb8:	e51b3008 	ldr	r3, [fp, #-8]
7000dcbc:	e5832000 	str	r2, [r3]
	*(--stk) = (rt_uint32_t)texit;			/* lr */
7000dcc0:	e51b3008 	ldr	r3, [fp, #-8]
7000dcc4:	e2433004 	sub	r3, r3, #4
7000dcc8:	e50b3008 	str	r3, [fp, #-8]
7000dccc:	e51b201c 	ldr	r2, [fp, #-28]
7000dcd0:	e51b3008 	ldr	r3, [fp, #-8]
7000dcd4:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r12 */
7000dcd8:	e51b3008 	ldr	r3, [fp, #-8]
7000dcdc:	e2433004 	sub	r3, r3, #4
7000dce0:	e50b3008 	str	r3, [fp, #-8]
7000dce4:	e51b3008 	ldr	r3, [fp, #-8]
7000dce8:	e3a02000 	mov	r2, #0
7000dcec:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r11 */
7000dcf0:	e51b3008 	ldr	r3, [fp, #-8]
7000dcf4:	e2433004 	sub	r3, r3, #4
7000dcf8:	e50b3008 	str	r3, [fp, #-8]
7000dcfc:	e51b3008 	ldr	r3, [fp, #-8]
7000dd00:	e3a02000 	mov	r2, #0
7000dd04:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r10 */
7000dd08:	e51b3008 	ldr	r3, [fp, #-8]
7000dd0c:	e2433004 	sub	r3, r3, #4
7000dd10:	e50b3008 	str	r3, [fp, #-8]
7000dd14:	e51b3008 	ldr	r3, [fp, #-8]
7000dd18:	e3a02000 	mov	r2, #0
7000dd1c:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r9 */
7000dd20:	e51b3008 	ldr	r3, [fp, #-8]
7000dd24:	e2433004 	sub	r3, r3, #4
7000dd28:	e50b3008 	str	r3, [fp, #-8]
7000dd2c:	e51b3008 	ldr	r3, [fp, #-8]
7000dd30:	e3a02000 	mov	r2, #0
7000dd34:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r8 */
7000dd38:	e51b3008 	ldr	r3, [fp, #-8]
7000dd3c:	e2433004 	sub	r3, r3, #4
7000dd40:	e50b3008 	str	r3, [fp, #-8]
7000dd44:	e51b3008 	ldr	r3, [fp, #-8]
7000dd48:	e3a02000 	mov	r2, #0
7000dd4c:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r7 */
7000dd50:	e51b3008 	ldr	r3, [fp, #-8]
7000dd54:	e2433004 	sub	r3, r3, #4
7000dd58:	e50b3008 	str	r3, [fp, #-8]
7000dd5c:	e51b3008 	ldr	r3, [fp, #-8]
7000dd60:	e3a02000 	mov	r2, #0
7000dd64:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r6 */
7000dd68:	e51b3008 	ldr	r3, [fp, #-8]
7000dd6c:	e2433004 	sub	r3, r3, #4
7000dd70:	e50b3008 	str	r3, [fp, #-8]
7000dd74:	e51b3008 	ldr	r3, [fp, #-8]
7000dd78:	e3a02000 	mov	r2, #0
7000dd7c:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r5 */
7000dd80:	e51b3008 	ldr	r3, [fp, #-8]
7000dd84:	e2433004 	sub	r3, r3, #4
7000dd88:	e50b3008 	str	r3, [fp, #-8]
7000dd8c:	e51b3008 	ldr	r3, [fp, #-8]
7000dd90:	e3a02000 	mov	r2, #0
7000dd94:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r4 */
7000dd98:	e51b3008 	ldr	r3, [fp, #-8]
7000dd9c:	e2433004 	sub	r3, r3, #4
7000dda0:	e50b3008 	str	r3, [fp, #-8]
7000dda4:	e51b3008 	ldr	r3, [fp, #-8]
7000dda8:	e3a02000 	mov	r2, #0
7000ddac:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r3 */
7000ddb0:	e51b3008 	ldr	r3, [fp, #-8]
7000ddb4:	e2433004 	sub	r3, r3, #4
7000ddb8:	e50b3008 	str	r3, [fp, #-8]
7000ddbc:	e51b3008 	ldr	r3, [fp, #-8]
7000ddc0:	e3a02000 	mov	r2, #0
7000ddc4:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r2 */
7000ddc8:	e51b3008 	ldr	r3, [fp, #-8]
7000ddcc:	e2433004 	sub	r3, r3, #4
7000ddd0:	e50b3008 	str	r3, [fp, #-8]
7000ddd4:	e51b3008 	ldr	r3, [fp, #-8]
7000ddd8:	e3a02000 	mov	r2, #0
7000dddc:	e5832000 	str	r2, [r3]
	*(--stk) = 0;							/* r1 */
7000dde0:	e51b3008 	ldr	r3, [fp, #-8]
7000dde4:	e2433004 	sub	r3, r3, #4
7000dde8:	e50b3008 	str	r3, [fp, #-8]
7000ddec:	e51b3008 	ldr	r3, [fp, #-8]
7000ddf0:	e3a02000 	mov	r2, #0
7000ddf4:	e5832000 	str	r2, [r3]
	*(--stk) = (rt_uint32_t)parameter;		/* r0 : argument */
7000ddf8:	e51b3008 	ldr	r3, [fp, #-8]
7000ddfc:	e2433004 	sub	r3, r3, #4
7000de00:	e50b3008 	str	r3, [fp, #-8]
7000de04:	e51b2014 	ldr	r2, [fp, #-20]
7000de08:	e51b3008 	ldr	r3, [fp, #-8]
7000de0c:	e5832000 	str	r2, [r3]

	/* cpsr */
	if ((rt_uint32_t)tentry & 0x01)
7000de10:	e51b3010 	ldr	r3, [fp, #-16]
7000de14:	e2033001 	and	r3, r3, #1
7000de18:	e3530000 	cmp	r3, #0
7000de1c:	0a000006 	beq	7000de3c <rt_hw_stack_init+0x1ac>
		*(--stk) = SVCMODE | 0x20;			/* thumb mode */
7000de20:	e51b3008 	ldr	r3, [fp, #-8]
7000de24:	e2433004 	sub	r3, r3, #4
7000de28:	e50b3008 	str	r3, [fp, #-8]
7000de2c:	e51b3008 	ldr	r3, [fp, #-8]
7000de30:	e3a02033 	mov	r2, #51	; 0x33
7000de34:	e5832000 	str	r2, [r3]
7000de38:	ea000005 	b	7000de54 <rt_hw_stack_init+0x1c4>
	else
		*(--stk) = SVCMODE;					/* arm mode   */
7000de3c:	e51b3008 	ldr	r3, [fp, #-8]
7000de40:	e2433004 	sub	r3, r3, #4
7000de44:	e50b3008 	str	r3, [fp, #-8]
7000de48:	e51b3008 	ldr	r3, [fp, #-8]
7000de4c:	e3a02013 	mov	r2, #19
7000de50:	e5832000 	str	r2, [r3]

	/* return task's current stack address */
	return (rt_uint8_t *)stk;
7000de54:	e51b3008 	ldr	r3, [fp, #-8]
}
7000de58:	e1a00003 	mov	r0, r3
7000de5c:	e24bd000 	sub	sp, fp, #0
7000de60:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000de64:	e12fff1e 	bx	lr

7000de68 <rt_hw_show_register>:
 * this function will show registers of CPU
 *
 * @param regs the registers point
 */
void rt_hw_show_register(struct rt_hw_exp_stack *regs)
{
7000de68:	e92d4800 	push	{fp, lr}
7000de6c:	e28db004 	add	fp, sp, #4
7000de70:	e24dd010 	sub	sp, sp, #16
7000de74:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("Execption:\n");
7000de78:	e3070134 	movw	r0, #28980	; 0x7134
7000de7c:	e3470002 	movt	r0, #28674	; 0x7002
7000de80:	ebffe65b 	bl	700077f4 <rt_kprintf>
    rt_kprintf("r00:0x%08x r01:0x%08x r02:0x%08x r03:0x%08x\n", regs->r0, regs->r1, regs->r2, regs->r3);
7000de84:	e51b3008 	ldr	r3, [fp, #-8]
7000de88:	e5931000 	ldr	r1, [r3]
7000de8c:	e51b3008 	ldr	r3, [fp, #-8]
7000de90:	e5932004 	ldr	r2, [r3, #4]
7000de94:	e51b3008 	ldr	r3, [fp, #-8]
7000de98:	e5933008 	ldr	r3, [r3, #8]
7000de9c:	e51b0008 	ldr	r0, [fp, #-8]
7000dea0:	e590000c 	ldr	r0, [r0, #12]
7000dea4:	e58d0000 	str	r0, [sp]
7000dea8:	e3070140 	movw	r0, #28992	; 0x7140
7000deac:	e3470002 	movt	r0, #28674	; 0x7002
7000deb0:	ebffe64f 	bl	700077f4 <rt_kprintf>
    rt_kprintf("r04:0x%08x r05:0x%08x r06:0x%08x r07:0x%08x\n", regs->r4, regs->r5, regs->r6, regs->r7);
7000deb4:	e51b3008 	ldr	r3, [fp, #-8]
7000deb8:	e5931010 	ldr	r1, [r3, #16]
7000debc:	e51b3008 	ldr	r3, [fp, #-8]
7000dec0:	e5932014 	ldr	r2, [r3, #20]
7000dec4:	e51b3008 	ldr	r3, [fp, #-8]
7000dec8:	e5933018 	ldr	r3, [r3, #24]
7000decc:	e51b0008 	ldr	r0, [fp, #-8]
7000ded0:	e590001c 	ldr	r0, [r0, #28]
7000ded4:	e58d0000 	str	r0, [sp]
7000ded8:	e3070170 	movw	r0, #29040	; 0x7170
7000dedc:	e3470002 	movt	r0, #28674	; 0x7002
7000dee0:	ebffe643 	bl	700077f4 <rt_kprintf>
    rt_kprintf("r08:0x%08x r09:0x%08x r10:0x%08x\n", regs->r8, regs->r9, regs->r10);
7000dee4:	e51b3008 	ldr	r3, [fp, #-8]
7000dee8:	e5931020 	ldr	r1, [r3, #32]
7000deec:	e51b3008 	ldr	r3, [fp, #-8]
7000def0:	e5932024 	ldr	r2, [r3, #36]	; 0x24
7000def4:	e51b3008 	ldr	r3, [fp, #-8]
7000def8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
7000defc:	e30701a0 	movw	r0, #29088	; 0x71a0
7000df00:	e3470002 	movt	r0, #28674	; 0x7002
7000df04:	ebffe63a 	bl	700077f4 <rt_kprintf>
    rt_kprintf("fp :0x%08x ip :0x%08x\n", regs->fp, regs->ip);
7000df08:	e51b3008 	ldr	r3, [fp, #-8]
7000df0c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
7000df10:	e51b3008 	ldr	r3, [fp, #-8]
7000df14:	e5933030 	ldr	r3, [r3, #48]	; 0x30
7000df18:	e30701c4 	movw	r0, #29124	; 0x71c4
7000df1c:	e3470002 	movt	r0, #28674	; 0x7002
7000df20:	e1a01002 	mov	r1, r2
7000df24:	e1a02003 	mov	r2, r3
7000df28:	ebffe631 	bl	700077f4 <rt_kprintf>
    rt_kprintf("sp :0x%08x lr :0x%08x pc :0x%08x\n", regs->sp, regs->lr, regs->pc);
7000df2c:	e51b3008 	ldr	r3, [fp, #-8]
7000df30:	e5931034 	ldr	r1, [r3, #52]	; 0x34
7000df34:	e51b3008 	ldr	r3, [fp, #-8]
7000df38:	e5932038 	ldr	r2, [r3, #56]	; 0x38
7000df3c:	e51b3008 	ldr	r3, [fp, #-8]
7000df40:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
7000df44:	e30701dc 	movw	r0, #29148	; 0x71dc
7000df48:	e3470002 	movt	r0, #28674	; 0x7002
7000df4c:	ebffe628 	bl	700077f4 <rt_kprintf>
    rt_kprintf("cpsr:0x%08x\n", regs->cpsr);
7000df50:	e51b3008 	ldr	r3, [fp, #-8]
7000df54:	e5933040 	ldr	r3, [r3, #64]	; 0x40
7000df58:	e3070200 	movw	r0, #29184	; 0x7200
7000df5c:	e3470002 	movt	r0, #28674	; 0x7002
7000df60:	e1a01003 	mov	r1, r3
7000df64:	ebffe622 	bl	700077f4 <rt_kprintf>
}
7000df68:	e24bd004 	sub	sp, fp, #4
7000df6c:	e8bd8800 	pop	{fp, pc}

7000df70 <rt_hw_trap_undef>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_undef(struct rt_hw_exp_stack *regs)
{
7000df70:	e92d4800 	push	{fp, lr}
7000df74:	e28db004 	add	fp, sp, #4
7000df78:	e24dd008 	sub	sp, sp, #8
7000df7c:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("undefined instruction:\n");
7000df80:	e3070210 	movw	r0, #29200	; 0x7210
7000df84:	e3470002 	movt	r0, #28674	; 0x7002
7000df88:	ebffe619 	bl	700077f4 <rt_kprintf>
    rt_hw_show_register(regs);
7000df8c:	e51b0008 	ldr	r0, [fp, #-8]
7000df90:	ebffffb4 	bl	7000de68 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
7000df94:	eb0007b6 	bl	7000fe74 <list_thread>
#endif
    rt_hw_cpu_shutdown();
7000df98:	ebfff7cc 	bl	7000bed0 <rt_hw_cpu_shutdown>
}
7000df9c:	e24bd004 	sub	sp, fp, #4
7000dfa0:	e8bd8800 	pop	{fp, pc}

7000dfa4 <rt_hw_trap_swi>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_swi(struct rt_hw_exp_stack *regs)
{
7000dfa4:	e92d4800 	push	{fp, lr}
7000dfa8:	e28db004 	add	fp, sp, #4
7000dfac:	e24dd008 	sub	sp, sp, #8
7000dfb0:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("software interrupt:\n");
7000dfb4:	e3070228 	movw	r0, #29224	; 0x7228
7000dfb8:	e3470002 	movt	r0, #28674	; 0x7002
7000dfbc:	ebffe60c 	bl	700077f4 <rt_kprintf>
    rt_hw_show_register(regs);
7000dfc0:	e51b0008 	ldr	r0, [fp, #-8]
7000dfc4:	ebffffa7 	bl	7000de68 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
7000dfc8:	eb0007a9 	bl	7000fe74 <list_thread>
#endif
    rt_hw_cpu_shutdown();
7000dfcc:	ebfff7bf 	bl	7000bed0 <rt_hw_cpu_shutdown>
}
7000dfd0:	e24bd004 	sub	sp, fp, #4
7000dfd4:	e8bd8800 	pop	{fp, pc}

7000dfd8 <rt_hw_trap_pabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_pabt(struct rt_hw_exp_stack *regs)
{
7000dfd8:	e92d4800 	push	{fp, lr}
7000dfdc:	e28db004 	add	fp, sp, #4
7000dfe0:	e24dd008 	sub	sp, sp, #8
7000dfe4:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("prefetch abort:\n");
7000dfe8:	e3070240 	movw	r0, #29248	; 0x7240
7000dfec:	e3470002 	movt	r0, #28674	; 0x7002
7000dff0:	ebffe5ff 	bl	700077f4 <rt_kprintf>
    rt_hw_show_register(regs);
7000dff4:	e51b0008 	ldr	r0, [fp, #-8]
7000dff8:	ebffff9a 	bl	7000de68 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
7000dffc:	eb00079c 	bl	7000fe74 <list_thread>
#endif
    rt_hw_cpu_shutdown();
7000e000:	ebfff7b2 	bl	7000bed0 <rt_hw_cpu_shutdown>
}
7000e004:	e24bd004 	sub	sp, fp, #4
7000e008:	e8bd8800 	pop	{fp, pc}

7000e00c <rt_hw_trap_dabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_dabt(struct rt_hw_exp_stack *regs)
{
7000e00c:	e92d4800 	push	{fp, lr}
7000e010:	e28db004 	add	fp, sp, #4
7000e014:	e24dd008 	sub	sp, sp, #8
7000e018:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("data abort:");
7000e01c:	e3070254 	movw	r0, #29268	; 0x7254
7000e020:	e3470002 	movt	r0, #28674	; 0x7002
7000e024:	ebffe5f2 	bl	700077f4 <rt_kprintf>
    rt_hw_show_register(regs);
7000e028:	e51b0008 	ldr	r0, [fp, #-8]
7000e02c:	ebffff8d 	bl	7000de68 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
7000e030:	eb00078f 	bl	7000fe74 <list_thread>
#endif
    rt_hw_cpu_shutdown();
7000e034:	ebfff7a5 	bl	7000bed0 <rt_hw_cpu_shutdown>
}
7000e038:	e24bd004 	sub	sp, fp, #4
7000e03c:	e8bd8800 	pop	{fp, pc}

7000e040 <rt_hw_trap_resv>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_resv(struct rt_hw_exp_stack *regs)
{
7000e040:	e92d4800 	push	{fp, lr}
7000e044:	e28db004 	add	fp, sp, #4
7000e048:	e24dd008 	sub	sp, sp, #8
7000e04c:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("reserved trap:\n");
7000e050:	e3070260 	movw	r0, #29280	; 0x7260
7000e054:	e3470002 	movt	r0, #28674	; 0x7002
7000e058:	ebffe5e5 	bl	700077f4 <rt_kprintf>
    rt_hw_show_register(regs);
7000e05c:	e51b0008 	ldr	r0, [fp, #-8]
7000e060:	ebffff80 	bl	7000de68 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
7000e064:	eb000782 	bl	7000fe74 <list_thread>
#endif
    rt_hw_cpu_shutdown();
7000e068:	ebfff798 	bl	7000bed0 <rt_hw_cpu_shutdown>
}
7000e06c:	e24bd004 	sub	sp, fp, #4
7000e070:	e8bd8800 	pop	{fp, pc}

7000e074 <rt_hw_trap_irq>:

#define GIC_ACK_INTID_MASK					0x000003ff

void rt_hw_trap_irq(void)
{
7000e074:	e92d4800 	push	{fp, lr}
7000e078:	e28db004 	add	fp, sp, #4
7000e07c:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
7000e080:	e3a00000 	mov	r0, #0
7000e084:	ebfff7be 	bl	7000bf84 <arm_gic_get_active_irq>
7000e088:	e1a03000 	mov	r3, r0
7000e08c:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
7000e090:	e51b3008 	ldr	r3, [fp, #-8]
7000e094:	e7e93053 	ubfx	r3, r3, #0, #10
7000e098:	e50b300c 	str	r3, [fp, #-12]

    if (ir == 1023)
7000e09c:	e51b200c 	ldr	r2, [fp, #-12]
7000e0a0:	e30033ff 	movw	r3, #1023	; 0x3ff
7000e0a4:	e1520003 	cmp	r2, r3
7000e0a8:	1a000000 	bne	7000e0b0 <rt_hw_trap_irq+0x3c>
    {
        /* Spurious interrupt */
        return;
7000e0ac:	ea000038 	b	7000e194 <rt_hw_trap_irq+0x120>
    }

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
7000e0b0:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e0b4:	e3472002 	movt	r2, #28674	; 0x7002
7000e0b8:	e51b100c 	ldr	r1, [fp, #-12]
7000e0bc:	e1a03001 	mov	r3, r1
7000e0c0:	e1a03103 	lsl	r3, r3, #2
7000e0c4:	e0833001 	add	r3, r3, r1
7000e0c8:	e1a03103 	lsl	r3, r3, #2
7000e0cc:	e0823003 	add	r3, r2, r3
7000e0d0:	e5933000 	ldr	r3, [r3]
7000e0d4:	e50b3010 	str	r3, [fp, #-16]
#ifdef RT_USING_INTERRUPT_INFO
    isr_table[ir].counter++;
7000e0d8:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e0dc:	e3472002 	movt	r2, #28674	; 0x7002
7000e0e0:	e51b100c 	ldr	r1, [fp, #-12]
7000e0e4:	e3a00010 	mov	r0, #16
7000e0e8:	e1a03001 	mov	r3, r1
7000e0ec:	e1a03103 	lsl	r3, r3, #2
7000e0f0:	e0833001 	add	r3, r3, r1
7000e0f4:	e1a03103 	lsl	r3, r3, #2
7000e0f8:	e0823003 	add	r3, r2, r3
7000e0fc:	e0833000 	add	r3, r3, r0
7000e100:	e5933000 	ldr	r3, [r3]
7000e104:	e2830001 	add	r0, r3, #1
7000e108:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e10c:	e3472002 	movt	r2, #28674	; 0x7002
7000e110:	e51b100c 	ldr	r1, [fp, #-12]
7000e114:	e3a0c010 	mov	ip, #16
7000e118:	e1a03001 	mov	r3, r1
7000e11c:	e1a03103 	lsl	r3, r3, #2
7000e120:	e0833001 	add	r3, r3, r1
7000e124:	e1a03103 	lsl	r3, r3, #2
7000e128:	e0823003 	add	r3, r2, r3
7000e12c:	e083300c 	add	r3, r3, ip
7000e130:	e5830000 	str	r0, [r3]
#endif
    if (isr_func)
7000e134:	e51b3010 	ldr	r3, [fp, #-16]
7000e138:	e3530000 	cmp	r3, #0
7000e13c:	0a000010 	beq	7000e184 <rt_hw_trap_irq+0x110>
    {
        /* Interrupt for myself. */
        param = isr_table[ir].param;
7000e140:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e144:	e3472002 	movt	r2, #28674	; 0x7002
7000e148:	e51b100c 	ldr	r1, [fp, #-12]
7000e14c:	e3a00004 	mov	r0, #4
7000e150:	e1a03001 	mov	r3, r1
7000e154:	e1a03103 	lsl	r3, r3, #2
7000e158:	e0833001 	add	r3, r3, r1
7000e15c:	e1a03103 	lsl	r3, r3, #2
7000e160:	e0823003 	add	r3, r2, r3
7000e164:	e0833000 	add	r3, r3, r0
7000e168:	e5933000 	ldr	r3, [r3]
7000e16c:	e50b3014 	str	r3, [fp, #-20]
        /* turn to interrupt service routine */
        isr_func(ir, param);
7000e170:	e51b200c 	ldr	r2, [fp, #-12]
7000e174:	e51b3010 	ldr	r3, [fp, #-16]
7000e178:	e1a00002 	mov	r0, r2
7000e17c:	e51b1014 	ldr	r1, [fp, #-20]
7000e180:	e12fff33 	blx	r3
        return;
    }
#endif

    /* end of interrupt */
    arm_gic_ack(0, fullir);
7000e184:	e51b3008 	ldr	r3, [fp, #-8]
7000e188:	e3a00000 	mov	r0, #0
7000e18c:	e1a01003 	mov	r1, r3
7000e190:	ebfff7be 	bl	7000c090 <arm_gic_ack>
}
7000e194:	e24bd004 	sub	sp, fp, #4
7000e198:	e8bd8800 	pop	{fp, pc}

7000e19c <rt_hw_trap_fiq>:

void rt_hw_trap_fiq(void)
{
7000e19c:	e92d4800 	push	{fp, lr}
7000e1a0:	e28db004 	add	fp, sp, #4
7000e1a4:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
7000e1a8:	e3a00000 	mov	r0, #0
7000e1ac:	ebfff774 	bl	7000bf84 <arm_gic_get_active_irq>
7000e1b0:	e1a03000 	mov	r3, r0
7000e1b4:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
7000e1b8:	e51b3008 	ldr	r3, [fp, #-8]
7000e1bc:	e7e93053 	ubfx	r3, r3, #0, #10
7000e1c0:	e50b300c 	str	r3, [fp, #-12]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
7000e1c4:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e1c8:	e3472002 	movt	r2, #28674	; 0x7002
7000e1cc:	e51b100c 	ldr	r1, [fp, #-12]
7000e1d0:	e1a03001 	mov	r3, r1
7000e1d4:	e1a03103 	lsl	r3, r3, #2
7000e1d8:	e0833001 	add	r3, r3, r1
7000e1dc:	e1a03103 	lsl	r3, r3, #2
7000e1e0:	e0823003 	add	r3, r2, r3
7000e1e4:	e5933000 	ldr	r3, [r3]
7000e1e8:	e50b3010 	str	r3, [fp, #-16]
    param = isr_table[ir].param;
7000e1ec:	e30a2c98 	movw	r2, #44184	; 0xac98
7000e1f0:	e3472002 	movt	r2, #28674	; 0x7002
7000e1f4:	e51b100c 	ldr	r1, [fp, #-12]
7000e1f8:	e3a00004 	mov	r0, #4
7000e1fc:	e1a03001 	mov	r3, r1
7000e200:	e1a03103 	lsl	r3, r3, #2
7000e204:	e0833001 	add	r3, r3, r1
7000e208:	e1a03103 	lsl	r3, r3, #2
7000e20c:	e0823003 	add	r3, r2, r3
7000e210:	e0833000 	add	r3, r3, r0
7000e214:	e5933000 	ldr	r3, [r3]
7000e218:	e50b3014 	str	r3, [fp, #-20]

    /* turn to interrupt service routine */
    isr_func(ir, param);
7000e21c:	e51b200c 	ldr	r2, [fp, #-12]
7000e220:	e51b3010 	ldr	r3, [fp, #-16]
7000e224:	e1a00002 	mov	r0, r2
7000e228:	e51b1014 	ldr	r1, [fp, #-20]
7000e22c:	e12fff33 	blx	r3

    /* end of interrupt */
    arm_gic_ack(0, fullir);
7000e230:	e51b3008 	ldr	r3, [fp, #-8]
7000e234:	e3a00000 	mov	r0, #0
7000e238:	e1a01003 	mov	r1, r3
7000e23c:	ebfff793 	bl	7000c090 <arm_gic_ack>
}
7000e240:	e24bd004 	sub	sp, fp, #4
7000e244:	e8bd8800 	pop	{fp, pc}

7000e248 <rt_hw_interrupt_disable>:
/*
 * rt_base_t rt_hw_interrupt_disable();
 */
.globl rt_hw_interrupt_disable
rt_hw_interrupt_disable:
    mrs r0, cpsr
7000e248:	e10f0000 	mrs	r0, CPSR
    cpsid i
7000e24c:	f10c0080 	cpsid	i
    bx  lr
7000e250:	e12fff1e 	bx	lr

7000e254 <rt_hw_interrupt_enable>:
/*
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.globl rt_hw_interrupt_enable
rt_hw_interrupt_enable:
    msr cpsr, r0
7000e254:	e129f000 	msr	CPSR_fc, r0
    bx  lr
7000e258:	e12fff1e 	bx	lr

7000e25c <rt_hw_context_switch_to>:
 * void rt_hw_context_switch_to(rt_uint32 to);
 * r0 --> to
 */
.globl rt_hw_context_switch_to
rt_hw_context_switch_to:
    ldr sp, [r0]            @ get new task stack pointer
7000e25c:	e590d000 	ldr	sp, [r0]

    ldmfd sp!, {r4}         @ pop new task spsr
7000e260:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
7000e264:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd sp!, {r0-r12, lr, pc}^   @ pop new task r0-r12, lr & pc
7000e268:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

7000e26c <rt_cpu_get_smp_id>:
 * 2013-07-05     Bernard      the first version
 */

.globl rt_cpu_get_smp_id
rt_cpu_get_smp_id:
    mrc     p15, #0, r0, c0, c0, #5
7000e26c:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
    bx      lr
7000e270:	e12fff1e 	bx	lr

7000e274 <rt_cpu_vector_set_base>:

.globl rt_cpu_vector_set_base
rt_cpu_vector_set_base:
    mcr     p15, #0, r0, c12, c0, #0
7000e274:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
    dsb
7000e278:	f57ff04f 	dsb	sy
    bx      lr
7000e27c:	e12fff1e 	bx	lr

7000e280 <rt_hw_cpu_dcache_enable>:

.globl rt_hw_cpu_dcache_enable
rt_hw_cpu_dcache_enable:
    mrc     p15, #0, r0, c1, c0, #0
7000e280:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00000004
7000e284:	e3800004 	orr	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
7000e288:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
7000e28c:	e12fff1e 	bx	lr

7000e290 <rt_hw_cpu_icache_enable>:

.globl rt_hw_cpu_icache_enable
rt_hw_cpu_icache_enable:
    mrc     p15, #0, r0, c1, c0, #0
7000e290:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00001000
7000e294:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
7000e298:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
7000e29c:	e12fff1e 	bx	lr

7000e2a0 <_FLD_MAX_WAY>:
7000e2a0:	000003ff 	.word	0x000003ff

7000e2a4 <_FLD_MAX_IDX>:
7000e2a4:	000007ff 	.word	0x000007ff

7000e2a8 <rt_cpu_dcache_clean_flush>:
_FLD_MAX_IDX:
   .word  0x7ff

.globl rt_cpu_dcache_clean_flush
rt_cpu_dcache_clean_flush:
    push    {r4-r11}
7000e2a8:	e92d0ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp}
    dmb
7000e2ac:	f57ff05f 	dmb	sy
    mrc     p15, #1, r0, c0, c0, #1  @ read clid register
7000e2b0:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ands    r3, r0, #0x7000000       @ get level of coherency
7000e2b4:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    mov     r3, r3, lsr #23
7000e2b8:	e1a03ba3 	lsr	r3, r3, #23
    beq     finished
7000e2bc:	0a00001a 	beq	7000e32c <finished>
    mov     r10, #0
7000e2c0:	e3a0a000 	mov	sl, #0

7000e2c4 <loop1>:
loop1:
    add     r2, r10, r10, lsr #1
7000e2c4:	e08a20aa 	add	r2, sl, sl, lsr #1
    mov     r1, r0, lsr r2
7000e2c8:	e1a01230 	lsr	r1, r0, r2
    and     r1, r1, #7
7000e2cc:	e2011007 	and	r1, r1, #7
    cmp     r1, #2
7000e2d0:	e3510002 	cmp	r1, #2
    blt     skip
7000e2d4:	ba000011 	blt	7000e320 <skip>
    mcr     p15, #2, r10, c0, c0, #0
7000e2d8:	ee40af10 	mcr	15, 2, sl, cr0, cr0, {0}
    isb
7000e2dc:	f57ff06f 	isb	sy
    mrc     p15, #1, r1, c0, c0, #0
7000e2e0:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    and     r2, r1, #7
7000e2e4:	e2012007 	and	r2, r1, #7
    add     r2, r2, #4
7000e2e8:	e2822004 	add	r2, r2, #4
    ldr     r4, _FLD_MAX_WAY
7000e2ec:	e51f4054 	ldr	r4, [pc, #-84]	; 7000e2a0 <_FLD_MAX_WAY>
    ands    r4, r4, r1, lsr #3
7000e2f0:	e01441a1 	ands	r4, r4, r1, lsr #3
    clz     r5, r4
7000e2f4:	e16f5f14 	clz	r5, r4
    ldr     r7, _FLD_MAX_IDX
7000e2f8:	e51f705c 	ldr	r7, [pc, #-92]	; 7000e2a4 <_FLD_MAX_IDX>
    ands    r7, r7, r1, lsr #13
7000e2fc:	e01776a1 	ands	r7, r7, r1, lsr #13

7000e300 <loop2>:
loop2:
    mov     r9, r4
7000e300:	e1a09004 	mov	r9, r4

7000e304 <loop3>:
loop3:
    orr     r11, r10, r9, lsl r5
7000e304:	e18ab519 	orr	fp, sl, r9, lsl r5
    orr     r11, r11, r7, lsl r2
7000e308:	e18bb217 	orr	fp, fp, r7, lsl r2
    mcr     p15, #0, r11, c7, c14, #2
7000e30c:	ee07bf5e 	mcr	15, 0, fp, cr7, cr14, {2}
    subs    r9, r9, #1
7000e310:	e2599001 	subs	r9, r9, #1
    bge     loop3
7000e314:	aafffffa 	bge	7000e304 <loop3>
    subs    r7, r7, #1
7000e318:	e2577001 	subs	r7, r7, #1
    bge     loop2
7000e31c:	aafffff7 	bge	7000e300 <loop2>

7000e320 <skip>:
skip:
    add     r10, r10, #2
7000e320:	e28aa002 	add	sl, sl, #2
    cmp     r3, r10
7000e324:	e153000a 	cmp	r3, sl
    bgt     loop1
7000e328:	caffffe5 	bgt	7000e2c4 <loop1>

7000e32c <finished>:

finished:
    dsb
7000e32c:	f57ff04f 	dsb	sy
    isb
7000e330:	f57ff06f 	isb	sy
    pop     {r4-r11}
7000e334:	e8bd0ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp}
    bx      lr
7000e338:	e12fff1e 	bx	lr

7000e33c <rt_hw_cpu_dcache_disable>:

.globl rt_hw_cpu_dcache_disable
rt_hw_cpu_dcache_disable:
    push    {r4-r11, lr}
7000e33c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bl      rt_cpu_dcache_clean_flush
7000e340:	ebffffd8 	bl	7000e2a8 <rt_cpu_dcache_clean_flush>
    mrc     p15, #0, r0, c1, c0, #0
7000e344:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00000004
7000e348:	e3c00004 	bic	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
7000e34c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    pop     {r4-r11, lr}
7000e350:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bx      lr
7000e354:	e12fff1e 	bx	lr

7000e358 <rt_hw_cpu_icache_disable>:

.globl rt_hw_cpu_icache_disable
rt_hw_cpu_icache_disable:
    mrc     p15, #0, r0, c1, c0, #0
7000e358:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00001000
7000e35c:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
7000e360:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
7000e364:	e12fff1e 	bx	lr

7000e368 <rt_cpu_mmu_disable>:

.globl rt_cpu_mmu_disable
rt_cpu_mmu_disable:
    mcr     p15, #0, r0, c8, c7, #0    @ invalidate tlb
7000e368:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    mrc     p15, #0, r0, c1, c0, #0
7000e36c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, r0, #1
7000e370:	e3c00001 	bic	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ clear mmu bit
7000e374:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
7000e378:	f57ff04f 	dsb	sy
    bx      lr
7000e37c:	e12fff1e 	bx	lr

7000e380 <rt_cpu_mmu_enable>:

.globl rt_cpu_mmu_enable
rt_cpu_mmu_enable:
    mrc     p15, #0, r0, c1, c0, #0
7000e380:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, r0, #0x001
7000e384:	e3800001 	orr	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ set mmu enable bit
7000e388:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
7000e38c:	f57ff04f 	dsb	sy
    bx      lr
7000e390:	e12fff1e 	bx	lr

7000e394 <rt_cpu_tlb_set>:

.globl rt_cpu_tlb_set
rt_cpu_tlb_set:
    mcr     p15, #0, r0, c2, c0, #0
7000e394:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
    dmb
7000e398:	f57ff05f 	dmb	sy
    bx      lr
7000e39c:	e12fff1e 	bx	lr

7000e3a0 <_reset>:
#ifdef RT_USING_VMM
    /* save all the parameter and variable registers */
    stmfd   sp!, {r0-r12, lr}
#endif
    /* set the cpu to SVC32 mode and disable interrupt */
    mrs     r0, cpsr
7000e3a0:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #0x1f
7000e3a4:	e3c0001f 	bic	r0, r0, #31
    orr     r0, r0, #0x13
7000e3a8:	e3800013 	orr	r0, r0, #19
    msr     cpsr_c, r0
7000e3ac:	e121f000 	msr	CPSR_c, r0

    /* setup stack */
    bl      stack_setup
7000e3b0:	eb000011 	bl	7000e3fc <stack_setup>

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
7000e3b4:	e3a00000 	mov	r0, #0
    ldr     r1,=__bss_start         /* bss start                        */
7000e3b8:	e59f107c 	ldr	r1, [pc, #124]	; 7000e43c <stack_setup+0x40>
    ldr     r2,=__bss_end           /* bss end                          */
7000e3bc:	e59f207c 	ldr	r2, [pc, #124]	; 7000e440 <stack_setup+0x44>

7000e3c0 <bss_loop>:

bss_loop:
    cmp     r1,r2                   /* check if data to clear           */
7000e3c0:	e1510002 	cmp	r1, r2
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
7000e3c4:	34810004 	strcc	r0, [r1], #4
    blo     bss_loop                /* loop until done                  */
7000e3c8:	3afffffc 	bcc	7000e3c0 <bss_loop>
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
    blo     bss_share_loop                /* loop until done                  */
#endif

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
7000e3cc:	e59f0070 	ldr	r0, [pc, #112]	; 7000e444 <stack_setup+0x48>
    ldr     r1, =__ctors_end__
7000e3d0:	e59f1070 	ldr	r1, [pc, #112]	; 7000e448 <stack_setup+0x4c>

7000e3d4 <ctor_loop>:

ctor_loop:
    cmp     r0, r1
7000e3d4:	e1500001 	cmp	r0, r1
    beq     ctor_end
7000e3d8:	0a000005 	beq	7000e3f4 <ctor_end>
    ldr     r2, [r0], #4
7000e3dc:	e4902004 	ldr	r2, [r0], #4
    stmfd   sp!, {r0-r1}
7000e3e0:	e92d0003 	push	{r0, r1}
    mov     lr, pc
7000e3e4:	e1a0e00f 	mov	lr, pc
    bx      r2
7000e3e8:	e12fff12 	bx	r2
    ldmfd   sp!, {r0-r1}
7000e3ec:	e8bd0003 	pop	{r0, r1}
    b       ctor_loop
7000e3f0:	eafffff7 	b	7000e3d4 <ctor_loop>

7000e3f4 <ctor_end>:
    /* restore the parameter */
    ldmfd   sp!, {r0-r3}
    bl      vmm_entry
    ldmfd   sp!, {r4-r12, pc}
#else
    ldr     pc, _rtthread_startup
7000e3f4:	e51ff004 	ldr	pc, [pc, #-4]	; 7000e3f8 <_rtthread_startup>

7000e3f8 <_rtthread_startup>:
7000e3f8:	700000bc 	.word	0x700000bc

7000e3fc <stack_setup>:
_rtthread_startup:
    .word rtthread_startup
#endif

stack_setup:
    ldr     r0, =stack_top
7000e3fc:	e59f0048 	ldr	r0, [pc, #72]	; 7000e44c <stack_setup+0x50>
    sub     r0, r0, #16
#endif

#ifndef RT_USING_VMM
    @  Set the startup stack for svc
    mov     sp, r0
7000e400:	e1a0d000 	mov	sp, r0
#endif

#ifndef RT_USING_VMM
    @  Enter Undefined Instruction Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_UND|I_Bit|F_Bit
7000e404:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    mov     sp, r0
7000e408:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #UND_Stack_Size
7000e40c:	e2400000 	sub	r0, r0, #0

    @  Enter Abort Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_ABT|I_Bit|F_Bit
7000e410:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    mov     sp, r0
7000e414:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #ABT_Stack_Size
7000e418:	e2400000 	sub	r0, r0, #0
#endif

    @  Enter FIQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_FIQ|I_Bit|F_Bit
7000e41c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    mov     sp, r0
7000e420:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #RT_FIQ_STACK_PGSZ
7000e424:	e2400000 	sub	r0, r0, #0

    @  Enter IRQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_IRQ|I_Bit|F_Bit
7000e428:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    mov     sp, r0
7000e42c:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #RT_IRQ_STACK_PGSZ
7000e430:	e2400c01 	sub	r0, r0, #256	; 0x100

    /* come back to SVC mode */
    msr     cpsr_c, #Mode_SVC|I_Bit|F_Bit
7000e434:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    bx      lr
7000e438:	e12fff1e 	bx	lr
    /* setup stack */
    bl      stack_setup

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
    ldr     r1,=__bss_start         /* bss start                        */
7000e43c:	7002954c 	.word	0x7002954c
    ldr     r2,=__bss_end           /* bss end                          */
7000e440:	7002b87c 	.word	0x7002b87c
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
    blo     bss_share_loop                /* loop until done                  */
#endif

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
7000e444:	70028d80 	.word	0x70028d80
    ldr     r1, =__ctors_end__
7000e448:	70028d80 	.word	0x70028d80
_rtthread_startup:
    .word rtthread_startup
#endif

stack_setup:
    ldr     r0, =stack_top
7000e44c:	700290a8 	.word	0x700290a8

7000e450 <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char* finsh_get_prompt()
{
7000e450:	e92d4800 	push	{fp, lr}
7000e454:	e28db004 	add	fp, sp, #4
    #define _MSH_PROMPT "msh "
    #define _PROMPT 	"finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
7000e458:	eb000af8 	bl	70011040 <msh_is_used>
7000e45c:	e1a03000 	mov	r3, r0
7000e460:	e3530000 	cmp	r3, #0
7000e464:	0a000008 	beq	7000e48c <finsh_get_prompt+0x3c>
7000e468:	e30a3988 	movw	r3, #43400	; 0xa988
7000e46c:	e3473002 	movt	r3, #28674	; 0x7002
7000e470:	e3072270 	movw	r2, #29296	; 0x7270
7000e474:	e3472002 	movt	r2, #28674	; 0x7002
7000e478:	e8920003 	ldm	r2, {r0, r1}
7000e47c:	e5830000 	str	r0, [r3]
7000e480:	e2833004 	add	r3, r3, #4
7000e484:	e5c31000 	strb	r1, [r3]
7000e488:	ea00000a 	b	7000e4b8 <finsh_get_prompt+0x68>
    else
#endif
    strcpy(finsh_prompt, _PROMPT);
7000e48c:	e30a3988 	movw	r3, #43400	; 0xa988
7000e490:	e3473002 	movt	r3, #28674	; 0x7002
7000e494:	e3072278 	movw	r2, #29304	; 0x7278
7000e498:	e3472002 	movt	r2, #28674	; 0x7002
7000e49c:	e8920003 	ldm	r2, {r0, r1}
7000e4a0:	e5830000 	str	r0, [r3]
7000e4a4:	e2833004 	add	r3, r3, #4
7000e4a8:	e1c310b0 	strh	r1, [r3]
7000e4ac:	e2833002 	add	r3, r3, #2
7000e4b0:	e1a02821 	lsr	r2, r1, #16
7000e4b4:	e5c32000 	strb	r2, [r3]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
7000e4b8:	e30a0988 	movw	r0, #43400	; 0xa988
7000e4bc:	e3470002 	movt	r0, #28674	; 0x7002
7000e4c0:	fa00579b 	blx	70024334 <strlen>
7000e4c4:	e1a03000 	mov	r3, r0
7000e4c8:	e1a02003 	mov	r2, r3
7000e4cc:	e30a3988 	movw	r3, #43400	; 0xa988
7000e4d0:	e3473002 	movt	r3, #28674	; 0x7002
7000e4d4:	e0822003 	add	r2, r2, r3
7000e4d8:	e3073280 	movw	r3, #29312	; 0x7280
7000e4dc:	e3473002 	movt	r3, #28674	; 0x7002
7000e4e0:	e1d330b0 	ldrh	r3, [r3]
7000e4e4:	e1c230b0 	strh	r3, [r2]

    return finsh_prompt;
7000e4e8:	e30a3988 	movw	r3, #43400	; 0xa988
7000e4ec:	e3473002 	movt	r3, #28674	; 0x7002
}
7000e4f0:	e1a00003 	mov	r0, r3
7000e4f4:	e8bd8800 	pop	{fp, pc}

7000e4f8 <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
7000e4f8:	e92d4800 	push	{fp, lr}
7000e4fc:	e28db004 	add	fp, sp, #4
7000e500:	e24dd010 	sub	sp, sp, #16
7000e504:	e50b0010 	str	r0, [fp, #-16]
7000e508:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(shell != RT_NULL);
7000e50c:	e30b3418 	movw	r3, #46104	; 0xb418
7000e510:	e3473002 	movt	r3, #28674	; 0x7002
7000e514:	e5933000 	ldr	r3, [r3]
7000e518:	e3530000 	cmp	r3, #0
7000e51c:	1a00001d 	bne	7000e598 <finsh_rx_ind+0xa0>
7000e520:	e3a03000 	mov	r3, #0
7000e524:	e54b3005 	strb	r3, [fp, #-5]
7000e528:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e52c:	e3473002 	movt	r3, #28674	; 0x7002
7000e530:	e5933000 	ldr	r3, [r3]
7000e534:	e3530000 	cmp	r3, #0
7000e538:	1a00000d 	bne	7000e574 <finsh_rx_ind+0x7c>
7000e53c:	e3070284 	movw	r0, #29316	; 0x7284
7000e540:	e3470002 	movt	r0, #28674	; 0x7002
7000e544:	e30712a4 	movw	r1, #29348	; 0x72a4
7000e548:	e3471002 	movt	r1, #28674	; 0x7002
7000e54c:	e3072364 	movw	r2, #29540	; 0x7364
7000e550:	e3472002 	movt	r2, #28674	; 0x7002
7000e554:	e3a03056 	mov	r3, #86	; 0x56
7000e558:	ebffe4a5 	bl	700077f4 <rt_kprintf>
7000e55c:	e1a00000 	nop			; (mov r0, r0)
7000e560:	e55b3005 	ldrb	r3, [fp, #-5]
7000e564:	e6ef3073 	uxtb	r3, r3
7000e568:	e3530000 	cmp	r3, #0
7000e56c:	0afffffb 	beq	7000e560 <finsh_rx_ind+0x68>
7000e570:	ea000008 	b	7000e598 <finsh_rx_ind+0xa0>
7000e574:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e578:	e3473002 	movt	r3, #28674	; 0x7002
7000e57c:	e5933000 	ldr	r3, [r3]
7000e580:	e30702a4 	movw	r0, #29348	; 0x72a4
7000e584:	e3470002 	movt	r0, #28674	; 0x7002
7000e588:	e3071364 	movw	r1, #29540	; 0x7364
7000e58c:	e3471002 	movt	r1, #28674	; 0x7002
7000e590:	e3a02056 	mov	r2, #86	; 0x56
7000e594:	e12fff33 	blx	r3

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
7000e598:	e30b3418 	movw	r3, #46104	; 0xb418
7000e59c:	e3473002 	movt	r3, #28674	; 0x7002
7000e5a0:	e5933000 	ldr	r3, [r3]
7000e5a4:	e1a00003 	mov	r0, r3
7000e5a8:	ebffcee8 	bl	70002150 <rt_sem_release>

    return RT_EOK;
7000e5ac:	e3a03000 	mov	r3, #0
}
7000e5b0:	e1a00003 	mov	r0, r3
7000e5b4:	e24bd004 	sub	sp, fp, #4
7000e5b8:	e8bd8800 	pop	{fp, pc}

7000e5bc <finsh_set_device>:
 * This function sets the input device of finsh shell.
 *
 * @param device_name the name of new input device.
 */
void finsh_set_device(const char* device_name)
{
7000e5bc:	e92d4800 	push	{fp, lr}
7000e5c0:	e28db004 	add	fp, sp, #4
7000e5c4:	e24dd010 	sub	sp, sp, #16
7000e5c8:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t dev = RT_NULL;
7000e5cc:	e3a03000 	mov	r3, #0
7000e5d0:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(shell != RT_NULL);
7000e5d4:	e30b3418 	movw	r3, #46104	; 0xb418
7000e5d8:	e3473002 	movt	r3, #28674	; 0x7002
7000e5dc:	e5933000 	ldr	r3, [r3]
7000e5e0:	e3530000 	cmp	r3, #0
7000e5e4:	1a00001d 	bne	7000e660 <finsh_set_device+0xa4>
7000e5e8:	e3a03000 	mov	r3, #0
7000e5ec:	e54b3009 	strb	r3, [fp, #-9]
7000e5f0:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e5f4:	e3473002 	movt	r3, #28674	; 0x7002
7000e5f8:	e5933000 	ldr	r3, [r3]
7000e5fc:	e3530000 	cmp	r3, #0
7000e600:	1a00000d 	bne	7000e63c <finsh_set_device+0x80>
7000e604:	e3070284 	movw	r0, #29316	; 0x7284
7000e608:	e3470002 	movt	r0, #28674	; 0x7002
7000e60c:	e30712a4 	movw	r1, #29348	; 0x72a4
7000e610:	e3471002 	movt	r1, #28674	; 0x7002
7000e614:	e3072374 	movw	r2, #29556	; 0x7374
7000e618:	e3472002 	movt	r2, #28674	; 0x7002
7000e61c:	e3a03069 	mov	r3, #105	; 0x69
7000e620:	ebffe473 	bl	700077f4 <rt_kprintf>
7000e624:	e1a00000 	nop			; (mov r0, r0)
7000e628:	e55b3009 	ldrb	r3, [fp, #-9]
7000e62c:	e6ef3073 	uxtb	r3, r3
7000e630:	e3530000 	cmp	r3, #0
7000e634:	0afffffb 	beq	7000e628 <finsh_set_device+0x6c>
7000e638:	ea000008 	b	7000e660 <finsh_set_device+0xa4>
7000e63c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e640:	e3473002 	movt	r3, #28674	; 0x7002
7000e644:	e5933000 	ldr	r3, [r3]
7000e648:	e30702a4 	movw	r0, #29348	; 0x72a4
7000e64c:	e3470002 	movt	r0, #28674	; 0x7002
7000e650:	e3071374 	movw	r1, #29556	; 0x7374
7000e654:	e3471002 	movt	r1, #28674	; 0x7002
7000e658:	e3a02069 	mov	r2, #105	; 0x69
7000e65c:	e12fff33 	blx	r3
    dev = rt_device_find(device_name);
7000e660:	e51b0010 	ldr	r0, [fp, #-16]
7000e664:	ebffc8ef 	bl	70000a28 <rt_device_find>
7000e668:	e50b0008 	str	r0, [fp, #-8]
    if (dev == RT_NULL)
7000e66c:	e51b3008 	ldr	r3, [fp, #-8]
7000e670:	e3530000 	cmp	r3, #0
7000e674:	1a000004 	bne	7000e68c <finsh_set_device+0xd0>
    {
        rt_kprintf("finsh: can not find device: %s\n", device_name);
7000e678:	e30702b8 	movw	r0, #29368	; 0x72b8
7000e67c:	e3470002 	movt	r0, #28674	; 0x7002
7000e680:	e51b1010 	ldr	r1, [fp, #-16]
7000e684:	ebffe45a 	bl	700077f4 <rt_kprintf>
        return;
7000e688:	ea00003b 	b	7000e77c <finsh_set_device+0x1c0>
    }

    /* check whether it's a same device */
    if (dev == shell->device) return;
7000e68c:	e30b3418 	movw	r3, #46104	; 0xb418
7000e690:	e3473002 	movt	r3, #28674	; 0x7002
7000e694:	e5933000 	ldr	r3, [r3]
7000e698:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
7000e69c:	e51b3008 	ldr	r3, [fp, #-8]
7000e6a0:	e1520003 	cmp	r2, r3
7000e6a4:	1a000000 	bne	7000e6ac <finsh_set_device+0xf0>
7000e6a8:	ea000033 	b	7000e77c <finsh_set_device+0x1c0>
    /* open this device and set the new device in finsh shell */
    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX |\
7000e6ac:	e51b0008 	ldr	r0, [fp, #-8]
7000e6b0:	e3001143 	movw	r1, #323	; 0x143
7000e6b4:	ebffc957 	bl	70000c18 <rt_device_open>
7000e6b8:	e1a03000 	mov	r3, r0
7000e6bc:	e3530000 	cmp	r3, #0
7000e6c0:	1a00002d 	bne	7000e77c <finsh_set_device+0x1c0>
                       RT_DEVICE_FLAG_STREAM) == RT_EOK)
    {
        if (shell->device != RT_NULL)
7000e6c4:	e30b3418 	movw	r3, #46104	; 0xb418
7000e6c8:	e3473002 	movt	r3, #28674	; 0x7002
7000e6cc:	e5933000 	ldr	r3, [r3]
7000e6d0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000e6d4:	e3530000 	cmp	r3, #0
7000e6d8:	0a00000c 	beq	7000e710 <finsh_set_device+0x154>
        {
            /* close old finsh device */
            rt_device_close(shell->device);
7000e6dc:	e30b3418 	movw	r3, #46104	; 0xb418
7000e6e0:	e3473002 	movt	r3, #28674	; 0x7002
7000e6e4:	e5933000 	ldr	r3, [r3]
7000e6e8:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000e6ec:	e1a00003 	mov	r0, r3
7000e6f0:	ebffc9de 	bl	70000e70 <rt_device_close>
            rt_device_set_rx_indicate(shell->device, RT_NULL);
7000e6f4:	e30b3418 	movw	r3, #46104	; 0xb418
7000e6f8:	e3473002 	movt	r3, #28674	; 0x7002
7000e6fc:	e5933000 	ldr	r3, [r3]
7000e700:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000e704:	e1a00003 	mov	r0, r3
7000e708:	e3a01000 	mov	r1, #0
7000e70c:	ebffcae5 	bl	700012a8 <rt_device_set_rx_indicate>
        }
        
        /* clear line buffer before switch to new device */
        memset(shell->line, 0, sizeof(shell->line));
7000e710:	e30b3418 	movw	r3, #46104	; 0xb418
7000e714:	e3473002 	movt	r3, #28674	; 0x7002
7000e718:	e5933000 	ldr	r3, [r3]
7000e71c:	e2833e25 	add	r3, r3, #592	; 0x250
7000e720:	e1a00003 	mov	r0, r3
7000e724:	e3a01000 	mov	r1, #0
7000e728:	e3a02050 	mov	r2, #80	; 0x50
7000e72c:	fa005607 	blx	70023f50 <memset>
        shell->line_curpos = shell->line_position = 0;
7000e730:	e30b3418 	movw	r3, #46104	; 0xb418
7000e734:	e3473002 	movt	r3, #28674	; 0x7002
7000e738:	e5932000 	ldr	r2, [r3]
7000e73c:	e30b3418 	movw	r3, #46104	; 0xb418
7000e740:	e3473002 	movt	r3, #28674	; 0x7002
7000e744:	e5933000 	ldr	r3, [r3]
7000e748:	e3a01000 	mov	r1, #0
7000e74c:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
7000e750:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000e754:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1
    
        shell->device = dev;
7000e758:	e30b3418 	movw	r3, #46104	; 0xb418
7000e75c:	e3473002 	movt	r3, #28674	; 0x7002
7000e760:	e5933000 	ldr	r3, [r3]
7000e764:	e51b2008 	ldr	r2, [fp, #-8]
7000e768:	e58322a4 	str	r2, [r3, #676]	; 0x2a4
        rt_device_set_rx_indicate(dev, finsh_rx_ind);
7000e76c:	e51b0008 	ldr	r0, [fp, #-8]
7000e770:	e30e14f8 	movw	r1, #58616	; 0xe4f8
7000e774:	e3471000 	movt	r1, #28672	; 0x7000
7000e778:	ebffcaca 	bl	700012a8 <rt_device_set_rx_indicate>
    }
}
7000e77c:	e24bd004 	sub	sp, fp, #4
7000e780:	e8bd8800 	pop	{fp, pc}

7000e784 <finsh_get_device>:
 * This function returns current finsh shell input device.
 *
 * @return the finsh shell input device name is returned.
 */
const char* finsh_get_device()
{
7000e784:	e92d4800 	push	{fp, lr}
7000e788:	e28db004 	add	fp, sp, #4
7000e78c:	e24dd008 	sub	sp, sp, #8
    RT_ASSERT(shell != RT_NULL);
7000e790:	e30b3418 	movw	r3, #46104	; 0xb418
7000e794:	e3473002 	movt	r3, #28674	; 0x7002
7000e798:	e5933000 	ldr	r3, [r3]
7000e79c:	e3530000 	cmp	r3, #0
7000e7a0:	1a00001d 	bne	7000e81c <finsh_get_device+0x98>
7000e7a4:	e3a03000 	mov	r3, #0
7000e7a8:	e54b3005 	strb	r3, [fp, #-5]
7000e7ac:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e7b0:	e3473002 	movt	r3, #28674	; 0x7002
7000e7b4:	e5933000 	ldr	r3, [r3]
7000e7b8:	e3530000 	cmp	r3, #0
7000e7bc:	1a00000d 	bne	7000e7f8 <finsh_get_device+0x74>
7000e7c0:	e3070284 	movw	r0, #29316	; 0x7284
7000e7c4:	e3470002 	movt	r0, #28674	; 0x7002
7000e7c8:	e30712a4 	movw	r1, #29348	; 0x72a4
7000e7cc:	e3471002 	movt	r1, #28674	; 0x7002
7000e7d0:	e3072388 	movw	r2, #29576	; 0x7388
7000e7d4:	e3472002 	movt	r2, #28674	; 0x7002
7000e7d8:	e3a03090 	mov	r3, #144	; 0x90
7000e7dc:	ebffe404 	bl	700077f4 <rt_kprintf>
7000e7e0:	e1a00000 	nop			; (mov r0, r0)
7000e7e4:	e55b3005 	ldrb	r3, [fp, #-5]
7000e7e8:	e6ef3073 	uxtb	r3, r3
7000e7ec:	e3530000 	cmp	r3, #0
7000e7f0:	0afffffb 	beq	7000e7e4 <finsh_get_device+0x60>
7000e7f4:	ea000008 	b	7000e81c <finsh_get_device+0x98>
7000e7f8:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e7fc:	e3473002 	movt	r3, #28674	; 0x7002
7000e800:	e5933000 	ldr	r3, [r3]
7000e804:	e30702a4 	movw	r0, #29348	; 0x72a4
7000e808:	e3470002 	movt	r0, #28674	; 0x7002
7000e80c:	e3071388 	movw	r1, #29576	; 0x7388
7000e810:	e3471002 	movt	r1, #28674	; 0x7002
7000e814:	e3a02090 	mov	r2, #144	; 0x90
7000e818:	e12fff33 	blx	r3
    return shell->device->parent.name;
7000e81c:	e30b3418 	movw	r3, #46104	; 0xb418
7000e820:	e3473002 	movt	r3, #28674	; 0x7002
7000e824:	e5933000 	ldr	r3, [r3]
7000e828:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
}
7000e82c:	e1a00003 	mov	r0, r3
7000e830:	e24bd004 	sub	sp, fp, #4
7000e834:	e8bd8800 	pop	{fp, pc}

7000e838 <finsh_set_echo>:
 * FINSH_OPTION_ECHO=0x01 is echo mode, other values are none-echo mode.
 *
 * @param echo the echo mode
 */
void finsh_set_echo(rt_uint32_t echo)
{
7000e838:	e92d4800 	push	{fp, lr}
7000e83c:	e28db004 	add	fp, sp, #4
7000e840:	e24dd010 	sub	sp, sp, #16
7000e844:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(shell != RT_NULL);
7000e848:	e30b3418 	movw	r3, #46104	; 0xb418
7000e84c:	e3473002 	movt	r3, #28674	; 0x7002
7000e850:	e5933000 	ldr	r3, [r3]
7000e854:	e3530000 	cmp	r3, #0
7000e858:	1a00001d 	bne	7000e8d4 <finsh_set_echo+0x9c>
7000e85c:	e3a03000 	mov	r3, #0
7000e860:	e54b3005 	strb	r3, [fp, #-5]
7000e864:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e868:	e3473002 	movt	r3, #28674	; 0x7002
7000e86c:	e5933000 	ldr	r3, [r3]
7000e870:	e3530000 	cmp	r3, #0
7000e874:	1a00000d 	bne	7000e8b0 <finsh_set_echo+0x78>
7000e878:	e3070284 	movw	r0, #29316	; 0x7284
7000e87c:	e3470002 	movt	r0, #28674	; 0x7002
7000e880:	e30712a4 	movw	r1, #29348	; 0x72a4
7000e884:	e3471002 	movt	r1, #28674	; 0x7002
7000e888:	e307239c 	movw	r2, #29596	; 0x739c
7000e88c:	e3472002 	movt	r2, #28674	; 0x7002
7000e890:	e3a0309f 	mov	r3, #159	; 0x9f
7000e894:	ebffe3d6 	bl	700077f4 <rt_kprintf>
7000e898:	e1a00000 	nop			; (mov r0, r0)
7000e89c:	e55b3005 	ldrb	r3, [fp, #-5]
7000e8a0:	e6ef3073 	uxtb	r3, r3
7000e8a4:	e3530000 	cmp	r3, #0
7000e8a8:	0afffffb 	beq	7000e89c <finsh_set_echo+0x64>
7000e8ac:	ea000008 	b	7000e8d4 <finsh_set_echo+0x9c>
7000e8b0:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e8b4:	e3473002 	movt	r3, #28674	; 0x7002
7000e8b8:	e5933000 	ldr	r3, [r3]
7000e8bc:	e30702a4 	movw	r0, #29348	; 0x72a4
7000e8c0:	e3470002 	movt	r0, #28674	; 0x7002
7000e8c4:	e307139c 	movw	r1, #29596	; 0x739c
7000e8c8:	e3471002 	movt	r1, #28674	; 0x7002
7000e8cc:	e3a0209f 	mov	r2, #159	; 0x9f
7000e8d0:	e12fff33 	blx	r3
    shell->echo_mode = (rt_uint8_t)echo;
7000e8d4:	e30b3418 	movw	r3, #46104	; 0xb418
7000e8d8:	e3473002 	movt	r3, #28674	; 0x7002
7000e8dc:	e5932000 	ldr	r2, [r3]
7000e8e0:	e51b3010 	ldr	r3, [fp, #-16]
7000e8e4:	e6ef3073 	uxtb	r3, r3
7000e8e8:	e2033001 	and	r3, r3, #1
7000e8ec:	e6ef1073 	uxtb	r1, r3
7000e8f0:	e5d2301d 	ldrb	r3, [r2, #29]
7000e8f4:	e7c03011 	bfi	r3, r1, #0, #1
7000e8f8:	e5c2301d 	strb	r3, [r2, #29]
}
7000e8fc:	e24bd004 	sub	sp, fp, #4
7000e900:	e8bd8800 	pop	{fp, pc}

7000e904 <finsh_get_echo>:
 * This function gets the echo mode of finsh shell.
 *
 * @return the echo mode
 */
rt_uint32_t finsh_get_echo()
{
7000e904:	e92d4800 	push	{fp, lr}
7000e908:	e28db004 	add	fp, sp, #4
7000e90c:	e24dd008 	sub	sp, sp, #8
    RT_ASSERT(shell != RT_NULL);
7000e910:	e30b3418 	movw	r3, #46104	; 0xb418
7000e914:	e3473002 	movt	r3, #28674	; 0x7002
7000e918:	e5933000 	ldr	r3, [r3]
7000e91c:	e3530000 	cmp	r3, #0
7000e920:	1a00001d 	bne	7000e99c <finsh_get_echo+0x98>
7000e924:	e3a03000 	mov	r3, #0
7000e928:	e54b3005 	strb	r3, [fp, #-5]
7000e92c:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e930:	e3473002 	movt	r3, #28674	; 0x7002
7000e934:	e5933000 	ldr	r3, [r3]
7000e938:	e3530000 	cmp	r3, #0
7000e93c:	1a00000d 	bne	7000e978 <finsh_get_echo+0x74>
7000e940:	e3070284 	movw	r0, #29316	; 0x7284
7000e944:	e3470002 	movt	r0, #28674	; 0x7002
7000e948:	e30712a4 	movw	r1, #29348	; 0x72a4
7000e94c:	e3471002 	movt	r1, #28674	; 0x7002
7000e950:	e30723ac 	movw	r2, #29612	; 0x73ac
7000e954:	e3472002 	movt	r2, #28674	; 0x7002
7000e958:	e3a030ac 	mov	r3, #172	; 0xac
7000e95c:	ebffe3a4 	bl	700077f4 <rt_kprintf>
7000e960:	e1a00000 	nop			; (mov r0, r0)
7000e964:	e55b3005 	ldrb	r3, [fp, #-5]
7000e968:	e6ef3073 	uxtb	r3, r3
7000e96c:	e3530000 	cmp	r3, #0
7000e970:	0afffffb 	beq	7000e964 <finsh_get_echo+0x60>
7000e974:	ea000008 	b	7000e99c <finsh_get_echo+0x98>
7000e978:	e30a3b74 	movw	r3, #43892	; 0xab74
7000e97c:	e3473002 	movt	r3, #28674	; 0x7002
7000e980:	e5933000 	ldr	r3, [r3]
7000e984:	e30702a4 	movw	r0, #29348	; 0x72a4
7000e988:	e3470002 	movt	r0, #28674	; 0x7002
7000e98c:	e30713ac 	movw	r1, #29612	; 0x73ac
7000e990:	e3471002 	movt	r1, #28674	; 0x7002
7000e994:	e3a020ac 	mov	r2, #172	; 0xac
7000e998:	e12fff33 	blx	r3

    return shell->echo_mode;
7000e99c:	e30b3418 	movw	r3, #46104	; 0xb418
7000e9a0:	e3473002 	movt	r3, #28674	; 0x7002
7000e9a4:	e5933000 	ldr	r3, [r3]
7000e9a8:	e5d3301d 	ldrb	r3, [r3, #29]
7000e9ac:	e7e03053 	ubfx	r3, r3, #0, #1
7000e9b0:	e6ef3073 	uxtb	r3, r3
}
7000e9b4:	e1a00003 	mov	r0, r3
7000e9b8:	e24bd004 	sub	sp, fp, #4
7000e9bc:	e8bd8800 	pop	{fp, pc}

7000e9c0 <shell_auto_complete>:

static void shell_auto_complete(char* prefix)
{
7000e9c0:	e92d4800 	push	{fp, lr}
7000e9c4:	e28db004 	add	fp, sp, #4
7000e9c8:	e24dd008 	sub	sp, sp, #8
7000e9cc:	e50b0008 	str	r0, [fp, #-8]

    rt_kprintf("\n");
7000e9d0:	e30702d8 	movw	r0, #29400	; 0x72d8
7000e9d4:	e3470002 	movt	r0, #28674	; 0x7002
7000e9d8:	ebffe385 	bl	700077f4 <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
7000e9dc:	eb000997 	bl	70011040 <msh_is_used>
7000e9e0:	e1a03000 	mov	r3, r0
7000e9e4:	e3530001 	cmp	r3, #1
7000e9e8:	1a000002 	bne	7000e9f8 <shell_auto_complete+0x38>
    {
        msh_auto_complete(prefix);
7000e9ec:	e51b0008 	ldr	r0, [fp, #-8]
7000e9f0:	eb000b9b 	bl	70011864 <msh_auto_complete>
7000e9f4:	ea000001 	b	7000ea00 <shell_auto_complete+0x40>
    else 
#endif
    {
#ifndef FINSH_USING_MSH_ONLY        
        extern void list_prefix(char* prefix);
        list_prefix(prefix);
7000e9f8:	e51b0008 	ldr	r0, [fp, #-8]
7000e9fc:	eb000848 	bl	70010b24 <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
7000ea00:	ebfffe92 	bl	7000e450 <finsh_get_prompt>
7000ea04:	e1a03000 	mov	r3, r0
7000ea08:	e30702dc 	movw	r0, #29404	; 0x72dc
7000ea0c:	e3470002 	movt	r0, #28674	; 0x7002
7000ea10:	e1a01003 	mov	r1, r3
7000ea14:	e51b2008 	ldr	r2, [fp, #-8]
7000ea18:	ebffe375 	bl	700077f4 <rt_kprintf>
}
7000ea1c:	e24bd004 	sub	sp, fp, #4
7000ea20:	e8bd8800 	pop	{fp, pc}

7000ea24 <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser* parser, const char *line)
{
7000ea24:	e92d4830 	push	{r4, r5, fp, lr}
7000ea28:	e28db00c 	add	fp, sp, #12
7000ea2c:	e24dd010 	sub	sp, sp, #16
7000ea30:	e50b0018 	str	r0, [fp, #-24]
7000ea34:	e50b101c 	str	r1, [fp, #-28]
    const char* err_str;

    rt_kprintf("\n");
7000ea38:	e30702d8 	movw	r0, #29400	; 0x72d8
7000ea3c:	e3470002 	movt	r0, #28674	; 0x7002
7000ea40:	ebffe36b 	bl	700077f4 <rt_kprintf>
    finsh_parser_run(parser, (unsigned char*)line);
7000ea44:	e51b0018 	ldr	r0, [fp, #-24]
7000ea48:	e51b101c 	ldr	r1, [fp, #-28]
7000ea4c:	eb002a0d 	bl	70019288 <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
7000ea50:	eb001ad0 	bl	70015598 <finsh_errno>
7000ea54:	e1a03000 	mov	r3, r0
7000ea58:	e3530000 	cmp	r3, #0
7000ea5c:	1a000004 	bne	7000ea74 <finsh_run_line+0x50>
    {
        finsh_compiler_run(parser->root);
7000ea60:	e51b3018 	ldr	r3, [fp, #-24]
7000ea64:	e5933098 	ldr	r3, [r3, #152]	; 0x98
7000ea68:	e1a00003 	mov	r0, r3
7000ea6c:	eb001a72 	bl	7001543c <finsh_compiler_run>
7000ea70:	ea000008 	b	7000ea98 <finsh_run_line+0x74>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
7000ea74:	eb001ac7 	bl	70015598 <finsh_errno>
7000ea78:	e1a03000 	mov	r3, r0
7000ea7c:	e1a00003 	mov	r0, r3
7000ea80:	eb001acd 	bl	700155bc <finsh_error_string>
7000ea84:	e50b0010 	str	r0, [fp, #-16]
        rt_kprintf("%s\n", err_str);
7000ea88:	e30702e4 	movw	r0, #29412	; 0x72e4
7000ea8c:	e3470002 	movt	r0, #28674	; 0x7002
7000ea90:	e51b1010 	ldr	r1, [fp, #-16]
7000ea94:	ebffe356 	bl	700077f4 <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
7000ea98:	eb001abe 	bl	70015598 <finsh_errno>
7000ea9c:	e1a03000 	mov	r3, r0
7000eaa0:	e3530000 	cmp	r3, #0
7000eaa4:	1a000022 	bne	7000eb34 <finsh_run_line+0x110>
    {
        char ch;
        finsh_vm_run();
7000eaa8:	eb002bc6 	bl	700199c8 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
7000eaac:	eb001c90 	bl	70015cf4 <finsh_stack_bottom>
7000eab0:	e1a03000 	mov	r3, r0
7000eab4:	e54b3011 	strb	r3, [fp, #-17]
        if (ch > 0x20 && ch < 0x7e)
7000eab8:	e55b3011 	ldrb	r3, [fp, #-17]
7000eabc:	e3530020 	cmp	r3, #32
7000eac0:	9a000011 	bls	7000eb0c <finsh_run_line+0xe8>
7000eac4:	e55b3011 	ldrb	r3, [fp, #-17]
7000eac8:	e353007d 	cmp	r3, #125	; 0x7d
7000eacc:	8a00000e 	bhi	7000eb0c <finsh_run_line+0xe8>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                (unsigned char)finsh_stack_bottom(),
7000ead0:	eb001c87 	bl	70015cf4 <finsh_stack_bottom>
7000ead4:	e1a03000 	mov	r3, r0
7000ead8:	e6ef3073 	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
7000eadc:	e1a05003 	mov	r5, r3
                (unsigned char)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom(),
7000eae0:	eb001c83 	bl	70015cf4 <finsh_stack_bottom>
7000eae4:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
7000eae8:	e1a04003 	mov	r4, r3
                (unsigned char)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom());
7000eaec:	eb001c80 	bl	70015cf4 <finsh_stack_bottom>
7000eaf0:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
7000eaf4:	e30702e8 	movw	r0, #29416	; 0x72e8
7000eaf8:	e3470002 	movt	r0, #28674	; 0x7002
7000eafc:	e1a01005 	mov	r1, r5
7000eb00:	e1a02004 	mov	r2, r4
7000eb04:	ebffe33a 	bl	700077f4 <rt_kprintf>
7000eb08:	ea000009 	b	7000eb34 <finsh_run_line+0x110>
                (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                (unsigned int)finsh_stack_bottom(),
7000eb0c:	eb001c78 	bl	70015cf4 <finsh_stack_bottom>
7000eb10:	e1a03000 	mov	r3, r0
                (unsigned int)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
7000eb14:	e1a04003 	mov	r4, r3
                (unsigned int)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom());
7000eb18:	eb001c75 	bl	70015cf4 <finsh_stack_bottom>
7000eb1c:	e1a03000 	mov	r3, r0
                (unsigned int)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
7000eb20:	e30702fc 	movw	r0, #29436	; 0x72fc
7000eb24:	e3470002 	movt	r0, #28674	; 0x7002
7000eb28:	e1a01004 	mov	r1, r4
7000eb2c:	e1a02003 	mov	r2, r3
7000eb30:	ebffe32f 	bl	700077f4 <rt_kprintf>
                (unsigned int)finsh_stack_bottom(),
                (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
7000eb34:	e51b0018 	ldr	r0, [fp, #-24]
7000eb38:	eb001c76 	bl	70015d18 <finsh_flush>
}
7000eb3c:	e24bd00c 	sub	sp, fp, #12
7000eb40:	e8bd8830 	pop	{r4, r5, fp, pc}

7000eb44 <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell* shell)
{
7000eb44:	e92d4800 	push	{fp, lr}
7000eb48:	e28db004 	add	fp, sp, #4
7000eb4c:	e24dd008 	sub	sp, sp, #8
7000eb50:	e50b0008 	str	r0, [fp, #-8]
    for(i=0; i<= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
7000eb54:	e307030c 	movw	r0, #29452	; 0x730c
7000eb58:	e3470002 	movt	r0, #28674	; 0x7002
7000eb5c:	ebffe324 	bl	700077f4 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
7000eb60:	ebfffe3a 	bl	7000e450 <finsh_get_prompt>
7000eb64:	e1a02000 	mov	r2, r0
7000eb68:	e51b3008 	ldr	r3, [fp, #-8]
7000eb6c:	e2833e25 	add	r3, r3, #592	; 0x250
7000eb70:	e30702dc 	movw	r0, #29404	; 0x72dc
7000eb74:	e3470002 	movt	r0, #28674	; 0x7002
7000eb78:	e1a01002 	mov	r1, r2
7000eb7c:	e1a02003 	mov	r2, r3
7000eb80:	ebffe31b 	bl	700077f4 <rt_kprintf>
    return RT_FALSE;
7000eb84:	e3a03000 	mov	r3, #0
}
7000eb88:	e1a00003 	mov	r0, r3
7000eb8c:	e24bd004 	sub	sp, fp, #4
7000eb90:	e8bd8800 	pop	{fp, pc}

7000eb94 <shell_push_history>:

static void shell_push_history(struct finsh_shell* shell)
{
7000eb94:	e92d4800 	push	{fp, lr}
7000eb98:	e28db004 	add	fp, sp, #4
7000eb9c:	e24dd010 	sub	sp, sp, #16
7000eba0:	e50b0010 	str	r0, [fp, #-16]
    if (shell->line_position != 0)
7000eba4:	e51b3010 	ldr	r3, [fp, #-16]
7000eba8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000ebac:	e3530000 	cmp	r3, #0
7000ebb0:	0a00006d 	beq	7000ed6c <shell_push_history+0x1d8>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
7000ebb4:	e51b3010 	ldr	r3, [fp, #-16]
7000ebb8:	e1d332b0 	ldrh	r3, [r3, #32]
7000ebbc:	e3530004 	cmp	r3, #4
7000ebc0:	9a000041 	bls	7000eccc <shell_push_history+0x138>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
7000ebc4:	e3a03000 	mov	r3, #0
7000ebc8:	e50b3008 	str	r3, [fp, #-8]
7000ebcc:	ea000019 	b	7000ec38 <shell_push_history+0xa4>
            {
                memcpy(&shell->cmd_history[index][0],
7000ebd0:	e51b2008 	ldr	r2, [fp, #-8]
7000ebd4:	e1a03002 	mov	r3, r2
7000ebd8:	e1a03103 	lsl	r3, r3, #2
7000ebdc:	e0833002 	add	r3, r3, r2
7000ebe0:	e1a03203 	lsl	r3, r3, #4
7000ebe4:	e2833020 	add	r3, r3, #32
7000ebe8:	e51b2010 	ldr	r2, [fp, #-16]
7000ebec:	e0823003 	add	r3, r2, r3
7000ebf0:	e2831002 	add	r1, r3, #2
                    &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
7000ebf4:	e51b3008 	ldr	r3, [fp, #-8]
7000ebf8:	e2832001 	add	r2, r3, #1
7000ebfc:	e1a03002 	mov	r3, r2
7000ec00:	e1a03103 	lsl	r3, r3, #2
7000ec04:	e0833002 	add	r3, r3, r2
7000ec08:	e1a03203 	lsl	r3, r3, #4
7000ec0c:	e2833020 	add	r3, r3, #32
7000ec10:	e51b2010 	ldr	r2, [fp, #-16]
7000ec14:	e0823003 	add	r3, r2, r3
7000ec18:	e2833002 	add	r3, r3, #2
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
7000ec1c:	e1a00001 	mov	r0, r1
7000ec20:	e1a01003 	mov	r1, r3
7000ec24:	e3a02050 	mov	r2, #80	; 0x50
7000ec28:	fa00549e 	blx	70023ea8 <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
7000ec2c:	e51b3008 	ldr	r3, [fp, #-8]
7000ec30:	e2833001 	add	r3, r3, #1
7000ec34:	e50b3008 	str	r3, [fp, #-8]
7000ec38:	e51b3008 	ldr	r3, [fp, #-8]
7000ec3c:	e3530003 	cmp	r3, #3
7000ec40:	daffffe2 	ble	7000ebd0 <shell_push_history+0x3c>
            {
                memcpy(&shell->cmd_history[index][0],
                    &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
7000ec44:	e51b2008 	ldr	r2, [fp, #-8]
7000ec48:	e1a03002 	mov	r3, r2
7000ec4c:	e1a03103 	lsl	r3, r3, #2
7000ec50:	e0833002 	add	r3, r3, r2
7000ec54:	e1a03203 	lsl	r3, r3, #4
7000ec58:	e2833020 	add	r3, r3, #32
7000ec5c:	e51b2010 	ldr	r2, [fp, #-16]
7000ec60:	e0823003 	add	r3, r2, r3
7000ec64:	e2833002 	add	r3, r3, #2
7000ec68:	e1a00003 	mov	r0, r3
7000ec6c:	e3a01000 	mov	r1, #0
7000ec70:	e3a02050 	mov	r2, #80	; 0x50
7000ec74:	fa0054b5 	blx	70023f50 <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
7000ec78:	e51b2008 	ldr	r2, [fp, #-8]
7000ec7c:	e1a03002 	mov	r3, r2
7000ec80:	e1a03103 	lsl	r3, r3, #2
7000ec84:	e0833002 	add	r3, r3, r2
7000ec88:	e1a03203 	lsl	r3, r3, #4
7000ec8c:	e2833020 	add	r3, r3, #32
7000ec90:	e51b2010 	ldr	r2, [fp, #-16]
7000ec94:	e0823003 	add	r3, r2, r3
7000ec98:	e2831002 	add	r1, r3, #2
7000ec9c:	e51b3010 	ldr	r3, [fp, #-16]
7000eca0:	e2832e25 	add	r2, r3, #592	; 0x250
7000eca4:	e51b3010 	ldr	r3, [fp, #-16]
7000eca8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000ecac:	e1a00001 	mov	r0, r1
7000ecb0:	e1a01002 	mov	r1, r2
7000ecb4:	e1a02003 	mov	r2, r3
7000ecb8:	fa00547a 	blx	70023ea8 <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
7000ecbc:	e51b3010 	ldr	r3, [fp, #-16]
7000ecc0:	e3a02005 	mov	r2, #5
7000ecc4:	e1c322b0 	strh	r2, [r3, #32]
7000ecc8:	ea000027 	b	7000ed6c <shell_push_history+0x1d8>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
7000eccc:	e51b3010 	ldr	r3, [fp, #-16]
7000ecd0:	e1d332b0 	ldrh	r3, [r3, #32]
7000ecd4:	e1a02003 	mov	r2, r3
7000ecd8:	e1a03002 	mov	r3, r2
7000ecdc:	e1a03103 	lsl	r3, r3, #2
7000ece0:	e0833002 	add	r3, r3, r2
7000ece4:	e1a03203 	lsl	r3, r3, #4
7000ece8:	e2833020 	add	r3, r3, #32
7000ecec:	e51b2010 	ldr	r2, [fp, #-16]
7000ecf0:	e0823003 	add	r3, r2, r3
7000ecf4:	e2833002 	add	r3, r3, #2
7000ecf8:	e1a00003 	mov	r0, r3
7000ecfc:	e3a01000 	mov	r1, #0
7000ed00:	e3a02050 	mov	r2, #80	; 0x50
7000ed04:	fa005491 	blx	70023f50 <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
7000ed08:	e51b3010 	ldr	r3, [fp, #-16]
7000ed0c:	e1d332b0 	ldrh	r3, [r3, #32]
7000ed10:	e1a02003 	mov	r2, r3
7000ed14:	e1a03002 	mov	r3, r2
7000ed18:	e1a03103 	lsl	r3, r3, #2
7000ed1c:	e0833002 	add	r3, r3, r2
7000ed20:	e1a03203 	lsl	r3, r3, #4
7000ed24:	e2833020 	add	r3, r3, #32
7000ed28:	e51b2010 	ldr	r2, [fp, #-16]
7000ed2c:	e0823003 	add	r3, r2, r3
7000ed30:	e2831002 	add	r1, r3, #2
7000ed34:	e51b3010 	ldr	r3, [fp, #-16]
7000ed38:	e2832e25 	add	r2, r3, #592	; 0x250
7000ed3c:	e51b3010 	ldr	r3, [fp, #-16]
7000ed40:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000ed44:	e1a00001 	mov	r0, r1
7000ed48:	e1a01002 	mov	r1, r2
7000ed4c:	e1a02003 	mov	r2, r3
7000ed50:	fa005454 	blx	70023ea8 <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
7000ed54:	e51b3010 	ldr	r3, [fp, #-16]
7000ed58:	e1d332b0 	ldrh	r3, [r3, #32]
7000ed5c:	e2833001 	add	r3, r3, #1
7000ed60:	e6ff2073 	uxth	r2, r3
7000ed64:	e51b3010 	ldr	r3, [fp, #-16]
7000ed68:	e1c322b0 	strh	r2, [r3, #32]
        }
    }
    shell->current_history = shell->history_count;
7000ed6c:	e51b3010 	ldr	r3, [fp, #-16]
7000ed70:	e1d322b0 	ldrh	r2, [r3, #32]
7000ed74:	e51b3010 	ldr	r3, [fp, #-16]
7000ed78:	e1c321be 	strh	r2, [r3, #30]
}
7000ed7c:	e24bd004 	sub	sp, fp, #4
7000ed80:	e8bd8800 	pop	{fp, pc}

7000ed84 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void* parameter)
{
7000ed84:	e92d4830 	push	{r4, r5, fp, lr}
7000ed88:	e28db00c 	add	fp, sp, #12
7000ed8c:	e24dd018 	sub	sp, sp, #24
7000ed90:	e50b0020 	str	r0, [fp, #-32]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
7000ed94:	e30b3418 	movw	r3, #46104	; 0xb418
7000ed98:	e3473002 	movt	r3, #28674	; 0x7002
7000ed9c:	e5932000 	ldr	r2, [r3]
7000eda0:	e5d2301d 	ldrb	r3, [r2, #29]
7000eda4:	e3833001 	orr	r3, r3, #1
7000eda8:	e5c2301d 	strb	r3, [r2, #29]

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
7000edac:	e30b3418 	movw	r3, #46104	; 0xb418
7000edb0:	e3473002 	movt	r3, #28674	; 0x7002
7000edb4:	e5933000 	ldr	r3, [r3]
7000edb8:	e2833f6d 	add	r3, r3, #436	; 0x1b4
7000edbc:	e1a00003 	mov	r0, r3
7000edc0:	eb001bbd 	bl	70015cbc <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
7000edc4:	ebfffda1 	bl	7000e450 <finsh_get_prompt>
7000edc8:	e1a03000 	mov	r3, r0
7000edcc:	e1a00003 	mov	r0, r3
7000edd0:	ebffe287 	bl	700077f4 <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
7000edd4:	e30b3418 	movw	r3, #46104	; 0xb418
7000edd8:	e3473002 	movt	r3, #28674	; 0x7002
7000eddc:	e5933000 	ldr	r3, [r3]
7000ede0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000ede4:	e3530000 	cmp	r3, #0
7000ede8:	1a000038 	bne	7000eed0 <finsh_thread_entry+0x14c>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
7000edec:	e30b3418 	movw	r3, #46104	; 0xb418
7000edf0:	e3473002 	movt	r3, #28674	; 0x7002
7000edf4:	e5934000 	ldr	r4, [r3]
7000edf8:	ebffe247 	bl	7000771c <rt_console_get_device>
7000edfc:	e1a03000 	mov	r3, r0
7000ee00:	e58432a4 	str	r3, [r4, #676]	; 0x2a4
        RT_ASSERT(shell->device);
7000ee04:	e30b3418 	movw	r3, #46104	; 0xb418
7000ee08:	e3473002 	movt	r3, #28674	; 0x7002
7000ee0c:	e5933000 	ldr	r3, [r3]
7000ee10:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000ee14:	e3530000 	cmp	r3, #0
7000ee18:	1a00001d 	bne	7000ee94 <finsh_thread_entry+0x110>
7000ee1c:	e3a03000 	mov	r3, #0
7000ee20:	e54b301a 	strb	r3, [fp, #-26]
7000ee24:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ee28:	e3473002 	movt	r3, #28674	; 0x7002
7000ee2c:	e5933000 	ldr	r3, [r3]
7000ee30:	e3530000 	cmp	r3, #0
7000ee34:	1a00000d 	bne	7000ee70 <finsh_thread_entry+0xec>
7000ee38:	e3070284 	movw	r0, #29316	; 0x7284
7000ee3c:	e3470002 	movt	r0, #28674	; 0x7002
7000ee40:	e3071314 	movw	r1, #29460	; 0x7314
7000ee44:	e3471002 	movt	r1, #28674	; 0x7002
7000ee48:	e30723bc 	movw	r2, #29628	; 0x73bc
7000ee4c:	e3472002 	movt	r2, #28674	; 0x7002
7000ee50:	e300313a 	movw	r3, #314	; 0x13a
7000ee54:	ebffe266 	bl	700077f4 <rt_kprintf>
7000ee58:	e1a00000 	nop			; (mov r0, r0)
7000ee5c:	e55b301a 	ldrb	r3, [fp, #-26]
7000ee60:	e6ef3073 	uxtb	r3, r3
7000ee64:	e3530000 	cmp	r3, #0
7000ee68:	0afffffb 	beq	7000ee5c <finsh_thread_entry+0xd8>
7000ee6c:	ea000008 	b	7000ee94 <finsh_thread_entry+0x110>
7000ee70:	e30a3b74 	movw	r3, #43892	; 0xab74
7000ee74:	e3473002 	movt	r3, #28674	; 0x7002
7000ee78:	e5933000 	ldr	r3, [r3]
7000ee7c:	e3070314 	movw	r0, #29460	; 0x7314
7000ee80:	e3470002 	movt	r0, #28674	; 0x7002
7000ee84:	e30713bc 	movw	r1, #29628	; 0x73bc
7000ee88:	e3471002 	movt	r1, #28674	; 0x7002
7000ee8c:	e300213a 	movw	r2, #314	; 0x13a
7000ee90:	e12fff33 	blx	r3
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
7000ee94:	e30b3418 	movw	r3, #46104	; 0xb418
7000ee98:	e3473002 	movt	r3, #28674	; 0x7002
7000ee9c:	e5933000 	ldr	r3, [r3]
7000eea0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000eea4:	e1a00003 	mov	r0, r3
7000eea8:	e30e14f8 	movw	r1, #58616	; 0xe4f8
7000eeac:	e3471000 	movt	r1, #28672	; 0x7000
7000eeb0:	ebffc8fc 	bl	700012a8 <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
7000eeb4:	e30b3418 	movw	r3, #46104	; 0xb418
7000eeb8:	e3473002 	movt	r3, #28674	; 0x7002
7000eebc:	e5933000 	ldr	r3, [r3]
7000eec0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
7000eec4:	e1a00003 	mov	r0, r3
7000eec8:	e3001143 	movw	r1, #323	; 0x143
7000eecc:	ebffc751 	bl	70000c18 <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
7000eed0:	e30b3418 	movw	r3, #46104	; 0xb418
7000eed4:	e3473002 	movt	r3, #28674	; 0x7002
7000eed8:	e5933000 	ldr	r3, [r3]
7000eedc:	e1a00003 	mov	r0, r3
7000eee0:	e3e01000 	mvn	r1, #0
7000eee4:	ebffcbbd 	bl	70001de0 <rt_sem_take>
7000eee8:	e1a03000 	mov	r3, r0
7000eeec:	e3530000 	cmp	r3, #0
7000eef0:	0a000000 	beq	7000eef8 <finsh_thread_entry+0x174>
7000eef4:	ea0002d2 	b	7000fa44 <finsh_thread_entry+0xcc0>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
7000eef8:	ea0002c4 	b	7000fa10 <finsh_thread_entry+0xc8c>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
7000eefc:	e55b3019 	ldrb	r3, [fp, #-25]
7000ef00:	e353001b 	cmp	r3, #27
7000ef04:	1a000005 	bne	7000ef20 <finsh_thread_entry+0x19c>
            {
                shell->stat = WAIT_SPEC_KEY;
7000ef08:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef0c:	e3473002 	movt	r3, #28674	; 0x7002
7000ef10:	e5933000 	ldr	r3, [r3]
7000ef14:	e3a02001 	mov	r2, #1
7000ef18:	e5c3201c 	strb	r2, [r3, #28]
                continue;
7000ef1c:	ea0002bb 	b	7000fa10 <finsh_thread_entry+0xc8c>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
7000ef20:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef24:	e3473002 	movt	r3, #28674	; 0x7002
7000ef28:	e5933000 	ldr	r3, [r3]
7000ef2c:	e5d3301c 	ldrb	r3, [r3, #28]
7000ef30:	e3530001 	cmp	r3, #1
7000ef34:	1a00000e 	bne	7000ef74 <finsh_thread_entry+0x1f0>
            {
                if (ch == 0x5b)
7000ef38:	e55b3019 	ldrb	r3, [fp, #-25]
7000ef3c:	e353005b 	cmp	r3, #91	; 0x5b
7000ef40:	1a000005 	bne	7000ef5c <finsh_thread_entry+0x1d8>
                {
                    shell->stat = WAIT_FUNC_KEY;
7000ef44:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef48:	e3473002 	movt	r3, #28674	; 0x7002
7000ef4c:	e5933000 	ldr	r3, [r3]
7000ef50:	e3a02002 	mov	r2, #2
7000ef54:	e5c3201c 	strb	r2, [r3, #28]
                    continue;
7000ef58:	ea0002ac 	b	7000fa10 <finsh_thread_entry+0xc8c>
                }

                shell->stat = WAIT_NORMAL;
7000ef5c:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef60:	e3473002 	movt	r3, #28674	; 0x7002
7000ef64:	e5933000 	ldr	r3, [r3]
7000ef68:	e3a02000 	mov	r2, #0
7000ef6c:	e5c3201c 	strb	r2, [r3, #28]
7000ef70:	ea0000e0 	b	7000f2f8 <finsh_thread_entry+0x574>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
7000ef74:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef78:	e3473002 	movt	r3, #28674	; 0x7002
7000ef7c:	e5933000 	ldr	r3, [r3]
7000ef80:	e5d3301c 	ldrb	r3, [r3, #28]
7000ef84:	e3530002 	cmp	r3, #2
7000ef88:	1a0000da 	bne	7000f2f8 <finsh_thread_entry+0x574>
            {
                shell->stat = WAIT_NORMAL;
7000ef8c:	e30b3418 	movw	r3, #46104	; 0xb418
7000ef90:	e3473002 	movt	r3, #28674	; 0x7002
7000ef94:	e5933000 	ldr	r3, [r3]
7000ef98:	e3a02000 	mov	r2, #0
7000ef9c:	e5c3201c 	strb	r2, [r3, #28]

                if (ch == 0x41) /* up key */
7000efa0:	e55b3019 	ldrb	r3, [fp, #-25]
7000efa4:	e3530041 	cmp	r3, #65	; 0x41
7000efa8:	1a000040 	bne	7000f0b0 <finsh_thread_entry+0x32c>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
7000efac:	e30b3418 	movw	r3, #46104	; 0xb418
7000efb0:	e3473002 	movt	r3, #28674	; 0x7002
7000efb4:	e5933000 	ldr	r3, [r3]
7000efb8:	e1d331be 	ldrh	r3, [r3, #30]
7000efbc:	e3530000 	cmp	r3, #0
7000efc0:	0a000034 	beq	7000f098 <finsh_thread_entry+0x314>
                        shell->current_history --;
7000efc4:	e30b3418 	movw	r3, #46104	; 0xb418
7000efc8:	e3473002 	movt	r3, #28674	; 0x7002
7000efcc:	e5933000 	ldr	r3, [r3]
7000efd0:	e1d321be 	ldrh	r2, [r3, #30]
7000efd4:	e2422001 	sub	r2, r2, #1
7000efd8:	e6ff2072 	uxth	r2, r2
7000efdc:	e1c321be 	strh	r2, [r3, #30]
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
7000efe0:	e30b3418 	movw	r3, #46104	; 0xb418
7000efe4:	e3473002 	movt	r3, #28674	; 0x7002
7000efe8:	e5933000 	ldr	r3, [r3]
7000efec:	e2831e25 	add	r1, r3, #592	; 0x250
7000eff0:	e30b3418 	movw	r3, #46104	; 0xb418
7000eff4:	e3473002 	movt	r3, #28674	; 0x7002
7000eff8:	e5930000 	ldr	r0, [r3]
7000effc:	e30b3418 	movw	r3, #46104	; 0xb418
7000f000:	e3473002 	movt	r3, #28674	; 0x7002
7000f004:	e5933000 	ldr	r3, [r3]
7000f008:	e1d331be 	ldrh	r3, [r3, #30]
7000f00c:	e1a02003 	mov	r2, r3
7000f010:	e1a03002 	mov	r3, r2
7000f014:	e1a03103 	lsl	r3, r3, #2
7000f018:	e0833002 	add	r3, r3, r2
7000f01c:	e1a03203 	lsl	r3, r3, #4
7000f020:	e2833020 	add	r3, r3, #32
7000f024:	e0803003 	add	r3, r0, r3
7000f028:	e2833002 	add	r3, r3, #2
7000f02c:	e1a00001 	mov	r0, r1
7000f030:	e1a01003 	mov	r1, r3
7000f034:	e3a02050 	mov	r2, #80	; 0x50
7000f038:	fa00539a 	blx	70023ea8 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
7000f03c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f040:	e3473002 	movt	r3, #28674	; 0x7002
7000f044:	e5935000 	ldr	r5, [r3]
7000f048:	e30b3418 	movw	r3, #46104	; 0xb418
7000f04c:	e3473002 	movt	r3, #28674	; 0x7002
7000f050:	e5934000 	ldr	r4, [r3]
7000f054:	e30b3418 	movw	r3, #46104	; 0xb418
7000f058:	e3473002 	movt	r3, #28674	; 0x7002
7000f05c:	e5933000 	ldr	r3, [r3]
7000f060:	e2833e25 	add	r3, r3, #592	; 0x250
7000f064:	e1a00003 	mov	r0, r3
7000f068:	fa0054b1 	blx	70024334 <strlen>
7000f06c:	e1a03000 	mov	r3, r0
7000f070:	e6ef3073 	uxtb	r3, r3
7000f074:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
7000f078:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
7000f07c:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
7000f080:	e30b3418 	movw	r3, #46104	; 0xb418
7000f084:	e3473002 	movt	r3, #28674	; 0x7002
7000f088:	e5933000 	ldr	r3, [r3]
7000f08c:	e1a00003 	mov	r0, r3
7000f090:	ebfffeab 	bl	7000eb44 <shell_handle_history>
#endif
                    continue;
7000f094:	ea00025d 	b	7000fa10 <finsh_thread_entry+0xc8c>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
7000f098:	e30b3418 	movw	r3, #46104	; 0xb418
7000f09c:	e3473002 	movt	r3, #28674	; 0x7002
7000f0a0:	e5933000 	ldr	r3, [r3]
7000f0a4:	e3a02000 	mov	r2, #0
7000f0a8:	e1c321be 	strh	r2, [r3, #30]
                        continue;
7000f0ac:	ea000257 	b	7000fa10 <finsh_thread_entry+0xc8c>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
7000f0b0:	e55b3019 	ldrb	r3, [fp, #-25]
7000f0b4:	e3530042 	cmp	r3, #66	; 0x42
7000f0b8:	1a000053 	bne	7000f20c <finsh_thread_entry+0x488>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
7000f0bc:	e30b3418 	movw	r3, #46104	; 0xb418
7000f0c0:	e3473002 	movt	r3, #28674	; 0x7002
7000f0c4:	e5933000 	ldr	r3, [r3]
7000f0c8:	e1d331be 	ldrh	r3, [r3, #30]
7000f0cc:	e1a02003 	mov	r2, r3
7000f0d0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f0d4:	e3473002 	movt	r3, #28674	; 0x7002
7000f0d8:	e5933000 	ldr	r3, [r3]
7000f0dc:	e1d332b0 	ldrh	r3, [r3, #32]
7000f0e0:	e2433001 	sub	r3, r3, #1
7000f0e4:	e1520003 	cmp	r2, r3
7000f0e8:	aa000007 	bge	7000f10c <finsh_thread_entry+0x388>
                        shell->current_history ++;
7000f0ec:	e30b3418 	movw	r3, #46104	; 0xb418
7000f0f0:	e3473002 	movt	r3, #28674	; 0x7002
7000f0f4:	e5933000 	ldr	r3, [r3]
7000f0f8:	e1d321be 	ldrh	r2, [r3, #30]
7000f0fc:	e2822001 	add	r2, r2, #1
7000f100:	e6ff2072 	uxth	r2, r2
7000f104:	e1c321be 	strh	r2, [r3, #30]
7000f108:	ea000011 	b	7000f154 <finsh_thread_entry+0x3d0>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
7000f10c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f110:	e3473002 	movt	r3, #28674	; 0x7002
7000f114:	e5933000 	ldr	r3, [r3]
7000f118:	e1d332b0 	ldrh	r3, [r3, #32]
7000f11c:	e3530000 	cmp	r3, #0
7000f120:	0a00000a 	beq	7000f150 <finsh_thread_entry+0x3cc>
                            shell->current_history = shell->history_count - 1;
7000f124:	e30b3418 	movw	r3, #46104	; 0xb418
7000f128:	e3473002 	movt	r3, #28674	; 0x7002
7000f12c:	e5932000 	ldr	r2, [r3]
7000f130:	e30b3418 	movw	r3, #46104	; 0xb418
7000f134:	e3473002 	movt	r3, #28674	; 0x7002
7000f138:	e5933000 	ldr	r3, [r3]
7000f13c:	e1d332b0 	ldrh	r3, [r3, #32]
7000f140:	e2433001 	sub	r3, r3, #1
7000f144:	e6ff3073 	uxth	r3, r3
7000f148:	e1c231be 	strh	r3, [r2, #30]
7000f14c:	ea000000 	b	7000f154 <finsh_thread_entry+0x3d0>
                        else
                            continue;
7000f150:	ea00022e 	b	7000fa10 <finsh_thread_entry+0xc8c>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
7000f154:	e30b3418 	movw	r3, #46104	; 0xb418
7000f158:	e3473002 	movt	r3, #28674	; 0x7002
7000f15c:	e5933000 	ldr	r3, [r3]
7000f160:	e2831e25 	add	r1, r3, #592	; 0x250
7000f164:	e30b3418 	movw	r3, #46104	; 0xb418
7000f168:	e3473002 	movt	r3, #28674	; 0x7002
7000f16c:	e5930000 	ldr	r0, [r3]
7000f170:	e30b3418 	movw	r3, #46104	; 0xb418
7000f174:	e3473002 	movt	r3, #28674	; 0x7002
7000f178:	e5933000 	ldr	r3, [r3]
7000f17c:	e1d331be 	ldrh	r3, [r3, #30]
7000f180:	e1a02003 	mov	r2, r3
7000f184:	e1a03002 	mov	r3, r2
7000f188:	e1a03103 	lsl	r3, r3, #2
7000f18c:	e0833002 	add	r3, r3, r2
7000f190:	e1a03203 	lsl	r3, r3, #4
7000f194:	e2833020 	add	r3, r3, #32
7000f198:	e0803003 	add	r3, r0, r3
7000f19c:	e2833002 	add	r3, r3, #2
7000f1a0:	e1a00001 	mov	r0, r1
7000f1a4:	e1a01003 	mov	r1, r3
7000f1a8:	e3a02050 	mov	r2, #80	; 0x50
7000f1ac:	fa00533d 	blx	70023ea8 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
7000f1b0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f1b4:	e3473002 	movt	r3, #28674	; 0x7002
7000f1b8:	e5935000 	ldr	r5, [r3]
7000f1bc:	e30b3418 	movw	r3, #46104	; 0xb418
7000f1c0:	e3473002 	movt	r3, #28674	; 0x7002
7000f1c4:	e5934000 	ldr	r4, [r3]
7000f1c8:	e30b3418 	movw	r3, #46104	; 0xb418
7000f1cc:	e3473002 	movt	r3, #28674	; 0x7002
7000f1d0:	e5933000 	ldr	r3, [r3]
7000f1d4:	e2833e25 	add	r3, r3, #592	; 0x250
7000f1d8:	e1a00003 	mov	r0, r3
7000f1dc:	fa005454 	blx	70024334 <strlen>
7000f1e0:	e1a03000 	mov	r3, r0
7000f1e4:	e6ef3073 	uxtb	r3, r3
7000f1e8:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
7000f1ec:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
7000f1f0:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
7000f1f4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f1f8:	e3473002 	movt	r3, #28674	; 0x7002
7000f1fc:	e5933000 	ldr	r3, [r3]
7000f200:	e1a00003 	mov	r0, r3
7000f204:	ebfffe4e 	bl	7000eb44 <shell_handle_history>
#endif
                    continue;
7000f208:	ea000200 	b	7000fa10 <finsh_thread_entry+0xc8c>
                }
                else if (ch == 0x44) /* left key */
7000f20c:	e55b3019 	ldrb	r3, [fp, #-25]
7000f210:	e3530044 	cmp	r3, #68	; 0x44
7000f214:	1a000011 	bne	7000f260 <finsh_thread_entry+0x4dc>
                {
                    if (shell->line_curpos)
7000f218:	e30b3418 	movw	r3, #46104	; 0xb418
7000f21c:	e3473002 	movt	r3, #28674	; 0x7002
7000f220:	e5933000 	ldr	r3, [r3]
7000f224:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f228:	e3530000 	cmp	r3, #0
7000f22c:	0a00000a 	beq	7000f25c <finsh_thread_entry+0x4d8>
                    {
                        rt_kprintf("\b");
7000f230:	e3070324 	movw	r0, #29476	; 0x7324
7000f234:	e3470002 	movt	r0, #28674	; 0x7002
7000f238:	ebffe16d 	bl	700077f4 <rt_kprintf>
                        shell->line_curpos --;
7000f23c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f240:	e3473002 	movt	r3, #28674	; 0x7002
7000f244:	e5933000 	ldr	r3, [r3]
7000f248:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f24c:	e2422001 	sub	r2, r2, #1
7000f250:	e6ef2072 	uxtb	r2, r2
7000f254:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
7000f258:	ea0001ec 	b	7000fa10 <finsh_thread_entry+0xc8c>
7000f25c:	ea0001eb 	b	7000fa10 <finsh_thread_entry+0xc8c>
                }
                else if (ch == 0x43) /* right key */
7000f260:	e55b3019 	ldrb	r3, [fp, #-25]
7000f264:	e3530043 	cmp	r3, #67	; 0x43
7000f268:	1a000022 	bne	7000f2f8 <finsh_thread_entry+0x574>
                {
                    if (shell->line_curpos < shell->line_position)
7000f26c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f270:	e3473002 	movt	r3, #28674	; 0x7002
7000f274:	e5933000 	ldr	r3, [r3]
7000f278:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f27c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f280:	e3473002 	movt	r3, #28674	; 0x7002
7000f284:	e5933000 	ldr	r3, [r3]
7000f288:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f28c:	e1520003 	cmp	r2, r3
7000f290:	2a000017 	bcs	7000f2f4 <finsh_thread_entry+0x570>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
7000f294:	e30b3418 	movw	r3, #46104	; 0xb418
7000f298:	e3473002 	movt	r3, #28674	; 0x7002
7000f29c:	e5931000 	ldr	r1, [r3]
7000f2a0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f2a4:	e3473002 	movt	r3, #28674	; 0x7002
7000f2a8:	e5933000 	ldr	r3, [r3]
7000f2ac:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f2b0:	e1a02003 	mov	r2, r3
7000f2b4:	e3a03e25 	mov	r3, #592	; 0x250
7000f2b8:	e0812002 	add	r2, r1, r2
7000f2bc:	e0823003 	add	r3, r2, r3
7000f2c0:	e5d33000 	ldrb	r3, [r3]
7000f2c4:	e3070328 	movw	r0, #29480	; 0x7328
7000f2c8:	e3470002 	movt	r0, #28674	; 0x7002
7000f2cc:	e1a01003 	mov	r1, r3
7000f2d0:	ebffe147 	bl	700077f4 <rt_kprintf>
                        shell->line_curpos ++;
7000f2d4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f2d8:	e3473002 	movt	r3, #28674	; 0x7002
7000f2dc:	e5933000 	ldr	r3, [r3]
7000f2e0:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f2e4:	e2822001 	add	r2, r2, #1
7000f2e8:	e6ef2072 	uxtb	r2, r2
7000f2ec:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
7000f2f0:	ea0001c6 	b	7000fa10 <finsh_thread_entry+0xc8c>
7000f2f4:	ea0001c5 	b	7000fa10 <finsh_thread_entry+0xc8c>
                }

            }

            /* handle CR key */
            if (ch == '\r')
7000f2f8:	e55b3019 	ldrb	r3, [fp, #-25]
7000f2fc:	e353000d 	cmp	r3, #13
7000f300:	1a000012 	bne	7000f350 <finsh_thread_entry+0x5cc>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
7000f304:	e30b3418 	movw	r3, #46104	; 0xb418
7000f308:	e3473002 	movt	r3, #28674	; 0x7002
7000f30c:	e5933000 	ldr	r3, [r3]
7000f310:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
7000f314:	e24b301b 	sub	r3, fp, #27
7000f318:	e1a00002 	mov	r0, r2
7000f31c:	e3a01000 	mov	r1, #0
7000f320:	e1a02003 	mov	r2, r3
7000f324:	e3a03001 	mov	r3, #1
7000f328:	ebffc71f 	bl	70000fac <rt_device_read>
7000f32c:	e1a03000 	mov	r3, r0
7000f330:	e3530001 	cmp	r3, #1
7000f334:	1a000002 	bne	7000f344 <finsh_thread_entry+0x5c0>
                    ch = next;
7000f338:	e55b301b 	ldrb	r3, [fp, #-27]
7000f33c:	e54b3019 	strb	r3, [fp, #-25]
7000f340:	ea0000b4 	b	7000f618 <finsh_thread_entry+0x894>
                else ch = '\r';
7000f344:	e3a0300d 	mov	r3, #13
7000f348:	e54b3019 	strb	r3, [fp, #-25]
7000f34c:	ea0000b1 	b	7000f618 <finsh_thread_entry+0x894>
            }
            /* handle tab key */
            else if (ch == '\t')
7000f350:	e55b3019 	ldrb	r3, [fp, #-25]
7000f354:	e3530009 	cmp	r3, #9
7000f358:	1a000028 	bne	7000f400 <finsh_thread_entry+0x67c>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
7000f35c:	e3a03000 	mov	r3, #0
7000f360:	e50b3010 	str	r3, [fp, #-16]
7000f364:	ea000005 	b	7000f380 <finsh_thread_entry+0x5fc>
                    rt_kprintf("\b");
7000f368:	e3070324 	movw	r0, #29476	; 0x7324
7000f36c:	e3470002 	movt	r0, #28674	; 0x7002
7000f370:	ebffe11f 	bl	700077f4 <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
7000f374:	e51b3010 	ldr	r3, [fp, #-16]
7000f378:	e2833001 	add	r3, r3, #1
7000f37c:	e50b3010 	str	r3, [fp, #-16]
7000f380:	e30b3418 	movw	r3, #46104	; 0xb418
7000f384:	e3473002 	movt	r3, #28674	; 0x7002
7000f388:	e5933000 	ldr	r3, [r3]
7000f38c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f390:	e1a02003 	mov	r2, r3
7000f394:	e51b3010 	ldr	r3, [fp, #-16]
7000f398:	e1520003 	cmp	r2, r3
7000f39c:	cafffff1 	bgt	7000f368 <finsh_thread_entry+0x5e4>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
7000f3a0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f3a4:	e3473002 	movt	r3, #28674	; 0x7002
7000f3a8:	e5933000 	ldr	r3, [r3]
7000f3ac:	e2833e25 	add	r3, r3, #592	; 0x250
7000f3b0:	e1a00003 	mov	r0, r3
7000f3b4:	ebfffd81 	bl	7000e9c0 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
7000f3b8:	e30b3418 	movw	r3, #46104	; 0xb418
7000f3bc:	e3473002 	movt	r3, #28674	; 0x7002
7000f3c0:	e5935000 	ldr	r5, [r3]
7000f3c4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f3c8:	e3473002 	movt	r3, #28674	; 0x7002
7000f3cc:	e5934000 	ldr	r4, [r3]
7000f3d0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f3d4:	e3473002 	movt	r3, #28674	; 0x7002
7000f3d8:	e5933000 	ldr	r3, [r3]
7000f3dc:	e2833e25 	add	r3, r3, #592	; 0x250
7000f3e0:	e1a00003 	mov	r0, r3
7000f3e4:	fa0053d2 	blx	70024334 <strlen>
7000f3e8:	e1a03000 	mov	r3, r0
7000f3ec:	e6ef3073 	uxtb	r3, r3
7000f3f0:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
7000f3f4:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
7000f3f8:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1

                continue;
7000f3fc:	ea000183 	b	7000fa10 <finsh_thread_entry+0xc8c>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
7000f400:	e55b3019 	ldrb	r3, [fp, #-25]
7000f404:	e353007f 	cmp	r3, #127	; 0x7f
7000f408:	0a000002 	beq	7000f418 <finsh_thread_entry+0x694>
7000f40c:	e55b3019 	ldrb	r3, [fp, #-25]
7000f410:	e3530008 	cmp	r3, #8
7000f414:	1a00007f 	bne	7000f618 <finsh_thread_entry+0x894>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
7000f418:	e30b3418 	movw	r3, #46104	; 0xb418
7000f41c:	e3473002 	movt	r3, #28674	; 0x7002
7000f420:	e5933000 	ldr	r3, [r3]
7000f424:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f428:	e3530000 	cmp	r3, #0
7000f42c:	1a000000 	bne	7000f434 <finsh_thread_entry+0x6b0>
                    continue;
7000f430:	ea000176 	b	7000fa10 <finsh_thread_entry+0xc8c>

                shell->line_position--;
7000f434:	e30b3418 	movw	r3, #46104	; 0xb418
7000f438:	e3473002 	movt	r3, #28674	; 0x7002
7000f43c:	e5933000 	ldr	r3, [r3]
7000f440:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
7000f444:	e2422001 	sub	r2, r2, #1
7000f448:	e6ef2072 	uxtb	r2, r2
7000f44c:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
                shell->line_curpos--;
7000f450:	e30b3418 	movw	r3, #46104	; 0xb418
7000f454:	e3473002 	movt	r3, #28674	; 0x7002
7000f458:	e5933000 	ldr	r3, [r3]
7000f45c:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f460:	e2422001 	sub	r2, r2, #1
7000f464:	e6ef2072 	uxtb	r2, r2
7000f468:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1

                if (shell->line_position > shell->line_curpos)
7000f46c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f470:	e3473002 	movt	r3, #28674	; 0x7002
7000f474:	e5933000 	ldr	r3, [r3]
7000f478:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
7000f47c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f480:	e3473002 	movt	r3, #28674	; 0x7002
7000f484:	e5933000 	ldr	r3, [r3]
7000f488:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f48c:	e1520003 	cmp	r2, r3
7000f490:	9a00004f 	bls	7000f5d4 <finsh_thread_entry+0x850>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
7000f494:	e30b3418 	movw	r3, #46104	; 0xb418
7000f498:	e3473002 	movt	r3, #28674	; 0x7002
7000f49c:	e5932000 	ldr	r2, [r3]
7000f4a0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f4a4:	e3473002 	movt	r3, #28674	; 0x7002
7000f4a8:	e5933000 	ldr	r3, [r3]
7000f4ac:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f4b0:	e2833e25 	add	r3, r3, #592	; 0x250
7000f4b4:	e0821003 	add	r1, r2, r3
                               &shell->line[shell->line_curpos + 1],
7000f4b8:	e30b3418 	movw	r3, #46104	; 0xb418
7000f4bc:	e3473002 	movt	r3, #28674	; 0x7002
7000f4c0:	e5932000 	ldr	r2, [r3]
7000f4c4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f4c8:	e3473002 	movt	r3, #28674	; 0x7002
7000f4cc:	e5933000 	ldr	r3, [r3]
7000f4d0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f4d4:	e2833001 	add	r3, r3, #1
7000f4d8:	e2833e25 	add	r3, r3, #592	; 0x250
7000f4dc:	e0822003 	add	r2, r2, r3
                               shell->line_position - shell->line_curpos);
7000f4e0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f4e4:	e3473002 	movt	r3, #28674	; 0x7002
7000f4e8:	e5933000 	ldr	r3, [r3]
7000f4ec:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f4f0:	e1a00003 	mov	r0, r3
7000f4f4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f4f8:	e3473002 	movt	r3, #28674	; 0x7002
7000f4fc:	e5933000 	ldr	r3, [r3]
7000f500:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f504:	e0633000 	rsb	r3, r3, r0

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
7000f508:	e1a00001 	mov	r0, r1
7000f50c:	e1a01002 	mov	r1, r2
7000f510:	e1a02003 	mov	r2, r3
7000f514:	ebffdb7c 	bl	7000630c <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
7000f518:	e30b3418 	movw	r3, #46104	; 0xb418
7000f51c:	e3473002 	movt	r3, #28674	; 0x7002
7000f520:	e5931000 	ldr	r1, [r3]
7000f524:	e30b3418 	movw	r3, #46104	; 0xb418
7000f528:	e3473002 	movt	r3, #28674	; 0x7002
7000f52c:	e5933000 	ldr	r3, [r3]
7000f530:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f534:	e1a02003 	mov	r2, r3
7000f538:	e3a03e25 	mov	r3, #592	; 0x250
7000f53c:	e0812002 	add	r2, r1, r2
7000f540:	e0823003 	add	r3, r2, r3
7000f544:	e3a02000 	mov	r2, #0
7000f548:	e5c32000 	strb	r2, [r3]

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
7000f54c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f550:	e3473002 	movt	r3, #28674	; 0x7002
7000f554:	e5932000 	ldr	r2, [r3]
7000f558:	e30b3418 	movw	r3, #46104	; 0xb418
7000f55c:	e3473002 	movt	r3, #28674	; 0x7002
7000f560:	e5933000 	ldr	r3, [r3]
7000f564:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f568:	e2833e25 	add	r3, r3, #592	; 0x250
7000f56c:	e0823003 	add	r3, r2, r3
7000f570:	e307032c 	movw	r0, #29484	; 0x732c
7000f574:	e3470002 	movt	r0, #28674	; 0x7002
7000f578:	e1a01003 	mov	r1, r3
7000f57c:	ebffe09c 	bl	700077f4 <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
7000f580:	e30b3418 	movw	r3, #46104	; 0xb418
7000f584:	e3473002 	movt	r3, #28674	; 0x7002
7000f588:	e5933000 	ldr	r3, [r3]
7000f58c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f590:	e50b3014 	str	r3, [fp, #-20]
7000f594:	ea000005 	b	7000f5b0 <finsh_thread_entry+0x82c>
                        rt_kprintf("\b");
7000f598:	e3070324 	movw	r0, #29476	; 0x7324
7000f59c:	e3470002 	movt	r0, #28674	; 0x7002
7000f5a0:	ebffe093 	bl	700077f4 <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
7000f5a4:	e51b3014 	ldr	r3, [fp, #-20]
7000f5a8:	e2833001 	add	r3, r3, #1
7000f5ac:	e50b3014 	str	r3, [fp, #-20]
7000f5b0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f5b4:	e3473002 	movt	r3, #28674	; 0x7002
7000f5b8:	e5933000 	ldr	r3, [r3]
7000f5bc:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f5c0:	e1a02003 	mov	r2, r3
7000f5c4:	e51b3014 	ldr	r3, [fp, #-20]
7000f5c8:	e1520003 	cmp	r2, r3
7000f5cc:	aafffff1 	bge	7000f598 <finsh_thread_entry+0x814>
                {
                    rt_kprintf("\b \b");
                    shell->line[shell->line_position] = 0;
                }

                continue;
7000f5d0:	ea00010e 	b	7000fa10 <finsh_thread_entry+0xc8c>
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
7000f5d4:	e3070334 	movw	r0, #29492	; 0x7334
7000f5d8:	e3470002 	movt	r0, #28674	; 0x7002
7000f5dc:	ebffe084 	bl	700077f4 <rt_kprintf>
                    shell->line[shell->line_position] = 0;
7000f5e0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f5e4:	e3473002 	movt	r3, #28674	; 0x7002
7000f5e8:	e5931000 	ldr	r1, [r3]
7000f5ec:	e30b3418 	movw	r3, #46104	; 0xb418
7000f5f0:	e3473002 	movt	r3, #28674	; 0x7002
7000f5f4:	e5933000 	ldr	r3, [r3]
7000f5f8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f5fc:	e1a02003 	mov	r2, r3
7000f600:	e3a03e25 	mov	r3, #592	; 0x250
7000f604:	e0812002 	add	r2, r1, r2
7000f608:	e0823003 	add	r3, r2, r3
7000f60c:	e3a02000 	mov	r2, #0
7000f610:	e5c32000 	strb	r2, [r3]
                }

                continue;
7000f614:	ea0000fd 	b	7000fa10 <finsh_thread_entry+0xc8c>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
7000f618:	e55b3019 	ldrb	r3, [fp, #-25]
7000f61c:	e353000d 	cmp	r3, #13
7000f620:	0a000002 	beq	7000f630 <finsh_thread_entry+0x8ac>
7000f624:	e55b3019 	ldrb	r3, [fp, #-25]
7000f628:	e353000a 	cmp	r3, #10
7000f62c:	1a000050 	bne	7000f774 <finsh_thread_entry+0x9f0>
            {
                #ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
7000f630:	e30b3418 	movw	r3, #46104	; 0xb418
7000f634:	e3473002 	movt	r3, #28674	; 0x7002
7000f638:	e5933000 	ldr	r3, [r3]
7000f63c:	e1a00003 	mov	r0, r3
7000f640:	ebfffd53 	bl	7000eb94 <shell_push_history>
                #endif

                #ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
7000f644:	eb00067d 	bl	70011040 <msh_is_used>
7000f648:	e1a03000 	mov	r3, r0
7000f64c:	e3530001 	cmp	r3, #1
7000f650:	1a00000e 	bne	7000f690 <finsh_thread_entry+0x90c>
                {
                    rt_kprintf("\n");
7000f654:	e30702d8 	movw	r0, #29400	; 0x72d8
7000f658:	e3470002 	movt	r0, #28674	; 0x7002
7000f65c:	ebffe064 	bl	700077f4 <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
7000f660:	e30b3418 	movw	r3, #46104	; 0xb418
7000f664:	e3473002 	movt	r3, #28674	; 0x7002
7000f668:	e5933000 	ldr	r3, [r3]
7000f66c:	e2832e25 	add	r2, r3, #592	; 0x250
7000f670:	e30b3418 	movw	r3, #46104	; 0xb418
7000f674:	e3473002 	movt	r3, #28674	; 0x7002
7000f678:	e5933000 	ldr	r3, [r3]
7000f67c:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f680:	e1a00002 	mov	r0, r2
7000f684:	e1a01003 	mov	r1, r3
7000f688:	eb000816 	bl	700116e8 <msh_exec>
7000f68c:	ea000021 	b	7000f718 <finsh_thread_entry+0x994>
                else
                #endif
                {
                #ifndef FINSH_USING_MSH_ONLY                
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
7000f690:	e30b3418 	movw	r3, #46104	; 0xb418
7000f694:	e3473002 	movt	r3, #28674	; 0x7002
7000f698:	e5931000 	ldr	r1, [r3]
7000f69c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f6a0:	e3473002 	movt	r3, #28674	; 0x7002
7000f6a4:	e5933000 	ldr	r3, [r3]
7000f6a8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f6ac:	e1a02003 	mov	r2, r3
7000f6b0:	e3a03e25 	mov	r3, #592	; 0x250
7000f6b4:	e0812002 	add	r2, r1, r2
7000f6b8:	e0823003 	add	r3, r2, r3
7000f6bc:	e3a0203b 	mov	r2, #59	; 0x3b
7000f6c0:	e5c32000 	strb	r2, [r3]

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
7000f6c4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f6c8:	e3473002 	movt	r3, #28674	; 0x7002
7000f6cc:	e5933000 	ldr	r3, [r3]
7000f6d0:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f6d4:	e3530000 	cmp	r3, #0
7000f6d8:	0a00000b 	beq	7000f70c <finsh_thread_entry+0x988>
7000f6dc:	e30b3418 	movw	r3, #46104	; 0xb418
7000f6e0:	e3473002 	movt	r3, #28674	; 0x7002
7000f6e4:	e5933000 	ldr	r3, [r3]
7000f6e8:	e2832f6d 	add	r2, r3, #436	; 0x1b4
7000f6ec:	e30b3418 	movw	r3, #46104	; 0xb418
7000f6f0:	e3473002 	movt	r3, #28674	; 0x7002
7000f6f4:	e5933000 	ldr	r3, [r3]
7000f6f8:	e2833e25 	add	r3, r3, #592	; 0x250
7000f6fc:	e1a00002 	mov	r0, r2
7000f700:	e1a01003 	mov	r1, r3
7000f704:	ebfffcc6 	bl	7000ea24 <finsh_run_line>
7000f708:	ea000002 	b	7000f718 <finsh_thread_entry+0x994>
                    else rt_kprintf("\n");
7000f70c:	e30702d8 	movw	r0, #29400	; 0x72d8
7000f710:	e3470002 	movt	r0, #28674	; 0x7002
7000f714:	ebffe036 	bl	700077f4 <rt_kprintf>
                #endif                  
                }

                rt_kprintf(FINSH_PROMPT);
7000f718:	ebfffb4c 	bl	7000e450 <finsh_get_prompt>
7000f71c:	e1a03000 	mov	r3, r0
7000f720:	e1a00003 	mov	r0, r3
7000f724:	ebffe032 	bl	700077f4 <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
7000f728:	e30b3418 	movw	r3, #46104	; 0xb418
7000f72c:	e3473002 	movt	r3, #28674	; 0x7002
7000f730:	e5933000 	ldr	r3, [r3]
7000f734:	e2833e25 	add	r3, r3, #592	; 0x250
7000f738:	e1a00003 	mov	r0, r3
7000f73c:	e3a01000 	mov	r1, #0
7000f740:	e3a02050 	mov	r2, #80	; 0x50
7000f744:	fa005201 	blx	70023f50 <memset>
                shell->line_curpos = shell->line_position = 0;
7000f748:	e30b3418 	movw	r3, #46104	; 0xb418
7000f74c:	e3473002 	movt	r3, #28674	; 0x7002
7000f750:	e5932000 	ldr	r2, [r3]
7000f754:	e30b3418 	movw	r3, #46104	; 0xb418
7000f758:	e3473002 	movt	r3, #28674	; 0x7002
7000f75c:	e5933000 	ldr	r3, [r3]
7000f760:	e3a01000 	mov	r1, #0
7000f764:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
7000f768:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f76c:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1
                break;
7000f770:	ea0000b3 	b	7000fa44 <finsh_thread_entry+0xcc0>
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
7000f774:	e30b3418 	movw	r3, #46104	; 0xb418
7000f778:	e3473002 	movt	r3, #28674	; 0x7002
7000f77c:	e5933000 	ldr	r3, [r3]
7000f780:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f784:	e353004f 	cmp	r3, #79	; 0x4f
7000f788:	9a000004 	bls	7000f7a0 <finsh_thread_entry+0xa1c>
                shell->line_position = 0;
7000f78c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f790:	e3473002 	movt	r3, #28674	; 0x7002
7000f794:	e5933000 	ldr	r3, [r3]
7000f798:	e3a02000 	mov	r2, #0
7000f79c:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0

            /* normal character */
            if (shell->line_curpos < shell->line_position)
7000f7a0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f7a4:	e3473002 	movt	r3, #28674	; 0x7002
7000f7a8:	e5933000 	ldr	r3, [r3]
7000f7ac:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f7b0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f7b4:	e3473002 	movt	r3, #28674	; 0x7002
7000f7b8:	e5933000 	ldr	r3, [r3]
7000f7bc:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f7c0:	e1520003 	cmp	r2, r3
7000f7c4:	2a000057 	bcs	7000f928 <finsh_thread_entry+0xba4>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
7000f7c8:	e30b3418 	movw	r3, #46104	; 0xb418
7000f7cc:	e3473002 	movt	r3, #28674	; 0x7002
7000f7d0:	e5932000 	ldr	r2, [r3]
7000f7d4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f7d8:	e3473002 	movt	r3, #28674	; 0x7002
7000f7dc:	e5933000 	ldr	r3, [r3]
7000f7e0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f7e4:	e2833001 	add	r3, r3, #1
7000f7e8:	e2833e25 	add	r3, r3, #592	; 0x250
7000f7ec:	e0821003 	add	r1, r2, r3
                           &shell->line[shell->line_curpos],
7000f7f0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f7f4:	e3473002 	movt	r3, #28674	; 0x7002
7000f7f8:	e5932000 	ldr	r2, [r3]
7000f7fc:	e30b3418 	movw	r3, #46104	; 0xb418
7000f800:	e3473002 	movt	r3, #28674	; 0x7002
7000f804:	e5933000 	ldr	r3, [r3]
7000f808:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f80c:	e2833e25 	add	r3, r3, #592	; 0x250
7000f810:	e0822003 	add	r2, r2, r3
                           shell->line_position - shell->line_curpos);
7000f814:	e30b3418 	movw	r3, #46104	; 0xb418
7000f818:	e3473002 	movt	r3, #28674	; 0x7002
7000f81c:	e5933000 	ldr	r3, [r3]
7000f820:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f824:	e1a00003 	mov	r0, r3
7000f828:	e30b3418 	movw	r3, #46104	; 0xb418
7000f82c:	e3473002 	movt	r3, #28674	; 0x7002
7000f830:	e5933000 	ldr	r3, [r3]
7000f834:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f838:	e0633000 	rsb	r3, r3, r0
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
7000f83c:	e1a00001 	mov	r0, r1
7000f840:	e1a01002 	mov	r1, r2
7000f844:	e1a02003 	mov	r2, r3
7000f848:	ebffdaaf 	bl	7000630c <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
7000f84c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f850:	e3473002 	movt	r3, #28674	; 0x7002
7000f854:	e5930000 	ldr	r0, [r3]
7000f858:	e30b3418 	movw	r3, #46104	; 0xb418
7000f85c:	e3473002 	movt	r3, #28674	; 0x7002
7000f860:	e5933000 	ldr	r3, [r3]
7000f864:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f868:	e1a01003 	mov	r1, r3
7000f86c:	e55b2019 	ldrb	r2, [fp, #-25]
7000f870:	e3a03e25 	mov	r3, #592	; 0x250
7000f874:	e0801001 	add	r1, r0, r1
7000f878:	e0813003 	add	r3, r1, r3
7000f87c:	e5c32000 	strb	r2, [r3]
                if (shell->echo_mode)
7000f880:	e30b3418 	movw	r3, #46104	; 0xb418
7000f884:	e3473002 	movt	r3, #28674	; 0x7002
7000f888:	e5933000 	ldr	r3, [r3]
7000f88c:	e5d3301d 	ldrb	r3, [r3, #29]
7000f890:	e7e03053 	ubfx	r3, r3, #0, #1
7000f894:	e6ef3073 	uxtb	r3, r3
7000f898:	e3530000 	cmp	r3, #0
7000f89c:	0a00000c 	beq	7000f8d4 <finsh_thread_entry+0xb50>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
7000f8a0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f8a4:	e3473002 	movt	r3, #28674	; 0x7002
7000f8a8:	e5932000 	ldr	r2, [r3]
7000f8ac:	e30b3418 	movw	r3, #46104	; 0xb418
7000f8b0:	e3473002 	movt	r3, #28674	; 0x7002
7000f8b4:	e5933000 	ldr	r3, [r3]
7000f8b8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f8bc:	e2833e25 	add	r3, r3, #592	; 0x250
7000f8c0:	e0823003 	add	r3, r2, r3
7000f8c4:	e3070338 	movw	r0, #29496	; 0x7338
7000f8c8:	e3470002 	movt	r0, #28674	; 0x7002
7000f8cc:	e1a01003 	mov	r1, r3
7000f8d0:	ebffdfc7 	bl	700077f4 <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
7000f8d4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f8d8:	e3473002 	movt	r3, #28674	; 0x7002
7000f8dc:	e5933000 	ldr	r3, [r3]
7000f8e0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
7000f8e4:	e50b3018 	str	r3, [fp, #-24]
7000f8e8:	ea000005 	b	7000f904 <finsh_thread_entry+0xb80>
                    rt_kprintf("\b");
7000f8ec:	e3070324 	movw	r0, #29476	; 0x7324
7000f8f0:	e3470002 	movt	r0, #28674	; 0x7002
7000f8f4:	ebffdfbe 	bl	700077f4 <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
7000f8f8:	e51b3018 	ldr	r3, [fp, #-24]
7000f8fc:	e2833001 	add	r3, r3, #1
7000f900:	e50b3018 	str	r3, [fp, #-24]
7000f904:	e30b3418 	movw	r3, #46104	; 0xb418
7000f908:	e3473002 	movt	r3, #28674	; 0x7002
7000f90c:	e5933000 	ldr	r3, [r3]
7000f910:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f914:	e1a02003 	mov	r2, r3
7000f918:	e51b3018 	ldr	r3, [fp, #-24]
7000f91c:	e1520003 	cmp	r2, r3
7000f920:	cafffff1 	bgt	7000f8ec <finsh_thread_entry+0xb68>
7000f924:	ea000019 	b	7000f990 <finsh_thread_entry+0xc0c>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
7000f928:	e30b3418 	movw	r3, #46104	; 0xb418
7000f92c:	e3473002 	movt	r3, #28674	; 0x7002
7000f930:	e5930000 	ldr	r0, [r3]
7000f934:	e30b3418 	movw	r3, #46104	; 0xb418
7000f938:	e3473002 	movt	r3, #28674	; 0x7002
7000f93c:	e5933000 	ldr	r3, [r3]
7000f940:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f944:	e1a01003 	mov	r1, r3
7000f948:	e55b2019 	ldrb	r2, [fp, #-25]
7000f94c:	e3a03e25 	mov	r3, #592	; 0x250
7000f950:	e0801001 	add	r1, r0, r1
7000f954:	e0813003 	add	r3, r1, r3
7000f958:	e5c32000 	strb	r2, [r3]
                if (shell->echo_mode)
7000f95c:	e30b3418 	movw	r3, #46104	; 0xb418
7000f960:	e3473002 	movt	r3, #28674	; 0x7002
7000f964:	e5933000 	ldr	r3, [r3]
7000f968:	e5d3301d 	ldrb	r3, [r3, #29]
7000f96c:	e7e03053 	ubfx	r3, r3, #0, #1
7000f970:	e6ef3073 	uxtb	r3, r3
7000f974:	e3530000 	cmp	r3, #0
7000f978:	0a000004 	beq	7000f990 <finsh_thread_entry+0xc0c>
                    rt_kprintf("%c", ch);
7000f97c:	e55b3019 	ldrb	r3, [fp, #-25]
7000f980:	e3070328 	movw	r0, #29480	; 0x7328
7000f984:	e3470002 	movt	r0, #28674	; 0x7002
7000f988:	e1a01003 	mov	r1, r3
7000f98c:	ebffdf98 	bl	700077f4 <rt_kprintf>
            }

            ch = 0;
7000f990:	e3a03000 	mov	r3, #0
7000f994:	e54b3019 	strb	r3, [fp, #-25]
            shell->line_position ++;
7000f998:	e30b3418 	movw	r3, #46104	; 0xb418
7000f99c:	e3473002 	movt	r3, #28674	; 0x7002
7000f9a0:	e5933000 	ldr	r3, [r3]
7000f9a4:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
7000f9a8:	e2822001 	add	r2, r2, #1
7000f9ac:	e6ef2072 	uxtb	r2, r2
7000f9b0:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
            shell->line_curpos++;
7000f9b4:	e30b3418 	movw	r3, #46104	; 0xb418
7000f9b8:	e3473002 	movt	r3, #28674	; 0x7002
7000f9bc:	e5933000 	ldr	r3, [r3]
7000f9c0:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
7000f9c4:	e2822001 	add	r2, r2, #1
7000f9c8:	e6ef2072 	uxtb	r2, r2
7000f9cc:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
			if (shell->line_position >= 80) 
7000f9d0:	e30b3418 	movw	r3, #46104	; 0xb418
7000f9d4:	e3473002 	movt	r3, #28674	; 0x7002
7000f9d8:	e5933000 	ldr	r3, [r3]
7000f9dc:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
7000f9e0:	e353004f 	cmp	r3, #79	; 0x4f
7000f9e4:	9a000009 	bls	7000fa10 <finsh_thread_entry+0xc8c>
			{
				/* clear command line */
				shell->line_position = 0;
7000f9e8:	e30b3418 	movw	r3, #46104	; 0xb418
7000f9ec:	e3473002 	movt	r3, #28674	; 0x7002
7000f9f0:	e5933000 	ldr	r3, [r3]
7000f9f4:	e3a02000 	mov	r2, #0
7000f9f8:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
				shell->line_curpos = 0;
7000f9fc:	e30b3418 	movw	r3, #46104	; 0xb418
7000fa00:	e3473002 	movt	r3, #28674	; 0x7002
7000fa04:	e5933000 	ldr	r3, [r3]
7000fa08:	e3a02000 	mov	r2, #0
7000fa0c:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
7000fa10:	e30b3418 	movw	r3, #46104	; 0xb418
7000fa14:	e3473002 	movt	r3, #28674	; 0x7002
7000fa18:	e5933000 	ldr	r3, [r3]
7000fa1c:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
7000fa20:	e24b3019 	sub	r3, fp, #25
7000fa24:	e1a00002 	mov	r0, r2
7000fa28:	e3a01000 	mov	r1, #0
7000fa2c:	e1a02003 	mov	r2, r3
7000fa30:	e3a03001 	mov	r3, #1
7000fa34:	ebffc55c 	bl	70000fac <rt_device_read>
7000fa38:	e1a03000 	mov	r3, r0
7000fa3c:	e3530001 	cmp	r3, #1
7000fa40:	0afffd2d 	beq	7000eefc <finsh_thread_entry+0x178>
				/* clear command line */
				shell->line_position = 0;
				shell->line_curpos = 0;
			}
        } /* end of device read */
    }
7000fa44:	eafffd21 	b	7000eed0 <finsh_thread_entry+0x14c>

7000fa48 <finsh_system_function_init>:
}

void finsh_system_function_init(const void* begin, const void* end)
{
7000fa48:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000fa4c:	e28db000 	add	fp, sp, #0
7000fa50:	e24dd00c 	sub	sp, sp, #12
7000fa54:	e50b0008 	str	r0, [fp, #-8]
7000fa58:	e50b100c 	str	r1, [fp, #-12]
    _syscall_table_begin = (struct finsh_syscall*) begin;
7000fa5c:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
7000fa60:	e3473002 	movt	r3, #28674	; 0x7002
7000fa64:	e51b2008 	ldr	r2, [fp, #-8]
7000fa68:	e5832000 	str	r2, [r3]
    _syscall_table_end = (struct finsh_syscall*) end;
7000fa6c:	e30a3a10 	movw	r3, #43536	; 0xaa10
7000fa70:	e3473002 	movt	r3, #28674	; 0x7002
7000fa74:	e51b200c 	ldr	r2, [fp, #-12]
7000fa78:	e5832000 	str	r2, [r3]
}
7000fa7c:	e24bd000 	sub	sp, fp, #0
7000fa80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000fa84:	e12fff1e 	bx	lr

7000fa88 <finsh_system_var_init>:

void finsh_system_var_init(const void* begin, const void* end)
{
7000fa88:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000fa8c:	e28db000 	add	fp, sp, #0
7000fa90:	e24dd00c 	sub	sp, sp, #12
7000fa94:	e50b0008 	str	r0, [fp, #-8]
7000fa98:	e50b100c 	str	r1, [fp, #-12]
    _sysvar_table_begin = (struct finsh_sysvar*) begin;
7000fa9c:	e30a3a14 	movw	r3, #43540	; 0xaa14
7000faa0:	e3473002 	movt	r3, #28674	; 0x7002
7000faa4:	e51b2008 	ldr	r2, [fp, #-8]
7000faa8:	e5832000 	str	r2, [r3]
    _sysvar_table_end = (struct finsh_sysvar*) end;
7000faac:	e30a3a18 	movw	r3, #43544	; 0xaa18
7000fab0:	e3473002 	movt	r3, #28674	; 0x7002
7000fab4:	e51b200c 	ldr	r2, [fp, #-12]
7000fab8:	e5832000 	str	r2, [r3]
}
7000fabc:	e24bd000 	sub	sp, fp, #0
7000fac0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000fac4:	e12fff1e 	bx	lr

7000fac8 <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
7000fac8:	e92d4800 	push	{fp, lr}
7000facc:	e28db004 	add	fp, sp, #4
7000fad0:	e24dd018 	sub	sp, sp, #24
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
7000fad4:	e3050f30 	movw	r0, #24368	; 0x5f30
7000fad8:	e3470002 	movt	r0, #28674	; 0x7002
7000fadc:	e30610c8 	movw	r1, #24776	; 0x60c8
7000fae0:	e3471002 	movt	r1, #28674	; 0x7002
7000fae4:	ebffffd7 	bl	7000fa48 <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
7000fae8:	e30600c8 	movw	r0, #24776	; 0x60c8
7000faec:	e3470002 	movt	r0, #28674	; 0x7002
7000faf0:	e30610d8 	movw	r1, #24792	; 0x60d8
7000faf4:	e3471002 	movt	r1, #28674	; 0x7002
7000faf8:	ebffffe2 	bl	7000fa88 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell*)rt_malloc(sizeof(struct finsh_shell));
7000fafc:	e3a00faa 	mov	r0, #680	; 0x2a8
7000fb00:	ebffe16d 	bl	700080bc <rt_malloc>
7000fb04:	e1a02000 	mov	r2, r0
7000fb08:	e30b3418 	movw	r3, #46104	; 0xb418
7000fb0c:	e3473002 	movt	r3, #28674	; 0x7002
7000fb10:	e5832000 	str	r2, [r3]
    if (shell == RT_NULL)
7000fb14:	e30b3418 	movw	r3, #46104	; 0xb418
7000fb18:	e3473002 	movt	r3, #28674	; 0x7002
7000fb1c:	e5933000 	ldr	r3, [r3]
7000fb20:	e3530000 	cmp	r3, #0
7000fb24:	1a000004 	bne	7000fb3c <finsh_system_init+0x74>
    {
        rt_kprintf("no memory for shell\n");
7000fb28:	e307033c 	movw	r0, #29500	; 0x733c
7000fb2c:	e3470002 	movt	r0, #28674	; 0x7002
7000fb30:	ebffdf2f 	bl	700077f4 <rt_kprintf>
        return -1;
7000fb34:	e3e03000 	mvn	r3, #0
7000fb38:	ea000028 	b	7000fbe0 <finsh_system_init+0x118>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
7000fb3c:	e30b3418 	movw	r3, #46104	; 0xb418
7000fb40:	e3473002 	movt	r3, #28674	; 0x7002
7000fb44:	e5933000 	ldr	r3, [r3]
7000fb48:	e1a00003 	mov	r0, r3
7000fb4c:	e3a01000 	mov	r1, #0
7000fb50:	e3a02faa 	mov	r2, #680	; 0x2a8
7000fb54:	fa0050fd 	blx	70023f50 <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
7000fb58:	e30b3418 	movw	r3, #46104	; 0xb418
7000fb5c:	e3473002 	movt	r3, #28674	; 0x7002
7000fb60:	e5933000 	ldr	r3, [r3]
7000fb64:	e1a00003 	mov	r0, r3
7000fb68:	e3071354 	movw	r1, #29524	; 0x7354
7000fb6c:	e3471002 	movt	r1, #28674	; 0x7002
7000fb70:	e3a02000 	mov	r2, #0
7000fb74:	e3a03000 	mov	r3, #0
7000fb78:	ebffc789 	bl	700019a4 <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
7000fb7c:	e3093988 	movw	r3, #39304	; 0x9988
7000fb80:	e3473002 	movt	r3, #28674	; 0x7002
7000fb84:	e58d3000 	str	r3, [sp]
7000fb88:	e3a03a01 	mov	r3, #4096	; 0x1000
7000fb8c:	e58d3004 	str	r3, [sp, #4]
7000fb90:	e3a03014 	mov	r3, #20
7000fb94:	e58d3008 	str	r3, [sp, #8]
7000fb98:	e3a0300a 	mov	r3, #10
7000fb9c:	e58d300c 	str	r3, [sp, #12]
7000fba0:	e3090910 	movw	r0, #39184	; 0x9910
7000fba4:	e3470002 	movt	r0, #28674	; 0x7002
7000fba8:	e307135c 	movw	r1, #29532	; 0x735c
7000fbac:	e3471002 	movt	r1, #28674	; 0x7002
7000fbb0:	e30e2d84 	movw	r2, #60804	; 0xed84
7000fbb4:	e3472000 	movt	r2, #28672	; 0x7000
7000fbb8:	e3a03000 	mov	r3, #0
7000fbbc:	ebffea0d 	bl	7000a3f8 <rt_thread_init>
7000fbc0:	e50b0008 	str	r0, [fp, #-8]
        "tshell",
        finsh_thread_entry, RT_NULL,
        &finsh_thread_stack[0], sizeof(finsh_thread_stack),
        FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
7000fbc4:	e51b3008 	ldr	r3, [fp, #-8]
7000fbc8:	e3530000 	cmp	r3, #0
7000fbcc:	1a000002 	bne	7000fbdc <finsh_system_init+0x114>
        rt_thread_startup(&finsh_thread);
7000fbd0:	e3090910 	movw	r0, #39184	; 0x9910
7000fbd4:	e3470002 	movt	r0, #28674	; 0x7002
7000fbd8:	ebffea6d 	bl	7000a594 <rt_thread_startup>
    return 0;
7000fbdc:	e3a03000 	mov	r3, #0
}
7000fbe0:	e1a00003 	mov	r0, r3
7000fbe4:	e24bd004 	sub	sp, fp, #4
7000fbe8:	e8bd8800 	pop	{fp, pc}

7000fbec <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
7000fbec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000fbf0:	e28db000 	add	fp, sp, #0
7000fbf4:	e24dd00c 	sub	sp, sp, #12
7000fbf8:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
7000fbfc:	e51b3008 	ldr	r3, [fp, #-8]
7000fc00:	e5932000 	ldr	r2, [r3]
7000fc04:	e51b3008 	ldr	r3, [fp, #-8]
7000fc08:	e1520003 	cmp	r2, r3
7000fc0c:	13a03000 	movne	r3, #0
7000fc10:	03a03001 	moveq	r3, #1
7000fc14:	e6ef3073 	uxtb	r3, r3
}
7000fc18:	e1a00003 	mov	r0, r3
7000fc1c:	e24bd000 	sub	sp, fp, #0
7000fc20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000fc24:	e12fff1e 	bx	lr

7000fc28 <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
7000fc28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7000fc2c:	e28db000 	add	fp, sp, #0
7000fc30:	e24dd014 	sub	sp, sp, #20
7000fc34:	e50b0010 	str	r0, [fp, #-16]
    unsigned int len = 0;
7000fc38:	e3a03000 	mov	r3, #0
7000fc3c:	e50b3008 	str	r3, [fp, #-8]
    const rt_list_t *p = l;
7000fc40:	e51b3010 	ldr	r3, [fp, #-16]
7000fc44:	e50b300c 	str	r3, [fp, #-12]
    while (p->next != l)
7000fc48:	ea000005 	b	7000fc64 <rt_list_len+0x3c>
    {
        p = p->next;
7000fc4c:	e51b300c 	ldr	r3, [fp, #-12]
7000fc50:	e5933000 	ldr	r3, [r3]
7000fc54:	e50b300c 	str	r3, [fp, #-12]
        len ++;
7000fc58:	e51b3008 	ldr	r3, [fp, #-8]
7000fc5c:	e2833001 	add	r3, r3, #1
7000fc60:	e50b3008 	str	r3, [fp, #-8]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
7000fc64:	e51b300c 	ldr	r3, [fp, #-12]
7000fc68:	e5932000 	ldr	r2, [r3]
7000fc6c:	e51b3010 	ldr	r3, [fp, #-16]
7000fc70:	e1520003 	cmp	r2, r3
7000fc74:	1afffff4 	bne	7000fc4c <rt_list_len+0x24>
    {
        p = p->next;
        len ++;
    }

    return len;
7000fc78:	e51b3008 	ldr	r3, [fp, #-8]
}
7000fc7c:	e1a00003 	mov	r0, r3
7000fc80:	e24bd000 	sub	sp, fp, #0
7000fc84:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7000fc88:	e12fff1e 	bx	lr

7000fc8c <hello>:

long hello(void)
{
7000fc8c:	e92d4800 	push	{fp, lr}
7000fc90:	e28db004 	add	fp, sp, #4
    rt_kprintf("Hello RT-Thread!\n");
7000fc94:	e30703d0 	movw	r0, #29648	; 0x73d0
7000fc98:	e3470002 	movt	r0, #28674	; 0x7002
7000fc9c:	ebffded4 	bl	700077f4 <rt_kprintf>

    return 0;
7000fca0:	e3a03000 	mov	r3, #0
}
7000fca4:	e1a00003 	mov	r0, r3
7000fca8:	e8bd8800 	pop	{fp, pc}

7000fcac <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
7000fcac:	e92d4800 	push	{fp, lr}
7000fcb0:	e28db004 	add	fp, sp, #4
    rt_show_version();
7000fcb4:	ebffdaf9 	bl	700068a0 <rt_show_version>

    return 0;
7000fcb8:	e3a03000 	mov	r3, #0
}
7000fcbc:	e1a00003 	mov	r0, r3
7000fcc0:	e8bd8800 	pop	{fp, pc}

7000fcc4 <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
7000fcc4:	e92d4800 	push	{fp, lr}
7000fcc8:	e28db004 	add	fp, sp, #4
7000fccc:	e24dd020 	sub	sp, sp, #32
7000fcd0:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
7000fcd4:	e307045c 	movw	r0, #29788	; 0x745c
7000fcd8:	e3470002 	movt	r0, #28674	; 0x7002
7000fcdc:	ebffdec4 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
7000fce0:	e30704a8 	movw	r0, #29864	; 0x74a8
7000fce4:	e3470002 	movt	r0, #28674	; 0x7002
7000fce8:	ebffdec1 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
7000fcec:	e51b3018 	ldr	r3, [fp, #-24]
7000fcf0:	e5933000 	ldr	r3, [r3]
7000fcf4:	e50b3008 	str	r3, [fp, #-8]
7000fcf8:	ea000055 	b	7000fe54 <_list_thread+0x190>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
7000fcfc:	e51b3008 	ldr	r3, [fp, #-8]
7000fd00:	e2433008 	sub	r3, r3, #8
7000fd04:	e50b3010 	str	r3, [fp, #-16]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
7000fd08:	e51b2010 	ldr	r2, [fp, #-16]
7000fd0c:	e51b3010 	ldr	r3, [fp, #-16]
7000fd10:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
7000fd14:	e30704f0 	movw	r0, #29936	; 0x74f0
7000fd18:	e3470002 	movt	r0, #28674	; 0x7002
7000fd1c:	e3a01006 	mov	r1, #6
7000fd20:	ebffdeb3 	bl	700077f4 <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
7000fd24:	e51b3010 	ldr	r3, [fp, #-16]
7000fd28:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000fd2c:	e3530001 	cmp	r3, #1
7000fd30:	1a000003 	bne	7000fd44 <_list_thread+0x80>
7000fd34:	e3070500 	movw	r0, #29952	; 0x7500
7000fd38:	e3470002 	movt	r0, #28674	; 0x7002
7000fd3c:	ebffdeac 	bl	700077f4 <rt_kprintf>
7000fd40:	ea000016 	b	7000fda0 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
7000fd44:	e51b3010 	ldr	r3, [fp, #-16]
7000fd48:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000fd4c:	e3530002 	cmp	r3, #2
7000fd50:	1a000003 	bne	7000fd64 <_list_thread+0xa0>
7000fd54:	e307050c 	movw	r0, #29964	; 0x750c
7000fd58:	e3470002 	movt	r0, #28674	; 0x7002
7000fd5c:	ebffdea4 	bl	700077f4 <rt_kprintf>
7000fd60:	ea00000e 	b	7000fda0 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
7000fd64:	e51b3010 	ldr	r3, [fp, #-16]
7000fd68:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000fd6c:	e3530000 	cmp	r3, #0
7000fd70:	1a000003 	bne	7000fd84 <_list_thread+0xc0>
7000fd74:	e3070518 	movw	r0, #29976	; 0x7518
7000fd78:	e3470002 	movt	r0, #28674	; 0x7002
7000fd7c:	ebffde9c 	bl	700077f4 <rt_kprintf>
7000fd80:	ea000006 	b	7000fda0 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
7000fd84:	e51b3010 	ldr	r3, [fp, #-16]
7000fd88:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7000fd8c:	e3530004 	cmp	r3, #4
7000fd90:	1a000002 	bne	7000fda0 <_list_thread+0xdc>
7000fd94:	e3070524 	movw	r0, #29988	; 0x7524
7000fd98:	e3470002 	movt	r0, #28674	; 0x7002
7000fd9c:	ebffde94 	bl	700077f4 <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
7000fda0:	e51b3010 	ldr	r3, [fp, #-16]
7000fda4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000fda8:	e50b300c 	str	r3, [fp, #-12]
        while (*ptr == '#')ptr ++;
7000fdac:	ea000002 	b	7000fdbc <_list_thread+0xf8>
7000fdb0:	e51b300c 	ldr	r3, [fp, #-12]
7000fdb4:	e2833001 	add	r3, r3, #1
7000fdb8:	e50b300c 	str	r3, [fp, #-12]
7000fdbc:	e51b300c 	ldr	r3, [fp, #-12]
7000fdc0:	e5d33000 	ldrb	r3, [r3]
7000fdc4:	e3530023 	cmp	r3, #35	; 0x23
7000fdc8:	0afffff8 	beq	7000fdb0 <_list_thread+0xec>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
7000fdcc:	e51b3010 	ldr	r3, [fp, #-16]
7000fdd0:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
7000fdd4:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
7000fdd8:	e51b3010 	ldr	r3, [fp, #-16]
7000fddc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000fde0:	e1a01003 	mov	r1, r3
7000fde4:	e51b3010 	ldr	r3, [fp, #-16]
7000fde8:	e5933018 	ldr	r3, [r3, #24]
7000fdec:	e0633001 	rsb	r3, r3, r1
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
7000fdf0:	e0821003 	add	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
7000fdf4:	e51b3010 	ldr	r3, [fp, #-16]
7000fdf8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
7000fdfc:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
7000fe00:	e51b3010 	ldr	r3, [fp, #-16]
7000fe04:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
7000fe08:	e1a00003 	mov	r0, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
7000fe0c:	e51b3010 	ldr	r3, [fp, #-16]
7000fe10:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7000fe14:	e1a0c003 	mov	ip, r3
7000fe18:	e51b300c 	ldr	r3, [fp, #-12]
7000fe1c:	e063300c 	rsb	r3, r3, ip
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
7000fe20:	e0803003 	add	r3, r0, r3
7000fe24:	e51b0010 	ldr	r0, [fp, #-16]
7000fe28:	e590c044 	ldr	ip, [r0, #68]	; 0x44
7000fe2c:	e51b0010 	ldr	r0, [fp, #-16]
7000fe30:	e590002c 	ldr	r0, [r0, #44]	; 0x2c
7000fe34:	e58dc000 	str	ip, [sp]
7000fe38:	e58d0004 	str	r0, [sp, #4]
7000fe3c:	e3070530 	movw	r0, #30000	; 0x7530
7000fe40:	e3470002 	movt	r0, #28674	; 0x7002
7000fe44:	ebffde6a 	bl	700077f4 <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
7000fe48:	e51b3008 	ldr	r3, [fp, #-8]
7000fe4c:	e5933000 	ldr	r3, [r3]
7000fe50:	e50b3008 	str	r3, [fp, #-8]
7000fe54:	e51b2008 	ldr	r2, [fp, #-8]
7000fe58:	e51b3018 	ldr	r3, [fp, #-24]
7000fe5c:	e1520003 	cmp	r2, r3
7000fe60:	1affffa5 	bne	7000fcfc <_list_thread+0x38>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
7000fe64:	e3a03000 	mov	r3, #0
}
7000fe68:	e1a00003 	mov	r0, r3
7000fe6c:	e24bd004 	sub	sp, fp, #4
7000fe70:	e8bd8800 	pop	{fp, pc}

7000fe74 <list_thread>:

long list_thread(void)
{
7000fe74:	e92d4800 	push	{fp, lr}
7000fe78:	e28db004 	add	fp, sp, #4
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
7000fe7c:	e59f000c 	ldr	r0, [pc, #12]	; 7000fe90 <list_thread+0x1c>
7000fe80:	ebffff8f 	bl	7000fcc4 <_list_thread>
7000fe84:	e1a03000 	mov	r3, r0
}
7000fe88:	e1a00003 	mov	r0, r3
7000fe8c:	e8bd8800 	pop	{fp, pc}
7000fe90:	70028d8c 	.word	0x70028d8c

7000fe94 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
7000fe94:	e92d4800 	push	{fp, lr}
7000fe98:	e28db004 	add	fp, sp, #4
7000fe9c:	e24dd010 	sub	sp, sp, #16
7000fea0:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
7000fea4:	e51b3010 	ldr	r3, [fp, #-16]
7000fea8:	e5933000 	ldr	r3, [r3]
7000feac:	e50b3008 	str	r3, [fp, #-8]
7000feb0:	ea000012 	b	7000ff00 <show_wait_queue+0x6c>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
7000feb4:	e51b3008 	ldr	r3, [fp, #-8]
7000feb8:	e2433010 	sub	r3, r3, #16
7000febc:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%s", thread->name);
7000fec0:	e51b300c 	ldr	r3, [fp, #-12]
7000fec4:	e307058c 	movw	r0, #30092	; 0x758c
7000fec8:	e3470002 	movt	r0, #28674	; 0x7002
7000fecc:	e1a01003 	mov	r1, r3
7000fed0:	ebffde47 	bl	700077f4 <rt_kprintf>

        if (node->next != list)
7000fed4:	e51b3008 	ldr	r3, [fp, #-8]
7000fed8:	e5932000 	ldr	r2, [r3]
7000fedc:	e51b3010 	ldr	r3, [fp, #-16]
7000fee0:	e1520003 	cmp	r2, r3
7000fee4:	0a000002 	beq	7000fef4 <show_wait_queue+0x60>
            rt_kprintf("/");
7000fee8:	e3070590 	movw	r0, #30096	; 0x7590
7000feec:	e3470002 	movt	r0, #28674	; 0x7002
7000fef0:	ebffde3f 	bl	700077f4 <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
7000fef4:	e51b3008 	ldr	r3, [fp, #-8]
7000fef8:	e5933000 	ldr	r3, [r3]
7000fefc:	e50b3008 	str	r3, [fp, #-8]
7000ff00:	e51b2008 	ldr	r2, [fp, #-8]
7000ff04:	e51b3010 	ldr	r3, [fp, #-16]
7000ff08:	e1520003 	cmp	r2, r3
7000ff0c:	1affffe8 	bne	7000feb4 <show_wait_queue+0x20>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
7000ff10:	e24bd004 	sub	sp, fp, #4
7000ff14:	e8bd8800 	pop	{fp, pc}

7000ff18 <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
7000ff18:	e92d4830 	push	{r4, r5, fp, lr}
7000ff1c:	e28db00c 	add	fp, sp, #12
7000ff20:	e24dd018 	sub	sp, sp, #24
7000ff24:	e50b0018 	str	r0, [fp, #-24]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
7000ff28:	e3070594 	movw	r0, #30100	; 0x7594
7000ff2c:	e3470002 	movt	r0, #28674	; 0x7002
7000ff30:	ebffde2f 	bl	700077f4 <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
7000ff34:	e30705b4 	movw	r0, #30132	; 0x75b4
7000ff38:	e3470002 	movt	r0, #28674	; 0x7002
7000ff3c:	ebffde2c 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
7000ff40:	e51b3018 	ldr	r3, [fp, #-24]
7000ff44:	e5933000 	ldr	r3, [r3]
7000ff48:	e50b3010 	str	r3, [fp, #-16]
7000ff4c:	ea000034 	b	70010024 <_list_sem+0x10c>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
7000ff50:	e51b3010 	ldr	r3, [fp, #-16]
7000ff54:	e2433008 	sub	r3, r3, #8
7000ff58:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
7000ff5c:	e51b3014 	ldr	r3, [fp, #-20]
7000ff60:	e2833010 	add	r3, r3, #16
7000ff64:	e1a00003 	mov	r0, r3
7000ff68:	ebffff1f 	bl	7000fbec <rt_list_isempty>
7000ff6c:	e1a03000 	mov	r3, r0
7000ff70:	e3530000 	cmp	r3, #0
7000ff74:	1a000017 	bne	7000ffd8 <_list_sem+0xc0>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
7000ff78:	e51b5014 	ldr	r5, [fp, #-20]
                       sem->value,
7000ff7c:	e51b3014 	ldr	r3, [fp, #-20]
7000ff80:	e1d331b8 	ldrh	r3, [r3, #24]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
7000ff84:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
7000ff88:	e51b3014 	ldr	r3, [fp, #-20]
7000ff8c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
7000ff90:	e1a00003 	mov	r0, r3
7000ff94:	ebffff23 	bl	7000fc28 <rt_list_len>
7000ff98:	e1a03000 	mov	r3, r0
7000ff9c:	e58d3000 	str	r3, [sp]
7000ffa0:	e30705d4 	movw	r0, #30164	; 0x75d4
7000ffa4:	e3470002 	movt	r0, #28674	; 0x7002
7000ffa8:	e3a01006 	mov	r1, #6
7000ffac:	e1a02005 	mov	r2, r5
7000ffb0:	e1a03004 	mov	r3, r4
7000ffb4:	ebffde0e 	bl	700077f4 <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
7000ffb8:	e51b3014 	ldr	r3, [fp, #-20]
7000ffbc:	e2833010 	add	r3, r3, #16
7000ffc0:	e1a00003 	mov	r0, r3
7000ffc4:	ebffffb2 	bl	7000fe94 <show_wait_queue>
            rt_kprintf("\n");
7000ffc8:	e30705e8 	movw	r0, #30184	; 0x75e8
7000ffcc:	e3470002 	movt	r0, #28674	; 0x7002
7000ffd0:	ebffde07 	bl	700077f4 <rt_kprintf>
7000ffd4:	ea00000f 	b	70010018 <_list_sem+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
7000ffd8:	e51b5014 	ldr	r5, [fp, #-20]
                       sem->value,
7000ffdc:	e51b3014 	ldr	r3, [fp, #-20]
7000ffe0:	e1d331b8 	ldrh	r3, [r3, #24]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
7000ffe4:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
7000ffe8:	e51b3014 	ldr	r3, [fp, #-20]
7000ffec:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
7000fff0:	e1a00003 	mov	r0, r3
7000fff4:	ebffff0b 	bl	7000fc28 <rt_list_len>
7000fff8:	e1a03000 	mov	r3, r0
7000fffc:	e58d3000 	str	r3, [sp]
70010000:	e30705ec 	movw	r0, #30188	; 0x75ec
70010004:	e3470002 	movt	r0, #28674	; 0x7002
70010008:	e3a01006 	mov	r1, #6
7001000c:	e1a02005 	mov	r2, r5
70010010:	e1a03004 	mov	r3, r4
70010014:	ebffddf6 	bl	700077f4 <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
70010018:	e51b3010 	ldr	r3, [fp, #-16]
7001001c:	e5933000 	ldr	r3, [r3]
70010020:	e50b3010 	str	r3, [fp, #-16]
70010024:	e51b2010 	ldr	r2, [fp, #-16]
70010028:	e51b3018 	ldr	r3, [fp, #-24]
7001002c:	e1520003 	cmp	r2, r3
70010030:	1affffc6 	bne	7000ff50 <_list_sem+0x38>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
70010034:	e3a03000 	mov	r3, #0
}
70010038:	e1a00003 	mov	r0, r3
7001003c:	e24bd00c 	sub	sp, fp, #12
70010040:	e8bd8830 	pop	{r4, r5, fp, pc}

70010044 <list_sem>:

long list_sem(void)
{
70010044:	e92d4800 	push	{fp, lr}
70010048:	e28db004 	add	fp, sp, #4
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
7001004c:	e59f000c 	ldr	r0, [pc, #12]	; 70010060 <list_sem+0x1c>
70010050:	ebffffb0 	bl	7000ff18 <_list_sem>
70010054:	e1a03000 	mov	r3, r0
}
70010058:	e1a00003 	mov	r0, r3
7001005c:	e8bd8800 	pop	{fp, pc}
70010060:	70028d9c 	.word	0x70028d9c

70010064 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
70010064:	e92d4830 	push	{r4, r5, fp, lr}
70010068:	e28db00c 	add	fp, sp, #12
7001006c:	e24dd018 	sub	sp, sp, #24
70010070:	e50b0018 	str	r0, [fp, #-24]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
70010074:	e3070654 	movw	r0, #30292	; 0x7654
70010078:	e3470002 	movt	r0, #28674	; 0x7002
7001007c:	ebffdddc 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
70010080:	e3070678 	movw	r0, #30328	; 0x7678
70010084:	e3470002 	movt	r0, #28674	; 0x7002
70010088:	ebffddd9 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
7001008c:	e51b3018 	ldr	r3, [fp, #-24]
70010090:	e5933000 	ldr	r3, [r3]
70010094:	e50b3010 	str	r3, [fp, #-16]
70010098:	ea00002a 	b	70010148 <_list_event+0xe4>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
7001009c:	e51b3010 	ldr	r3, [fp, #-16]
700100a0:	e2433008 	sub	r3, r3, #8
700100a4:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&e->parent.suspend_thread))
700100a8:	e51b3014 	ldr	r3, [fp, #-20]
700100ac:	e2833010 	add	r3, r3, #16
700100b0:	e1a00003 	mov	r0, r3
700100b4:	ebfffecc 	bl	7000fbec <rt_list_isempty>
700100b8:	e1a03000 	mov	r3, r0
700100bc:	e3530000 	cmp	r3, #0
700100c0:	1a000016 	bne	70010120 <_list_event+0xbc>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
700100c4:	e51b5014 	ldr	r5, [fp, #-20]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
700100c8:	e51b3014 	ldr	r3, [fp, #-20]
700100cc:	e5934018 	ldr	r4, [r3, #24]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
700100d0:	e51b3014 	ldr	r3, [fp, #-20]
700100d4:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
700100d8:	e1a00003 	mov	r0, r3
700100dc:	ebfffed1 	bl	7000fc28 <rt_list_len>
700100e0:	e1a03000 	mov	r3, r0
700100e4:	e58d3000 	str	r3, [sp]
700100e8:	e307069c 	movw	r0, #30364	; 0x769c
700100ec:	e3470002 	movt	r0, #28674	; 0x7002
700100f0:	e3a01006 	mov	r1, #6
700100f4:	e1a02005 	mov	r2, r5
700100f8:	e1a03004 	mov	r3, r4
700100fc:	ebffddbc 	bl	700077f4 <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
70010100:	e51b3014 	ldr	r3, [fp, #-20]
70010104:	e2833010 	add	r3, r3, #16
70010108:	e1a00003 	mov	r0, r3
7001010c:	ebffff60 	bl	7000fe94 <show_wait_queue>
            rt_kprintf("\n");
70010110:	e30705e8 	movw	r0, #30184	; 0x75e8
70010114:	e3470002 	movt	r0, #28674	; 0x7002
70010118:	ebffddb5 	bl	700077f4 <rt_kprintf>
7001011c:	ea000006 	b	7001013c <_list_event+0xd8>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
70010120:	e51b2014 	ldr	r2, [fp, #-20]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
70010124:	e51b3014 	ldr	r3, [fp, #-20]
70010128:	e5933018 	ldr	r3, [r3, #24]
7001012c:	e30706b4 	movw	r0, #30388	; 0x76b4
70010130:	e3470002 	movt	r0, #28674	; 0x7002
70010134:	e3a01006 	mov	r1, #6
70010138:	ebffddad 	bl	700077f4 <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
7001013c:	e51b3010 	ldr	r3, [fp, #-16]
70010140:	e5933000 	ldr	r3, [r3]
70010144:	e50b3010 	str	r3, [fp, #-16]
70010148:	e51b2010 	ldr	r2, [fp, #-16]
7001014c:	e51b3018 	ldr	r3, [fp, #-24]
70010150:	e1520003 	cmp	r2, r3
70010154:	1affffd0 	bne	7001009c <_list_event+0x38>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
70010158:	e3a03000 	mov	r3, #0
}
7001015c:	e1a00003 	mov	r0, r3
70010160:	e24bd00c 	sub	sp, fp, #12
70010164:	e8bd8830 	pop	{r4, r5, fp, pc}

70010168 <list_event>:

long list_event(void)
{
70010168:	e92d4800 	push	{fp, lr}
7001016c:	e28db004 	add	fp, sp, #4
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
70010170:	e59f000c 	ldr	r0, [pc, #12]	; 70010184 <list_event+0x1c>
70010174:	ebffffba 	bl	70010064 <_list_event>
70010178:	e1a03000 	mov	r3, r0
}
7001017c:	e1a00003 	mov	r0, r3
70010180:	e8bd8800 	pop	{fp, pc}
70010184:	70028dbc 	.word	0x70028dbc

70010188 <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
70010188:	e92d4870 	push	{r4, r5, r6, fp, lr}
7001018c:	e28db010 	add	fp, sp, #16
70010190:	e24dd024 	sub	sp, sp, #36	; 0x24
70010194:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
70010198:	e3070718 	movw	r0, #30488	; 0x7718
7001019c:	e3470002 	movt	r0, #28674	; 0x7002
700101a0:	ebffdd93 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
700101a4:	e3070740 	movw	r0, #30528	; 0x7740
700101a8:	e3470002 	movt	r0, #28674	; 0x7002
700101ac:	ebffdd90 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
700101b0:	e51b3020 	ldr	r3, [fp, #-32]
700101b4:	e5933000 	ldr	r3, [r3]
700101b8:	e50b3018 	str	r3, [fp, #-24]
700101bc:	ea00001a 	b	7001022c <_list_mutex+0xa4>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
700101c0:	e51b3018 	ldr	r3, [fp, #-24]
700101c4:	e2433008 	sub	r3, r3, #8
700101c8:	e50b301c 	str	r3, [fp, #-28]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
700101cc:	e51b401c 	ldr	r4, [fp, #-28]
                   RT_NAME_MAX,
                   m->owner->name,
700101d0:	e51b301c 	ldr	r3, [fp, #-28]
700101d4:	e593301c 	ldr	r3, [r3, #28]
700101d8:	e1a06003 	mov	r6, r3
                   m->hold,
700101dc:	e51b301c 	ldr	r3, [fp, #-28]
700101e0:	e5d3301b 	ldrb	r3, [r3, #27]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
700101e4:	e1a05003 	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
700101e8:	e51b301c 	ldr	r3, [fp, #-28]
700101ec:	e2833010 	add	r3, r3, #16
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
700101f0:	e1a00003 	mov	r0, r3
700101f4:	ebfffe8b 	bl	7000fc28 <rt_list_len>
700101f8:	e1a03000 	mov	r3, r0
700101fc:	e58d6000 	str	r6, [sp]
70010200:	e58d5004 	str	r5, [sp, #4]
70010204:	e58d3008 	str	r3, [sp, #8]
70010208:	e3070768 	movw	r0, #30568	; 0x7768
7001020c:	e3470002 	movt	r0, #28674	; 0x7002
70010210:	e3a01006 	mov	r1, #6
70010214:	e1a02004 	mov	r2, r4
70010218:	e3a03006 	mov	r3, #6
7001021c:	ebffdd74 	bl	700077f4 <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
70010220:	e51b3018 	ldr	r3, [fp, #-24]
70010224:	e5933000 	ldr	r3, [r3]
70010228:	e50b3018 	str	r3, [fp, #-24]
7001022c:	e51b2018 	ldr	r2, [fp, #-24]
70010230:	e51b3020 	ldr	r3, [fp, #-32]
70010234:	e1520003 	cmp	r2, r3
70010238:	1affffe0 	bne	700101c0 <_list_mutex+0x38>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
7001023c:	e3a03000 	mov	r3, #0
}
70010240:	e1a00003 	mov	r0, r3
70010244:	e24bd010 	sub	sp, fp, #16
70010248:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

7001024c <list_mutex>:

long list_mutex(void)
{
7001024c:	e92d4800 	push	{fp, lr}
70010250:	e28db004 	add	fp, sp, #4
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
70010254:	e59f000c 	ldr	r0, [pc, #12]	; 70010268 <list_mutex+0x1c>
70010258:	ebffffca 	bl	70010188 <_list_mutex>
7001025c:	e1a03000 	mov	r3, r0
}
70010260:	e1a00003 	mov	r0, r3
70010264:	e8bd8800 	pop	{fp, pc}
70010268:	70028dac 	.word	0x70028dac

7001026c <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
7001026c:	e92d4870 	push	{r4, r5, r6, fp, lr}
70010270:	e28db010 	add	fp, sp, #16
70010274:	e24dd01c 	sub	sp, sp, #28
70010278:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
7001027c:	e30707d0 	movw	r0, #30672	; 0x77d0
70010280:	e3470002 	movt	r0, #28674	; 0x7002
70010284:	ebffdd5a 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
70010288:	e30707f4 	movw	r0, #30708	; 0x77f4
7001028c:	e3470002 	movt	r0, #28674	; 0x7002
70010290:	ebffdd57 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
70010294:	e51b3020 	ldr	r3, [fp, #-32]
70010298:	e5933000 	ldr	r3, [r3]
7001029c:	e50b3018 	str	r3, [fp, #-24]
700102a0:	ea00003c 	b	70010398 <_list_mailbox+0x12c>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
700102a4:	e51b3018 	ldr	r3, [fp, #-24]
700102a8:	e2433008 	sub	r3, r3, #8
700102ac:	e50b301c 	str	r3, [fp, #-28]
        if (!rt_list_isempty(&m->parent.suspend_thread))
700102b0:	e51b301c 	ldr	r3, [fp, #-28]
700102b4:	e2833010 	add	r3, r3, #16
700102b8:	e1a00003 	mov	r0, r3
700102bc:	ebfffe4a 	bl	7000fbec <rt_list_isempty>
700102c0:	e1a03000 	mov	r3, r0
700102c4:	e3530000 	cmp	r3, #0
700102c8:	1a00001b 	bne	7001033c <_list_mailbox+0xd0>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
700102cc:	e51b501c 	ldr	r5, [fp, #-28]
                       m->entry,
700102d0:	e51b301c 	ldr	r3, [fp, #-28]
700102d4:	e1d331be 	ldrh	r3, [r3, #30]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
700102d8:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
700102dc:	e51b301c 	ldr	r3, [fp, #-28]
700102e0:	e1d331bc 	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
700102e4:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
700102e8:	e51b301c 	ldr	r3, [fp, #-28]
700102ec:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
700102f0:	e1a00003 	mov	r0, r3
700102f4:	ebfffe4b 	bl	7000fc28 <rt_list_len>
700102f8:	e1a03000 	mov	r3, r0
700102fc:	e58d6000 	str	r6, [sp]
70010300:	e58d3004 	str	r3, [sp, #4]
70010304:	e3070818 	movw	r0, #30744	; 0x7818
70010308:	e3470002 	movt	r0, #28674	; 0x7002
7001030c:	e3a01006 	mov	r1, #6
70010310:	e1a02005 	mov	r2, r5
70010314:	e1a03004 	mov	r3, r4
70010318:	ebffdd35 	bl	700077f4 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
7001031c:	e51b301c 	ldr	r3, [fp, #-28]
70010320:	e2833010 	add	r3, r3, #16
70010324:	e1a00003 	mov	r0, r3
70010328:	ebfffed9 	bl	7000fe94 <show_wait_queue>
            rt_kprintf("\n");
7001032c:	e30705e8 	movw	r0, #30184	; 0x75e8
70010330:	e3470002 	movt	r0, #28674	; 0x7002
70010334:	ebffdd2e 	bl	700077f4 <rt_kprintf>
70010338:	ea000013 	b	7001038c <_list_mailbox+0x120>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
7001033c:	e51b501c 	ldr	r5, [fp, #-28]
                       m->entry,
70010340:	e51b301c 	ldr	r3, [fp, #-28]
70010344:	e1d331be 	ldrh	r3, [r3, #30]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
70010348:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
7001034c:	e51b301c 	ldr	r3, [fp, #-28]
70010350:	e1d331bc 	ldrh	r3, [r3, #28]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
70010354:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
70010358:	e51b301c 	ldr	r3, [fp, #-28]
7001035c:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
70010360:	e1a00003 	mov	r0, r3
70010364:	ebfffe2f 	bl	7000fc28 <rt_list_len>
70010368:	e1a03000 	mov	r3, r0
7001036c:	e58d6000 	str	r6, [sp]
70010370:	e58d3004 	str	r3, [sp, #4]
70010374:	e3070830 	movw	r0, #30768	; 0x7830
70010378:	e3470002 	movt	r0, #28674	; 0x7002
7001037c:	e3a01006 	mov	r1, #6
70010380:	e1a02005 	mov	r2, r5
70010384:	e1a03004 	mov	r3, r4
70010388:	ebffdd19 	bl	700077f4 <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
7001038c:	e51b3018 	ldr	r3, [fp, #-24]
70010390:	e5933000 	ldr	r3, [r3]
70010394:	e50b3018 	str	r3, [fp, #-24]
70010398:	e51b2018 	ldr	r2, [fp, #-24]
7001039c:	e51b3020 	ldr	r3, [fp, #-32]
700103a0:	e1520003 	cmp	r2, r3
700103a4:	1affffbe 	bne	700102a4 <_list_mailbox+0x38>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
700103a8:	e3a03000 	mov	r3, #0
}
700103ac:	e1a00003 	mov	r0, r3
700103b0:	e24bd010 	sub	sp, fp, #16
700103b4:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

700103b8 <list_mailbox>:

long list_mailbox(void)
{
700103b8:	e92d4800 	push	{fp, lr}
700103bc:	e28db004 	add	fp, sp, #4
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
700103c0:	e59f000c 	ldr	r0, [pc, #12]	; 700103d4 <list_mailbox+0x1c>
700103c4:	ebffffa8 	bl	7001026c <_list_mailbox>
700103c8:	e1a03000 	mov	r3, r0
}
700103cc:	e1a00003 	mov	r0, r3
700103d0:	e8bd8800 	pop	{fp, pc}
700103d4:	70028dcc 	.word	0x70028dcc

700103d8 <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
700103d8:	e92d4830 	push	{r4, r5, fp, lr}
700103dc:	e28db00c 	add	fp, sp, #12
700103e0:	e24dd018 	sub	sp, sp, #24
700103e4:	e50b0018 	str	r0, [fp, #-24]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
700103e8:	e307089c 	movw	r0, #30876	; 0x789c
700103ec:	e3470002 	movt	r0, #28674	; 0x7002
700103f0:	ebffdcff 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
700103f4:	e30708bc 	movw	r0, #30908	; 0x78bc
700103f8:	e3470002 	movt	r0, #28674	; 0x7002
700103fc:	ebffdcfc 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
70010400:	e51b3018 	ldr	r3, [fp, #-24]
70010404:	e5933000 	ldr	r3, [r3]
70010408:	e50b3010 	str	r3, [fp, #-16]
7001040c:	ea000034 	b	700104e4 <_list_msgqueue+0x10c>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
70010410:	e51b3010 	ldr	r3, [fp, #-16]
70010414:	e2433008 	sub	r3, r3, #8
70010418:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&m->parent.suspend_thread))
7001041c:	e51b3014 	ldr	r3, [fp, #-20]
70010420:	e2833010 	add	r3, r3, #16
70010424:	e1a00003 	mov	r0, r3
70010428:	ebfffdef 	bl	7000fbec <rt_list_isempty>
7001042c:	e1a03000 	mov	r3, r0
70010430:	e3530000 	cmp	r3, #0
70010434:	1a000017 	bne	70010498 <_list_msgqueue+0xc0>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
70010438:	e51b5014 	ldr	r5, [fp, #-20]
                       m->entry,
7001043c:	e51b3014 	ldr	r3, [fp, #-20]
70010440:	e1d332b0 	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
70010444:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
70010448:	e51b3014 	ldr	r3, [fp, #-20]
7001044c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
70010450:	e1a00003 	mov	r0, r3
70010454:	ebfffdf3 	bl	7000fc28 <rt_list_len>
70010458:	e1a03000 	mov	r3, r0
7001045c:	e58d3000 	str	r3, [sp]
70010460:	e30708dc 	movw	r0, #30940	; 0x78dc
70010464:	e3470002 	movt	r0, #28674	; 0x7002
70010468:	e3a01006 	mov	r1, #6
7001046c:	e1a02005 	mov	r2, r5
70010470:	e1a03004 	mov	r3, r4
70010474:	ebffdcde 	bl	700077f4 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
70010478:	e51b3014 	ldr	r3, [fp, #-20]
7001047c:	e2833010 	add	r3, r3, #16
70010480:	e1a00003 	mov	r0, r3
70010484:	ebfffe82 	bl	7000fe94 <show_wait_queue>
            rt_kprintf("\n");
70010488:	e30705e8 	movw	r0, #30184	; 0x75e8
7001048c:	e3470002 	movt	r0, #28674	; 0x7002
70010490:	ebffdcd7 	bl	700077f4 <rt_kprintf>
70010494:	ea00000f 	b	700104d8 <_list_msgqueue+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
70010498:	e51b5014 	ldr	r5, [fp, #-20]
                       m->entry,
7001049c:	e51b3014 	ldr	r3, [fp, #-20]
700104a0:	e1d332b0 	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
700104a4:	e1a04003 	mov	r4, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
700104a8:	e51b3014 	ldr	r3, [fp, #-20]
700104ac:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
700104b0:	e1a00003 	mov	r0, r3
700104b4:	ebfffddb 	bl	7000fc28 <rt_list_len>
700104b8:	e1a03000 	mov	r3, r0
700104bc:	e58d3000 	str	r3, [sp]
700104c0:	e30708f0 	movw	r0, #30960	; 0x78f0
700104c4:	e3470002 	movt	r0, #28674	; 0x7002
700104c8:	e3a01006 	mov	r1, #6
700104cc:	e1a02005 	mov	r2, r5
700104d0:	e1a03004 	mov	r3, r4
700104d4:	ebffdcc6 	bl	700077f4 <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
700104d8:	e51b3010 	ldr	r3, [fp, #-16]
700104dc:	e5933000 	ldr	r3, [r3]
700104e0:	e50b3010 	str	r3, [fp, #-16]
700104e4:	e51b2010 	ldr	r2, [fp, #-16]
700104e8:	e51b3018 	ldr	r3, [fp, #-24]
700104ec:	e1520003 	cmp	r2, r3
700104f0:	1affffc6 	bne	70010410 <_list_msgqueue+0x38>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
700104f4:	e3a03000 	mov	r3, #0
}
700104f8:	e1a00003 	mov	r0, r3
700104fc:	e24bd00c 	sub	sp, fp, #12
70010500:	e8bd8830 	pop	{r4, r5, fp, pc}

70010504 <list_msgqueue>:

long list_msgqueue(void)
{
70010504:	e92d4800 	push	{fp, lr}
70010508:	e28db004 	add	fp, sp, #4
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
7001050c:	e59f000c 	ldr	r0, [pc, #12]	; 70010520 <list_msgqueue+0x1c>
70010510:	ebffffb0 	bl	700103d8 <_list_msgqueue>
70010514:	e1a03000 	mov	r3, r0
}
70010518:	e1a00003 	mov	r0, r3
7001051c:	e8bd8800 	pop	{fp, pc}
70010520:	70028ddc 	.word	0x70028ddc

70010524 <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
70010524:	e92d4800 	push	{fp, lr}
70010528:	e28db004 	add	fp, sp, #4
7001052c:	e24dd020 	sub	sp, sp, #32
70010530:	e50b0010 	str	r0, [fp, #-16]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
70010534:	e3070968 	movw	r0, #31080	; 0x7968
70010538:	e3470002 	movt	r0, #28674	; 0x7002
7001053c:	ebffdcac 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
70010540:	e3070994 	movw	r0, #31124	; 0x7994
70010544:	e3470002 	movt	r0, #28674	; 0x7002
70010548:	ebffdca9 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
7001054c:	e51b3010 	ldr	r3, [fp, #-16]
70010550:	e5933000 	ldr	r3, [r3]
70010554:	e50b3008 	str	r3, [fp, #-8]
70010558:	ea000031 	b	70010624 <_list_mempool+0x100>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
7001055c:	e51b3008 	ldr	r3, [fp, #-8]
70010560:	e2433008 	sub	r3, r3, #8
70010564:	e50b300c 	str	r3, [fp, #-12]
        if (mp->suspend_thread_count > 0)
70010568:	e51b300c 	ldr	r3, [fp, #-12]
7001056c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
70010570:	e3530000 	cmp	r3, #0
70010574:	0a000017 	beq	700105d8 <_list_mempool+0xb4>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
70010578:	e51b200c 	ldr	r2, [fp, #-12]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
7001057c:	e51b300c 	ldr	r3, [fp, #-12]
70010580:	e5933018 	ldr	r3, [r3, #24]
70010584:	e51b100c 	ldr	r1, [fp, #-12]
70010588:	e591c020 	ldr	ip, [r1, #32]
7001058c:	e51b100c 	ldr	r1, [fp, #-12]
70010590:	e5910024 	ldr	r0, [r1, #36]	; 0x24
70010594:	e51b100c 	ldr	r1, [fp, #-12]
70010598:	e5911030 	ldr	r1, [r1, #48]	; 0x30
7001059c:	e58dc000 	str	ip, [sp]
700105a0:	e58d0004 	str	r0, [sp, #4]
700105a4:	e58d1008 	str	r1, [sp, #8]
700105a8:	e30709c0 	movw	r0, #31168	; 0x79c0
700105ac:	e3470002 	movt	r0, #28674	; 0x7002
700105b0:	e3a01006 	mov	r1, #6
700105b4:	ebffdc8e 	bl	700077f4 <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
700105b8:	e51b300c 	ldr	r3, [fp, #-12]
700105bc:	e2833028 	add	r3, r3, #40	; 0x28
700105c0:	e1a00003 	mov	r0, r3
700105c4:	ebfffe32 	bl	7000fe94 <show_wait_queue>
            rt_kprintf("\n");
700105c8:	e30705e8 	movw	r0, #30184	; 0x75e8
700105cc:	e3470002 	movt	r0, #28674	; 0x7002
700105d0:	ebffdc87 	bl	700077f4 <rt_kprintf>
700105d4:	ea00000f 	b	70010618 <_list_mempool+0xf4>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
700105d8:	e51b200c 	ldr	r2, [fp, #-12]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
700105dc:	e51b300c 	ldr	r3, [fp, #-12]
700105e0:	e5933018 	ldr	r3, [r3, #24]
700105e4:	e51b100c 	ldr	r1, [fp, #-12]
700105e8:	e591c020 	ldr	ip, [r1, #32]
700105ec:	e51b100c 	ldr	r1, [fp, #-12]
700105f0:	e5910024 	ldr	r0, [r1, #36]	; 0x24
700105f4:	e51b100c 	ldr	r1, [fp, #-12]
700105f8:	e5911030 	ldr	r1, [r1, #48]	; 0x30
700105fc:	e58dc000 	str	ip, [sp]
70010600:	e58d0004 	str	r0, [sp, #4]
70010604:	e58d1008 	str	r1, [sp, #8]
70010608:	e30709dc 	movw	r0, #31196	; 0x79dc
7001060c:	e3470002 	movt	r0, #28674	; 0x7002
70010610:	e3a01006 	mov	r1, #6
70010614:	ebffdc76 	bl	700077f4 <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
70010618:	e51b3008 	ldr	r3, [fp, #-8]
7001061c:	e5933000 	ldr	r3, [r3]
70010620:	e50b3008 	str	r3, [fp, #-8]
70010624:	e51b2008 	ldr	r2, [fp, #-8]
70010628:	e51b3010 	ldr	r3, [fp, #-16]
7001062c:	e1520003 	cmp	r2, r3
70010630:	1affffc9 	bne	7001055c <_list_mempool+0x38>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
70010634:	e3a03000 	mov	r3, #0
}
70010638:	e1a00003 	mov	r0, r3
7001063c:	e24bd004 	sub	sp, fp, #4
70010640:	e8bd8800 	pop	{fp, pc}

70010644 <list_mempool>:

long list_mempool(void)
{
70010644:	e92d4800 	push	{fp, lr}
70010648:	e28db004 	add	fp, sp, #4
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
7001064c:	e59f000c 	ldr	r0, [pc, #12]	; 70010660 <list_mempool+0x1c>
70010650:	ebffffb3 	bl	70010524 <_list_mempool>
70010654:	e1a03000 	mov	r3, r0
}
70010658:	e1a00003 	mov	r0, r3
7001065c:	e8bd8800 	pop	{fp, pc}
70010660:	70028dec 	.word	0x70028dec

70010664 <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
70010664:	e92d4800 	push	{fp, lr}
70010668:	e28db004 	add	fp, sp, #4
7001066c:	e24dd018 	sub	sp, sp, #24
70010670:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
70010674:	e3070a54 	movw	r0, #31316	; 0x7a54
70010678:	e3470002 	movt	r0, #28674	; 0x7002
7001067c:	ebffdc5c 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
70010680:	e3070a7c 	movw	r0, #31356	; 0x7a7c
70010684:	e3470002 	movt	r0, #28674	; 0x7002
70010688:	ebffdc59 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
7001068c:	e51b3010 	ldr	r3, [fp, #-16]
70010690:	e5933000 	ldr	r3, [r3]
70010694:	e50b3008 	str	r3, [fp, #-8]
70010698:	ea00001b 	b	7001070c <_list_timer+0xa8>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
7001069c:	e51b3008 	ldr	r3, [fp, #-8]
700106a0:	e2433008 	sub	r3, r3, #8
700106a4:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
700106a8:	e51b200c 	ldr	r2, [fp, #-12]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
700106ac:	e51b300c 	ldr	r3, [fp, #-12]
700106b0:	e5933020 	ldr	r3, [r3, #32]
700106b4:	e51b100c 	ldr	r1, [fp, #-12]
700106b8:	e5911024 	ldr	r1, [r1, #36]	; 0x24
700106bc:	e58d1000 	str	r1, [sp]
700106c0:	e3070aa8 	movw	r0, #31400	; 0x7aa8
700106c4:	e3470002 	movt	r0, #28674	; 0x7002
700106c8:	e3a01006 	mov	r1, #6
700106cc:	ebffdc48 	bl	700077f4 <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
700106d0:	e51b300c 	ldr	r3, [fp, #-12]
700106d4:	e5d33007 	ldrb	r3, [r3, #7]
700106d8:	e2033001 	and	r3, r3, #1
700106dc:	e3530000 	cmp	r3, #0
700106e0:	0a000003 	beq	700106f4 <_list_timer+0x90>
            rt_kprintf("activated\n");
700106e4:	e3070ac0 	movw	r0, #31424	; 0x7ac0
700106e8:	e3470002 	movt	r0, #28674	; 0x7002
700106ec:	ebffdc40 	bl	700077f4 <rt_kprintf>
700106f0:	ea000002 	b	70010700 <_list_timer+0x9c>
        else
            rt_kprintf("deactivated\n");
700106f4:	e3070acc 	movw	r0, #31436	; 0x7acc
700106f8:	e3470002 	movt	r0, #28674	; 0x7002
700106fc:	ebffdc3c 	bl	700077f4 <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
70010700:	e51b3008 	ldr	r3, [fp, #-8]
70010704:	e5933000 	ldr	r3, [r3]
70010708:	e50b3008 	str	r3, [fp, #-8]
7001070c:	e51b2008 	ldr	r2, [fp, #-8]
70010710:	e51b3010 	ldr	r3, [fp, #-16]
70010714:	e1520003 	cmp	r2, r3
70010718:	1affffdf 	bne	7001069c <_list_timer+0x38>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
7001071c:	ebffbfea 	bl	700006cc <rt_tick_get>
70010720:	e1a03000 	mov	r3, r0
70010724:	e3070adc 	movw	r0, #31452	; 0x7adc
70010728:	e3470002 	movt	r0, #28674	; 0x7002
7001072c:	e1a01003 	mov	r1, r3
70010730:	ebffdc2f 	bl	700077f4 <rt_kprintf>

    return 0;
70010734:	e3a03000 	mov	r3, #0
}
70010738:	e1a00003 	mov	r0, r3
7001073c:	e24bd004 	sub	sp, fp, #4
70010740:	e8bd8800 	pop	{fp, pc}

70010744 <list_timer>:

long list_timer(void)
{
70010744:	e92d4800 	push	{fp, lr}
70010748:	e28db004 	add	fp, sp, #4
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
7001074c:	e59f000c 	ldr	r0, [pc, #12]	; 70010760 <list_timer+0x1c>
70010750:	ebffffc3 	bl	70010664 <_list_timer>
70010754:	e1a03000 	mov	r3, r0
}
70010758:	e1a00003 	mov	r0, r3
7001075c:	e8bd8800 	pop	{fp, pc}
70010760:	70028e0c 	.word	0x70028e0c

70010764 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
70010764:	e92d4800 	push	{fp, lr}
70010768:	e28db004 	add	fp, sp, #4
7001076c:	e24dd068 	sub	sp, sp, #104	; 0x68
70010770:	e50b0060 	str	r0, [fp, #-96]	; 0x60
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
70010774:	e3073cbc 	movw	r3, #31932	; 0x7cbc
70010778:	e3473002 	movt	r3, #28674	; 0x7002
7001077c:	e24b1058 	sub	r1, fp, #88	; 0x58
70010780:	e1a02003 	mov	r2, r3
70010784:	e3a0304c 	mov	r3, #76	; 0x4c
70010788:	e1a00001 	mov	r0, r1
7001078c:	e1a01002 	mov	r1, r2
70010790:	e1a02003 	mov	r2, r3
70010794:	fa004dc3 	blx	70023ea8 <memcpy>
        "Portal Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
70010798:	e3070b44 	movw	r0, #31556	; 0x7b44
7001079c:	e3470002 	movt	r0, #28674	; 0x7002
700107a0:	ebffdc13 	bl	700077f4 <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
700107a4:	e3070b70 	movw	r0, #31600	; 0x7b70
700107a8:	e3470002 	movt	r0, #28674	; 0x7002
700107ac:	ebffdc10 	bl	700077f4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
700107b0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
700107b4:	e5933000 	ldr	r3, [r3]
700107b8:	e50b3008 	str	r3, [fp, #-8]
700107bc:	ea00001c 	b	70010834 <_list_device+0xd0>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
700107c0:	e51b3008 	ldr	r3, [fp, #-8]
700107c4:	e2433008 	sub	r3, r3, #8
700107c8:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
700107cc:	e51b200c 	ldr	r2, [fp, #-12]
                   (device->type <= RT_Device_Class_Unknown) ?
700107d0:	e51b300c 	ldr	r3, [fp, #-12]
700107d4:	e5d33010 	ldrb	r3, [r3, #16]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
700107d8:	e3530012 	cmp	r3, #18
700107dc:	8a000009 	bhi	70010808 <_list_device+0xa4>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
700107e0:	e51b300c 	ldr	r3, [fp, #-12]
700107e4:	e5d33010 	ldrb	r3, [r3, #16]
700107e8:	e1a01003 	mov	r1, r3
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
700107ec:	e3e03053 	mvn	r3, #83	; 0x53
700107f0:	e1a01101 	lsl	r1, r1, #2
700107f4:	e24b0004 	sub	r0, fp, #4
700107f8:	e0801001 	add	r1, r0, r1
700107fc:	e0813003 	add	r3, r1, r3
70010800:	e5933000 	ldr	r3, [r3]
70010804:	ea000000 	b	7001080c <_list_device+0xa8>
70010808:	e51b3010 	ldr	r3, [fp, #-16]
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
7001080c:	e51b100c 	ldr	r1, [fp, #-12]
70010810:	e5d11016 	ldrb	r1, [r1, #22]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
70010814:	e58d1000 	str	r1, [sp]
70010818:	e3070b9c 	movw	r0, #31644	; 0x7b9c
7001081c:	e3470002 	movt	r0, #28674	; 0x7002
70010820:	e3a01006 	mov	r1, #6
70010824:	ebffdbf2 	bl	700077f4 <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
70010828:	e51b3008 	ldr	r3, [fp, #-8]
7001082c:	e5933000 	ldr	r3, [r3]
70010830:	e50b3008 	str	r3, [fp, #-8]
70010834:	e51b2008 	ldr	r2, [fp, #-8]
70010838:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
7001083c:	e1520003 	cmp	r2, r3
70010840:	1affffde 	bne	700107c0 <_list_device+0x5c>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
70010844:	e3a03000 	mov	r3, #0
}
70010848:	e1a00003 	mov	r0, r3
7001084c:	e24bd004 	sub	sp, fp, #4
70010850:	e8bd8800 	pop	{fp, pc}

70010854 <list_device>:

long list_device(void)
{
70010854:	e92d4800 	push	{fp, lr}
70010858:	e28db004 	add	fp, sp, #4
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
7001085c:	e59f000c 	ldr	r0, [pc, #12]	; 70010870 <list_device+0x1c>
70010860:	ebffffbf 	bl	70010764 <_list_device>
70010864:	e1a03000 	mov	r3, r0
}
70010868:	e1a00003 	mov	r0, r3
7001086c:	e8bd8800 	pop	{fp, pc}
70010870:	70028dfc 	.word	0x70028dfc

70010874 <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
70010874:	e92d4800 	push	{fp, lr}
70010878:	e28db004 	add	fp, sp, #4
7001087c:	e24dd010 	sub	sp, sp, #16
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
70010880:	e3070d58 	movw	r0, #32088	; 0x7d58
70010884:	e3470002 	movt	r0, #28674	; 0x7002
70010888:	ebffdbd9 	bl	700077f4 <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
7001088c:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
70010890:	e3473002 	movt	r3, #28674	; 0x7002
70010894:	e5933000 	ldr	r3, [r3]
70010898:	e50b3010 	str	r3, [fp, #-16]
7001089c:	ea000016 	b	700108fc <list+0x88>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
700108a0:	e51b3010 	ldr	r3, [fp, #-16]
700108a4:	e5933000 	ldr	r3, [r3]
700108a8:	e1a00003 	mov	r0, r3
700108ac:	e3071d6c 	movw	r1, #32108	; 0x7d6c
700108b0:	e3471002 	movt	r1, #28674	; 0x7002
700108b4:	e3a02002 	mov	r2, #2
700108b8:	fa004eb5 	blx	70024394 <strncmp>
700108bc:	e1a03000 	mov	r3, r0
700108c0:	e3530000 	cmp	r3, #0
700108c4:	1a000000 	bne	700108cc <list+0x58>
700108c8:	ea000008 	b	700108f0 <list+0x7c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
700108cc:	e51b3010 	ldr	r3, [fp, #-16]
700108d0:	e5932000 	ldr	r2, [r3]
700108d4:	e51b3010 	ldr	r3, [fp, #-16]
700108d8:	e5933004 	ldr	r3, [r3, #4]
700108dc:	e3070d70 	movw	r0, #32112	; 0x7d70
700108e0:	e3470002 	movt	r0, #28674	; 0x7002
700108e4:	e1a01002 	mov	r1, r2
700108e8:	e1a02003 	mov	r2, r3
700108ec:	ebffdbc0 	bl	700077f4 <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
700108f0:	e51b3010 	ldr	r3, [fp, #-16]
700108f4:	e283300c 	add	r3, r3, #12
700108f8:	e50b3010 	str	r3, [fp, #-16]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
700108fc:	e30a3a10 	movw	r3, #43536	; 0xaa10
70010900:	e3473002 	movt	r3, #28674	; 0x7002
70010904:	e5933000 	ldr	r3, [r3]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
70010908:	e51b2010 	ldr	r2, [fp, #-16]
7001090c:	e1520003 	cmp	r2, r3
70010910:	3affffe2 	bcc	700108a0 <list+0x2c>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
70010914:	e30a3a28 	movw	r3, #43560	; 0xaa28
70010918:	e3473002 	movt	r3, #28674	; 0x7002
7001091c:	e5933000 	ldr	r3, [r3]
70010920:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
70010924:	ea000008 	b	7001094c <list+0xd8>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
70010928:	e51b3008 	ldr	r3, [fp, #-8]
7001092c:	e5933004 	ldr	r3, [r3, #4]
70010930:	e3070d80 	movw	r0, #32128	; 0x7d80
70010934:	e3470002 	movt	r0, #28674	; 0x7002
70010938:	e1a01003 	mov	r1, r3
7001093c:	ebffdbac 	bl	700077f4 <rt_kprintf>
        syscall_item = syscall_item->next;
70010940:	e51b3008 	ldr	r3, [fp, #-8]
70010944:	e5933000 	ldr	r3, [r3]
70010948:	e50b3008 	str	r3, [fp, #-8]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
7001094c:	e51b3008 	ldr	r3, [fp, #-8]
70010950:	e3530000 	cmp	r3, #0
70010954:	1afffff3 	bne	70010928 <list+0xb4>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
70010958:	e3070d88 	movw	r0, #32136	; 0x7d88
7001095c:	e3470002 	movt	r0, #28674	; 0x7002
70010960:	ebffdba3 	bl	700077f4 <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
70010964:	e30a3a14 	movw	r3, #43540	; 0xaa14
70010968:	e3473002 	movt	r3, #28674	; 0x7002
7001096c:	e5933000 	ldr	r3, [r3]
70010970:	e50b3014 	str	r3, [fp, #-20]
70010974:	ea00000b 	b	700109a8 <list+0x134>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
70010978:	e51b3014 	ldr	r3, [fp, #-20]
7001097c:	e5932000 	ldr	r2, [r3]
70010980:	e51b3014 	ldr	r3, [fp, #-20]
70010984:	e5933004 	ldr	r3, [r3, #4]
70010988:	e3070d70 	movw	r0, #32112	; 0x7d70
7001098c:	e3470002 	movt	r0, #28674	; 0x7002
70010990:	e1a01002 	mov	r1, r2
70010994:	e1a02003 	mov	r2, r3
70010998:	ebffdb95 	bl	700077f4 <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
7001099c:	e51b3014 	ldr	r3, [fp, #-20]
700109a0:	e2833010 	add	r3, r3, #16
700109a4:	e50b3014 	str	r3, [fp, #-20]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
700109a8:	e30a3a18 	movw	r3, #43544	; 0xaa18
700109ac:	e3473002 	movt	r3, #28674	; 0x7002
700109b0:	e5933000 	ldr	r3, [r3]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
700109b4:	e51b2014 	ldr	r2, [fp, #-20]
700109b8:	e1520003 	cmp	r2, r3
700109bc:	3affffed 	bcc	70010978 <list+0x104>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
700109c0:	e30b35e8 	movw	r3, #46568	; 0xb5e8
700109c4:	e3473002 	movt	r3, #28674	; 0x7002
700109c8:	e5933000 	ldr	r3, [r3]
700109cc:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
700109d0:	ea000008 	b	700109f8 <list+0x184>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
700109d4:	e51b300c 	ldr	r3, [fp, #-12]
700109d8:	e5933004 	ldr	r3, [r3, #4]
700109dc:	e3070d80 	movw	r0, #32128	; 0x7d80
700109e0:	e3470002 	movt	r0, #28674	; 0x7002
700109e4:	e1a01003 	mov	r1, r3
700109e8:	ebffdb81 	bl	700077f4 <rt_kprintf>
        sysvar_item = sysvar_item->next;
700109ec:	e51b300c 	ldr	r3, [fp, #-12]
700109f0:	e5933000 	ldr	r3, [r3]
700109f4:	e50b300c 	str	r3, [fp, #-12]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
700109f8:	e51b300c 	ldr	r3, [fp, #-12]
700109fc:	e3530000 	cmp	r3, #0
70010a00:	1afffff3 	bne	700109d4 <list+0x160>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
70010a04:	e3a03000 	mov	r3, #0
}
70010a08:	e1a00003 	mov	r0, r3
70010a0c:	e24bd004 	sub	sp, fp, #4
70010a10:	e8bd8800 	pop	{fp, pc}

70010a14 <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
70010a14:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70010a18:	e28db000 	add	fp, sp, #0
70010a1c:	e24dd00c 	sub	sp, sp, #12
70010a20:	e50b0008 	str	r0, [fp, #-8]
70010a24:	e50b100c 	str	r1, [fp, #-12]
    while ((*prefix) && (*prefix == *str))
70010a28:	ea000005 	b	70010a44 <str_is_prefix+0x30>
    {
        prefix ++;
70010a2c:	e51b3008 	ldr	r3, [fp, #-8]
70010a30:	e2833001 	add	r3, r3, #1
70010a34:	e50b3008 	str	r3, [fp, #-8]
        str ++;
70010a38:	e51b300c 	ldr	r3, [fp, #-12]
70010a3c:	e2833001 	add	r3, r3, #1
70010a40:	e50b300c 	str	r3, [fp, #-12]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
70010a44:	e51b3008 	ldr	r3, [fp, #-8]
70010a48:	e5d33000 	ldrb	r3, [r3]
70010a4c:	e3530000 	cmp	r3, #0
70010a50:	0a000005 	beq	70010a6c <str_is_prefix+0x58>
70010a54:	e51b3008 	ldr	r3, [fp, #-8]
70010a58:	e5d32000 	ldrb	r2, [r3]
70010a5c:	e51b300c 	ldr	r3, [fp, #-12]
70010a60:	e5d33000 	ldrb	r3, [r3]
70010a64:	e1520003 	cmp	r2, r3
70010a68:	0affffef 	beq	70010a2c <str_is_prefix+0x18>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
70010a6c:	e51b3008 	ldr	r3, [fp, #-8]
70010a70:	e5d33000 	ldrb	r3, [r3]
70010a74:	e3530000 	cmp	r3, #0
70010a78:	1a000001 	bne	70010a84 <str_is_prefix+0x70>
        return 0;
70010a7c:	e3a03000 	mov	r3, #0
70010a80:	ea000000 	b	70010a88 <str_is_prefix+0x74>

    return -1;
70010a84:	e3e03000 	mvn	r3, #0
}
70010a88:	e1a00003 	mov	r0, r3
70010a8c:	e24bd000 	sub	sp, fp, #0
70010a90:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70010a94:	e12fff1e 	bx	lr

70010a98 <str_common>:

static int str_common(const char *str1, const char *str2)
{
70010a98:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70010a9c:	e28db000 	add	fp, sp, #0
70010aa0:	e24dd014 	sub	sp, sp, #20
70010aa4:	e50b0010 	str	r0, [fp, #-16]
70010aa8:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
70010aac:	e51b3010 	ldr	r3, [fp, #-16]
70010ab0:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
70010ab4:	ea000005 	b	70010ad0 <str_common+0x38>
    {
        str ++;
70010ab8:	e51b3008 	ldr	r3, [fp, #-8]
70010abc:	e2833001 	add	r3, r3, #1
70010ac0:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
70010ac4:	e51b3014 	ldr	r3, [fp, #-20]
70010ac8:	e2833001 	add	r3, r3, #1
70010acc:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
70010ad0:	e51b3008 	ldr	r3, [fp, #-8]
70010ad4:	e5d33000 	ldrb	r3, [r3]
70010ad8:	e3530000 	cmp	r3, #0
70010adc:	0a000009 	beq	70010b08 <str_common+0x70>
70010ae0:	e51b3014 	ldr	r3, [fp, #-20]
70010ae4:	e5d33000 	ldrb	r3, [r3]
70010ae8:	e3530000 	cmp	r3, #0
70010aec:	0a000005 	beq	70010b08 <str_common+0x70>
70010af0:	e51b3008 	ldr	r3, [fp, #-8]
70010af4:	e5d32000 	ldrb	r2, [r3]
70010af8:	e51b3014 	ldr	r3, [fp, #-20]
70010afc:	e5d33000 	ldrb	r3, [r3]
70010b00:	e1520003 	cmp	r2, r3
70010b04:	0affffeb 	beq	70010ab8 <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
70010b08:	e51b2008 	ldr	r2, [fp, #-8]
70010b0c:	e51b3010 	ldr	r3, [fp, #-16]
70010b10:	e0633002 	rsb	r3, r3, r2
}
70010b14:	e1a00003 	mov	r0, r3
70010b18:	e24bd000 	sub	sp, fp, #0
70010b1c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70010b20:	e12fff1e 	bx	lr

70010b24 <list_prefix>:

void list_prefix(char *prefix)
{
70010b24:	e92d4800 	push	{fp, lr}
70010b28:	e28db004 	add	fp, sp, #4
70010b2c:	e24dd028 	sub	sp, sp, #40	; 0x28
70010b30:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
70010b34:	e3a03000 	mov	r3, #0
70010b38:	e14b30be 	strh	r3, [fp, #-14]
    var_cnt  = 0;
70010b3c:	e3a03000 	mov	r3, #0
70010b40:	e14b31b0 	strh	r3, [fp, #-16]
    min_length = 0;
70010b44:	e3a03000 	mov	r3, #0
70010b48:	e50b3014 	str	r3, [fp, #-20]
    name_ptr = RT_NULL;
70010b4c:	e3a03000 	mov	r3, #0
70010b50:	e50b3018 	str	r3, [fp, #-24]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
70010b54:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
70010b58:	e3473002 	movt	r3, #28674	; 0x7002
70010b5c:	e5933000 	ldr	r3, [r3]
70010b60:	e50b301c 	str	r3, [fp, #-28]
70010b64:	ea000041 	b	70010c70 <list_prefix+0x14c>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
70010b68:	e51b301c 	ldr	r3, [fp, #-28]
70010b6c:	e5933000 	ldr	r3, [r3]
70010b70:	e3070d6c 	movw	r0, #32108	; 0x7d6c
70010b74:	e3470002 	movt	r0, #28674	; 0x7002
70010b78:	e1a01003 	mov	r1, r3
70010b7c:	ebffffa4 	bl	70010a14 <str_is_prefix>
70010b80:	e1a03000 	mov	r3, r0
70010b84:	e3530000 	cmp	r3, #0
70010b88:	1a000000 	bne	70010b90 <list_prefix+0x6c>
70010b8c:	ea000034 	b	70010c64 <list_prefix+0x140>
			
            if (str_is_prefix(prefix, index->name) == 0)
70010b90:	e51b301c 	ldr	r3, [fp, #-28]
70010b94:	e5933000 	ldr	r3, [r3]
70010b98:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70010b9c:	e1a01003 	mov	r1, r3
70010ba0:	ebffff9b 	bl	70010a14 <str_is_prefix>
70010ba4:	e1a03000 	mov	r3, r0
70010ba8:	e3530000 	cmp	r3, #0
70010bac:	1a00002c 	bne	70010c64 <list_prefix+0x140>
            {
                if (func_cnt == 0)
70010bb0:	e15b30be 	ldrh	r3, [fp, #-14]
70010bb4:	e3530000 	cmp	r3, #0
70010bb8:	1a00000d 	bne	70010bf4 <list_prefix+0xd0>
                {
                    rt_kprintf("--function:\n");
70010bbc:	e3070dc0 	movw	r0, #32192	; 0x7dc0
70010bc0:	e3470002 	movt	r0, #28674	; 0x7002
70010bc4:	ebffdb0a 	bl	700077f4 <rt_kprintf>

                    if (*prefix != 0)
70010bc8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010bcc:	e5d33000 	ldrb	r3, [r3]
70010bd0:	e3530000 	cmp	r3, #0
70010bd4:	0a000006 	beq	70010bf4 <list_prefix+0xd0>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
70010bd8:	e51b301c 	ldr	r3, [fp, #-28]
70010bdc:	e5933000 	ldr	r3, [r3]
70010be0:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
70010be4:	e51b0018 	ldr	r0, [fp, #-24]
70010be8:	fa004dd1 	blx	70024334 <strlen>
70010bec:	e1a03000 	mov	r3, r0
70010bf0:	e50b3014 	str	r3, [fp, #-20]
                    }
                }

                func_cnt ++;
70010bf4:	e15b30be 	ldrh	r3, [fp, #-14]
70010bf8:	e2833001 	add	r3, r3, #1
70010bfc:	e14b30be 	strh	r3, [fp, #-14]

                if (*prefix != 0)
70010c00:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010c04:	e5d33000 	ldrb	r3, [r3]
70010c08:	e3530000 	cmp	r3, #0
70010c0c:	0a00000b 	beq	70010c40 <list_prefix+0x11c>
                {
                    length = str_common(name_ptr, index->name);
70010c10:	e51b301c 	ldr	r3, [fp, #-28]
70010c14:	e5933000 	ldr	r3, [r3]
70010c18:	e51b0018 	ldr	r0, [fp, #-24]
70010c1c:	e1a01003 	mov	r1, r3
70010c20:	ebffff9c 	bl	70010a98 <str_common>
70010c24:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
70010c28:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70010c2c:	e51b3014 	ldr	r3, [fp, #-20]
70010c30:	e1520003 	cmp	r2, r3
70010c34:	aa000001 	bge	70010c40 <list_prefix+0x11c>
                        min_length = length;
70010c38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70010c3c:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
70010c40:	e51b301c 	ldr	r3, [fp, #-28]
70010c44:	e5932000 	ldr	r2, [r3]
70010c48:	e51b301c 	ldr	r3, [fp, #-28]
70010c4c:	e5933004 	ldr	r3, [r3, #4]
70010c50:	e3070d70 	movw	r0, #32112	; 0x7d70
70010c54:	e3470002 	movt	r0, #28674	; 0x7002
70010c58:	e1a01002 	mov	r1, r2
70010c5c:	e1a02003 	mov	r2, r3
70010c60:	ebffdae3 	bl	700077f4 <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
70010c64:	e51b301c 	ldr	r3, [fp, #-28]
70010c68:	e283300c 	add	r3, r3, #12
70010c6c:	e50b301c 	str	r3, [fp, #-28]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
70010c70:	e30a3a10 	movw	r3, #43536	; 0xaa10
70010c74:	e3473002 	movt	r3, #28674	; 0x7002
70010c78:	e5933000 	ldr	r3, [r3]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
70010c7c:	e51b201c 	ldr	r2, [fp, #-28]
70010c80:	e1520003 	cmp	r2, r3
70010c84:	3affffb7 	bcc	70010b68 <list_prefix+0x44>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
70010c88:	e30a3a28 	movw	r3, #43560	; 0xaa28
70010c8c:	e3473002 	movt	r3, #28674	; 0x7002
70010c90:	e5933000 	ldr	r3, [r3]
70010c94:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
70010c98:	ea000037 	b	70010d7c <list_prefix+0x258>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
70010c9c:	e51b3008 	ldr	r3, [fp, #-8]
70010ca0:	e5933004 	ldr	r3, [r3, #4]
70010ca4:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70010ca8:	e1a01003 	mov	r1, r3
70010cac:	ebffff58 	bl	70010a14 <str_is_prefix>
70010cb0:	e1a03000 	mov	r3, r0
70010cb4:	e3530000 	cmp	r3, #0
70010cb8:	1a00002c 	bne	70010d70 <list_prefix+0x24c>
        {
            if (func_cnt == 0)
70010cbc:	e15b30be 	ldrh	r3, [fp, #-14]
70010cc0:	e3530000 	cmp	r3, #0
70010cc4:	1a000010 	bne	70010d0c <list_prefix+0x1e8>
            {
                rt_kprintf("--function:\n");
70010cc8:	e3070dc0 	movw	r0, #32192	; 0x7dc0
70010ccc:	e3470002 	movt	r0, #28674	; 0x7002
70010cd0:	ebffdac7 	bl	700077f4 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
70010cd4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010cd8:	e5d33000 	ldrb	r3, [r3]
70010cdc:	e3530000 	cmp	r3, #0
70010ce0:	0a000009 	beq	70010d0c <list_prefix+0x1e8>
70010ce4:	e51b3018 	ldr	r3, [fp, #-24]
70010ce8:	e3530000 	cmp	r3, #0
70010cec:	1a000006 	bne	70010d0c <list_prefix+0x1e8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
70010cf0:	e51b3008 	ldr	r3, [fp, #-8]
70010cf4:	e5933004 	ldr	r3, [r3, #4]
70010cf8:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
70010cfc:	e51b0018 	ldr	r0, [fp, #-24]
70010d00:	fa004d8b 	blx	70024334 <strlen>
70010d04:	e1a03000 	mov	r3, r0
70010d08:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            func_cnt ++;
70010d0c:	e15b30be 	ldrh	r3, [fp, #-14]
70010d10:	e2833001 	add	r3, r3, #1
70010d14:	e14b30be 	strh	r3, [fp, #-14]

            if (*prefix != 0)
70010d18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010d1c:	e5d33000 	ldrb	r3, [r3]
70010d20:	e3530000 	cmp	r3, #0
70010d24:	0a00000b 	beq	70010d58 <list_prefix+0x234>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
70010d28:	e51b3008 	ldr	r3, [fp, #-8]
70010d2c:	e5933004 	ldr	r3, [r3, #4]
70010d30:	e51b0018 	ldr	r0, [fp, #-24]
70010d34:	e1a01003 	mov	r1, r3
70010d38:	ebffff56 	bl	70010a98 <str_common>
70010d3c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
70010d40:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70010d44:	e51b3014 	ldr	r3, [fp, #-20]
70010d48:	e1520003 	cmp	r2, r3
70010d4c:	aa000001 	bge	70010d58 <list_prefix+0x234>
                    min_length = length;
70010d50:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70010d54:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
70010d58:	e51b3008 	ldr	r3, [fp, #-8]
70010d5c:	e5933004 	ldr	r3, [r3, #4]
70010d60:	e3070d80 	movw	r0, #32128	; 0x7d80
70010d64:	e3470002 	movt	r0, #28674	; 0x7002
70010d68:	e1a01003 	mov	r1, r3
70010d6c:	ebffdaa0 	bl	700077f4 <rt_kprintf>
        }
        syscall_item = syscall_item->next;
70010d70:	e51b3008 	ldr	r3, [fp, #-8]
70010d74:	e5933000 	ldr	r3, [r3]
70010d78:	e50b3008 	str	r3, [fp, #-8]
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
70010d7c:	e51b3008 	ldr	r3, [fp, #-8]
70010d80:	e3530000 	cmp	r3, #0
70010d84:	1affffc4 	bne	70010c9c <list_prefix+0x178>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
70010d88:	e30a3a14 	movw	r3, #43540	; 0xaa14
70010d8c:	e3473002 	movt	r3, #28674	; 0x7002
70010d90:	e5933000 	ldr	r3, [r3]
70010d94:	e50b3020 	str	r3, [fp, #-32]
70010d98:	ea00003a 	b	70010e88 <list_prefix+0x364>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
70010d9c:	e51b3020 	ldr	r3, [fp, #-32]
70010da0:	e5933000 	ldr	r3, [r3]
70010da4:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70010da8:	e1a01003 	mov	r1, r3
70010dac:	ebffff18 	bl	70010a14 <str_is_prefix>
70010db0:	e1a03000 	mov	r3, r0
70010db4:	e3530000 	cmp	r3, #0
70010db8:	1a00002f 	bne	70010e7c <list_prefix+0x358>
            {
                if (var_cnt == 0)
70010dbc:	e15b31b0 	ldrh	r3, [fp, #-16]
70010dc0:	e3530000 	cmp	r3, #0
70010dc4:	1a000010 	bne	70010e0c <list_prefix+0x2e8>
                {
                    rt_kprintf("--variable:\n");
70010dc8:	e3070dd0 	movw	r0, #32208	; 0x7dd0
70010dcc:	e3470002 	movt	r0, #28674	; 0x7002
70010dd0:	ebffda87 	bl	700077f4 <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
70010dd4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010dd8:	e5d33000 	ldrb	r3, [r3]
70010ddc:	e3530000 	cmp	r3, #0
70010de0:	0a000009 	beq	70010e0c <list_prefix+0x2e8>
70010de4:	e51b3018 	ldr	r3, [fp, #-24]
70010de8:	e3530000 	cmp	r3, #0
70010dec:	1a000006 	bne	70010e0c <list_prefix+0x2e8>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
70010df0:	e51b3020 	ldr	r3, [fp, #-32]
70010df4:	e5933000 	ldr	r3, [r3]
70010df8:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
70010dfc:	e51b0018 	ldr	r0, [fp, #-24]
70010e00:	fa004d4b 	blx	70024334 <strlen>
70010e04:	e1a03000 	mov	r3, r0
70010e08:	e50b3014 	str	r3, [fp, #-20]

                    }
                }

                var_cnt ++;
70010e0c:	e15b31b0 	ldrh	r3, [fp, #-16]
70010e10:	e2833001 	add	r3, r3, #1
70010e14:	e14b31b0 	strh	r3, [fp, #-16]

                if (*prefix != 0)
70010e18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010e1c:	e5d33000 	ldrb	r3, [r3]
70010e20:	e3530000 	cmp	r3, #0
70010e24:	0a00000b 	beq	70010e58 <list_prefix+0x334>
                {
                    length = str_common(name_ptr, index->name);
70010e28:	e51b3020 	ldr	r3, [fp, #-32]
70010e2c:	e5933000 	ldr	r3, [r3]
70010e30:	e51b0018 	ldr	r0, [fp, #-24]
70010e34:	e1a01003 	mov	r1, r3
70010e38:	ebffff16 	bl	70010a98 <str_common>
70010e3c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
70010e40:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70010e44:	e51b3014 	ldr	r3, [fp, #-20]
70010e48:	e1520003 	cmp	r2, r3
70010e4c:	aa000001 	bge	70010e58 <list_prefix+0x334>
                        min_length = length;
70010e50:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70010e54:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
70010e58:	e51b3020 	ldr	r3, [fp, #-32]
70010e5c:	e5932000 	ldr	r2, [r3]
70010e60:	e51b3020 	ldr	r3, [fp, #-32]
70010e64:	e5933004 	ldr	r3, [r3, #4]
70010e68:	e3070d70 	movw	r0, #32112	; 0x7d70
70010e6c:	e3470002 	movt	r0, #28674	; 0x7002
70010e70:	e1a01002 	mov	r1, r2
70010e74:	e1a02003 	mov	r2, r3
70010e78:	ebffda5d 	bl	700077f4 <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
70010e7c:	e51b3020 	ldr	r3, [fp, #-32]
70010e80:	e2833010 	add	r3, r3, #16
70010e84:	e50b3020 	str	r3, [fp, #-32]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
70010e88:	e30a3a18 	movw	r3, #43544	; 0xaa18
70010e8c:	e3473002 	movt	r3, #28674	; 0x7002
70010e90:	e5933000 	ldr	r3, [r3]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
70010e94:	e51b2020 	ldr	r2, [fp, #-32]
70010e98:	e1520003 	cmp	r2, r3
70010e9c:	3affffbe 	bcc	70010d9c <list_prefix+0x278>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
70010ea0:	e30b35e8 	movw	r3, #46568	; 0xb5e8
70010ea4:	e3473002 	movt	r3, #28674	; 0x7002
70010ea8:	e5933000 	ldr	r3, [r3]
70010eac:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
70010eb0:	ea000037 	b	70010f94 <list_prefix+0x470>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
70010eb4:	e51b300c 	ldr	r3, [fp, #-12]
70010eb8:	e5933004 	ldr	r3, [r3, #4]
70010ebc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70010ec0:	e1a01003 	mov	r1, r3
70010ec4:	ebfffed2 	bl	70010a14 <str_is_prefix>
70010ec8:	e1a03000 	mov	r3, r0
70010ecc:	e3530000 	cmp	r3, #0
70010ed0:	1a00002c 	bne	70010f88 <list_prefix+0x464>
        {
            if (var_cnt == 0)
70010ed4:	e15b31b0 	ldrh	r3, [fp, #-16]
70010ed8:	e3530000 	cmp	r3, #0
70010edc:	1a000010 	bne	70010f24 <list_prefix+0x400>
            {
                rt_kprintf("--variable:\n");
70010ee0:	e3070dd0 	movw	r0, #32208	; 0x7dd0
70010ee4:	e3470002 	movt	r0, #28674	; 0x7002
70010ee8:	ebffda41 	bl	700077f4 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
70010eec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010ef0:	e5d33000 	ldrb	r3, [r3]
70010ef4:	e3530000 	cmp	r3, #0
70010ef8:	0a000009 	beq	70010f24 <list_prefix+0x400>
70010efc:	e51b3018 	ldr	r3, [fp, #-24]
70010f00:	e3530000 	cmp	r3, #0
70010f04:	1a000006 	bne	70010f24 <list_prefix+0x400>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
70010f08:	e51b300c 	ldr	r3, [fp, #-12]
70010f0c:	e5933004 	ldr	r3, [r3, #4]
70010f10:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
70010f14:	e51b0018 	ldr	r0, [fp, #-24]
70010f18:	fa004d05 	blx	70024334 <strlen>
70010f1c:	e1a03000 	mov	r3, r0
70010f20:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            var_cnt ++;
70010f24:	e15b31b0 	ldrh	r3, [fp, #-16]
70010f28:	e2833001 	add	r3, r3, #1
70010f2c:	e14b31b0 	strh	r3, [fp, #-16]

            if (*prefix != 0)
70010f30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70010f34:	e5d33000 	ldrb	r3, [r3]
70010f38:	e3530000 	cmp	r3, #0
70010f3c:	0a00000b 	beq	70010f70 <list_prefix+0x44c>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
70010f40:	e51b300c 	ldr	r3, [fp, #-12]
70010f44:	e5933004 	ldr	r3, [r3, #4]
70010f48:	e51b0018 	ldr	r0, [fp, #-24]
70010f4c:	e1a01003 	mov	r1, r3
70010f50:	ebfffed0 	bl	70010a98 <str_common>
70010f54:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
70010f58:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70010f5c:	e51b3014 	ldr	r3, [fp, #-20]
70010f60:	e1520003 	cmp	r2, r3
70010f64:	aa000001 	bge	70010f70 <list_prefix+0x44c>
                    min_length = length;
70010f68:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70010f6c:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
70010f70:	e51b300c 	ldr	r3, [fp, #-12]
70010f74:	e5933004 	ldr	r3, [r3, #4]
70010f78:	e3070de0 	movw	r0, #32224	; 0x7de0
70010f7c:	e3470002 	movt	r0, #28674	; 0x7002
70010f80:	e1a01003 	mov	r1, r3
70010f84:	ebffda1a 	bl	700077f4 <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
70010f88:	e51b300c 	ldr	r3, [fp, #-12]
70010f8c:	e5933000 	ldr	r3, [r3]
70010f90:	e50b300c 	str	r3, [fp, #-12]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
70010f94:	e51b300c 	ldr	r3, [fp, #-12]
70010f98:	e3530000 	cmp	r3, #0
70010f9c:	1affffc4 	bne	70010eb4 <list_prefix+0x390>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
70010fa0:	e51b3018 	ldr	r3, [fp, #-24]
70010fa4:	e3530000 	cmp	r3, #0
70010fa8:	0a000004 	beq	70010fc0 <list_prefix+0x49c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
70010fac:	e51b3014 	ldr	r3, [fp, #-20]
70010fb0:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
70010fb4:	e51b1018 	ldr	r1, [fp, #-24]
70010fb8:	e1a02003 	mov	r2, r3
70010fbc:	ebffd595 	bl	70006618 <rt_strncpy>
    }
}
70010fc0:	e24bd004 	sub	sp, fp, #4
70010fc4:	e8bd8800 	pop	{fp, pc}

70010fc8 <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
70010fc8:	e92d4800 	push	{fp, lr}
70010fcc:	e28db004 	add	fp, sp, #4
70010fd0:	e24dd008 	sub	sp, sp, #8
70010fd4:	e50b0008 	str	r0, [fp, #-8]
70010fd8:	e50b100c 	str	r1, [fp, #-12]
    extern long list_thread(void);

    list_thread();
70010fdc:	ebfffba4 	bl	7000fe74 <list_thread>
    return 0;
70010fe0:	e3a03000 	mov	r3, #0
}
70010fe4:	e1a00003 	mov	r0, r3
70010fe8:	e24bd004 	sub	sp, fp, #4
70010fec:	e8bd8800 	pop	{fp, pc}

70010ff0 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
70010ff0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70010ff4:	e28db000 	add	fp, sp, #0
70010ff8:	e24dd00c 	sub	sp, sp, #12
70010ffc:	e50b0008 	str	r0, [fp, #-8]
70011000:	e50b100c 	str	r1, [fp, #-12]
    return 0;
70011004:	e3a03000 	mov	r3, #0
}
70011008:	e1a00003 	mov	r0, r3
7001100c:	e24bd000 	sub	sp, fp, #0
70011010:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70011014:	e12fff1e 	bx	lr

70011018 <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
70011018:	e92d4800 	push	{fp, lr}
7001101c:	e28db004 	add	fp, sp, #4
70011020:	e24dd008 	sub	sp, sp, #8
70011024:	e50b0008 	str	r0, [fp, #-8]
70011028:	e50b100c 	str	r1, [fp, #-12]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
7001102c:	ebffe00f 	bl	70009070 <list_mem>
#endif
    return 0;
70011030:	e3a03000 	mov	r3, #0
}
70011034:	e1a00003 	mov	r0, r3
70011038:	e24bd004 	sub	sp, fp, #4
7001103c:	e8bd8800 	pop	{fp, pc}

70011040 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
70011040:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70011044:	e28db000 	add	fp, sp, #0
    return __msh_state;
70011048:	e3083e18 	movw	r3, #36376	; 0x8e18
7001104c:	e3473002 	movt	r3, #28674	; 0x7002
70011050:	e5933000 	ldr	r3, [r3]
}
70011054:	e1a00003 	mov	r0, r3
70011058:	e24bd000 	sub	sp, fp, #0
7001105c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70011060:	e12fff1e 	bx	lr

70011064 <msh_exit>:

static int msh_exit(int argc, char** argv)
{
70011064:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70011068:	e28db000 	add	fp, sp, #0
7001106c:	e24dd00c 	sub	sp, sp, #12
70011070:	e50b0008 	str	r0, [fp, #-8]
70011074:	e50b100c 	str	r1, [fp, #-12]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
70011078:	e3083e18 	movw	r3, #36376	; 0x8e18
7001107c:	e3473002 	movt	r3, #28674	; 0x7002
70011080:	e3a02000 	mov	r2, #0
70011084:	e5832000 	str	r2, [r3]

    return 0;
70011088:	e3a03000 	mov	r3, #0
}
7001108c:	e1a00003 	mov	r0, r3
70011090:	e24bd000 	sub	sp, fp, #0
70011094:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70011098:	e12fff1e 	bx	lr

7001109c <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
7001109c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700110a0:	e28db000 	add	fp, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
700110a4:	e3083e18 	movw	r3, #36376	; 0x8e18
700110a8:	e3473002 	movt	r3, #28674	; 0x7002
700110ac:	e3a02001 	mov	r2, #1
700110b0:	e5832000 	str	r2, [r3]
    return 0;
700110b4:	e3a03000 	mov	r3, #0
}
700110b8:	e1a00003 	mov	r0, r3
700110bc:	e24bd000 	sub	sp, fp, #0
700110c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700110c4:	e12fff1e 	bx	lr

700110c8 <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
700110c8:	e92d4800 	push	{fp, lr}
700110cc:	e28db004 	add	fp, sp, #4
700110d0:	e24dd010 	sub	sp, sp, #16
700110d4:	e50b0010 	str	r0, [fp, #-16]
700110d8:	e50b1014 	str	r1, [fp, #-20]
    rt_kprintf("RT-Thread shell commands:\n");
700110dc:	e3070ed4 	movw	r0, #32468	; 0x7ed4
700110e0:	e3470002 	movt	r0, #28674	; 0x7002
700110e4:	ebffd9c2 	bl	700077f4 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
700110e8:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
700110ec:	e3473002 	movt	r3, #28674	; 0x7002
700110f0:	e5933000 	ldr	r3, [r3]
700110f4:	e50b3008 	str	r3, [fp, #-8]
700110f8:	ea000017 	b	7001115c <msh_help+0x94>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
700110fc:	e51b3008 	ldr	r3, [fp, #-8]
70011100:	e5933000 	ldr	r3, [r3]
70011104:	e1a00003 	mov	r0, r3
70011108:	e3071ef0 	movw	r1, #32496	; 0x7ef0
7001110c:	e3471002 	movt	r1, #28674	; 0x7002
70011110:	e3a02006 	mov	r2, #6
70011114:	fa004c9e 	blx	70024394 <strncmp>
70011118:	e1a03000 	mov	r3, r0
7001111c:	e3530000 	cmp	r3, #0
70011120:	0a000000 	beq	70011128 <msh_help+0x60>
70011124:	ea000009 	b	70011150 <msh_help+0x88>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
70011128:	e51b3008 	ldr	r3, [fp, #-8]
7001112c:	e5933000 	ldr	r3, [r3]
70011130:	e2832006 	add	r2, r3, #6
70011134:	e51b3008 	ldr	r3, [fp, #-8]
70011138:	e5933004 	ldr	r3, [r3, #4]
7001113c:	e3070ef8 	movw	r0, #32504	; 0x7ef8
70011140:	e3470002 	movt	r0, #28674	; 0x7002
70011144:	e1a01002 	mov	r1, r2
70011148:	e1a02003 	mov	r2, r3
7001114c:	ebffd9a8 	bl	700077f4 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
70011150:	e51b3008 	ldr	r3, [fp, #-8]
70011154:	e283300c 	add	r3, r3, #12
70011158:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
7001115c:	e30a3a10 	movw	r3, #43536	; 0xaa10
70011160:	e3473002 	movt	r3, #28674	; 0x7002
70011164:	e5933000 	ldr	r3, [r3]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
70011168:	e51b2008 	ldr	r2, [fp, #-8]
7001116c:	e1520003 	cmp	r2, r3
70011170:	3affffe1 	bcc	700110fc <msh_help+0x34>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
70011174:	e3070f04 	movw	r0, #32516	; 0x7f04
70011178:	e3470002 	movt	r0, #28674	; 0x7002
7001117c:	ebffd99c 	bl	700077f4 <rt_kprintf>

    return 0;
70011180:	e3a03000 	mov	r3, #0
}
70011184:	e1a00003 	mov	r0, r3
70011188:	e24bd004 	sub	sp, fp, #4
7001118c:	e8bd8800 	pop	{fp, pc}

70011190 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
70011190:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70011194:	e28db000 	add	fp, sp, #0
70011198:	e24dd024 	sub	sp, sp, #36	; 0x24
7001119c:	e50b0018 	str	r0, [fp, #-24]
700111a0:	e50b101c 	str	r1, [fp, #-28]
700111a4:	e50b2020 	str	r2, [fp, #-32]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
700111a8:	e51b3018 	ldr	r3, [fp, #-24]
700111ac:	e50b3008 	str	r3, [fp, #-8]
    position = 0; argc = 0;
700111b0:	e3a03000 	mov	r3, #0
700111b4:	e50b300c 	str	r3, [fp, #-12]
700111b8:	e3a03000 	mov	r3, #0
700111bc:	e50b3010 	str	r3, [fp, #-16]

    while (position < length)
700111c0:	ea00007b 	b	700113b4 <msh_split+0x224>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
700111c4:	ea000008 	b	700111ec <msh_split+0x5c>
        {
            *ptr = '\0';
700111c8:	e51b3008 	ldr	r3, [fp, #-8]
700111cc:	e3a02000 	mov	r2, #0
700111d0:	e5c32000 	strb	r2, [r3]
            ptr ++; position ++;
700111d4:	e51b3008 	ldr	r3, [fp, #-8]
700111d8:	e2833001 	add	r3, r3, #1
700111dc:	e50b3008 	str	r3, [fp, #-8]
700111e0:	e51b300c 	ldr	r3, [fp, #-12]
700111e4:	e2833001 	add	r3, r3, #1
700111e8:	e50b300c 	str	r3, [fp, #-12]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
700111ec:	e51b3008 	ldr	r3, [fp, #-8]
700111f0:	e5d33000 	ldrb	r3, [r3]
700111f4:	e3530020 	cmp	r3, #32
700111f8:	0a000003 	beq	7001120c <msh_split+0x7c>
700111fc:	e51b3008 	ldr	r3, [fp, #-8]
70011200:	e5d33000 	ldrb	r3, [r3]
70011204:	e3530009 	cmp	r3, #9
70011208:	1a000003 	bne	7001121c <msh_split+0x8c>
7001120c:	e51b200c 	ldr	r2, [fp, #-12]
70011210:	e51b301c 	ldr	r3, [fp, #-28]
70011214:	e1520003 	cmp	r2, r3
70011218:	3affffea 	bcc	700111c8 <msh_split+0x38>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
7001121c:	e51b200c 	ldr	r2, [fp, #-12]
70011220:	e51b301c 	ldr	r3, [fp, #-28]
70011224:	e1520003 	cmp	r2, r3
70011228:	3a000000 	bcc	70011230 <msh_split+0xa0>
7001122c:	ea000064 	b	700113c4 <msh_split+0x234>

        /* handle string */
        if (*ptr == '"')
70011230:	e51b3008 	ldr	r3, [fp, #-8]
70011234:	e5d33000 	ldrb	r3, [r3]
70011238:	e3530022 	cmp	r3, #34	; 0x22
7001123c:	1a00003b 	bne	70011330 <msh_split+0x1a0>
        {
            ptr ++; position ++;
70011240:	e51b3008 	ldr	r3, [fp, #-8]
70011244:	e2833001 	add	r3, r3, #1
70011248:	e50b3008 	str	r3, [fp, #-8]
7001124c:	e51b300c 	ldr	r3, [fp, #-12]
70011250:	e2833001 	add	r3, r3, #1
70011254:	e50b300c 	str	r3, [fp, #-12]
            argv[argc] = ptr; argc ++;
70011258:	e51b3010 	ldr	r3, [fp, #-16]
7001125c:	e1a03103 	lsl	r3, r3, #2
70011260:	e51b2020 	ldr	r2, [fp, #-32]
70011264:	e0823003 	add	r3, r2, r3
70011268:	e51b2008 	ldr	r2, [fp, #-8]
7001126c:	e5832000 	str	r2, [r3]
70011270:	e51b3010 	ldr	r3, [fp, #-16]
70011274:	e2833001 	add	r3, r3, #1
70011278:	e50b3010 	str	r3, [fp, #-16]

            /* skip this string */
            while (*ptr != '"' && position < length)
7001127c:	ea000014 	b	700112d4 <msh_split+0x144>
            {
                if (*ptr == '\\')
70011280:	e51b3008 	ldr	r3, [fp, #-8]
70011284:	e5d33000 	ldrb	r3, [r3]
70011288:	e353005c 	cmp	r3, #92	; 0x5c
7001128c:	1a00000a 	bne	700112bc <msh_split+0x12c>
                {
                    if (*(ptr + 1) == '"')
70011290:	e51b3008 	ldr	r3, [fp, #-8]
70011294:	e2833001 	add	r3, r3, #1
70011298:	e5d33000 	ldrb	r3, [r3]
7001129c:	e3530022 	cmp	r3, #34	; 0x22
700112a0:	1a000005 	bne	700112bc <msh_split+0x12c>
                    {
                        ptr ++; position ++;
700112a4:	e51b3008 	ldr	r3, [fp, #-8]
700112a8:	e2833001 	add	r3, r3, #1
700112ac:	e50b3008 	str	r3, [fp, #-8]
700112b0:	e51b300c 	ldr	r3, [fp, #-12]
700112b4:	e2833001 	add	r3, r3, #1
700112b8:	e50b300c 	str	r3, [fp, #-12]
                    }
                }
                ptr ++; position ++;
700112bc:	e51b3008 	ldr	r3, [fp, #-8]
700112c0:	e2833001 	add	r3, r3, #1
700112c4:	e50b3008 	str	r3, [fp, #-8]
700112c8:	e51b300c 	ldr	r3, [fp, #-12]
700112cc:	e2833001 	add	r3, r3, #1
700112d0:	e50b300c 	str	r3, [fp, #-12]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
700112d4:	e51b3008 	ldr	r3, [fp, #-8]
700112d8:	e5d33000 	ldrb	r3, [r3]
700112dc:	e3530022 	cmp	r3, #34	; 0x22
700112e0:	0a000003 	beq	700112f4 <msh_split+0x164>
700112e4:	e51b200c 	ldr	r2, [fp, #-12]
700112e8:	e51b301c 	ldr	r3, [fp, #-28]
700112ec:	e1520003 	cmp	r2, r3
700112f0:	3affffe2 	bcc	70011280 <msh_split+0xf0>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
700112f4:	e51b200c 	ldr	r2, [fp, #-12]
700112f8:	e51b301c 	ldr	r3, [fp, #-28]
700112fc:	e1520003 	cmp	r2, r3
70011300:	3a000000 	bcc	70011308 <msh_split+0x178>
70011304:	ea00002e 	b	700113c4 <msh_split+0x234>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
70011308:	e51b3008 	ldr	r3, [fp, #-8]
7001130c:	e3a02000 	mov	r2, #0
70011310:	e5c32000 	strb	r2, [r3]
70011314:	e51b3008 	ldr	r3, [fp, #-8]
70011318:	e2833001 	add	r3, r3, #1
7001131c:	e50b3008 	str	r3, [fp, #-8]
70011320:	e51b300c 	ldr	r3, [fp, #-12]
70011324:	e2833001 	add	r3, r3, #1
70011328:	e50b300c 	str	r3, [fp, #-12]
7001132c:	ea000020 	b	700113b4 <msh_split+0x224>
        }
        else
        {
            argv[argc] = ptr;
70011330:	e51b3010 	ldr	r3, [fp, #-16]
70011334:	e1a03103 	lsl	r3, r3, #2
70011338:	e51b2020 	ldr	r2, [fp, #-32]
7001133c:	e0823003 	add	r3, r2, r3
70011340:	e51b2008 	ldr	r2, [fp, #-8]
70011344:	e5832000 	str	r2, [r3]
            argc ++;
70011348:	e51b3010 	ldr	r3, [fp, #-16]
7001134c:	e2833001 	add	r3, r3, #1
70011350:	e50b3010 	str	r3, [fp, #-16]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
70011354:	ea000005 	b	70011370 <msh_split+0x1e0>
            {
                ptr ++; position ++;
70011358:	e51b3008 	ldr	r3, [fp, #-8]
7001135c:	e2833001 	add	r3, r3, #1
70011360:	e50b3008 	str	r3, [fp, #-8]
70011364:	e51b300c 	ldr	r3, [fp, #-12]
70011368:	e2833001 	add	r3, r3, #1
7001136c:	e50b300c 	str	r3, [fp, #-12]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
70011370:	e51b3008 	ldr	r3, [fp, #-8]
70011374:	e5d33000 	ldrb	r3, [r3]
70011378:	e3530020 	cmp	r3, #32
7001137c:	0a000007 	beq	700113a0 <msh_split+0x210>
70011380:	e51b3008 	ldr	r3, [fp, #-8]
70011384:	e5d33000 	ldrb	r3, [r3]
70011388:	e3530009 	cmp	r3, #9
7001138c:	0a000003 	beq	700113a0 <msh_split+0x210>
70011390:	e51b200c 	ldr	r2, [fp, #-12]
70011394:	e51b301c 	ldr	r3, [fp, #-28]
70011398:	e1520003 	cmp	r2, r3
7001139c:	3affffed 	bcc	70011358 <msh_split+0x1c8>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
700113a0:	e51b200c 	ldr	r2, [fp, #-12]
700113a4:	e51b301c 	ldr	r3, [fp, #-28]
700113a8:	e1520003 	cmp	r2, r3
700113ac:	3a000000 	bcc	700113b4 <msh_split+0x224>
700113b0:	ea000003 	b	700113c4 <msh_split+0x234>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
700113b4:	e51b200c 	ldr	r2, [fp, #-12]
700113b8:	e51b301c 	ldr	r3, [fp, #-28]
700113bc:	e1520003 	cmp	r2, r3
700113c0:	3affff7f 	bcc	700111c4 <msh_split+0x34>
            }
            if (position >= length) break;
        }
    }

    return argc;
700113c4:	e51b3010 	ldr	r3, [fp, #-16]
}
700113c8:	e1a00003 	mov	r0, r3
700113cc:	e24bd000 	sub	sp, fp, #0
700113d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700113d4:	e12fff1e 	bx	lr

700113d8 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
700113d8:	e92d4800 	push	{fp, lr}
700113dc:	e28db004 	add	fp, sp, #4
700113e0:	e24dd010 	sub	sp, sp, #16
700113e4:	e50b0010 	str	r0, [fp, #-16]
700113e8:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
700113ec:	e3a03000 	mov	r3, #0
700113f0:	e50b300c 	str	r3, [fp, #-12]

    for (index = _syscall_table_begin;
700113f4:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
700113f8:	e3473002 	movt	r3, #28674	; 0x7002
700113fc:	e5933000 	ldr	r3, [r3]
70011400:	e50b3008 	str	r3, [fp, #-8]
70011404:	ea000024 	b	7001149c <msh_get_cmd+0xc4>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
70011408:	e51b3008 	ldr	r3, [fp, #-8]
7001140c:	e5933000 	ldr	r3, [r3]
70011410:	e1a00003 	mov	r0, r3
70011414:	e3071ef0 	movw	r1, #32496	; 0x7ef0
70011418:	e3471002 	movt	r1, #28674	; 0x7002
7001141c:	e3a02006 	mov	r2, #6
70011420:	fa004bdb 	blx	70024394 <strncmp>
70011424:	e1a03000 	mov	r3, r0
70011428:	e3530000 	cmp	r3, #0
7001142c:	0a000000 	beq	70011434 <msh_get_cmd+0x5c>
70011430:	ea000016 	b	70011490 <msh_get_cmd+0xb8>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
70011434:	e51b3008 	ldr	r3, [fp, #-8]
70011438:	e5933000 	ldr	r3, [r3]
7001143c:	e2832006 	add	r2, r3, #6
70011440:	e51b3014 	ldr	r3, [fp, #-20]
70011444:	e1a00002 	mov	r0, r2
70011448:	e51b1010 	ldr	r1, [fp, #-16]
7001144c:	e1a02003 	mov	r2, r3
70011450:	fa004bcf 	blx	70024394 <strncmp>
70011454:	e1a03000 	mov	r3, r0
70011458:	e3530000 	cmp	r3, #0
7001145c:	1a00000b 	bne	70011490 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
70011460:	e51b3008 	ldr	r3, [fp, #-8]
70011464:	e5932000 	ldr	r2, [r3]
70011468:	e51b3014 	ldr	r3, [fp, #-20]
7001146c:	e2833006 	add	r3, r3, #6
70011470:	e0823003 	add	r3, r2, r3
70011474:	e5d33000 	ldrb	r3, [r3]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
70011478:	e3530000 	cmp	r3, #0
7001147c:	1a000003 	bne	70011490 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
70011480:	e51b3008 	ldr	r3, [fp, #-8]
70011484:	e5933008 	ldr	r3, [r3, #8]
70011488:	e50b300c 	str	r3, [fp, #-12]
            break;
7001148c:	ea000008 	b	700114b4 <msh_get_cmd+0xdc>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
70011490:	e51b3008 	ldr	r3, [fp, #-8]
70011494:	e283300c 	add	r3, r3, #12
70011498:	e50b3008 	str	r3, [fp, #-8]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
7001149c:	e30a3a10 	movw	r3, #43536	; 0xaa10
700114a0:	e3473002 	movt	r3, #28674	; 0x7002
700114a4:	e5933000 	ldr	r3, [r3]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
700114a8:	e51b2008 	ldr	r2, [fp, #-8]
700114ac:	e1520003 	cmp	r2, r3
700114b0:	3affffd4 	bcc	70011408 <msh_get_cmd+0x30>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
700114b4:	e51b300c 	ldr	r3, [fp, #-12]
}
700114b8:	e1a00003 	mov	r0, r3
700114bc:	e24bd004 	sub	sp, fp, #4
700114c0:	e8bd8800 	pop	{fp, pc}

700114c4 <_msh_exec_cmd>:
    return msh_exec_module(command, rt_strlen(command));
}
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
700114c4:	e92d4800 	push	{fp, lr}
700114c8:	e28db004 	add	fp, sp, #4
700114cc:	e24dd048 	sub	sp, sp, #72	; 0x48
700114d0:	e50b0040 	str	r0, [fp, #-64]	; 0x40
700114d4:	e50b1044 	str	r1, [fp, #-68]	; 0x44
700114d8:	e50b2048 	str	r2, [fp, #-72]	; 0x48
    int argc;
    int cmd0_size = 0;
700114dc:	e3a03000 	mov	r3, #0
700114e0:	e50b3008 	str	r3, [fp, #-8]
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
700114e4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
700114e8:	e3530000 	cmp	r3, #0
700114ec:	1a00001d 	bne	70011568 <_msh_exec_cmd+0xa4>
700114f0:	e3a03000 	mov	r3, #0
700114f4:	e54b3039 	strb	r3, [fp, #-57]	; 0x39
700114f8:	e30a3b74 	movw	r3, #43892	; 0xab74
700114fc:	e3473002 	movt	r3, #28674	; 0x7002
70011500:	e5933000 	ldr	r3, [r3]
70011504:	e3530000 	cmp	r3, #0
70011508:	1a00000d 	bne	70011544 <_msh_exec_cmd+0x80>
7001150c:	e3070f2c 	movw	r0, #32556	; 0x7f2c
70011510:	e3470002 	movt	r0, #28674	; 0x7002
70011514:	e3071f4c 	movw	r1, #32588	; 0x7f4c
70011518:	e3471002 	movt	r1, #28674	; 0x7002
7001151c:	e3072f74 	movw	r2, #32628	; 0x7f74
70011520:	e3472002 	movt	r2, #28674	; 0x7002
70011524:	e3003109 	movw	r3, #265	; 0x109
70011528:	ebffd8b1 	bl	700077f4 <rt_kprintf>
7001152c:	e1a00000 	nop			; (mov r0, r0)
70011530:	e55b3039 	ldrb	r3, [fp, #-57]	; 0x39
70011534:	e6ef3073 	uxtb	r3, r3
70011538:	e3530000 	cmp	r3, #0
7001153c:	0afffffb 	beq	70011530 <_msh_exec_cmd+0x6c>
70011540:	ea000008 	b	70011568 <_msh_exec_cmd+0xa4>
70011544:	e30a3b74 	movw	r3, #43892	; 0xab74
70011548:	e3473002 	movt	r3, #28674	; 0x7002
7001154c:	e5933000 	ldr	r3, [r3]
70011550:	e3070f4c 	movw	r0, #32588	; 0x7f4c
70011554:	e3470002 	movt	r0, #28674	; 0x7002
70011558:	e3071f74 	movw	r1, #32628	; 0x7f74
7001155c:	e3471002 	movt	r1, #28674	; 0x7002
70011560:	e3002109 	movw	r2, #265	; 0x109
70011564:	e12fff33 	blx	r3
    RT_ASSERT(retp);
70011568:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
7001156c:	e3530000 	cmp	r3, #0
70011570:	1a00001e 	bne	700115f0 <_msh_exec_cmd+0x12c>
70011574:	e3a03000 	mov	r3, #0
70011578:	e54b303a 	strb	r3, [fp, #-58]	; 0x3a
7001157c:	e30a3b74 	movw	r3, #43892	; 0xab74
70011580:	e3473002 	movt	r3, #28674	; 0x7002
70011584:	e5933000 	ldr	r3, [r3]
70011588:	e3530000 	cmp	r3, #0
7001158c:	1a00000d 	bne	700115c8 <_msh_exec_cmd+0x104>
70011590:	e3070f2c 	movw	r0, #32556	; 0x7f2c
70011594:	e3470002 	movt	r0, #28674	; 0x7002
70011598:	e3071f50 	movw	r1, #32592	; 0x7f50
7001159c:	e3471002 	movt	r1, #28674	; 0x7002
700115a0:	e3072f74 	movw	r2, #32628	; 0x7f74
700115a4:	e3472002 	movt	r2, #28674	; 0x7002
700115a8:	e300310a 	movw	r3, #266	; 0x10a
700115ac:	ebffd890 	bl	700077f4 <rt_kprintf>
700115b0:	e1a00000 	nop			; (mov r0, r0)
700115b4:	e55b303a 	ldrb	r3, [fp, #-58]	; 0x3a
700115b8:	e6ef3073 	uxtb	r3, r3
700115bc:	e3530000 	cmp	r3, #0
700115c0:	0afffffb 	beq	700115b4 <_msh_exec_cmd+0xf0>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
700115c4:	ea00000d 	b	70011600 <_msh_exec_cmd+0x13c>
    int cmd0_size = 0;
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
    RT_ASSERT(retp);
700115c8:	e30a3b74 	movw	r3, #43892	; 0xab74
700115cc:	e3473002 	movt	r3, #28674	; 0x7002
700115d0:	e5933000 	ldr	r3, [r3]
700115d4:	e3070f50 	movw	r0, #32592	; 0x7f50
700115d8:	e3470002 	movt	r0, #28674	; 0x7002
700115dc:	e3071f74 	movw	r1, #32628	; 0x7f74
700115e0:	e3471002 	movt	r1, #28674	; 0x7002
700115e4:	e300210a 	movw	r2, #266	; 0x10a
700115e8:	e12fff33 	blx	r3

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
700115ec:	ea000003 	b	70011600 <_msh_exec_cmd+0x13c>
700115f0:	ea000002 	b	70011600 <_msh_exec_cmd+0x13c>
        cmd0_size ++;
700115f4:	e51b3008 	ldr	r3, [fp, #-8]
700115f8:	e2833001 	add	r3, r3, #1
700115fc:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
70011600:	e51b3008 	ldr	r3, [fp, #-8]
70011604:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
70011608:	e0823003 	add	r3, r2, r3
7001160c:	e5d33000 	ldrb	r3, [r3]
70011610:	e3530020 	cmp	r3, #32
70011614:	0a000009 	beq	70011640 <_msh_exec_cmd+0x17c>
70011618:	e51b3008 	ldr	r3, [fp, #-8]
7001161c:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
70011620:	e0823003 	add	r3, r2, r3
70011624:	e5d33000 	ldrb	r3, [r3]
70011628:	e3530009 	cmp	r3, #9
7001162c:	0a000003 	beq	70011640 <_msh_exec_cmd+0x17c>
70011630:	e51b2008 	ldr	r2, [fp, #-8]
70011634:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
70011638:	e1520003 	cmp	r2, r3
7001163c:	3affffec 	bcc	700115f4 <_msh_exec_cmd+0x130>
        cmd0_size ++;
    if (cmd0_size == 0)
70011640:	e51b3008 	ldr	r3, [fp, #-8]
70011644:	e3530000 	cmp	r3, #0
70011648:	1a000001 	bne	70011654 <_msh_exec_cmd+0x190>
        return -RT_ERROR;
7001164c:	e3e03000 	mvn	r3, #0
70011650:	ea000021 	b	700116dc <_msh_exec_cmd+0x218>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
70011654:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70011658:	e51b1008 	ldr	r1, [fp, #-8]
7001165c:	ebffff5d 	bl	700113d8 <msh_get_cmd>
70011660:	e50b000c 	str	r0, [fp, #-12]
    if (cmd_func == RT_NULL)
70011664:	e51b300c 	ldr	r3, [fp, #-12]
70011668:	e3530000 	cmp	r3, #0
7001166c:	1a000001 	bne	70011678 <_msh_exec_cmd+0x1b4>
        return -RT_ERROR;
70011670:	e3e03000 	mvn	r3, #0
70011674:	ea000018 	b	700116dc <_msh_exec_cmd+0x218>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
70011678:	e24b3038 	sub	r3, fp, #56	; 0x38
7001167c:	e1a00003 	mov	r0, r3
70011680:	e3a01000 	mov	r1, #0
70011684:	e3a02028 	mov	r2, #40	; 0x28
70011688:	fa004a30 	blx	70023f50 <memset>
    argc = msh_split(cmd, length, argv);
7001168c:	e24b3038 	sub	r3, fp, #56	; 0x38
70011690:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70011694:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
70011698:	e1a02003 	mov	r2, r3
7001169c:	ebfffebb 	bl	70011190 <msh_split>
700116a0:	e50b0010 	str	r0, [fp, #-16]
    if (argc == 0)
700116a4:	e51b3010 	ldr	r3, [fp, #-16]
700116a8:	e3530000 	cmp	r3, #0
700116ac:	1a000001 	bne	700116b8 <_msh_exec_cmd+0x1f4>
        return -RT_ERROR;
700116b0:	e3e03000 	mvn	r3, #0
700116b4:	ea000008 	b	700116dc <_msh_exec_cmd+0x218>

    /* exec this command */
    *retp = cmd_func(argc, argv);
700116b8:	e24b2038 	sub	r2, fp, #56	; 0x38
700116bc:	e51b300c 	ldr	r3, [fp, #-12]
700116c0:	e51b0010 	ldr	r0, [fp, #-16]
700116c4:	e1a01002 	mov	r1, r2
700116c8:	e12fff33 	blx	r3
700116cc:	e1a02000 	mov	r2, r0
700116d0:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
700116d4:	e5832000 	str	r2, [r3]
    return 0;
700116d8:	e3a03000 	mov	r3, #0
}
700116dc:	e1a00003 	mov	r0, r3
700116e0:	e24bd004 	sub	sp, fp, #4
700116e4:	e8bd8800 	pop	{fp, pc}

700116e8 <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
700116e8:	e92d4800 	push	{fp, lr}
700116ec:	e28db004 	add	fp, sp, #4
700116f0:	e24dd010 	sub	sp, sp, #16
700116f4:	e50b0010 	str	r0, [fp, #-16]
700116f8:	e50b1014 	str	r1, [fp, #-20]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
700116fc:	ea000005 	b	70011718 <msh_exec+0x30>
    {
        cmd++;
70011700:	e51b3010 	ldr	r3, [fp, #-16]
70011704:	e2833001 	add	r3, r3, #1
70011708:	e50b3010 	str	r3, [fp, #-16]
        length--;
7001170c:	e51b3014 	ldr	r3, [fp, #-20]
70011710:	e2433001 	sub	r3, r3, #1
70011714:	e50b3014 	str	r3, [fp, #-20]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
70011718:	e51b3010 	ldr	r3, [fp, #-16]
7001171c:	e5d33000 	ldrb	r3, [r3]
70011720:	e3530020 	cmp	r3, #32
70011724:	0afffff5 	beq	70011700 <msh_exec+0x18>
70011728:	e51b3010 	ldr	r3, [fp, #-16]
7001172c:	e5d33000 	ldrb	r3, [r3]
70011730:	e3530009 	cmp	r3, #9
70011734:	0afffff1 	beq	70011700 <msh_exec+0x18>
    {
        cmd++;
        length--;
    }

    if (length == 0)
70011738:	e51b3014 	ldr	r3, [fp, #-20]
7001173c:	e3530000 	cmp	r3, #0
70011740:	1a000001 	bne	7001174c <msh_exec+0x64>
        return 0;
70011744:	e3a03000 	mov	r3, #0
70011748:	ea00001f 	b	700117cc <msh_exec+0xe4>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
7001174c:	e24b300c 	sub	r3, fp, #12
70011750:	e51b0010 	ldr	r0, [fp, #-16]
70011754:	e51b1014 	ldr	r1, [fp, #-20]
70011758:	e1a02003 	mov	r2, r3
7001175c:	ebffff58 	bl	700114c4 <_msh_exec_cmd>
70011760:	e1a03000 	mov	r3, r0
70011764:	e3530000 	cmp	r3, #0
70011768:	1a000001 	bne	70011774 <msh_exec+0x8c>
    {
        return cmd_ret;
7001176c:	e51b300c 	ldr	r3, [fp, #-12]
70011770:	ea000015 	b	700117cc <msh_exec+0xe4>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
70011774:	e51b3010 	ldr	r3, [fp, #-16]
70011778:	e50b3008 	str	r3, [fp, #-8]
        while(*tcmd != ' ' && *tcmd != '\0')
7001177c:	ea000002 	b	7001178c <msh_exec+0xa4>
        {
            tcmd++;
70011780:	e51b3008 	ldr	r3, [fp, #-8]
70011784:	e2833001 	add	r3, r3, #1
70011788:	e50b3008 	str	r3, [fp, #-8]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
7001178c:	e51b3008 	ldr	r3, [fp, #-8]
70011790:	e5d33000 	ldrb	r3, [r3]
70011794:	e3530020 	cmp	r3, #32
70011798:	0a000003 	beq	700117ac <msh_exec+0xc4>
7001179c:	e51b3008 	ldr	r3, [fp, #-8]
700117a0:	e5d33000 	ldrb	r3, [r3]
700117a4:	e3530000 	cmp	r3, #0
700117a8:	1afffff4 	bne	70011780 <msh_exec+0x98>
        {
            tcmd++;
        }
        *tcmd = '\0';
700117ac:	e51b3008 	ldr	r3, [fp, #-8]
700117b0:	e3a02000 	mov	r2, #0
700117b4:	e5c32000 	strb	r2, [r3]
    }
    rt_kprintf("%s: command not found.\n", cmd);
700117b8:	e3070f58 	movw	r0, #32600	; 0x7f58
700117bc:	e3470002 	movt	r0, #28674	; 0x7002
700117c0:	e51b1010 	ldr	r1, [fp, #-16]
700117c4:	ebffd80a 	bl	700077f4 <rt_kprintf>
    return -1;
700117c8:	e3e03000 	mvn	r3, #0
}
700117cc:	e1a00003 	mov	r0, r3
700117d0:	e24bd004 	sub	sp, fp, #4
700117d4:	e8bd8800 	pop	{fp, pc}

700117d8 <str_common>:

static int str_common(const char *str1, const char *str2)
{
700117d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700117dc:	e28db000 	add	fp, sp, #0
700117e0:	e24dd014 	sub	sp, sp, #20
700117e4:	e50b0010 	str	r0, [fp, #-16]
700117e8:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
700117ec:	e51b3010 	ldr	r3, [fp, #-16]
700117f0:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
700117f4:	ea000005 	b	70011810 <str_common+0x38>
    {
        str ++;
700117f8:	e51b3008 	ldr	r3, [fp, #-8]
700117fc:	e2833001 	add	r3, r3, #1
70011800:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
70011804:	e51b3014 	ldr	r3, [fp, #-20]
70011808:	e2833001 	add	r3, r3, #1
7001180c:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
70011810:	e51b3008 	ldr	r3, [fp, #-8]
70011814:	e5d33000 	ldrb	r3, [r3]
70011818:	e3530000 	cmp	r3, #0
7001181c:	0a000009 	beq	70011848 <str_common+0x70>
70011820:	e51b3014 	ldr	r3, [fp, #-20]
70011824:	e5d33000 	ldrb	r3, [r3]
70011828:	e3530000 	cmp	r3, #0
7001182c:	0a000005 	beq	70011848 <str_common+0x70>
70011830:	e51b3008 	ldr	r3, [fp, #-8]
70011834:	e5d32000 	ldrb	r2, [r3]
70011838:	e51b3014 	ldr	r3, [fp, #-20]
7001183c:	e5d33000 	ldrb	r3, [r3]
70011840:	e1520003 	cmp	r2, r3
70011844:	0affffeb 	beq	700117f8 <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
70011848:	e51b2008 	ldr	r2, [fp, #-8]
7001184c:	e51b3010 	ldr	r3, [fp, #-16]
70011850:	e0633002 	rsb	r3, r3, r2
}
70011854:	e1a00003 	mov	r0, r3
70011858:	e24bd000 	sub	sp, fp, #0
7001185c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70011860:	e12fff1e 	bx	lr

70011864 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
70011864:	e92d4800 	push	{fp, lr}
70011868:	e28db004 	add	fp, sp, #4
7001186c:	e24dd020 	sub	sp, sp, #32
70011870:	e50b0020 	str	r0, [fp, #-32]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
70011874:	e3a03000 	mov	r3, #0
70011878:	e50b3008 	str	r3, [fp, #-8]
    name_ptr = RT_NULL;
7001187c:	e3a03000 	mov	r3, #0
70011880:	e50b300c 	str	r3, [fp, #-12]

    if (*prefix == '\0') 
70011884:	e51b3020 	ldr	r3, [fp, #-32]
70011888:	e5d33000 	ldrb	r3, [r3]
7001188c:	e3530000 	cmp	r3, #0
70011890:	1a000003 	bne	700118a4 <msh_auto_complete+0x40>
    {
        msh_help(0, RT_NULL);
70011894:	e3a00000 	mov	r0, #0
70011898:	e3a01000 	mov	r1, #0
7001189c:	ebfffe09 	bl	700110c8 <msh_help>
        return;
700118a0:	ea000046 	b	700119c0 <msh_auto_complete+0x15c>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
700118a4:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
700118a8:	e3473002 	movt	r3, #28674	; 0x7002
700118ac:	e5933000 	ldr	r3, [r3]
700118b0:	e50b3010 	str	r3, [fp, #-16]
700118b4:	ea000032 	b	70011984 <msh_auto_complete+0x120>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
700118b8:	e51b3010 	ldr	r3, [fp, #-16]
700118bc:	e5933000 	ldr	r3, [r3]
700118c0:	e1a00003 	mov	r0, r3
700118c4:	e3071ef0 	movw	r1, #32496	; 0x7ef0
700118c8:	e3471002 	movt	r1, #28674	; 0x7002
700118cc:	e3a02006 	mov	r2, #6
700118d0:	fa004aaf 	blx	70024394 <strncmp>
700118d4:	e1a03000 	mov	r3, r0
700118d8:	e3530000 	cmp	r3, #0
700118dc:	0a000000 	beq	700118e4 <msh_auto_complete+0x80>
700118e0:	ea000024 	b	70011978 <msh_auto_complete+0x114>

            cmd_name = (const char*) &index->name[6];
700118e4:	e51b3010 	ldr	r3, [fp, #-16]
700118e8:	e5933000 	ldr	r3, [r3]
700118ec:	e2833006 	add	r3, r3, #6
700118f0:	e50b3014 	str	r3, [fp, #-20]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
700118f4:	e51b0020 	ldr	r0, [fp, #-32]
700118f8:	fa004a8d 	blx	70024334 <strlen>
700118fc:	e1a03000 	mov	r3, r0
70011900:	e51b0020 	ldr	r0, [fp, #-32]
70011904:	e51b1014 	ldr	r1, [fp, #-20]
70011908:	e1a02003 	mov	r2, r3
7001190c:	fa004aa0 	blx	70024394 <strncmp>
70011910:	e1a03000 	mov	r3, r0
70011914:	e3530000 	cmp	r3, #0
70011918:	1a000016 	bne	70011978 <msh_auto_complete+0x114>
            {
                if (min_length == 0)
7001191c:	e51b3008 	ldr	r3, [fp, #-8]
70011920:	e3530000 	cmp	r3, #0
70011924:	1a000005 	bne	70011940 <msh_auto_complete+0xdc>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
70011928:	e51b3014 	ldr	r3, [fp, #-20]
7001192c:	e50b300c 	str	r3, [fp, #-12]
                    /* set initial length */
                    min_length = strlen(name_ptr);
70011930:	e51b000c 	ldr	r0, [fp, #-12]
70011934:	fa004a7e 	blx	70024334 <strlen>
70011938:	e1a03000 	mov	r3, r0
7001193c:	e50b3008 	str	r3, [fp, #-8]
                }

                length = str_common(name_ptr, cmd_name);
70011940:	e51b000c 	ldr	r0, [fp, #-12]
70011944:	e51b1014 	ldr	r1, [fp, #-20]
70011948:	ebffffa2 	bl	700117d8 <str_common>
7001194c:	e50b0018 	str	r0, [fp, #-24]
                if (length < min_length)
70011950:	e51b2018 	ldr	r2, [fp, #-24]
70011954:	e51b3008 	ldr	r3, [fp, #-8]
70011958:	e1520003 	cmp	r2, r3
7001195c:	aa000001 	bge	70011968 <msh_auto_complete+0x104>
                    min_length = length;
70011960:	e51b3018 	ldr	r3, [fp, #-24]
70011964:	e50b3008 	str	r3, [fp, #-8]

                rt_kprintf("%s\n", cmd_name);
70011968:	e3070f70 	movw	r0, #32624	; 0x7f70
7001196c:	e3470002 	movt	r0, #28674	; 0x7002
70011970:	e51b1014 	ldr	r1, [fp, #-20]
70011974:	ebffd79e 	bl	700077f4 <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
70011978:	e51b3010 	ldr	r3, [fp, #-16]
7001197c:	e283300c 	add	r3, r3, #12
70011980:	e50b3010 	str	r3, [fp, #-16]
70011984:	e30a3a10 	movw	r3, #43536	; 0xaa10
70011988:	e3473002 	movt	r3, #28674	; 0x7002
7001198c:	e5933000 	ldr	r3, [r3]
70011990:	e51b2010 	ldr	r2, [fp, #-16]
70011994:	e1520003 	cmp	r2, r3
70011998:	3affffc6 	bcc	700118b8 <msh_auto_complete+0x54>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
7001199c:	e51b300c 	ldr	r3, [fp, #-12]
700119a0:	e3530000 	cmp	r3, #0
700119a4:	0a000004 	beq	700119bc <msh_auto_complete+0x158>
    {
        rt_strncpy(prefix, name_ptr, min_length);
700119a8:	e51b3008 	ldr	r3, [fp, #-8]
700119ac:	e51b0020 	ldr	r0, [fp, #-32]
700119b0:	e51b100c 	ldr	r1, [fp, #-12]
700119b4:	e1a02003 	mov	r2, r3
700119b8:	ebffd316 	bl	70006618 <rt_strncpy>
    }

    return ;
700119bc:	e1a00000 	nop			; (mov r0, r0)
}
700119c0:	e24bd004 	sub	sp, fp, #4
700119c4:	e8bd8800 	pop	{fp, pc}

700119c8 <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
700119c8:	e92d4800 	push	{fp, lr}
700119cc:	e28db004 	add	fp, sp, #4
700119d0:	e24dd028 	sub	sp, sp, #40	; 0x28
700119d4:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    if (node != NULL)
700119d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700119dc:	e3530000 	cmp	r3, #0
700119e0:	0a000db3 	beq	700150b4 <finsh_compile+0x36ec>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
700119e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700119e8:	e5933010 	ldr	r3, [r3, #16]
700119ec:	e3530000 	cmp	r3, #0
700119f0:	0a000003 	beq	70011a04 <finsh_compile+0x3c>
            finsh_compile(finsh_node_child(node));
700119f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700119f8:	e5933010 	ldr	r3, [r3, #16]
700119fc:	e1a00003 	mov	r0, r3
70011a00:	ebfffff0 	bl	700119c8 <finsh_compile>

        /* compile current node */
        switch (node->node_type)
70011a04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011a08:	e5d33000 	ldrb	r3, [r3]
70011a0c:	e2433001 	sub	r3, r3, #1
70011a10:	e353001a 	cmp	r3, #26
70011a14:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70011a18:	ea000d97 	b	7001507c <finsh_compile+0x36b4>
70011a1c:	70011a88 	.word	0x70011a88
70011a20:	70012320 	.word	0x70012320
70011a24:	70012388 	.word	0x70012388
70011a28:	70012388 	.word	0x70012388
70011a2c:	70012460 	.word	0x70012460
70011a30:	70012460 	.word	0x70012460
70011a34:	70012538 	.word	0x70012538
70011a38:	70012608 	.word	0x70012608
70011a3c:	700126d8 	.word	0x700126d8
70011a40:	700127a8 	.word	0x700127a8
70011a44:	70012878 	.word	0x70012878
70011a48:	70012948 	.word	0x70012948
70011a4c:	70012a18 	.word	0x70012a18
70011a50:	70012ae8 	.word	0x70012ae8
70011a54:	70012bb8 	.word	0x70012bb8
70011a58:	70012c88 	.word	0x70012c88
70011a5c:	70012d58 	.word	0x70012d58
70011a60:	70012e28 	.word	0x70012e28
70011a64:	70012ee4 	.word	0x70012ee4
70011a68:	7001507c 	.word	0x7001507c
70011a6c:	700131e0 	.word	0x700131e0
70011a70:	700137f4 	.word	0x700137f4
70011a74:	70013e08 	.word	0x70013e08
70011a78:	70014698 	.word	0x70014698
70011a7c:	70014fa4 	.word	0x70014fa4
70011a80:	70015088 	.word	0x70015088
70011a84:	70014f28 	.word	0x70014f28
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
70011a88:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011a8c:	e5d33002 	ldrb	r3, [r3, #2]
70011a90:	e2033004 	and	r3, r3, #4
70011a94:	e3530000 	cmp	r3, #0
70011a98:	0a000039 	beq	70011b84 <finsh_compile+0x1bc>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70011a9c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011aa0:	e3473002 	movt	r3, #28674	; 0x7002
70011aa4:	e5933000 	ldr	r3, [r3]
70011aa8:	e3a02024 	mov	r2, #36	; 0x24
70011aac:	e5c32000 	strb	r2, [r3]
70011ab0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ab4:	e3473002 	movt	r3, #28674	; 0x7002
70011ab8:	e5933000 	ldr	r3, [r3]
70011abc:	e2832001 	add	r2, r3, #1
70011ac0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ac4:	e3473002 	movt	r3, #28674	; 0x7002
70011ac8:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)node->id.syscall->func);
70011acc:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ad0:	e3473002 	movt	r3, #28674	; 0x7002
70011ad4:	e5933000 	ldr	r3, [r3]
70011ad8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70011adc:	e5922008 	ldr	r2, [r2, #8]
70011ae0:	e5922008 	ldr	r2, [r2, #8]
70011ae4:	e6ef2072 	uxtb	r2, r2
70011ae8:	e5c32000 	strb	r2, [r3]
70011aec:	e30b341c 	movw	r3, #46108	; 0xb41c
70011af0:	e3473002 	movt	r3, #28674	; 0x7002
70011af4:	e5933000 	ldr	r3, [r3]
70011af8:	e2833001 	add	r3, r3, #1
70011afc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70011b00:	e5922008 	ldr	r2, [r2, #8]
70011b04:	e5922008 	ldr	r2, [r2, #8]
70011b08:	e1a02422 	lsr	r2, r2, #8
70011b0c:	e6ef2072 	uxtb	r2, r2
70011b10:	e5c32000 	strb	r2, [r3]
70011b14:	e30b341c 	movw	r3, #46108	; 0xb41c
70011b18:	e3473002 	movt	r3, #28674	; 0x7002
70011b1c:	e5933000 	ldr	r3, [r3]
70011b20:	e2833002 	add	r3, r3, #2
70011b24:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70011b28:	e5922008 	ldr	r2, [r2, #8]
70011b2c:	e5922008 	ldr	r2, [r2, #8]
70011b30:	e1a02822 	lsr	r2, r2, #16
70011b34:	e6ef2072 	uxtb	r2, r2
70011b38:	e5c32000 	strb	r2, [r3]
70011b3c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011b40:	e3473002 	movt	r3, #28674	; 0x7002
70011b44:	e5933000 	ldr	r3, [r3]
70011b48:	e2833003 	add	r3, r3, #3
70011b4c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70011b50:	e5922008 	ldr	r2, [r2, #8]
70011b54:	e5922008 	ldr	r2, [r2, #8]
70011b58:	e1a02c22 	lsr	r2, r2, #24
70011b5c:	e6ef2072 	uxtb	r2, r2
70011b60:	e5c32000 	strb	r2, [r3]
70011b64:	e30b341c 	movw	r3, #46108	; 0xb41c
70011b68:	e3473002 	movt	r3, #28674	; 0x7002
70011b6c:	e5933000 	ldr	r3, [r3]
70011b70:	e2832004 	add	r2, r3, #4
70011b74:	e30b341c 	movw	r3, #46108	; 0xb41c
70011b78:	e3473002 	movt	r3, #28674	; 0x7002
70011b7c:	e5832000 	str	r2, [r3]
70011b80:	ea0001e5 	b	7001231c <finsh_compile+0x954>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
70011b84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011b88:	e5d33002 	ldrb	r3, [r3, #2]
70011b8c:	e2033002 	and	r3, r3, #2
70011b90:	e3530000 	cmp	r3, #0
70011b94:	0a0000f0 	beq	70011f5c <finsh_compile+0x594>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
70011b98:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011b9c:	e5933008 	ldr	r3, [r3, #8]
70011ba0:	e50b3010 	str	r3, [fp, #-16]
                    if (sysvar != NULL)
70011ba4:	e51b3010 	ldr	r3, [fp, #-16]
70011ba8:	e3530000 	cmp	r3, #0
70011bac:	0a0000e9 	beq	70011f58 <finsh_compile+0x590>
                    {
                        switch (sysvar->type)
70011bb0:	e51b3010 	ldr	r3, [fp, #-16]
70011bb4:	e5d33008 	ldrb	r3, [r3, #8]
70011bb8:	e2433003 	sub	r3, r3, #3
70011bbc:	e353000b 	cmp	r3, #11
70011bc0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70011bc4:	ea0001d4 	b	7001231c <finsh_compile+0x954>
70011bc8:	70011bf8 	.word	0x70011bf8
70011bcc:	70011bf8 	.word	0x70011bf8
70011bd0:	70011e38 	.word	0x70011e38
70011bd4:	70011d18 	.word	0x70011d18
70011bd8:	70011d18 	.word	0x70011d18
70011bdc:	70011e38 	.word	0x70011e38
70011be0:	70011e38 	.word	0x70011e38
70011be4:	70011e38 	.word	0x70011e38
70011be8:	70011e38 	.word	0x70011e38
70011bec:	70011e38 	.word	0x70011e38
70011bf0:	70011e38 	.word	0x70011e38
70011bf4:	70011e38 	.word	0x70011e38
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
70011bf8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011bfc:	e5d33002 	ldrb	r3, [r3, #2]
70011c00:	e2033008 	and	r3, r3, #8
70011c04:	e3530000 	cmp	r3, #0
70011c08:	0a00000c 	beq	70011c40 <finsh_compile+0x278>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
70011c0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c10:	e3473002 	movt	r3, #28674	; 0x7002
70011c14:	e5933000 	ldr	r3, [r3]
70011c18:	e3a02024 	mov	r2, #36	; 0x24
70011c1c:	e5c32000 	strb	r2, [r3]
70011c20:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c24:	e3473002 	movt	r3, #28674	; 0x7002
70011c28:	e5933000 	ldr	r3, [r3]
70011c2c:	e2832001 	add	r2, r3, #1
70011c30:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c34:	e3473002 	movt	r3, #28674	; 0x7002
70011c38:	e5832000 	str	r2, [r3]
70011c3c:	ea00000b 	b	70011c70 <finsh_compile+0x2a8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
70011c40:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c44:	e3473002 	movt	r3, #28674	; 0x7002
70011c48:	e5933000 	ldr	r3, [r3]
70011c4c:	e3a02025 	mov	r2, #37	; 0x25
70011c50:	e5c32000 	strb	r2, [r3]
70011c54:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c58:	e3473002 	movt	r3, #28674	; 0x7002
70011c5c:	e5933000 	ldr	r3, [r3]
70011c60:	e2832001 	add	r2, r3, #1
70011c64:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c68:	e3473002 	movt	r3, #28674	; 0x7002
70011c6c:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
70011c70:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c74:	e3473002 	movt	r3, #28674	; 0x7002
70011c78:	e5933000 	ldr	r3, [r3]
70011c7c:	e51b2010 	ldr	r2, [fp, #-16]
70011c80:	e592200c 	ldr	r2, [r2, #12]
70011c84:	e6ef2072 	uxtb	r2, r2
70011c88:	e5c32000 	strb	r2, [r3]
70011c8c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011c90:	e3473002 	movt	r3, #28674	; 0x7002
70011c94:	e5933000 	ldr	r3, [r3]
70011c98:	e2833001 	add	r3, r3, #1
70011c9c:	e51b2010 	ldr	r2, [fp, #-16]
70011ca0:	e592200c 	ldr	r2, [r2, #12]
70011ca4:	e1a02422 	lsr	r2, r2, #8
70011ca8:	e6ef2072 	uxtb	r2, r2
70011cac:	e5c32000 	strb	r2, [r3]
70011cb0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011cb4:	e3473002 	movt	r3, #28674	; 0x7002
70011cb8:	e5933000 	ldr	r3, [r3]
70011cbc:	e2833002 	add	r3, r3, #2
70011cc0:	e51b2010 	ldr	r2, [fp, #-16]
70011cc4:	e592200c 	ldr	r2, [r2, #12]
70011cc8:	e1a02822 	lsr	r2, r2, #16
70011ccc:	e6ef2072 	uxtb	r2, r2
70011cd0:	e5c32000 	strb	r2, [r3]
70011cd4:	e30b341c 	movw	r3, #46108	; 0xb41c
70011cd8:	e3473002 	movt	r3, #28674	; 0x7002
70011cdc:	e5933000 	ldr	r3, [r3]
70011ce0:	e2833003 	add	r3, r3, #3
70011ce4:	e51b2010 	ldr	r2, [fp, #-16]
70011ce8:	e592200c 	ldr	r2, [r2, #12]
70011cec:	e1a02c22 	lsr	r2, r2, #24
70011cf0:	e6ef2072 	uxtb	r2, r2
70011cf4:	e5c32000 	strb	r2, [r3]
70011cf8:	e30b341c 	movw	r3, #46108	; 0xb41c
70011cfc:	e3473002 	movt	r3, #28674	; 0x7002
70011d00:	e5933000 	ldr	r3, [r3]
70011d04:	e2832004 	add	r2, r3, #4
70011d08:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d0c:	e3473002 	movt	r3, #28674	; 0x7002
70011d10:	e5832000 	str	r2, [r3]
                            break;
70011d14:	ea00008f 	b	70011f58 <finsh_compile+0x590>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
70011d18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011d1c:	e5d33002 	ldrb	r3, [r3, #2]
70011d20:	e2033008 	and	r3, r3, #8
70011d24:	e3530000 	cmp	r3, #0
70011d28:	0a00000c 	beq	70011d60 <finsh_compile+0x398>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
70011d2c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d30:	e3473002 	movt	r3, #28674	; 0x7002
70011d34:	e5933000 	ldr	r3, [r3]
70011d38:	e3a02024 	mov	r2, #36	; 0x24
70011d3c:	e5c32000 	strb	r2, [r3]
70011d40:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d44:	e3473002 	movt	r3, #28674	; 0x7002
70011d48:	e5933000 	ldr	r3, [r3]
70011d4c:	e2832001 	add	r2, r3, #1
70011d50:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d54:	e3473002 	movt	r3, #28674	; 0x7002
70011d58:	e5832000 	str	r2, [r3]
70011d5c:	ea00000b 	b	70011d90 <finsh_compile+0x3c8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
70011d60:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d64:	e3473002 	movt	r3, #28674	; 0x7002
70011d68:	e5933000 	ldr	r3, [r3]
70011d6c:	e3a02026 	mov	r2, #38	; 0x26
70011d70:	e5c32000 	strb	r2, [r3]
70011d74:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d78:	e3473002 	movt	r3, #28674	; 0x7002
70011d7c:	e5933000 	ldr	r3, [r3]
70011d80:	e2832001 	add	r2, r3, #1
70011d84:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d88:	e3473002 	movt	r3, #28674	; 0x7002
70011d8c:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
70011d90:	e30b341c 	movw	r3, #46108	; 0xb41c
70011d94:	e3473002 	movt	r3, #28674	; 0x7002
70011d98:	e5933000 	ldr	r3, [r3]
70011d9c:	e51b2010 	ldr	r2, [fp, #-16]
70011da0:	e592200c 	ldr	r2, [r2, #12]
70011da4:	e6ef2072 	uxtb	r2, r2
70011da8:	e5c32000 	strb	r2, [r3]
70011dac:	e30b341c 	movw	r3, #46108	; 0xb41c
70011db0:	e3473002 	movt	r3, #28674	; 0x7002
70011db4:	e5933000 	ldr	r3, [r3]
70011db8:	e2833001 	add	r3, r3, #1
70011dbc:	e51b2010 	ldr	r2, [fp, #-16]
70011dc0:	e592200c 	ldr	r2, [r2, #12]
70011dc4:	e1a02422 	lsr	r2, r2, #8
70011dc8:	e6ef2072 	uxtb	r2, r2
70011dcc:	e5c32000 	strb	r2, [r3]
70011dd0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011dd4:	e3473002 	movt	r3, #28674	; 0x7002
70011dd8:	e5933000 	ldr	r3, [r3]
70011ddc:	e2833002 	add	r3, r3, #2
70011de0:	e51b2010 	ldr	r2, [fp, #-16]
70011de4:	e592200c 	ldr	r2, [r2, #12]
70011de8:	e1a02822 	lsr	r2, r2, #16
70011dec:	e6ef2072 	uxtb	r2, r2
70011df0:	e5c32000 	strb	r2, [r3]
70011df4:	e30b341c 	movw	r3, #46108	; 0xb41c
70011df8:	e3473002 	movt	r3, #28674	; 0x7002
70011dfc:	e5933000 	ldr	r3, [r3]
70011e00:	e2833003 	add	r3, r3, #3
70011e04:	e51b2010 	ldr	r2, [fp, #-16]
70011e08:	e592200c 	ldr	r2, [r2, #12]
70011e0c:	e1a02c22 	lsr	r2, r2, #24
70011e10:	e6ef2072 	uxtb	r2, r2
70011e14:	e5c32000 	strb	r2, [r3]
70011e18:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e1c:	e3473002 	movt	r3, #28674	; 0x7002
70011e20:	e5933000 	ldr	r3, [r3]
70011e24:	e2832004 	add	r2, r3, #4
70011e28:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e2c:	e3473002 	movt	r3, #28674	; 0x7002
70011e30:	e5832000 	str	r2, [r3]
                            break;
70011e34:	ea000047 	b	70011f58 <finsh_compile+0x590>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
70011e38:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011e3c:	e5d33002 	ldrb	r3, [r3, #2]
70011e40:	e2033008 	and	r3, r3, #8
70011e44:	e3530000 	cmp	r3, #0
70011e48:	0a00000c 	beq	70011e80 <finsh_compile+0x4b8>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
70011e4c:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e50:	e3473002 	movt	r3, #28674	; 0x7002
70011e54:	e5933000 	ldr	r3, [r3]
70011e58:	e3a02024 	mov	r2, #36	; 0x24
70011e5c:	e5c32000 	strb	r2, [r3]
70011e60:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e64:	e3473002 	movt	r3, #28674	; 0x7002
70011e68:	e5933000 	ldr	r3, [r3]
70011e6c:	e2832001 	add	r2, r3, #1
70011e70:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e74:	e3473002 	movt	r3, #28674	; 0x7002
70011e78:	e5832000 	str	r2, [r3]
70011e7c:	ea00000b 	b	70011eb0 <finsh_compile+0x4e8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
70011e80:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e84:	e3473002 	movt	r3, #28674	; 0x7002
70011e88:	e5933000 	ldr	r3, [r3]
70011e8c:	e3a02027 	mov	r2, #39	; 0x27
70011e90:	e5c32000 	strb	r2, [r3]
70011e94:	e30b341c 	movw	r3, #46108	; 0xb41c
70011e98:	e3473002 	movt	r3, #28674	; 0x7002
70011e9c:	e5933000 	ldr	r3, [r3]
70011ea0:	e2832001 	add	r2, r3, #1
70011ea4:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ea8:	e3473002 	movt	r3, #28674	; 0x7002
70011eac:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
70011eb0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011eb4:	e3473002 	movt	r3, #28674	; 0x7002
70011eb8:	e5933000 	ldr	r3, [r3]
70011ebc:	e51b2010 	ldr	r2, [fp, #-16]
70011ec0:	e592200c 	ldr	r2, [r2, #12]
70011ec4:	e6ef2072 	uxtb	r2, r2
70011ec8:	e5c32000 	strb	r2, [r3]
70011ecc:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ed0:	e3473002 	movt	r3, #28674	; 0x7002
70011ed4:	e5933000 	ldr	r3, [r3]
70011ed8:	e2833001 	add	r3, r3, #1
70011edc:	e51b2010 	ldr	r2, [fp, #-16]
70011ee0:	e592200c 	ldr	r2, [r2, #12]
70011ee4:	e1a02422 	lsr	r2, r2, #8
70011ee8:	e6ef2072 	uxtb	r2, r2
70011eec:	e5c32000 	strb	r2, [r3]
70011ef0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ef4:	e3473002 	movt	r3, #28674	; 0x7002
70011ef8:	e5933000 	ldr	r3, [r3]
70011efc:	e2833002 	add	r3, r3, #2
70011f00:	e51b2010 	ldr	r2, [fp, #-16]
70011f04:	e592200c 	ldr	r2, [r2, #12]
70011f08:	e1a02822 	lsr	r2, r2, #16
70011f0c:	e6ef2072 	uxtb	r2, r2
70011f10:	e5c32000 	strb	r2, [r3]
70011f14:	e30b341c 	movw	r3, #46108	; 0xb41c
70011f18:	e3473002 	movt	r3, #28674	; 0x7002
70011f1c:	e5933000 	ldr	r3, [r3]
70011f20:	e2833003 	add	r3, r3, #3
70011f24:	e51b2010 	ldr	r2, [fp, #-16]
70011f28:	e592200c 	ldr	r2, [r2, #12]
70011f2c:	e1a02c22 	lsr	r2, r2, #24
70011f30:	e6ef2072 	uxtb	r2, r2
70011f34:	e5c32000 	strb	r2, [r3]
70011f38:	e30b341c 	movw	r3, #46108	; 0xb41c
70011f3c:	e3473002 	movt	r3, #28674	; 0x7002
70011f40:	e5933000 	ldr	r3, [r3]
70011f44:	e2832004 	add	r2, r3, #4
70011f48:	e30b341c 	movw	r3, #46108	; 0xb41c
70011f4c:	e3473002 	movt	r3, #28674	; 0x7002
70011f50:	e5832000 	str	r2, [r3]
                            break;
70011f54:	e1a00000 	nop			; (mov r0, r0)
70011f58:	ea0000ef 	b	7001231c <finsh_compile+0x954>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
70011f5c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011f60:	e5933008 	ldr	r3, [r3, #8]
70011f64:	e50b3014 	str	r3, [fp, #-20]
                    if (var != NULL)
70011f68:	e51b3014 	ldr	r3, [fp, #-20]
70011f6c:	e3530000 	cmp	r3, #0
70011f70:	0a0000e9 	beq	7001231c <finsh_compile+0x954>
                    {
                        switch (var->type)
70011f74:	e51b3014 	ldr	r3, [fp, #-20]
70011f78:	e5d33011 	ldrb	r3, [r3, #17]
70011f7c:	e2433003 	sub	r3, r3, #3
70011f80:	e353000b 	cmp	r3, #11
70011f84:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70011f88:	ea000c40 	b	70015090 <finsh_compile+0x36c8>
70011f8c:	70011fbc 	.word	0x70011fbc
70011f90:	70011fbc 	.word	0x70011fbc
70011f94:	700121fc 	.word	0x700121fc
70011f98:	700120dc 	.word	0x700120dc
70011f9c:	700120dc 	.word	0x700120dc
70011fa0:	700121fc 	.word	0x700121fc
70011fa4:	700121fc 	.word	0x700121fc
70011fa8:	700121fc 	.word	0x700121fc
70011fac:	700121fc 	.word	0x700121fc
70011fb0:	700121fc 	.word	0x700121fc
70011fb4:	700121fc 	.word	0x700121fc
70011fb8:	700121fc 	.word	0x700121fc
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
70011fbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70011fc0:	e5d33002 	ldrb	r3, [r3, #2]
70011fc4:	e2033008 	and	r3, r3, #8
70011fc8:	e3530000 	cmp	r3, #0
70011fcc:	0a00000c 	beq	70012004 <finsh_compile+0x63c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
70011fd0:	e30b341c 	movw	r3, #46108	; 0xb41c
70011fd4:	e3473002 	movt	r3, #28674	; 0x7002
70011fd8:	e5933000 	ldr	r3, [r3]
70011fdc:	e3a02024 	mov	r2, #36	; 0x24
70011fe0:	e5c32000 	strb	r2, [r3]
70011fe4:	e30b341c 	movw	r3, #46108	; 0xb41c
70011fe8:	e3473002 	movt	r3, #28674	; 0x7002
70011fec:	e5933000 	ldr	r3, [r3]
70011ff0:	e2832001 	add	r2, r3, #1
70011ff4:	e30b341c 	movw	r3, #46108	; 0xb41c
70011ff8:	e3473002 	movt	r3, #28674	; 0x7002
70011ffc:	e5832000 	str	r2, [r3]
70012000:	ea00000b 	b	70012034 <finsh_compile+0x66c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
70012004:	e30b341c 	movw	r3, #46108	; 0xb41c
70012008:	e3473002 	movt	r3, #28674	; 0x7002
7001200c:	e5933000 	ldr	r3, [r3]
70012010:	e3a02025 	mov	r2, #37	; 0x25
70012014:	e5c32000 	strb	r2, [r3]
70012018:	e30b341c 	movw	r3, #46108	; 0xb41c
7001201c:	e3473002 	movt	r3, #28674	; 0x7002
70012020:	e5933000 	ldr	r3, [r3]
70012024:	e2832001 	add	r2, r3, #1
70012028:	e30b341c 	movw	r3, #46108	; 0xb41c
7001202c:	e3473002 	movt	r3, #28674	; 0x7002
70012030:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
70012034:	e30b341c 	movw	r3, #46108	; 0xb41c
70012038:	e3473002 	movt	r3, #28674	; 0x7002
7001203c:	e5933000 	ldr	r3, [r3]
70012040:	e51b2014 	ldr	r2, [fp, #-20]
70012044:	e2822014 	add	r2, r2, #20
70012048:	e6ef2072 	uxtb	r2, r2
7001204c:	e5c32000 	strb	r2, [r3]
70012050:	e30b341c 	movw	r3, #46108	; 0xb41c
70012054:	e3473002 	movt	r3, #28674	; 0x7002
70012058:	e5933000 	ldr	r3, [r3]
7001205c:	e2833001 	add	r3, r3, #1
70012060:	e51b2014 	ldr	r2, [fp, #-20]
70012064:	e2822014 	add	r2, r2, #20
70012068:	e1a02422 	lsr	r2, r2, #8
7001206c:	e6ef2072 	uxtb	r2, r2
70012070:	e5c32000 	strb	r2, [r3]
70012074:	e30b341c 	movw	r3, #46108	; 0xb41c
70012078:	e3473002 	movt	r3, #28674	; 0x7002
7001207c:	e5933000 	ldr	r3, [r3]
70012080:	e2833002 	add	r3, r3, #2
70012084:	e51b2014 	ldr	r2, [fp, #-20]
70012088:	e2822014 	add	r2, r2, #20
7001208c:	e1a02822 	lsr	r2, r2, #16
70012090:	e6ef2072 	uxtb	r2, r2
70012094:	e5c32000 	strb	r2, [r3]
70012098:	e30b341c 	movw	r3, #46108	; 0xb41c
7001209c:	e3473002 	movt	r3, #28674	; 0x7002
700120a0:	e5933000 	ldr	r3, [r3]
700120a4:	e2833003 	add	r3, r3, #3
700120a8:	e51b2014 	ldr	r2, [fp, #-20]
700120ac:	e2822014 	add	r2, r2, #20
700120b0:	e1a02c22 	lsr	r2, r2, #24
700120b4:	e6ef2072 	uxtb	r2, r2
700120b8:	e5c32000 	strb	r2, [r3]
700120bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700120c0:	e3473002 	movt	r3, #28674	; 0x7002
700120c4:	e5933000 	ldr	r3, [r3]
700120c8:	e2832004 	add	r2, r3, #4
700120cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700120d0:	e3473002 	movt	r3, #28674	; 0x7002
700120d4:	e5832000 	str	r2, [r3]
                            break;
700120d8:	ea00008f 	b	7001231c <finsh_compile+0x954>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
700120dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700120e0:	e5d33002 	ldrb	r3, [r3, #2]
700120e4:	e2033008 	and	r3, r3, #8
700120e8:	e3530000 	cmp	r3, #0
700120ec:	0a00000c 	beq	70012124 <finsh_compile+0x75c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
700120f0:	e30b341c 	movw	r3, #46108	; 0xb41c
700120f4:	e3473002 	movt	r3, #28674	; 0x7002
700120f8:	e5933000 	ldr	r3, [r3]
700120fc:	e3a02024 	mov	r2, #36	; 0x24
70012100:	e5c32000 	strb	r2, [r3]
70012104:	e30b341c 	movw	r3, #46108	; 0xb41c
70012108:	e3473002 	movt	r3, #28674	; 0x7002
7001210c:	e5933000 	ldr	r3, [r3]
70012110:	e2832001 	add	r2, r3, #1
70012114:	e30b341c 	movw	r3, #46108	; 0xb41c
70012118:	e3473002 	movt	r3, #28674	; 0x7002
7001211c:	e5832000 	str	r2, [r3]
70012120:	ea00000b 	b	70012154 <finsh_compile+0x78c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
70012124:	e30b341c 	movw	r3, #46108	; 0xb41c
70012128:	e3473002 	movt	r3, #28674	; 0x7002
7001212c:	e5933000 	ldr	r3, [r3]
70012130:	e3a02026 	mov	r2, #38	; 0x26
70012134:	e5c32000 	strb	r2, [r3]
70012138:	e30b341c 	movw	r3, #46108	; 0xb41c
7001213c:	e3473002 	movt	r3, #28674	; 0x7002
70012140:	e5933000 	ldr	r3, [r3]
70012144:	e2832001 	add	r2, r3, #1
70012148:	e30b341c 	movw	r3, #46108	; 0xb41c
7001214c:	e3473002 	movt	r3, #28674	; 0x7002
70012150:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
70012154:	e30b341c 	movw	r3, #46108	; 0xb41c
70012158:	e3473002 	movt	r3, #28674	; 0x7002
7001215c:	e5933000 	ldr	r3, [r3]
70012160:	e51b2014 	ldr	r2, [fp, #-20]
70012164:	e2822014 	add	r2, r2, #20
70012168:	e6ef2072 	uxtb	r2, r2
7001216c:	e5c32000 	strb	r2, [r3]
70012170:	e30b341c 	movw	r3, #46108	; 0xb41c
70012174:	e3473002 	movt	r3, #28674	; 0x7002
70012178:	e5933000 	ldr	r3, [r3]
7001217c:	e2833001 	add	r3, r3, #1
70012180:	e51b2014 	ldr	r2, [fp, #-20]
70012184:	e2822014 	add	r2, r2, #20
70012188:	e1a02422 	lsr	r2, r2, #8
7001218c:	e6ef2072 	uxtb	r2, r2
70012190:	e5c32000 	strb	r2, [r3]
70012194:	e30b341c 	movw	r3, #46108	; 0xb41c
70012198:	e3473002 	movt	r3, #28674	; 0x7002
7001219c:	e5933000 	ldr	r3, [r3]
700121a0:	e2833002 	add	r3, r3, #2
700121a4:	e51b2014 	ldr	r2, [fp, #-20]
700121a8:	e2822014 	add	r2, r2, #20
700121ac:	e1a02822 	lsr	r2, r2, #16
700121b0:	e6ef2072 	uxtb	r2, r2
700121b4:	e5c32000 	strb	r2, [r3]
700121b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700121bc:	e3473002 	movt	r3, #28674	; 0x7002
700121c0:	e5933000 	ldr	r3, [r3]
700121c4:	e2833003 	add	r3, r3, #3
700121c8:	e51b2014 	ldr	r2, [fp, #-20]
700121cc:	e2822014 	add	r2, r2, #20
700121d0:	e1a02c22 	lsr	r2, r2, #24
700121d4:	e6ef2072 	uxtb	r2, r2
700121d8:	e5c32000 	strb	r2, [r3]
700121dc:	e30b341c 	movw	r3, #46108	; 0xb41c
700121e0:	e3473002 	movt	r3, #28674	; 0x7002
700121e4:	e5933000 	ldr	r3, [r3]
700121e8:	e2832004 	add	r2, r3, #4
700121ec:	e30b341c 	movw	r3, #46108	; 0xb41c
700121f0:	e3473002 	movt	r3, #28674	; 0x7002
700121f4:	e5832000 	str	r2, [r3]
                            break;
700121f8:	ea000047 	b	7001231c <finsh_compile+0x954>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
700121fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012200:	e5d33002 	ldrb	r3, [r3, #2]
70012204:	e2033008 	and	r3, r3, #8
70012208:	e3530000 	cmp	r3, #0
7001220c:	0a00000c 	beq	70012244 <finsh_compile+0x87c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
70012210:	e30b341c 	movw	r3, #46108	; 0xb41c
70012214:	e3473002 	movt	r3, #28674	; 0x7002
70012218:	e5933000 	ldr	r3, [r3]
7001221c:	e3a02024 	mov	r2, #36	; 0x24
70012220:	e5c32000 	strb	r2, [r3]
70012224:	e30b341c 	movw	r3, #46108	; 0xb41c
70012228:	e3473002 	movt	r3, #28674	; 0x7002
7001222c:	e5933000 	ldr	r3, [r3]
70012230:	e2832001 	add	r2, r3, #1
70012234:	e30b341c 	movw	r3, #46108	; 0xb41c
70012238:	e3473002 	movt	r3, #28674	; 0x7002
7001223c:	e5832000 	str	r2, [r3]
70012240:	ea00000b 	b	70012274 <finsh_compile+0x8ac>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
70012244:	e30b341c 	movw	r3, #46108	; 0xb41c
70012248:	e3473002 	movt	r3, #28674	; 0x7002
7001224c:	e5933000 	ldr	r3, [r3]
70012250:	e3a02027 	mov	r2, #39	; 0x27
70012254:	e5c32000 	strb	r2, [r3]
70012258:	e30b341c 	movw	r3, #46108	; 0xb41c
7001225c:	e3473002 	movt	r3, #28674	; 0x7002
70012260:	e5933000 	ldr	r3, [r3]
70012264:	e2832001 	add	r2, r3, #1
70012268:	e30b341c 	movw	r3, #46108	; 0xb41c
7001226c:	e3473002 	movt	r3, #28674	; 0x7002
70012270:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
70012274:	e30b341c 	movw	r3, #46108	; 0xb41c
70012278:	e3473002 	movt	r3, #28674	; 0x7002
7001227c:	e5933000 	ldr	r3, [r3]
70012280:	e51b2014 	ldr	r2, [fp, #-20]
70012284:	e2822014 	add	r2, r2, #20
70012288:	e6ef2072 	uxtb	r2, r2
7001228c:	e5c32000 	strb	r2, [r3]
70012290:	e30b341c 	movw	r3, #46108	; 0xb41c
70012294:	e3473002 	movt	r3, #28674	; 0x7002
70012298:	e5933000 	ldr	r3, [r3]
7001229c:	e2833001 	add	r3, r3, #1
700122a0:	e51b2014 	ldr	r2, [fp, #-20]
700122a4:	e2822014 	add	r2, r2, #20
700122a8:	e1a02422 	lsr	r2, r2, #8
700122ac:	e6ef2072 	uxtb	r2, r2
700122b0:	e5c32000 	strb	r2, [r3]
700122b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700122b8:	e3473002 	movt	r3, #28674	; 0x7002
700122bc:	e5933000 	ldr	r3, [r3]
700122c0:	e2833002 	add	r3, r3, #2
700122c4:	e51b2014 	ldr	r2, [fp, #-20]
700122c8:	e2822014 	add	r2, r2, #20
700122cc:	e1a02822 	lsr	r2, r2, #16
700122d0:	e6ef2072 	uxtb	r2, r2
700122d4:	e5c32000 	strb	r2, [r3]
700122d8:	e30b341c 	movw	r3, #46108	; 0xb41c
700122dc:	e3473002 	movt	r3, #28674	; 0x7002
700122e0:	e5933000 	ldr	r3, [r3]
700122e4:	e2833003 	add	r3, r3, #3
700122e8:	e51b2014 	ldr	r2, [fp, #-20]
700122ec:	e2822014 	add	r2, r2, #20
700122f0:	e1a02c22 	lsr	r2, r2, #24
700122f4:	e6ef2072 	uxtb	r2, r2
700122f8:	e5c32000 	strb	r2, [r3]
700122fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012300:	e3473002 	movt	r3, #28674	; 0x7002
70012304:	e5933000 	ldr	r3, [r3]
70012308:	e2832004 	add	r2, r3, #4
7001230c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012310:	e3473002 	movt	r3, #28674	; 0x7002
70012314:	e5832000 	str	r2, [r3]
                            break;
70012318:	e1a00000 	nop			; (mov r0, r0)
                        }
                    }
                }
            }
            break;
7001231c:	ea000b5b 	b	70015090 <finsh_compile+0x36c8>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
70012320:	e30b341c 	movw	r3, #46108	; 0xb41c
70012324:	e3473002 	movt	r3, #28674	; 0x7002
70012328:	e5933000 	ldr	r3, [r3]
7001232c:	e3a02022 	mov	r2, #34	; 0x22
70012330:	e5c32000 	strb	r2, [r3]
70012334:	e30b341c 	movw	r3, #46108	; 0xb41c
70012338:	e3473002 	movt	r3, #28674	; 0x7002
7001233c:	e5933000 	ldr	r3, [r3]
70012340:	e2832001 	add	r2, r3, #1
70012344:	e30b341c 	movw	r3, #46108	; 0xb41c
70012348:	e3473002 	movt	r3, #28674	; 0x7002
7001234c:	e5832000 	str	r2, [r3]
            finsh_code_byte(node->value.char_value);
70012350:	e30b341c 	movw	r3, #46108	; 0xb41c
70012354:	e3473002 	movt	r3, #28674	; 0x7002
70012358:	e5933000 	ldr	r3, [r3]
7001235c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70012360:	e5d22004 	ldrb	r2, [r2, #4]
70012364:	e5c32000 	strb	r2, [r3]
70012368:	e30b341c 	movw	r3, #46108	; 0xb41c
7001236c:	e3473002 	movt	r3, #28674	; 0x7002
70012370:	e5933000 	ldr	r3, [r3]
70012374:	e2832001 	add	r2, r3, #1
70012378:	e30b341c 	movw	r3, #46108	; 0xb41c
7001237c:	e3473002 	movt	r3, #28674	; 0x7002
70012380:	e5832000 	str	r2, [r3]
            break;
70012384:	ea000b42 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
70012388:	e30b341c 	movw	r3, #46108	; 0xb41c
7001238c:	e3473002 	movt	r3, #28674	; 0x7002
70012390:	e5933000 	ldr	r3, [r3]
70012394:	e3a02024 	mov	r2, #36	; 0x24
70012398:	e5c32000 	strb	r2, [r3]
7001239c:	e30b341c 	movw	r3, #46108	; 0xb41c
700123a0:	e3473002 	movt	r3, #28674	; 0x7002
700123a4:	e5933000 	ldr	r3, [r3]
700123a8:	e2832001 	add	r2, r3, #1
700123ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700123b0:	e3473002 	movt	r3, #28674	; 0x7002
700123b4:	e5832000 	str	r2, [r3]
            finsh_code_dword(node->value.long_value);
700123b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700123bc:	e3473002 	movt	r3, #28674	; 0x7002
700123c0:	e5933000 	ldr	r3, [r3]
700123c4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700123c8:	e5922004 	ldr	r2, [r2, #4]
700123cc:	e6ef2072 	uxtb	r2, r2
700123d0:	e5c32000 	strb	r2, [r3]
700123d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700123d8:	e3473002 	movt	r3, #28674	; 0x7002
700123dc:	e5933000 	ldr	r3, [r3]
700123e0:	e2833001 	add	r3, r3, #1
700123e4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700123e8:	e5922004 	ldr	r2, [r2, #4]
700123ec:	e1a02422 	lsr	r2, r2, #8
700123f0:	e6ef2072 	uxtb	r2, r2
700123f4:	e5c32000 	strb	r2, [r3]
700123f8:	e30b341c 	movw	r3, #46108	; 0xb41c
700123fc:	e3473002 	movt	r3, #28674	; 0x7002
70012400:	e5933000 	ldr	r3, [r3]
70012404:	e2833002 	add	r3, r3, #2
70012408:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
7001240c:	e5922004 	ldr	r2, [r2, #4]
70012410:	e1a02822 	lsr	r2, r2, #16
70012414:	e6ef2072 	uxtb	r2, r2
70012418:	e5c32000 	strb	r2, [r3]
7001241c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012420:	e3473002 	movt	r3, #28674	; 0x7002
70012424:	e5933000 	ldr	r3, [r3]
70012428:	e2833003 	add	r3, r3, #3
7001242c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70012430:	e5922004 	ldr	r2, [r2, #4]
70012434:	e1a02c22 	lsr	r2, r2, #24
70012438:	e6ef2072 	uxtb	r2, r2
7001243c:	e5c32000 	strb	r2, [r3]
70012440:	e30b341c 	movw	r3, #46108	; 0xb41c
70012444:	e3473002 	movt	r3, #28674	; 0x7002
70012448:	e5933000 	ldr	r3, [r3]
7001244c:	e2832004 	add	r2, r3, #4
70012450:	e30b341c 	movw	r3, #46108	; 0xb41c
70012454:	e3473002 	movt	r3, #28674	; 0x7002
70012458:	e5832000 	str	r2, [r3]
            break;
7001245c:	ea000b0c 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
70012460:	e30b341c 	movw	r3, #46108	; 0xb41c
70012464:	e3473002 	movt	r3, #28674	; 0x7002
70012468:	e5933000 	ldr	r3, [r3]
7001246c:	e3a02024 	mov	r2, #36	; 0x24
70012470:	e5c32000 	strb	r2, [r3]
70012474:	e30b341c 	movw	r3, #46108	; 0xb41c
70012478:	e3473002 	movt	r3, #28674	; 0x7002
7001247c:	e5933000 	ldr	r3, [r3]
70012480:	e2832001 	add	r2, r3, #1
70012484:	e30b341c 	movw	r3, #46108	; 0xb41c
70012488:	e3473002 	movt	r3, #28674	; 0x7002
7001248c:	e5832000 	str	r2, [r3]
            finsh_code_dword((u_long)node->value.ptr);
70012490:	e30b341c 	movw	r3, #46108	; 0xb41c
70012494:	e3473002 	movt	r3, #28674	; 0x7002
70012498:	e5933000 	ldr	r3, [r3]
7001249c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700124a0:	e5922004 	ldr	r2, [r2, #4]
700124a4:	e6ef2072 	uxtb	r2, r2
700124a8:	e5c32000 	strb	r2, [r3]
700124ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700124b0:	e3473002 	movt	r3, #28674	; 0x7002
700124b4:	e5933000 	ldr	r3, [r3]
700124b8:	e2833001 	add	r3, r3, #1
700124bc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700124c0:	e5922004 	ldr	r2, [r2, #4]
700124c4:	e1a02422 	lsr	r2, r2, #8
700124c8:	e6ef2072 	uxtb	r2, r2
700124cc:	e5c32000 	strb	r2, [r3]
700124d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700124d4:	e3473002 	movt	r3, #28674	; 0x7002
700124d8:	e5933000 	ldr	r3, [r3]
700124dc:	e2833002 	add	r3, r3, #2
700124e0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
700124e4:	e5922004 	ldr	r2, [r2, #4]
700124e8:	e1a02822 	lsr	r2, r2, #16
700124ec:	e6ef2072 	uxtb	r2, r2
700124f0:	e5c32000 	strb	r2, [r3]
700124f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700124f8:	e3473002 	movt	r3, #28674	; 0x7002
700124fc:	e5933000 	ldr	r3, [r3]
70012500:	e2833003 	add	r3, r3, #3
70012504:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70012508:	e5922004 	ldr	r2, [r2, #4]
7001250c:	e1a02c22 	lsr	r2, r2, #24
70012510:	e6ef2072 	uxtb	r2, r2
70012514:	e5c32000 	strb	r2, [r3]
70012518:	e30b341c 	movw	r3, #46108	; 0xb41c
7001251c:	e3473002 	movt	r3, #28674	; 0x7002
70012520:	e5933000 	ldr	r3, [r3]
70012524:	e2832004 	add	r2, r3, #4
70012528:	e30b341c 	movw	r3, #46108	; 0xb41c
7001252c:	e3473002 	movt	r3, #28674	; 0x7002
70012530:	e5832000 	str	r2, [r3]
            break;
70012534:	ea000ad6 	b	70015094 <finsh_compile+0x36cc>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
70012538:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001253c:	e5d33001 	ldrb	r3, [r3, #1]
70012540:	e3530001 	cmp	r3, #1
70012544:	1a00000c 	bne	7001257c <finsh_compile+0xbb4>
70012548:	e30b341c 	movw	r3, #46108	; 0xb41c
7001254c:	e3473002 	movt	r3, #28674	; 0x7002
70012550:	e5933000 	ldr	r3, [r3]
70012554:	e3a02001 	mov	r2, #1
70012558:	e5c32000 	strb	r2, [r3]
7001255c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012560:	e3473002 	movt	r3, #28674	; 0x7002
70012564:	e5933000 	ldr	r3, [r3]
70012568:	e2832001 	add	r2, r3, #1
7001256c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012570:	e3473002 	movt	r3, #28674	; 0x7002
70012574:	e5832000 	str	r2, [r3]
70012578:	ea000021 	b	70012604 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
7001257c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012580:	e5d33001 	ldrb	r3, [r3, #1]
70012584:	e3530002 	cmp	r3, #2
70012588:	1a00000c 	bne	700125c0 <finsh_compile+0xbf8>
7001258c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012590:	e3473002 	movt	r3, #28674	; 0x7002
70012594:	e5933000 	ldr	r3, [r3]
70012598:	e3a02002 	mov	r2, #2
7001259c:	e5c32000 	strb	r2, [r3]
700125a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700125a4:	e3473002 	movt	r3, #28674	; 0x7002
700125a8:	e5933000 	ldr	r3, [r3]
700125ac:	e2832001 	add	r2, r3, #1
700125b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700125b4:	e3473002 	movt	r3, #28674	; 0x7002
700125b8:	e5832000 	str	r2, [r3]
700125bc:	ea000010 	b	70012604 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
700125c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700125c4:	e5d33001 	ldrb	r3, [r3, #1]
700125c8:	e3530003 	cmp	r3, #3
700125cc:	1a00000c 	bne	70012604 <finsh_compile+0xc3c>
700125d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700125d4:	e3473002 	movt	r3, #28674	; 0x7002
700125d8:	e5933000 	ldr	r3, [r3]
700125dc:	e3a02003 	mov	r2, #3
700125e0:	e5c32000 	strb	r2, [r3]
700125e4:	e30b341c 	movw	r3, #46108	; 0xb41c
700125e8:	e3473002 	movt	r3, #28674	; 0x7002
700125ec:	e5933000 	ldr	r3, [r3]
700125f0:	e2832001 	add	r2, r3, #1
700125f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700125f8:	e3473002 	movt	r3, #28674	; 0x7002
700125fc:	e5832000 	str	r2, [r3]
            break;
70012600:	ea000aa3 	b	70015094 <finsh_compile+0x36cc>
70012604:	ea000aa2 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
70012608:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001260c:	e5d33001 	ldrb	r3, [r3, #1]
70012610:	e3530001 	cmp	r3, #1
70012614:	1a00000c 	bne	7001264c <finsh_compile+0xc84>
70012618:	e30b341c 	movw	r3, #46108	; 0xb41c
7001261c:	e3473002 	movt	r3, #28674	; 0x7002
70012620:	e5933000 	ldr	r3, [r3]
70012624:	e3a02004 	mov	r2, #4
70012628:	e5c32000 	strb	r2, [r3]
7001262c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012630:	e3473002 	movt	r3, #28674	; 0x7002
70012634:	e5933000 	ldr	r3, [r3]
70012638:	e2832001 	add	r2, r3, #1
7001263c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012640:	e3473002 	movt	r3, #28674	; 0x7002
70012644:	e5832000 	str	r2, [r3]
70012648:	ea000021 	b	700126d4 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
7001264c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012650:	e5d33001 	ldrb	r3, [r3, #1]
70012654:	e3530002 	cmp	r3, #2
70012658:	1a00000c 	bne	70012690 <finsh_compile+0xcc8>
7001265c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012660:	e3473002 	movt	r3, #28674	; 0x7002
70012664:	e5933000 	ldr	r3, [r3]
70012668:	e3a02005 	mov	r2, #5
7001266c:	e5c32000 	strb	r2, [r3]
70012670:	e30b341c 	movw	r3, #46108	; 0xb41c
70012674:	e3473002 	movt	r3, #28674	; 0x7002
70012678:	e5933000 	ldr	r3, [r3]
7001267c:	e2832001 	add	r2, r3, #1
70012680:	e30b341c 	movw	r3, #46108	; 0xb41c
70012684:	e3473002 	movt	r3, #28674	; 0x7002
70012688:	e5832000 	str	r2, [r3]
7001268c:	ea000010 	b	700126d4 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
70012690:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012694:	e5d33001 	ldrb	r3, [r3, #1]
70012698:	e3530003 	cmp	r3, #3
7001269c:	1a00000c 	bne	700126d4 <finsh_compile+0xd0c>
700126a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700126a4:	e3473002 	movt	r3, #28674	; 0x7002
700126a8:	e5933000 	ldr	r3, [r3]
700126ac:	e3a02006 	mov	r2, #6
700126b0:	e5c32000 	strb	r2, [r3]
700126b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700126b8:	e3473002 	movt	r3, #28674	; 0x7002
700126bc:	e5933000 	ldr	r3, [r3]
700126c0:	e2832001 	add	r2, r3, #1
700126c4:	e30b341c 	movw	r3, #46108	; 0xb41c
700126c8:	e3473002 	movt	r3, #28674	; 0x7002
700126cc:	e5832000 	str	r2, [r3]
            break;
700126d0:	ea000a6f 	b	70015094 <finsh_compile+0x36cc>
700126d4:	ea000a6e 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
700126d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700126dc:	e5d33001 	ldrb	r3, [r3, #1]
700126e0:	e3530001 	cmp	r3, #1
700126e4:	1a00000c 	bne	7001271c <finsh_compile+0xd54>
700126e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700126ec:	e3473002 	movt	r3, #28674	; 0x7002
700126f0:	e5933000 	ldr	r3, [r3]
700126f4:	e3a0200d 	mov	r2, #13
700126f8:	e5c32000 	strb	r2, [r3]
700126fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012700:	e3473002 	movt	r3, #28674	; 0x7002
70012704:	e5933000 	ldr	r3, [r3]
70012708:	e2832001 	add	r2, r3, #1
7001270c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012710:	e3473002 	movt	r3, #28674	; 0x7002
70012714:	e5832000 	str	r2, [r3]
70012718:	ea000021 	b	700127a4 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
7001271c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012720:	e5d33001 	ldrb	r3, [r3, #1]
70012724:	e3530002 	cmp	r3, #2
70012728:	1a00000c 	bne	70012760 <finsh_compile+0xd98>
7001272c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012730:	e3473002 	movt	r3, #28674	; 0x7002
70012734:	e5933000 	ldr	r3, [r3]
70012738:	e3a0200e 	mov	r2, #14
7001273c:	e5c32000 	strb	r2, [r3]
70012740:	e30b341c 	movw	r3, #46108	; 0xb41c
70012744:	e3473002 	movt	r3, #28674	; 0x7002
70012748:	e5933000 	ldr	r3, [r3]
7001274c:	e2832001 	add	r2, r3, #1
70012750:	e30b341c 	movw	r3, #46108	; 0xb41c
70012754:	e3473002 	movt	r3, #28674	; 0x7002
70012758:	e5832000 	str	r2, [r3]
7001275c:	ea000010 	b	700127a4 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
70012760:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012764:	e5d33001 	ldrb	r3, [r3, #1]
70012768:	e3530003 	cmp	r3, #3
7001276c:	1a00000c 	bne	700127a4 <finsh_compile+0xddc>
70012770:	e30b341c 	movw	r3, #46108	; 0xb41c
70012774:	e3473002 	movt	r3, #28674	; 0x7002
70012778:	e5933000 	ldr	r3, [r3]
7001277c:	e3a0200f 	mov	r2, #15
70012780:	e5c32000 	strb	r2, [r3]
70012784:	e30b341c 	movw	r3, #46108	; 0xb41c
70012788:	e3473002 	movt	r3, #28674	; 0x7002
7001278c:	e5933000 	ldr	r3, [r3]
70012790:	e2832001 	add	r2, r3, #1
70012794:	e30b341c 	movw	r3, #46108	; 0xb41c
70012798:	e3473002 	movt	r3, #28674	; 0x7002
7001279c:	e5832000 	str	r2, [r3]
            break;
700127a0:	ea000a3b 	b	70015094 <finsh_compile+0x36cc>
700127a4:	ea000a3a 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
700127a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700127ac:	e5d33001 	ldrb	r3, [r3, #1]
700127b0:	e3530001 	cmp	r3, #1
700127b4:	1a00000c 	bne	700127ec <finsh_compile+0xe24>
700127b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700127bc:	e3473002 	movt	r3, #28674	; 0x7002
700127c0:	e5933000 	ldr	r3, [r3]
700127c4:	e3a02007 	mov	r2, #7
700127c8:	e5c32000 	strb	r2, [r3]
700127cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700127d0:	e3473002 	movt	r3, #28674	; 0x7002
700127d4:	e5933000 	ldr	r3, [r3]
700127d8:	e2832001 	add	r2, r3, #1
700127dc:	e30b341c 	movw	r3, #46108	; 0xb41c
700127e0:	e3473002 	movt	r3, #28674	; 0x7002
700127e4:	e5832000 	str	r2, [r3]
700127e8:	ea000021 	b	70012874 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
700127ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700127f0:	e5d33001 	ldrb	r3, [r3, #1]
700127f4:	e3530002 	cmp	r3, #2
700127f8:	1a00000c 	bne	70012830 <finsh_compile+0xe68>
700127fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012800:	e3473002 	movt	r3, #28674	; 0x7002
70012804:	e5933000 	ldr	r3, [r3]
70012808:	e3a02008 	mov	r2, #8
7001280c:	e5c32000 	strb	r2, [r3]
70012810:	e30b341c 	movw	r3, #46108	; 0xb41c
70012814:	e3473002 	movt	r3, #28674	; 0x7002
70012818:	e5933000 	ldr	r3, [r3]
7001281c:	e2832001 	add	r2, r3, #1
70012820:	e30b341c 	movw	r3, #46108	; 0xb41c
70012824:	e3473002 	movt	r3, #28674	; 0x7002
70012828:	e5832000 	str	r2, [r3]
7001282c:	ea000010 	b	70012874 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
70012830:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012834:	e5d33001 	ldrb	r3, [r3, #1]
70012838:	e3530003 	cmp	r3, #3
7001283c:	1a00000c 	bne	70012874 <finsh_compile+0xeac>
70012840:	e30b341c 	movw	r3, #46108	; 0xb41c
70012844:	e3473002 	movt	r3, #28674	; 0x7002
70012848:	e5933000 	ldr	r3, [r3]
7001284c:	e3a02009 	mov	r2, #9
70012850:	e5c32000 	strb	r2, [r3]
70012854:	e30b341c 	movw	r3, #46108	; 0xb41c
70012858:	e3473002 	movt	r3, #28674	; 0x7002
7001285c:	e5933000 	ldr	r3, [r3]
70012860:	e2832001 	add	r2, r3, #1
70012864:	e30b341c 	movw	r3, #46108	; 0xb41c
70012868:	e3473002 	movt	r3, #28674	; 0x7002
7001286c:	e5832000 	str	r2, [r3]
            break;
70012870:	ea000a07 	b	70015094 <finsh_compile+0x36cc>
70012874:	ea000a06 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
70012878:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001287c:	e5d33001 	ldrb	r3, [r3, #1]
70012880:	e3530001 	cmp	r3, #1
70012884:	1a00000c 	bne	700128bc <finsh_compile+0xef4>
70012888:	e30b341c 	movw	r3, #46108	; 0xb41c
7001288c:	e3473002 	movt	r3, #28674	; 0x7002
70012890:	e5933000 	ldr	r3, [r3]
70012894:	e3a0200a 	mov	r2, #10
70012898:	e5c32000 	strb	r2, [r3]
7001289c:	e30b341c 	movw	r3, #46108	; 0xb41c
700128a0:	e3473002 	movt	r3, #28674	; 0x7002
700128a4:	e5933000 	ldr	r3, [r3]
700128a8:	e2832001 	add	r2, r3, #1
700128ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700128b0:	e3473002 	movt	r3, #28674	; 0x7002
700128b4:	e5832000 	str	r2, [r3]
700128b8:	ea000021 	b	70012944 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
700128bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700128c0:	e5d33001 	ldrb	r3, [r3, #1]
700128c4:	e3530002 	cmp	r3, #2
700128c8:	1a00000c 	bne	70012900 <finsh_compile+0xf38>
700128cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700128d0:	e3473002 	movt	r3, #28674	; 0x7002
700128d4:	e5933000 	ldr	r3, [r3]
700128d8:	e3a0200b 	mov	r2, #11
700128dc:	e5c32000 	strb	r2, [r3]
700128e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700128e4:	e3473002 	movt	r3, #28674	; 0x7002
700128e8:	e5933000 	ldr	r3, [r3]
700128ec:	e2832001 	add	r2, r3, #1
700128f0:	e30b341c 	movw	r3, #46108	; 0xb41c
700128f4:	e3473002 	movt	r3, #28674	; 0x7002
700128f8:	e5832000 	str	r2, [r3]
700128fc:	ea000010 	b	70012944 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
70012900:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012904:	e5d33001 	ldrb	r3, [r3, #1]
70012908:	e3530003 	cmp	r3, #3
7001290c:	1a00000c 	bne	70012944 <finsh_compile+0xf7c>
70012910:	e30b341c 	movw	r3, #46108	; 0xb41c
70012914:	e3473002 	movt	r3, #28674	; 0x7002
70012918:	e5933000 	ldr	r3, [r3]
7001291c:	e3a0200c 	mov	r2, #12
70012920:	e5c32000 	strb	r2, [r3]
70012924:	e30b341c 	movw	r3, #46108	; 0xb41c
70012928:	e3473002 	movt	r3, #28674	; 0x7002
7001292c:	e5933000 	ldr	r3, [r3]
70012930:	e2832001 	add	r2, r3, #1
70012934:	e30b341c 	movw	r3, #46108	; 0xb41c
70012938:	e3473002 	movt	r3, #28674	; 0x7002
7001293c:	e5832000 	str	r2, [r3]
            break;
70012940:	ea0009d3 	b	70015094 <finsh_compile+0x36cc>
70012944:	ea0009d2 	b	70015094 <finsh_compile+0x36cc>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
70012948:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001294c:	e5d33001 	ldrb	r3, [r3, #1]
70012950:	e3530001 	cmp	r3, #1
70012954:	1a00000c 	bne	7001298c <finsh_compile+0xfc4>
70012958:	e30b341c 	movw	r3, #46108	; 0xb41c
7001295c:	e3473002 	movt	r3, #28674	; 0x7002
70012960:	e5933000 	ldr	r3, [r3]
70012964:	e3a02010 	mov	r2, #16
70012968:	e5c32000 	strb	r2, [r3]
7001296c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012970:	e3473002 	movt	r3, #28674	; 0x7002
70012974:	e5933000 	ldr	r3, [r3]
70012978:	e2832001 	add	r2, r3, #1
7001297c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012980:	e3473002 	movt	r3, #28674	; 0x7002
70012984:	e5832000 	str	r2, [r3]
70012988:	ea000021 	b	70012a14 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
7001298c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012990:	e5d33001 	ldrb	r3, [r3, #1]
70012994:	e3530002 	cmp	r3, #2
70012998:	1a00000c 	bne	700129d0 <finsh_compile+0x1008>
7001299c:	e30b341c 	movw	r3, #46108	; 0xb41c
700129a0:	e3473002 	movt	r3, #28674	; 0x7002
700129a4:	e5933000 	ldr	r3, [r3]
700129a8:	e3a02011 	mov	r2, #17
700129ac:	e5c32000 	strb	r2, [r3]
700129b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700129b4:	e3473002 	movt	r3, #28674	; 0x7002
700129b8:	e5933000 	ldr	r3, [r3]
700129bc:	e2832001 	add	r2, r3, #1
700129c0:	e30b341c 	movw	r3, #46108	; 0xb41c
700129c4:	e3473002 	movt	r3, #28674	; 0x7002
700129c8:	e5832000 	str	r2, [r3]
700129cc:	ea000010 	b	70012a14 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
700129d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700129d4:	e5d33001 	ldrb	r3, [r3, #1]
700129d8:	e3530003 	cmp	r3, #3
700129dc:	1a00000c 	bne	70012a14 <finsh_compile+0x104c>
700129e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700129e4:	e3473002 	movt	r3, #28674	; 0x7002
700129e8:	e5933000 	ldr	r3, [r3]
700129ec:	e3a02012 	mov	r2, #18
700129f0:	e5c32000 	strb	r2, [r3]
700129f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700129f8:	e3473002 	movt	r3, #28674	; 0x7002
700129fc:	e5933000 	ldr	r3, [r3]
70012a00:	e2832001 	add	r2, r3, #1
70012a04:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a08:	e3473002 	movt	r3, #28674	; 0x7002
70012a0c:	e5832000 	str	r2, [r3]
            break;
70012a10:	ea00099f 	b	70015094 <finsh_compile+0x36cc>
70012a14:	ea00099e 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
70012a18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012a1c:	e5d33001 	ldrb	r3, [r3, #1]
70012a20:	e3530001 	cmp	r3, #1
70012a24:	1a00000c 	bne	70012a5c <finsh_compile+0x1094>
70012a28:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a2c:	e3473002 	movt	r3, #28674	; 0x7002
70012a30:	e5933000 	ldr	r3, [r3]
70012a34:	e3a02013 	mov	r2, #19
70012a38:	e5c32000 	strb	r2, [r3]
70012a3c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a40:	e3473002 	movt	r3, #28674	; 0x7002
70012a44:	e5933000 	ldr	r3, [r3]
70012a48:	e2832001 	add	r2, r3, #1
70012a4c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a50:	e3473002 	movt	r3, #28674	; 0x7002
70012a54:	e5832000 	str	r2, [r3]
70012a58:	ea000021 	b	70012ae4 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
70012a5c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012a60:	e5d33001 	ldrb	r3, [r3, #1]
70012a64:	e3530002 	cmp	r3, #2
70012a68:	1a00000c 	bne	70012aa0 <finsh_compile+0x10d8>
70012a6c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a70:	e3473002 	movt	r3, #28674	; 0x7002
70012a74:	e5933000 	ldr	r3, [r3]
70012a78:	e3a02014 	mov	r2, #20
70012a7c:	e5c32000 	strb	r2, [r3]
70012a80:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a84:	e3473002 	movt	r3, #28674	; 0x7002
70012a88:	e5933000 	ldr	r3, [r3]
70012a8c:	e2832001 	add	r2, r3, #1
70012a90:	e30b341c 	movw	r3, #46108	; 0xb41c
70012a94:	e3473002 	movt	r3, #28674	; 0x7002
70012a98:	e5832000 	str	r2, [r3]
70012a9c:	ea000010 	b	70012ae4 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
70012aa0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012aa4:	e5d33001 	ldrb	r3, [r3, #1]
70012aa8:	e3530003 	cmp	r3, #3
70012aac:	1a00000c 	bne	70012ae4 <finsh_compile+0x111c>
70012ab0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ab4:	e3473002 	movt	r3, #28674	; 0x7002
70012ab8:	e5933000 	ldr	r3, [r3]
70012abc:	e3a02015 	mov	r2, #21
70012ac0:	e5c32000 	strb	r2, [r3]
70012ac4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ac8:	e3473002 	movt	r3, #28674	; 0x7002
70012acc:	e5933000 	ldr	r3, [r3]
70012ad0:	e2832001 	add	r2, r3, #1
70012ad4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ad8:	e3473002 	movt	r3, #28674	; 0x7002
70012adc:	e5832000 	str	r2, [r3]
            break;
70012ae0:	ea00096b 	b	70015094 <finsh_compile+0x36cc>
70012ae4:	ea00096a 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
70012ae8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012aec:	e5d33001 	ldrb	r3, [r3, #1]
70012af0:	e3530001 	cmp	r3, #1
70012af4:	1a00000c 	bne	70012b2c <finsh_compile+0x1164>
70012af8:	e30b341c 	movw	r3, #46108	; 0xb41c
70012afc:	e3473002 	movt	r3, #28674	; 0x7002
70012b00:	e5933000 	ldr	r3, [r3]
70012b04:	e3a02016 	mov	r2, #22
70012b08:	e5c32000 	strb	r2, [r3]
70012b0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b10:	e3473002 	movt	r3, #28674	; 0x7002
70012b14:	e5933000 	ldr	r3, [r3]
70012b18:	e2832001 	add	r2, r3, #1
70012b1c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b20:	e3473002 	movt	r3, #28674	; 0x7002
70012b24:	e5832000 	str	r2, [r3]
70012b28:	ea000021 	b	70012bb4 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
70012b2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012b30:	e5d33001 	ldrb	r3, [r3, #1]
70012b34:	e3530002 	cmp	r3, #2
70012b38:	1a00000c 	bne	70012b70 <finsh_compile+0x11a8>
70012b3c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b40:	e3473002 	movt	r3, #28674	; 0x7002
70012b44:	e5933000 	ldr	r3, [r3]
70012b48:	e3a02017 	mov	r2, #23
70012b4c:	e5c32000 	strb	r2, [r3]
70012b50:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b54:	e3473002 	movt	r3, #28674	; 0x7002
70012b58:	e5933000 	ldr	r3, [r3]
70012b5c:	e2832001 	add	r2, r3, #1
70012b60:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b64:	e3473002 	movt	r3, #28674	; 0x7002
70012b68:	e5832000 	str	r2, [r3]
70012b6c:	ea000010 	b	70012bb4 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
70012b70:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012b74:	e5d33001 	ldrb	r3, [r3, #1]
70012b78:	e3530003 	cmp	r3, #3
70012b7c:	1a00000c 	bne	70012bb4 <finsh_compile+0x11ec>
70012b80:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b84:	e3473002 	movt	r3, #28674	; 0x7002
70012b88:	e5933000 	ldr	r3, [r3]
70012b8c:	e3a02018 	mov	r2, #24
70012b90:	e5c32000 	strb	r2, [r3]
70012b94:	e30b341c 	movw	r3, #46108	; 0xb41c
70012b98:	e3473002 	movt	r3, #28674	; 0x7002
70012b9c:	e5933000 	ldr	r3, [r3]
70012ba0:	e2832001 	add	r2, r3, #1
70012ba4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ba8:	e3473002 	movt	r3, #28674	; 0x7002
70012bac:	e5832000 	str	r2, [r3]
            break;
70012bb0:	ea000937 	b	70015094 <finsh_compile+0x36cc>
70012bb4:	ea000936 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
70012bb8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012bbc:	e5d33001 	ldrb	r3, [r3, #1]
70012bc0:	e3530001 	cmp	r3, #1
70012bc4:	1a00000c 	bne	70012bfc <finsh_compile+0x1234>
70012bc8:	e30b341c 	movw	r3, #46108	; 0xb41c
70012bcc:	e3473002 	movt	r3, #28674	; 0x7002
70012bd0:	e5933000 	ldr	r3, [r3]
70012bd4:	e3a02019 	mov	r2, #25
70012bd8:	e5c32000 	strb	r2, [r3]
70012bdc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012be0:	e3473002 	movt	r3, #28674	; 0x7002
70012be4:	e5933000 	ldr	r3, [r3]
70012be8:	e2832001 	add	r2, r3, #1
70012bec:	e30b341c 	movw	r3, #46108	; 0xb41c
70012bf0:	e3473002 	movt	r3, #28674	; 0x7002
70012bf4:	e5832000 	str	r2, [r3]
70012bf8:	ea000021 	b	70012c84 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
70012bfc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012c00:	e5d33001 	ldrb	r3, [r3, #1]
70012c04:	e3530002 	cmp	r3, #2
70012c08:	1a00000c 	bne	70012c40 <finsh_compile+0x1278>
70012c0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c10:	e3473002 	movt	r3, #28674	; 0x7002
70012c14:	e5933000 	ldr	r3, [r3]
70012c18:	e3a0201a 	mov	r2, #26
70012c1c:	e5c32000 	strb	r2, [r3]
70012c20:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c24:	e3473002 	movt	r3, #28674	; 0x7002
70012c28:	e5933000 	ldr	r3, [r3]
70012c2c:	e2832001 	add	r2, r3, #1
70012c30:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c34:	e3473002 	movt	r3, #28674	; 0x7002
70012c38:	e5832000 	str	r2, [r3]
70012c3c:	ea000010 	b	70012c84 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
70012c40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012c44:	e5d33001 	ldrb	r3, [r3, #1]
70012c48:	e3530003 	cmp	r3, #3
70012c4c:	1a00000c 	bne	70012c84 <finsh_compile+0x12bc>
70012c50:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c54:	e3473002 	movt	r3, #28674	; 0x7002
70012c58:	e5933000 	ldr	r3, [r3]
70012c5c:	e3a0201b 	mov	r2, #27
70012c60:	e5c32000 	strb	r2, [r3]
70012c64:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c68:	e3473002 	movt	r3, #28674	; 0x7002
70012c6c:	e5933000 	ldr	r3, [r3]
70012c70:	e2832001 	add	r2, r3, #1
70012c74:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c78:	e3473002 	movt	r3, #28674	; 0x7002
70012c7c:	e5832000 	str	r2, [r3]
            break;
70012c80:	ea000903 	b	70015094 <finsh_compile+0x36cc>
70012c84:	ea000902 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
70012c88:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012c8c:	e5d33001 	ldrb	r3, [r3, #1]
70012c90:	e3530001 	cmp	r3, #1
70012c94:	1a00000c 	bne	70012ccc <finsh_compile+0x1304>
70012c98:	e30b341c 	movw	r3, #46108	; 0xb41c
70012c9c:	e3473002 	movt	r3, #28674	; 0x7002
70012ca0:	e5933000 	ldr	r3, [r3]
70012ca4:	e3a0201c 	mov	r2, #28
70012ca8:	e5c32000 	strb	r2, [r3]
70012cac:	e30b341c 	movw	r3, #46108	; 0xb41c
70012cb0:	e3473002 	movt	r3, #28674	; 0x7002
70012cb4:	e5933000 	ldr	r3, [r3]
70012cb8:	e2832001 	add	r2, r3, #1
70012cbc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012cc0:	e3473002 	movt	r3, #28674	; 0x7002
70012cc4:	e5832000 	str	r2, [r3]
70012cc8:	ea000021 	b	70012d54 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
70012ccc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012cd0:	e5d33001 	ldrb	r3, [r3, #1]
70012cd4:	e3530002 	cmp	r3, #2
70012cd8:	1a00000c 	bne	70012d10 <finsh_compile+0x1348>
70012cdc:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ce0:	e3473002 	movt	r3, #28674	; 0x7002
70012ce4:	e5933000 	ldr	r3, [r3]
70012ce8:	e3a0201d 	mov	r2, #29
70012cec:	e5c32000 	strb	r2, [r3]
70012cf0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012cf4:	e3473002 	movt	r3, #28674	; 0x7002
70012cf8:	e5933000 	ldr	r3, [r3]
70012cfc:	e2832001 	add	r2, r3, #1
70012d00:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d04:	e3473002 	movt	r3, #28674	; 0x7002
70012d08:	e5832000 	str	r2, [r3]
70012d0c:	ea000010 	b	70012d54 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
70012d10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012d14:	e5d33001 	ldrb	r3, [r3, #1]
70012d18:	e3530003 	cmp	r3, #3
70012d1c:	1a00000c 	bne	70012d54 <finsh_compile+0x138c>
70012d20:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d24:	e3473002 	movt	r3, #28674	; 0x7002
70012d28:	e5933000 	ldr	r3, [r3]
70012d2c:	e3a0201e 	mov	r2, #30
70012d30:	e5c32000 	strb	r2, [r3]
70012d34:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d38:	e3473002 	movt	r3, #28674	; 0x7002
70012d3c:	e5933000 	ldr	r3, [r3]
70012d40:	e2832001 	add	r2, r3, #1
70012d44:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d48:	e3473002 	movt	r3, #28674	; 0x7002
70012d4c:	e5832000 	str	r2, [r3]
            break;
70012d50:	ea0008cf 	b	70015094 <finsh_compile+0x36cc>
70012d54:	ea0008ce 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
70012d58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012d5c:	e5d33001 	ldrb	r3, [r3, #1]
70012d60:	e3530001 	cmp	r3, #1
70012d64:	1a00000c 	bne	70012d9c <finsh_compile+0x13d4>
70012d68:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d6c:	e3473002 	movt	r3, #28674	; 0x7002
70012d70:	e5933000 	ldr	r3, [r3]
70012d74:	e3a0201f 	mov	r2, #31
70012d78:	e5c32000 	strb	r2, [r3]
70012d7c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d80:	e3473002 	movt	r3, #28674	; 0x7002
70012d84:	e5933000 	ldr	r3, [r3]
70012d88:	e2832001 	add	r2, r3, #1
70012d8c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012d90:	e3473002 	movt	r3, #28674	; 0x7002
70012d94:	e5832000 	str	r2, [r3]
70012d98:	ea000021 	b	70012e24 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
70012d9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012da0:	e5d33001 	ldrb	r3, [r3, #1]
70012da4:	e3530002 	cmp	r3, #2
70012da8:	1a00000c 	bne	70012de0 <finsh_compile+0x1418>
70012dac:	e30b341c 	movw	r3, #46108	; 0xb41c
70012db0:	e3473002 	movt	r3, #28674	; 0x7002
70012db4:	e5933000 	ldr	r3, [r3]
70012db8:	e3a02020 	mov	r2, #32
70012dbc:	e5c32000 	strb	r2, [r3]
70012dc0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012dc4:	e3473002 	movt	r3, #28674	; 0x7002
70012dc8:	e5933000 	ldr	r3, [r3]
70012dcc:	e2832001 	add	r2, r3, #1
70012dd0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012dd4:	e3473002 	movt	r3, #28674	; 0x7002
70012dd8:	e5832000 	str	r2, [r3]
70012ddc:	ea000010 	b	70012e24 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
70012de0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012de4:	e5d33001 	ldrb	r3, [r3, #1]
70012de8:	e3530003 	cmp	r3, #3
70012dec:	1a00000c 	bne	70012e24 <finsh_compile+0x145c>
70012df0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012df4:	e3473002 	movt	r3, #28674	; 0x7002
70012df8:	e5933000 	ldr	r3, [r3]
70012dfc:	e3a02021 	mov	r2, #33	; 0x21
70012e00:	e5c32000 	strb	r2, [r3]
70012e04:	e30b341c 	movw	r3, #46108	; 0xb41c
70012e08:	e3473002 	movt	r3, #28674	; 0x7002
70012e0c:	e5933000 	ldr	r3, [r3]
70012e10:	e2832001 	add	r2, r3, #1
70012e14:	e30b341c 	movw	r3, #46108	; 0xb41c
70012e18:	e3473002 	movt	r3, #28674	; 0x7002
70012e1c:	e5832000 	str	r2, [r3]
            break;
70012e20:	ea00089b 	b	70015094 <finsh_compile+0x36cc>
70012e24:	ea00089a 	b	70015094 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
70012e28:	e3a03000 	mov	r3, #0
70012e2c:	e50b3008 	str	r3, [fp, #-8]
                if (finsh_node_child(node) != NULL)
70012e30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012e34:	e5933010 	ldr	r3, [r3, #16]
70012e38:	e3530000 	cmp	r3, #0
70012e3c:	0a000027 	beq	70012ee0 <finsh_compile+0x1518>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
70012e40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012e44:	e5933010 	ldr	r3, [r3, #16]
70012e48:	e593300c 	ldr	r3, [r3, #12]
70012e4c:	e50b300c 	str	r3, [fp, #-12]
                    while (sibling != NULL)
70012e50:	ea000005 	b	70012e6c <finsh_compile+0x14a4>
                    {
                        parameters ++;
70012e54:	e51b3008 	ldr	r3, [fp, #-8]
70012e58:	e2833001 	add	r3, r3, #1
70012e5c:	e50b3008 	str	r3, [fp, #-8]
                        sibling = finsh_node_sibling(sibling);
70012e60:	e51b300c 	ldr	r3, [fp, #-12]
70012e64:	e593300c 	ldr	r3, [r3, #12]
70012e68:	e50b300c 	str	r3, [fp, #-12]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
70012e6c:	e51b300c 	ldr	r3, [fp, #-12]
70012e70:	e3530000 	cmp	r3, #0
70012e74:	1afffff6 	bne	70012e54 <finsh_compile+0x148c>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
70012e78:	e30b341c 	movw	r3, #46108	; 0xb41c
70012e7c:	e3473002 	movt	r3, #28674	; 0x7002
70012e80:	e5933000 	ldr	r3, [r3]
70012e84:	e3a0202c 	mov	r2, #44	; 0x2c
70012e88:	e5c32000 	strb	r2, [r3]
70012e8c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012e90:	e3473002 	movt	r3, #28674	; 0x7002
70012e94:	e5933000 	ldr	r3, [r3]
70012e98:	e2832001 	add	r2, r3, #1
70012e9c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ea0:	e3473002 	movt	r3, #28674	; 0x7002
70012ea4:	e5832000 	str	r2, [r3]
                    finsh_code_byte(parameters);
70012ea8:	e30b341c 	movw	r3, #46108	; 0xb41c
70012eac:	e3473002 	movt	r3, #28674	; 0x7002
70012eb0:	e5933000 	ldr	r3, [r3]
70012eb4:	e51b2008 	ldr	r2, [fp, #-8]
70012eb8:	e6ef2072 	uxtb	r2, r2
70012ebc:	e5c32000 	strb	r2, [r3]
70012ec0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ec4:	e3473002 	movt	r3, #28674	; 0x7002
70012ec8:	e5933000 	ldr	r3, [r3]
70012ecc:	e2832001 	add	r2, r3, #1
70012ed0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ed4:	e3473002 	movt	r3, #28674	; 0x7002
70012ed8:	e5832000 	str	r2, [r3]
                }
            }
            break;
70012edc:	ea00086c 	b	70015094 <finsh_compile+0x36cc>
70012ee0:	ea00086b 	b	70015094 <finsh_compile+0x36cc>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
70012ee4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012ee8:	e5933010 	ldr	r3, [r3, #16]
70012eec:	e3530000 	cmp	r3, #0
70012ef0:	0a00005c 	beq	70013068 <finsh_compile+0x16a0>
70012ef4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012ef8:	e5933010 	ldr	r3, [r3, #16]
70012efc:	e5d33000 	ldrb	r3, [r3]
70012f00:	e3530001 	cmp	r3, #1
70012f04:	1a000057 	bne	70013068 <finsh_compile+0x16a0>
            {
                switch (finsh_node_child(node)->data_type)
70012f08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70012f0c:	e5933010 	ldr	r3, [r3, #16]
70012f10:	e5d33001 	ldrb	r3, [r3, #1]
70012f14:	e3530002 	cmp	r3, #2
70012f18:	0a00001c 	beq	70012f90 <finsh_compile+0x15c8>
70012f1c:	e3530003 	cmp	r3, #3
70012f20:	0a000033 	beq	70012ff4 <finsh_compile+0x162c>
70012f24:	e3530001 	cmp	r3, #1
70012f28:	1a00004a 	bne	70013058 <finsh_compile+0x1690>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
70012f2c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f30:	e3473002 	movt	r3, #28674	; 0x7002
70012f34:	e5933000 	ldr	r3, [r3]
70012f38:	e3a02028 	mov	r2, #40	; 0x28
70012f3c:	e5c32000 	strb	r2, [r3]
70012f40:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f44:	e3473002 	movt	r3, #28674	; 0x7002
70012f48:	e5933000 	ldr	r3, [r3]
70012f4c:	e2832001 	add	r2, r3, #1
70012f50:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f54:	e3473002 	movt	r3, #28674	; 0x7002
70012f58:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
70012f5c:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f60:	e3473002 	movt	r3, #28674	; 0x7002
70012f64:	e5933000 	ldr	r3, [r3]
70012f68:	e3a0202d 	mov	r2, #45	; 0x2d
70012f6c:	e5c32000 	strb	r2, [r3]
70012f70:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f74:	e3473002 	movt	r3, #28674	; 0x7002
70012f78:	e5933000 	ldr	r3, [r3]
70012f7c:	e2832001 	add	r2, r3, #1
70012f80:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f84:	e3473002 	movt	r3, #28674	; 0x7002
70012f88:	e5832000 	str	r2, [r3]
                    break;
70012f8c:	ea000034 	b	70013064 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
70012f90:	e30b341c 	movw	r3, #46108	; 0xb41c
70012f94:	e3473002 	movt	r3, #28674	; 0x7002
70012f98:	e5933000 	ldr	r3, [r3]
70012f9c:	e3a02029 	mov	r2, #41	; 0x29
70012fa0:	e5c32000 	strb	r2, [r3]
70012fa4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012fa8:	e3473002 	movt	r3, #28674	; 0x7002
70012fac:	e5933000 	ldr	r3, [r3]
70012fb0:	e2832001 	add	r2, r3, #1
70012fb4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012fb8:	e3473002 	movt	r3, #28674	; 0x7002
70012fbc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
70012fc0:	e30b341c 	movw	r3, #46108	; 0xb41c
70012fc4:	e3473002 	movt	r3, #28674	; 0x7002
70012fc8:	e5933000 	ldr	r3, [r3]
70012fcc:	e3a0202e 	mov	r2, #46	; 0x2e
70012fd0:	e5c32000 	strb	r2, [r3]
70012fd4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012fd8:	e3473002 	movt	r3, #28674	; 0x7002
70012fdc:	e5933000 	ldr	r3, [r3]
70012fe0:	e2832001 	add	r2, r3, #1
70012fe4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012fe8:	e3473002 	movt	r3, #28674	; 0x7002
70012fec:	e5832000 	str	r2, [r3]
                    break;
70012ff0:	ea00001b 	b	70013064 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
70012ff4:	e30b341c 	movw	r3, #46108	; 0xb41c
70012ff8:	e3473002 	movt	r3, #28674	; 0x7002
70012ffc:	e5933000 	ldr	r3, [r3]
70013000:	e3a0202a 	mov	r2, #42	; 0x2a
70013004:	e5c32000 	strb	r2, [r3]
70013008:	e30b341c 	movw	r3, #46108	; 0xb41c
7001300c:	e3473002 	movt	r3, #28674	; 0x7002
70013010:	e5933000 	ldr	r3, [r3]
70013014:	e2832001 	add	r2, r3, #1
70013018:	e30b341c 	movw	r3, #46108	; 0xb41c
7001301c:	e3473002 	movt	r3, #28674	; 0x7002
70013020:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
70013024:	e30b341c 	movw	r3, #46108	; 0xb41c
70013028:	e3473002 	movt	r3, #28674	; 0x7002
7001302c:	e5933000 	ldr	r3, [r3]
70013030:	e3a0202f 	mov	r2, #47	; 0x2f
70013034:	e5c32000 	strb	r2, [r3]
70013038:	e30b341c 	movw	r3, #46108	; 0xb41c
7001303c:	e3473002 	movt	r3, #28674	; 0x7002
70013040:	e5933000 	ldr	r3, [r3]
70013044:	e2832001 	add	r2, r3, #1
70013048:	e30b341c 	movw	r3, #46108	; 0xb41c
7001304c:	e3473002 	movt	r3, #28674	; 0x7002
70013050:	e5832000 	str	r2, [r3]
                    break;
70013054:	ea000002 	b	70013064 <finsh_compile+0x169c>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
70013058:	e3a00003 	mov	r0, #3
7001305c:	eb00093f 	bl	70015560 <finsh_error_set>
                }
            }
70013060:	ea00005d 	b	700131dc <finsh_compile+0x1814>
70013064:	ea00005c 	b	700131dc <finsh_compile+0x1814>
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
70013068:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001306c:	e5933010 	ldr	r3, [r3, #16]
70013070:	e5d33000 	ldrb	r3, [r3]
70013074:	e3530019 	cmp	r3, #25
70013078:	1a000057 	bne	700131dc <finsh_compile+0x1814>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
7001307c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013080:	e5933010 	ldr	r3, [r3, #16]
70013084:	e5d33001 	ldrb	r3, [r3, #1]
70013088:	e203300f 	and	r3, r3, #15
7001308c:	e3530002 	cmp	r3, #2
70013090:	0a00001c 	beq	70013108 <finsh_compile+0x1740>
70013094:	e3530003 	cmp	r3, #3
70013098:	0a000033 	beq	7001316c <finsh_compile+0x17a4>
7001309c:	e3530001 	cmp	r3, #1
700130a0:	1a00004a 	bne	700131d0 <finsh_compile+0x1808>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
700130a4:	e30b341c 	movw	r3, #46108	; 0xb41c
700130a8:	e3473002 	movt	r3, #28674	; 0x7002
700130ac:	e5933000 	ldr	r3, [r3]
700130b0:	e3a02028 	mov	r2, #40	; 0x28
700130b4:	e5c32000 	strb	r2, [r3]
700130b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700130bc:	e3473002 	movt	r3, #28674	; 0x7002
700130c0:	e5933000 	ldr	r3, [r3]
700130c4:	e2832001 	add	r2, r3, #1
700130c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700130cc:	e3473002 	movt	r3, #28674	; 0x7002
700130d0:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
700130d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700130d8:	e3473002 	movt	r3, #28674	; 0x7002
700130dc:	e5933000 	ldr	r3, [r3]
700130e0:	e3a0202d 	mov	r2, #45	; 0x2d
700130e4:	e5c32000 	strb	r2, [r3]
700130e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700130ec:	e3473002 	movt	r3, #28674	; 0x7002
700130f0:	e5933000 	ldr	r3, [r3]
700130f4:	e2832001 	add	r2, r3, #1
700130f8:	e30b341c 	movw	r3, #46108	; 0xb41c
700130fc:	e3473002 	movt	r3, #28674	; 0x7002
70013100:	e5832000 	str	r2, [r3]
                    break;
70013104:	ea000034 	b	700131dc <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
70013108:	e30b341c 	movw	r3, #46108	; 0xb41c
7001310c:	e3473002 	movt	r3, #28674	; 0x7002
70013110:	e5933000 	ldr	r3, [r3]
70013114:	e3a02029 	mov	r2, #41	; 0x29
70013118:	e5c32000 	strb	r2, [r3]
7001311c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013120:	e3473002 	movt	r3, #28674	; 0x7002
70013124:	e5933000 	ldr	r3, [r3]
70013128:	e2832001 	add	r2, r3, #1
7001312c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013130:	e3473002 	movt	r3, #28674	; 0x7002
70013134:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
70013138:	e30b341c 	movw	r3, #46108	; 0xb41c
7001313c:	e3473002 	movt	r3, #28674	; 0x7002
70013140:	e5933000 	ldr	r3, [r3]
70013144:	e3a0202e 	mov	r2, #46	; 0x2e
70013148:	e5c32000 	strb	r2, [r3]
7001314c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013150:	e3473002 	movt	r3, #28674	; 0x7002
70013154:	e5933000 	ldr	r3, [r3]
70013158:	e2832001 	add	r2, r3, #1
7001315c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013160:	e3473002 	movt	r3, #28674	; 0x7002
70013164:	e5832000 	str	r2, [r3]
                    break;
70013168:	ea00001b 	b	700131dc <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
7001316c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013170:	e3473002 	movt	r3, #28674	; 0x7002
70013174:	e5933000 	ldr	r3, [r3]
70013178:	e3a0202a 	mov	r2, #42	; 0x2a
7001317c:	e5c32000 	strb	r2, [r3]
70013180:	e30b341c 	movw	r3, #46108	; 0xb41c
70013184:	e3473002 	movt	r3, #28674	; 0x7002
70013188:	e5933000 	ldr	r3, [r3]
7001318c:	e2832001 	add	r2, r3, #1
70013190:	e30b341c 	movw	r3, #46108	; 0xb41c
70013194:	e3473002 	movt	r3, #28674	; 0x7002
70013198:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
7001319c:	e30b341c 	movw	r3, #46108	; 0xb41c
700131a0:	e3473002 	movt	r3, #28674	; 0x7002
700131a4:	e5933000 	ldr	r3, [r3]
700131a8:	e3a0202f 	mov	r2, #47	; 0x2f
700131ac:	e5c32000 	strb	r2, [r3]
700131b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700131b4:	e3473002 	movt	r3, #28674	; 0x7002
700131b8:	e5933000 	ldr	r3, [r3]
700131bc:	e2832001 	add	r2, r3, #1
700131c0:	e30b341c 	movw	r3, #46108	; 0xb41c
700131c4:	e3473002 	movt	r3, #28674	; 0x7002
700131c8:	e5832000 	str	r2, [r3]
                    break;
700131cc:	ea000002 	b	700131dc <finsh_compile+0x1814>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
700131d0:	e3a00003 	mov	r0, #3
700131d4:	eb0008e1 	bl	70015560 <finsh_error_set>
                }
            }
            break;
700131d8:	ea0007ad 	b	70015094 <finsh_compile+0x36cc>
700131dc:	ea0007ac 	b	70015094 <finsh_compile+0x36cc>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
700131e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700131e4:	e5933010 	ldr	r3, [r3, #16]
700131e8:	e3530000 	cmp	r3, #0
700131ec:	0a00017f 	beq	700137f0 <finsh_compile+0x1e28>
700131f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700131f4:	e5933010 	ldr	r3, [r3, #16]
700131f8:	e5d33000 	ldrb	r3, [r3]
700131fc:	e3530001 	cmp	r3, #1
70013200:	1a00017a 	bne	700137f0 <finsh_compile+0x1e28>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
70013204:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013208:	e5933010 	ldr	r3, [r3, #16]
7001320c:	e5933008 	ldr	r3, [r3, #8]
70013210:	e50b3018 	str	r3, [fp, #-24]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
70013214:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013218:	e5d33001 	ldrb	r3, [r3, #1]
7001321c:	e3530002 	cmp	r3, #2
70013220:	0a000076 	beq	70013400 <finsh_compile+0x1a38>
70013224:	e3530003 	cmp	r3, #3
70013228:	0a0000ec 	beq	700135e0 <finsh_compile+0x1c18>
7001322c:	e3530001 	cmp	r3, #1
70013230:	0a000000 	beq	70013238 <finsh_compile+0x1870>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
70013234:	ea000796 	b	70015094 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
70013238:	e30b341c 	movw	r3, #46108	; 0xb41c
7001323c:	e3473002 	movt	r3, #28674	; 0x7002
70013240:	e5933000 	ldr	r3, [r3]
70013244:	e3a02025 	mov	r2, #37	; 0x25
70013248:	e5c32000 	strb	r2, [r3]
7001324c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013250:	e3473002 	movt	r3, #28674	; 0x7002
70013254:	e5933000 	ldr	r3, [r3]
70013258:	e2832001 	add	r2, r3, #1
7001325c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013260:	e3473002 	movt	r3, #28674	; 0x7002
70013264:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
70013268:	e30b341c 	movw	r3, #46108	; 0xb41c
7001326c:	e3473002 	movt	r3, #28674	; 0x7002
70013270:	e5933000 	ldr	r3, [r3]
70013274:	e51b2018 	ldr	r2, [fp, #-24]
70013278:	e2822014 	add	r2, r2, #20
7001327c:	e6ef2072 	uxtb	r2, r2
70013280:	e5c32000 	strb	r2, [r3]
70013284:	e30b341c 	movw	r3, #46108	; 0xb41c
70013288:	e3473002 	movt	r3, #28674	; 0x7002
7001328c:	e5933000 	ldr	r3, [r3]
70013290:	e2833001 	add	r3, r3, #1
70013294:	e51b2018 	ldr	r2, [fp, #-24]
70013298:	e2822014 	add	r2, r2, #20
7001329c:	e1a02422 	lsr	r2, r2, #8
700132a0:	e6ef2072 	uxtb	r2, r2
700132a4:	e5c32000 	strb	r2, [r3]
700132a8:	e30b341c 	movw	r3, #46108	; 0xb41c
700132ac:	e3473002 	movt	r3, #28674	; 0x7002
700132b0:	e5933000 	ldr	r3, [r3]
700132b4:	e2833002 	add	r3, r3, #2
700132b8:	e51b2018 	ldr	r2, [fp, #-24]
700132bc:	e2822014 	add	r2, r2, #20
700132c0:	e1a02822 	lsr	r2, r2, #16
700132c4:	e6ef2072 	uxtb	r2, r2
700132c8:	e5c32000 	strb	r2, [r3]
700132cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700132d0:	e3473002 	movt	r3, #28674	; 0x7002
700132d4:	e5933000 	ldr	r3, [r3]
700132d8:	e2833003 	add	r3, r3, #3
700132dc:	e51b2018 	ldr	r2, [fp, #-24]
700132e0:	e2822014 	add	r2, r2, #20
700132e4:	e1a02c22 	lsr	r2, r2, #24
700132e8:	e6ef2072 	uxtb	r2, r2
700132ec:	e5c32000 	strb	r2, [r3]
700132f0:	e30b341c 	movw	r3, #46108	; 0xb41c
700132f4:	e3473002 	movt	r3, #28674	; 0x7002
700132f8:	e5933000 	ldr	r3, [r3]
700132fc:	e2832004 	add	r2, r3, #4
70013300:	e30b341c 	movw	r3, #46108	; 0xb41c
70013304:	e3473002 	movt	r3, #28674	; 0x7002
70013308:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
7001330c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013310:	e3473002 	movt	r3, #28674	; 0x7002
70013314:	e5933000 	ldr	r3, [r3]
70013318:	e3a02022 	mov	r2, #34	; 0x22
7001331c:	e5c32000 	strb	r2, [r3]
70013320:	e30b341c 	movw	r3, #46108	; 0xb41c
70013324:	e3473002 	movt	r3, #28674	; 0x7002
70013328:	e5933000 	ldr	r3, [r3]
7001332c:	e2832001 	add	r2, r3, #1
70013330:	e30b341c 	movw	r3, #46108	; 0xb41c
70013334:	e3473002 	movt	r3, #28674	; 0x7002
70013338:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
7001333c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013340:	e3473002 	movt	r3, #28674	; 0x7002
70013344:	e5933000 	ldr	r3, [r3]
70013348:	e3a02001 	mov	r2, #1
7001334c:	e5c32000 	strb	r2, [r3]
70013350:	e30b341c 	movw	r3, #46108	; 0xb41c
70013354:	e3473002 	movt	r3, #28674	; 0x7002
70013358:	e5933000 	ldr	r3, [r3]
7001335c:	e2832001 	add	r2, r3, #1
70013360:	e30b341c 	movw	r3, #46108	; 0xb41c
70013364:	e3473002 	movt	r3, #28674	; 0x7002
70013368:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
7001336c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013370:	e3473002 	movt	r3, #28674	; 0x7002
70013374:	e5933000 	ldr	r3, [r3]
70013378:	e3a02001 	mov	r2, #1
7001337c:	e5c32000 	strb	r2, [r3]
70013380:	e30b341c 	movw	r3, #46108	; 0xb41c
70013384:	e3473002 	movt	r3, #28674	; 0x7002
70013388:	e5933000 	ldr	r3, [r3]
7001338c:	e2832001 	add	r2, r3, #1
70013390:	e30b341c 	movw	r3, #46108	; 0xb41c
70013394:	e3473002 	movt	r3, #28674	; 0x7002
70013398:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
7001339c:	e30b341c 	movw	r3, #46108	; 0xb41c
700133a0:	e3473002 	movt	r3, #28674	; 0x7002
700133a4:	e5933000 	ldr	r3, [r3]
700133a8:	e3a02028 	mov	r2, #40	; 0x28
700133ac:	e5c32000 	strb	r2, [r3]
700133b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700133b4:	e3473002 	movt	r3, #28674	; 0x7002
700133b8:	e5933000 	ldr	r3, [r3]
700133bc:	e2832001 	add	r2, r3, #1
700133c0:	e30b341c 	movw	r3, #46108	; 0xb41c
700133c4:	e3473002 	movt	r3, #28674	; 0x7002
700133c8:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
700133cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700133d0:	e3473002 	movt	r3, #28674	; 0x7002
700133d4:	e5933000 	ldr	r3, [r3]
700133d8:	e3a0202f 	mov	r2, #47	; 0x2f
700133dc:	e5c32000 	strb	r2, [r3]
700133e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700133e4:	e3473002 	movt	r3, #28674	; 0x7002
700133e8:	e5933000 	ldr	r3, [r3]
700133ec:	e2832001 	add	r2, r3, #1
700133f0:	e30b341c 	movw	r3, #46108	; 0xb41c
700133f4:	e3473002 	movt	r3, #28674	; 0x7002
700133f8:	e5832000 	str	r2, [r3]

                    break;
700133fc:	ea0000fb 	b	700137f0 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
70013400:	e30b341c 	movw	r3, #46108	; 0xb41c
70013404:	e3473002 	movt	r3, #28674	; 0x7002
70013408:	e5933000 	ldr	r3, [r3]
7001340c:	e3a02026 	mov	r2, #38	; 0x26
70013410:	e5c32000 	strb	r2, [r3]
70013414:	e30b341c 	movw	r3, #46108	; 0xb41c
70013418:	e3473002 	movt	r3, #28674	; 0x7002
7001341c:	e5933000 	ldr	r3, [r3]
70013420:	e2832001 	add	r2, r3, #1
70013424:	e30b341c 	movw	r3, #46108	; 0xb41c
70013428:	e3473002 	movt	r3, #28674	; 0x7002
7001342c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
70013430:	e30b341c 	movw	r3, #46108	; 0xb41c
70013434:	e3473002 	movt	r3, #28674	; 0x7002
70013438:	e5933000 	ldr	r3, [r3]
7001343c:	e51b2018 	ldr	r2, [fp, #-24]
70013440:	e2822014 	add	r2, r2, #20
70013444:	e6ef2072 	uxtb	r2, r2
70013448:	e5c32000 	strb	r2, [r3]
7001344c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013450:	e3473002 	movt	r3, #28674	; 0x7002
70013454:	e5933000 	ldr	r3, [r3]
70013458:	e2833001 	add	r3, r3, #1
7001345c:	e51b2018 	ldr	r2, [fp, #-24]
70013460:	e2822014 	add	r2, r2, #20
70013464:	e1a02422 	lsr	r2, r2, #8
70013468:	e6ef2072 	uxtb	r2, r2
7001346c:	e5c32000 	strb	r2, [r3]
70013470:	e30b341c 	movw	r3, #46108	; 0xb41c
70013474:	e3473002 	movt	r3, #28674	; 0x7002
70013478:	e5933000 	ldr	r3, [r3]
7001347c:	e2833002 	add	r3, r3, #2
70013480:	e51b2018 	ldr	r2, [fp, #-24]
70013484:	e2822014 	add	r2, r2, #20
70013488:	e1a02822 	lsr	r2, r2, #16
7001348c:	e6ef2072 	uxtb	r2, r2
70013490:	e5c32000 	strb	r2, [r3]
70013494:	e30b341c 	movw	r3, #46108	; 0xb41c
70013498:	e3473002 	movt	r3, #28674	; 0x7002
7001349c:	e5933000 	ldr	r3, [r3]
700134a0:	e2833003 	add	r3, r3, #3
700134a4:	e51b2018 	ldr	r2, [fp, #-24]
700134a8:	e2822014 	add	r2, r2, #20
700134ac:	e1a02c22 	lsr	r2, r2, #24
700134b0:	e6ef2072 	uxtb	r2, r2
700134b4:	e5c32000 	strb	r2, [r3]
700134b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700134bc:	e3473002 	movt	r3, #28674	; 0x7002
700134c0:	e5933000 	ldr	r3, [r3]
700134c4:	e2832004 	add	r2, r3, #4
700134c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700134cc:	e3473002 	movt	r3, #28674	; 0x7002
700134d0:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
700134d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700134d8:	e3473002 	movt	r3, #28674	; 0x7002
700134dc:	e5933000 	ldr	r3, [r3]
700134e0:	e3a02023 	mov	r2, #35	; 0x23
700134e4:	e5c32000 	strb	r2, [r3]
700134e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700134ec:	e3473002 	movt	r3, #28674	; 0x7002
700134f0:	e5933000 	ldr	r3, [r3]
700134f4:	e2832001 	add	r2, r3, #1
700134f8:	e30b341c 	movw	r3, #46108	; 0xb41c
700134fc:	e3473002 	movt	r3, #28674	; 0x7002
70013500:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
70013504:	e30b341c 	movw	r3, #46108	; 0xb41c
70013508:	e3473002 	movt	r3, #28674	; 0x7002
7001350c:	e5933000 	ldr	r3, [r3]
70013510:	e3a02001 	mov	r2, #1
70013514:	e5c32000 	strb	r2, [r3]
70013518:	e30b341c 	movw	r3, #46108	; 0xb41c
7001351c:	e3473002 	movt	r3, #28674	; 0x7002
70013520:	e5933000 	ldr	r3, [r3]
70013524:	e2833001 	add	r3, r3, #1
70013528:	e3a02000 	mov	r2, #0
7001352c:	e5c32000 	strb	r2, [r3]
70013530:	e30b341c 	movw	r3, #46108	; 0xb41c
70013534:	e3473002 	movt	r3, #28674	; 0x7002
70013538:	e5933000 	ldr	r3, [r3]
7001353c:	e2832002 	add	r2, r3, #2
70013540:	e30b341c 	movw	r3, #46108	; 0xb41c
70013544:	e3473002 	movt	r3, #28674	; 0x7002
70013548:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
7001354c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013550:	e3473002 	movt	r3, #28674	; 0x7002
70013554:	e5933000 	ldr	r3, [r3]
70013558:	e3a02002 	mov	r2, #2
7001355c:	e5c32000 	strb	r2, [r3]
70013560:	e30b341c 	movw	r3, #46108	; 0xb41c
70013564:	e3473002 	movt	r3, #28674	; 0x7002
70013568:	e5933000 	ldr	r3, [r3]
7001356c:	e2832001 	add	r2, r3, #1
70013570:	e30b341c 	movw	r3, #46108	; 0xb41c
70013574:	e3473002 	movt	r3, #28674	; 0x7002
70013578:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
7001357c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013580:	e3473002 	movt	r3, #28674	; 0x7002
70013584:	e5933000 	ldr	r3, [r3]
70013588:	e3a02029 	mov	r2, #41	; 0x29
7001358c:	e5c32000 	strb	r2, [r3]
70013590:	e30b341c 	movw	r3, #46108	; 0xb41c
70013594:	e3473002 	movt	r3, #28674	; 0x7002
70013598:	e5933000 	ldr	r3, [r3]
7001359c:	e2832001 	add	r2, r3, #1
700135a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700135a4:	e3473002 	movt	r3, #28674	; 0x7002
700135a8:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
700135ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700135b0:	e3473002 	movt	r3, #28674	; 0x7002
700135b4:	e5933000 	ldr	r3, [r3]
700135b8:	e3a0202f 	mov	r2, #47	; 0x2f
700135bc:	e5c32000 	strb	r2, [r3]
700135c0:	e30b341c 	movw	r3, #46108	; 0xb41c
700135c4:	e3473002 	movt	r3, #28674	; 0x7002
700135c8:	e5933000 	ldr	r3, [r3]
700135cc:	e2832001 	add	r2, r3, #1
700135d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700135d4:	e3473002 	movt	r3, #28674	; 0x7002
700135d8:	e5832000 	str	r2, [r3]

                    break;
700135dc:	ea000083 	b	700137f0 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
700135e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700135e4:	e3473002 	movt	r3, #28674	; 0x7002
700135e8:	e5933000 	ldr	r3, [r3]
700135ec:	e3a02027 	mov	r2, #39	; 0x27
700135f0:	e5c32000 	strb	r2, [r3]
700135f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700135f8:	e3473002 	movt	r3, #28674	; 0x7002
700135fc:	e5933000 	ldr	r3, [r3]
70013600:	e2832001 	add	r2, r3, #1
70013604:	e30b341c 	movw	r3, #46108	; 0xb41c
70013608:	e3473002 	movt	r3, #28674	; 0x7002
7001360c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
70013610:	e30b341c 	movw	r3, #46108	; 0xb41c
70013614:	e3473002 	movt	r3, #28674	; 0x7002
70013618:	e5933000 	ldr	r3, [r3]
7001361c:	e51b2018 	ldr	r2, [fp, #-24]
70013620:	e2822014 	add	r2, r2, #20
70013624:	e6ef2072 	uxtb	r2, r2
70013628:	e5c32000 	strb	r2, [r3]
7001362c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013630:	e3473002 	movt	r3, #28674	; 0x7002
70013634:	e5933000 	ldr	r3, [r3]
70013638:	e2833001 	add	r3, r3, #1
7001363c:	e51b2018 	ldr	r2, [fp, #-24]
70013640:	e2822014 	add	r2, r2, #20
70013644:	e1a02422 	lsr	r2, r2, #8
70013648:	e6ef2072 	uxtb	r2, r2
7001364c:	e5c32000 	strb	r2, [r3]
70013650:	e30b341c 	movw	r3, #46108	; 0xb41c
70013654:	e3473002 	movt	r3, #28674	; 0x7002
70013658:	e5933000 	ldr	r3, [r3]
7001365c:	e2833002 	add	r3, r3, #2
70013660:	e51b2018 	ldr	r2, [fp, #-24]
70013664:	e2822014 	add	r2, r2, #20
70013668:	e1a02822 	lsr	r2, r2, #16
7001366c:	e6ef2072 	uxtb	r2, r2
70013670:	e5c32000 	strb	r2, [r3]
70013674:	e30b341c 	movw	r3, #46108	; 0xb41c
70013678:	e3473002 	movt	r3, #28674	; 0x7002
7001367c:	e5933000 	ldr	r3, [r3]
70013680:	e2833003 	add	r3, r3, #3
70013684:	e51b2018 	ldr	r2, [fp, #-24]
70013688:	e2822014 	add	r2, r2, #20
7001368c:	e1a02c22 	lsr	r2, r2, #24
70013690:	e6ef2072 	uxtb	r2, r2
70013694:	e5c32000 	strb	r2, [r3]
70013698:	e30b341c 	movw	r3, #46108	; 0xb41c
7001369c:	e3473002 	movt	r3, #28674	; 0x7002
700136a0:	e5933000 	ldr	r3, [r3]
700136a4:	e2832004 	add	r2, r3, #4
700136a8:	e30b341c 	movw	r3, #46108	; 0xb41c
700136ac:	e3473002 	movt	r3, #28674	; 0x7002
700136b0:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
700136b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700136b8:	e3473002 	movt	r3, #28674	; 0x7002
700136bc:	e5933000 	ldr	r3, [r3]
700136c0:	e3a02024 	mov	r2, #36	; 0x24
700136c4:	e5c32000 	strb	r2, [r3]
700136c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700136cc:	e3473002 	movt	r3, #28674	; 0x7002
700136d0:	e5933000 	ldr	r3, [r3]
700136d4:	e2832001 	add	r2, r3, #1
700136d8:	e30b341c 	movw	r3, #46108	; 0xb41c
700136dc:	e3473002 	movt	r3, #28674	; 0x7002
700136e0:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
700136e4:	e30b341c 	movw	r3, #46108	; 0xb41c
700136e8:	e3473002 	movt	r3, #28674	; 0x7002
700136ec:	e5933000 	ldr	r3, [r3]
700136f0:	e3a02001 	mov	r2, #1
700136f4:	e5c32000 	strb	r2, [r3]
700136f8:	e30b341c 	movw	r3, #46108	; 0xb41c
700136fc:	e3473002 	movt	r3, #28674	; 0x7002
70013700:	e5933000 	ldr	r3, [r3]
70013704:	e2833001 	add	r3, r3, #1
70013708:	e3a02000 	mov	r2, #0
7001370c:	e5c32000 	strb	r2, [r3]
70013710:	e30b341c 	movw	r3, #46108	; 0xb41c
70013714:	e3473002 	movt	r3, #28674	; 0x7002
70013718:	e5933000 	ldr	r3, [r3]
7001371c:	e2833002 	add	r3, r3, #2
70013720:	e3a02000 	mov	r2, #0
70013724:	e5c32000 	strb	r2, [r3]
70013728:	e30b341c 	movw	r3, #46108	; 0xb41c
7001372c:	e3473002 	movt	r3, #28674	; 0x7002
70013730:	e5933000 	ldr	r3, [r3]
70013734:	e2833003 	add	r3, r3, #3
70013738:	e3a02000 	mov	r2, #0
7001373c:	e5c32000 	strb	r2, [r3]
70013740:	e30b341c 	movw	r3, #46108	; 0xb41c
70013744:	e3473002 	movt	r3, #28674	; 0x7002
70013748:	e5933000 	ldr	r3, [r3]
7001374c:	e2832004 	add	r2, r3, #4
70013750:	e30b341c 	movw	r3, #46108	; 0xb41c
70013754:	e3473002 	movt	r3, #28674	; 0x7002
70013758:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
7001375c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013760:	e3473002 	movt	r3, #28674	; 0x7002
70013764:	e5933000 	ldr	r3, [r3]
70013768:	e3a02003 	mov	r2, #3
7001376c:	e5c32000 	strb	r2, [r3]
70013770:	e30b341c 	movw	r3, #46108	; 0xb41c
70013774:	e3473002 	movt	r3, #28674	; 0x7002
70013778:	e5933000 	ldr	r3, [r3]
7001377c:	e2832001 	add	r2, r3, #1
70013780:	e30b341c 	movw	r3, #46108	; 0xb41c
70013784:	e3473002 	movt	r3, #28674	; 0x7002
70013788:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
7001378c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013790:	e3473002 	movt	r3, #28674	; 0x7002
70013794:	e5933000 	ldr	r3, [r3]
70013798:	e3a0202a 	mov	r2, #42	; 0x2a
7001379c:	e5c32000 	strb	r2, [r3]
700137a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700137a4:	e3473002 	movt	r3, #28674	; 0x7002
700137a8:	e5933000 	ldr	r3, [r3]
700137ac:	e2832001 	add	r2, r3, #1
700137b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700137b4:	e3473002 	movt	r3, #28674	; 0x7002
700137b8:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
700137bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700137c0:	e3473002 	movt	r3, #28674	; 0x7002
700137c4:	e5933000 	ldr	r3, [r3]
700137c8:	e3a0202f 	mov	r2, #47	; 0x2f
700137cc:	e5c32000 	strb	r2, [r3]
700137d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700137d4:	e3473002 	movt	r3, #28674	; 0x7002
700137d8:	e5933000 	ldr	r3, [r3]
700137dc:	e2832001 	add	r2, r3, #1
700137e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700137e4:	e3473002 	movt	r3, #28674	; 0x7002
700137e8:	e5832000 	str	r2, [r3]

                    break;
700137ec:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
700137f0:	ea000627 	b	70015094 <finsh_compile+0x36cc>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
700137f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700137f8:	e5933010 	ldr	r3, [r3, #16]
700137fc:	e3530000 	cmp	r3, #0
70013800:	0a00017f 	beq	70013e04 <finsh_compile+0x243c>
70013804:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013808:	e5933010 	ldr	r3, [r3, #16]
7001380c:	e5d33000 	ldrb	r3, [r3]
70013810:	e3530001 	cmp	r3, #1
70013814:	1a00017a 	bne	70013e04 <finsh_compile+0x243c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
70013818:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001381c:	e5933010 	ldr	r3, [r3, #16]
70013820:	e5933008 	ldr	r3, [r3, #8]
70013824:	e50b301c 	str	r3, [fp, #-28]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
70013828:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001382c:	e5d33001 	ldrb	r3, [r3, #1]
70013830:	e3530002 	cmp	r3, #2
70013834:	0a000076 	beq	70013a14 <finsh_compile+0x204c>
70013838:	e3530003 	cmp	r3, #3
7001383c:	0a0000ec 	beq	70013bf4 <finsh_compile+0x222c>
70013840:	e3530001 	cmp	r3, #1
70013844:	0a000000 	beq	7001384c <finsh_compile+0x1e84>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
70013848:	ea000611 	b	70015094 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
7001384c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013850:	e3473002 	movt	r3, #28674	; 0x7002
70013854:	e5933000 	ldr	r3, [r3]
70013858:	e3a02025 	mov	r2, #37	; 0x25
7001385c:	e5c32000 	strb	r2, [r3]
70013860:	e30b341c 	movw	r3, #46108	; 0xb41c
70013864:	e3473002 	movt	r3, #28674	; 0x7002
70013868:	e5933000 	ldr	r3, [r3]
7001386c:	e2832001 	add	r2, r3, #1
70013870:	e30b341c 	movw	r3, #46108	; 0xb41c
70013874:	e3473002 	movt	r3, #28674	; 0x7002
70013878:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
7001387c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013880:	e3473002 	movt	r3, #28674	; 0x7002
70013884:	e5933000 	ldr	r3, [r3]
70013888:	e51b201c 	ldr	r2, [fp, #-28]
7001388c:	e2822014 	add	r2, r2, #20
70013890:	e6ef2072 	uxtb	r2, r2
70013894:	e5c32000 	strb	r2, [r3]
70013898:	e30b341c 	movw	r3, #46108	; 0xb41c
7001389c:	e3473002 	movt	r3, #28674	; 0x7002
700138a0:	e5933000 	ldr	r3, [r3]
700138a4:	e2833001 	add	r3, r3, #1
700138a8:	e51b201c 	ldr	r2, [fp, #-28]
700138ac:	e2822014 	add	r2, r2, #20
700138b0:	e1a02422 	lsr	r2, r2, #8
700138b4:	e6ef2072 	uxtb	r2, r2
700138b8:	e5c32000 	strb	r2, [r3]
700138bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700138c0:	e3473002 	movt	r3, #28674	; 0x7002
700138c4:	e5933000 	ldr	r3, [r3]
700138c8:	e2833002 	add	r3, r3, #2
700138cc:	e51b201c 	ldr	r2, [fp, #-28]
700138d0:	e2822014 	add	r2, r2, #20
700138d4:	e1a02822 	lsr	r2, r2, #16
700138d8:	e6ef2072 	uxtb	r2, r2
700138dc:	e5c32000 	strb	r2, [r3]
700138e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700138e4:	e3473002 	movt	r3, #28674	; 0x7002
700138e8:	e5933000 	ldr	r3, [r3]
700138ec:	e2833003 	add	r3, r3, #3
700138f0:	e51b201c 	ldr	r2, [fp, #-28]
700138f4:	e2822014 	add	r2, r2, #20
700138f8:	e1a02c22 	lsr	r2, r2, #24
700138fc:	e6ef2072 	uxtb	r2, r2
70013900:	e5c32000 	strb	r2, [r3]
70013904:	e30b341c 	movw	r3, #46108	; 0xb41c
70013908:	e3473002 	movt	r3, #28674	; 0x7002
7001390c:	e5933000 	ldr	r3, [r3]
70013910:	e2832004 	add	r2, r3, #4
70013914:	e30b341c 	movw	r3, #46108	; 0xb41c
70013918:	e3473002 	movt	r3, #28674	; 0x7002
7001391c:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
70013920:	e30b341c 	movw	r3, #46108	; 0xb41c
70013924:	e3473002 	movt	r3, #28674	; 0x7002
70013928:	e5933000 	ldr	r3, [r3]
7001392c:	e3a02022 	mov	r2, #34	; 0x22
70013930:	e5c32000 	strb	r2, [r3]
70013934:	e30b341c 	movw	r3, #46108	; 0xb41c
70013938:	e3473002 	movt	r3, #28674	; 0x7002
7001393c:	e5933000 	ldr	r3, [r3]
70013940:	e2832001 	add	r2, r3, #1
70013944:	e30b341c 	movw	r3, #46108	; 0xb41c
70013948:	e3473002 	movt	r3, #28674	; 0x7002
7001394c:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
70013950:	e30b341c 	movw	r3, #46108	; 0xb41c
70013954:	e3473002 	movt	r3, #28674	; 0x7002
70013958:	e5933000 	ldr	r3, [r3]
7001395c:	e3a02001 	mov	r2, #1
70013960:	e5c32000 	strb	r2, [r3]
70013964:	e30b341c 	movw	r3, #46108	; 0xb41c
70013968:	e3473002 	movt	r3, #28674	; 0x7002
7001396c:	e5933000 	ldr	r3, [r3]
70013970:	e2832001 	add	r2, r3, #1
70013974:	e30b341c 	movw	r3, #46108	; 0xb41c
70013978:	e3473002 	movt	r3, #28674	; 0x7002
7001397c:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
70013980:	e30b341c 	movw	r3, #46108	; 0xb41c
70013984:	e3473002 	movt	r3, #28674	; 0x7002
70013988:	e5933000 	ldr	r3, [r3]
7001398c:	e3a02004 	mov	r2, #4
70013990:	e5c32000 	strb	r2, [r3]
70013994:	e30b341c 	movw	r3, #46108	; 0xb41c
70013998:	e3473002 	movt	r3, #28674	; 0x7002
7001399c:	e5933000 	ldr	r3, [r3]
700139a0:	e2832001 	add	r2, r3, #1
700139a4:	e30b341c 	movw	r3, #46108	; 0xb41c
700139a8:	e3473002 	movt	r3, #28674	; 0x7002
700139ac:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
700139b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700139b4:	e3473002 	movt	r3, #28674	; 0x7002
700139b8:	e5933000 	ldr	r3, [r3]
700139bc:	e3a02028 	mov	r2, #40	; 0x28
700139c0:	e5c32000 	strb	r2, [r3]
700139c4:	e30b341c 	movw	r3, #46108	; 0xb41c
700139c8:	e3473002 	movt	r3, #28674	; 0x7002
700139cc:	e5933000 	ldr	r3, [r3]
700139d0:	e2832001 	add	r2, r3, #1
700139d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700139d8:	e3473002 	movt	r3, #28674	; 0x7002
700139dc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
700139e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700139e4:	e3473002 	movt	r3, #28674	; 0x7002
700139e8:	e5933000 	ldr	r3, [r3]
700139ec:	e3a0202f 	mov	r2, #47	; 0x2f
700139f0:	e5c32000 	strb	r2, [r3]
700139f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700139f8:	e3473002 	movt	r3, #28674	; 0x7002
700139fc:	e5933000 	ldr	r3, [r3]
70013a00:	e2832001 	add	r2, r3, #1
70013a04:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a08:	e3473002 	movt	r3, #28674	; 0x7002
70013a0c:	e5832000 	str	r2, [r3]

                    break;
70013a10:	ea0000fb 	b	70013e04 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
70013a14:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a18:	e3473002 	movt	r3, #28674	; 0x7002
70013a1c:	e5933000 	ldr	r3, [r3]
70013a20:	e3a02026 	mov	r2, #38	; 0x26
70013a24:	e5c32000 	strb	r2, [r3]
70013a28:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a2c:	e3473002 	movt	r3, #28674	; 0x7002
70013a30:	e5933000 	ldr	r3, [r3]
70013a34:	e2832001 	add	r2, r3, #1
70013a38:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a3c:	e3473002 	movt	r3, #28674	; 0x7002
70013a40:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
70013a44:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a48:	e3473002 	movt	r3, #28674	; 0x7002
70013a4c:	e5933000 	ldr	r3, [r3]
70013a50:	e51b201c 	ldr	r2, [fp, #-28]
70013a54:	e2822014 	add	r2, r2, #20
70013a58:	e6ef2072 	uxtb	r2, r2
70013a5c:	e5c32000 	strb	r2, [r3]
70013a60:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a64:	e3473002 	movt	r3, #28674	; 0x7002
70013a68:	e5933000 	ldr	r3, [r3]
70013a6c:	e2833001 	add	r3, r3, #1
70013a70:	e51b201c 	ldr	r2, [fp, #-28]
70013a74:	e2822014 	add	r2, r2, #20
70013a78:	e1a02422 	lsr	r2, r2, #8
70013a7c:	e6ef2072 	uxtb	r2, r2
70013a80:	e5c32000 	strb	r2, [r3]
70013a84:	e30b341c 	movw	r3, #46108	; 0xb41c
70013a88:	e3473002 	movt	r3, #28674	; 0x7002
70013a8c:	e5933000 	ldr	r3, [r3]
70013a90:	e2833002 	add	r3, r3, #2
70013a94:	e51b201c 	ldr	r2, [fp, #-28]
70013a98:	e2822014 	add	r2, r2, #20
70013a9c:	e1a02822 	lsr	r2, r2, #16
70013aa0:	e6ef2072 	uxtb	r2, r2
70013aa4:	e5c32000 	strb	r2, [r3]
70013aa8:	e30b341c 	movw	r3, #46108	; 0xb41c
70013aac:	e3473002 	movt	r3, #28674	; 0x7002
70013ab0:	e5933000 	ldr	r3, [r3]
70013ab4:	e2833003 	add	r3, r3, #3
70013ab8:	e51b201c 	ldr	r2, [fp, #-28]
70013abc:	e2822014 	add	r2, r2, #20
70013ac0:	e1a02c22 	lsr	r2, r2, #24
70013ac4:	e6ef2072 	uxtb	r2, r2
70013ac8:	e5c32000 	strb	r2, [r3]
70013acc:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ad0:	e3473002 	movt	r3, #28674	; 0x7002
70013ad4:	e5933000 	ldr	r3, [r3]
70013ad8:	e2832004 	add	r2, r3, #4
70013adc:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ae0:	e3473002 	movt	r3, #28674	; 0x7002
70013ae4:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
70013ae8:	e30b341c 	movw	r3, #46108	; 0xb41c
70013aec:	e3473002 	movt	r3, #28674	; 0x7002
70013af0:	e5933000 	ldr	r3, [r3]
70013af4:	e3a02023 	mov	r2, #35	; 0x23
70013af8:	e5c32000 	strb	r2, [r3]
70013afc:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b00:	e3473002 	movt	r3, #28674	; 0x7002
70013b04:	e5933000 	ldr	r3, [r3]
70013b08:	e2832001 	add	r2, r3, #1
70013b0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b10:	e3473002 	movt	r3, #28674	; 0x7002
70013b14:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
70013b18:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b1c:	e3473002 	movt	r3, #28674	; 0x7002
70013b20:	e5933000 	ldr	r3, [r3]
70013b24:	e3a02001 	mov	r2, #1
70013b28:	e5c32000 	strb	r2, [r3]
70013b2c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b30:	e3473002 	movt	r3, #28674	; 0x7002
70013b34:	e5933000 	ldr	r3, [r3]
70013b38:	e2833001 	add	r3, r3, #1
70013b3c:	e3a02000 	mov	r2, #0
70013b40:	e5c32000 	strb	r2, [r3]
70013b44:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b48:	e3473002 	movt	r3, #28674	; 0x7002
70013b4c:	e5933000 	ldr	r3, [r3]
70013b50:	e2832002 	add	r2, r3, #2
70013b54:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b58:	e3473002 	movt	r3, #28674	; 0x7002
70013b5c:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
70013b60:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b64:	e3473002 	movt	r3, #28674	; 0x7002
70013b68:	e5933000 	ldr	r3, [r3]
70013b6c:	e3a02005 	mov	r2, #5
70013b70:	e5c32000 	strb	r2, [r3]
70013b74:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b78:	e3473002 	movt	r3, #28674	; 0x7002
70013b7c:	e5933000 	ldr	r3, [r3]
70013b80:	e2832001 	add	r2, r3, #1
70013b84:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b88:	e3473002 	movt	r3, #28674	; 0x7002
70013b8c:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
70013b90:	e30b341c 	movw	r3, #46108	; 0xb41c
70013b94:	e3473002 	movt	r3, #28674	; 0x7002
70013b98:	e5933000 	ldr	r3, [r3]
70013b9c:	e3a02029 	mov	r2, #41	; 0x29
70013ba0:	e5c32000 	strb	r2, [r3]
70013ba4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ba8:	e3473002 	movt	r3, #28674	; 0x7002
70013bac:	e5933000 	ldr	r3, [r3]
70013bb0:	e2832001 	add	r2, r3, #1
70013bb4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013bb8:	e3473002 	movt	r3, #28674	; 0x7002
70013bbc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
70013bc0:	e30b341c 	movw	r3, #46108	; 0xb41c
70013bc4:	e3473002 	movt	r3, #28674	; 0x7002
70013bc8:	e5933000 	ldr	r3, [r3]
70013bcc:	e3a0202f 	mov	r2, #47	; 0x2f
70013bd0:	e5c32000 	strb	r2, [r3]
70013bd4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013bd8:	e3473002 	movt	r3, #28674	; 0x7002
70013bdc:	e5933000 	ldr	r3, [r3]
70013be0:	e2832001 	add	r2, r3, #1
70013be4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013be8:	e3473002 	movt	r3, #28674	; 0x7002
70013bec:	e5832000 	str	r2, [r3]

                    break;
70013bf0:	ea000083 	b	70013e04 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
70013bf4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013bf8:	e3473002 	movt	r3, #28674	; 0x7002
70013bfc:	e5933000 	ldr	r3, [r3]
70013c00:	e3a02027 	mov	r2, #39	; 0x27
70013c04:	e5c32000 	strb	r2, [r3]
70013c08:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c0c:	e3473002 	movt	r3, #28674	; 0x7002
70013c10:	e5933000 	ldr	r3, [r3]
70013c14:	e2832001 	add	r2, r3, #1
70013c18:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c1c:	e3473002 	movt	r3, #28674	; 0x7002
70013c20:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
70013c24:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c28:	e3473002 	movt	r3, #28674	; 0x7002
70013c2c:	e5933000 	ldr	r3, [r3]
70013c30:	e51b201c 	ldr	r2, [fp, #-28]
70013c34:	e2822014 	add	r2, r2, #20
70013c38:	e6ef2072 	uxtb	r2, r2
70013c3c:	e5c32000 	strb	r2, [r3]
70013c40:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c44:	e3473002 	movt	r3, #28674	; 0x7002
70013c48:	e5933000 	ldr	r3, [r3]
70013c4c:	e2833001 	add	r3, r3, #1
70013c50:	e51b201c 	ldr	r2, [fp, #-28]
70013c54:	e2822014 	add	r2, r2, #20
70013c58:	e1a02422 	lsr	r2, r2, #8
70013c5c:	e6ef2072 	uxtb	r2, r2
70013c60:	e5c32000 	strb	r2, [r3]
70013c64:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c68:	e3473002 	movt	r3, #28674	; 0x7002
70013c6c:	e5933000 	ldr	r3, [r3]
70013c70:	e2833002 	add	r3, r3, #2
70013c74:	e51b201c 	ldr	r2, [fp, #-28]
70013c78:	e2822014 	add	r2, r2, #20
70013c7c:	e1a02822 	lsr	r2, r2, #16
70013c80:	e6ef2072 	uxtb	r2, r2
70013c84:	e5c32000 	strb	r2, [r3]
70013c88:	e30b341c 	movw	r3, #46108	; 0xb41c
70013c8c:	e3473002 	movt	r3, #28674	; 0x7002
70013c90:	e5933000 	ldr	r3, [r3]
70013c94:	e2833003 	add	r3, r3, #3
70013c98:	e51b201c 	ldr	r2, [fp, #-28]
70013c9c:	e2822014 	add	r2, r2, #20
70013ca0:	e1a02c22 	lsr	r2, r2, #24
70013ca4:	e6ef2072 	uxtb	r2, r2
70013ca8:	e5c32000 	strb	r2, [r3]
70013cac:	e30b341c 	movw	r3, #46108	; 0xb41c
70013cb0:	e3473002 	movt	r3, #28674	; 0x7002
70013cb4:	e5933000 	ldr	r3, [r3]
70013cb8:	e2832004 	add	r2, r3, #4
70013cbc:	e30b341c 	movw	r3, #46108	; 0xb41c
70013cc0:	e3473002 	movt	r3, #28674	; 0x7002
70013cc4:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70013cc8:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ccc:	e3473002 	movt	r3, #28674	; 0x7002
70013cd0:	e5933000 	ldr	r3, [r3]
70013cd4:	e3a02024 	mov	r2, #36	; 0x24
70013cd8:	e5c32000 	strb	r2, [r3]
70013cdc:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ce0:	e3473002 	movt	r3, #28674	; 0x7002
70013ce4:	e5933000 	ldr	r3, [r3]
70013ce8:	e2832001 	add	r2, r3, #1
70013cec:	e30b341c 	movw	r3, #46108	; 0xb41c
70013cf0:	e3473002 	movt	r3, #28674	; 0x7002
70013cf4:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
70013cf8:	e30b341c 	movw	r3, #46108	; 0xb41c
70013cfc:	e3473002 	movt	r3, #28674	; 0x7002
70013d00:	e5933000 	ldr	r3, [r3]
70013d04:	e3a02001 	mov	r2, #1
70013d08:	e5c32000 	strb	r2, [r3]
70013d0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d10:	e3473002 	movt	r3, #28674	; 0x7002
70013d14:	e5933000 	ldr	r3, [r3]
70013d18:	e2833001 	add	r3, r3, #1
70013d1c:	e3a02000 	mov	r2, #0
70013d20:	e5c32000 	strb	r2, [r3]
70013d24:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d28:	e3473002 	movt	r3, #28674	; 0x7002
70013d2c:	e5933000 	ldr	r3, [r3]
70013d30:	e2833002 	add	r3, r3, #2
70013d34:	e3a02000 	mov	r2, #0
70013d38:	e5c32000 	strb	r2, [r3]
70013d3c:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d40:	e3473002 	movt	r3, #28674	; 0x7002
70013d44:	e5933000 	ldr	r3, [r3]
70013d48:	e2833003 	add	r3, r3, #3
70013d4c:	e3a02000 	mov	r2, #0
70013d50:	e5c32000 	strb	r2, [r3]
70013d54:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d58:	e3473002 	movt	r3, #28674	; 0x7002
70013d5c:	e5933000 	ldr	r3, [r3]
70013d60:	e2832004 	add	r2, r3, #4
70013d64:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d68:	e3473002 	movt	r3, #28674	; 0x7002
70013d6c:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
70013d70:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d74:	e3473002 	movt	r3, #28674	; 0x7002
70013d78:	e5933000 	ldr	r3, [r3]
70013d7c:	e3a02006 	mov	r2, #6
70013d80:	e5c32000 	strb	r2, [r3]
70013d84:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d88:	e3473002 	movt	r3, #28674	; 0x7002
70013d8c:	e5933000 	ldr	r3, [r3]
70013d90:	e2832001 	add	r2, r3, #1
70013d94:	e30b341c 	movw	r3, #46108	; 0xb41c
70013d98:	e3473002 	movt	r3, #28674	; 0x7002
70013d9c:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
70013da0:	e30b341c 	movw	r3, #46108	; 0xb41c
70013da4:	e3473002 	movt	r3, #28674	; 0x7002
70013da8:	e5933000 	ldr	r3, [r3]
70013dac:	e3a0202a 	mov	r2, #42	; 0x2a
70013db0:	e5c32000 	strb	r2, [r3]
70013db4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013db8:	e3473002 	movt	r3, #28674	; 0x7002
70013dbc:	e5933000 	ldr	r3, [r3]
70013dc0:	e2832001 	add	r2, r3, #1
70013dc4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013dc8:	e3473002 	movt	r3, #28674	; 0x7002
70013dcc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
70013dd0:	e30b341c 	movw	r3, #46108	; 0xb41c
70013dd4:	e3473002 	movt	r3, #28674	; 0x7002
70013dd8:	e5933000 	ldr	r3, [r3]
70013ddc:	e3a0202f 	mov	r2, #47	; 0x2f
70013de0:	e5c32000 	strb	r2, [r3]
70013de4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013de8:	e3473002 	movt	r3, #28674	; 0x7002
70013dec:	e5933000 	ldr	r3, [r3]
70013df0:	e2832001 	add	r2, r3, #1
70013df4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013df8:	e3473002 	movt	r3, #28674	; 0x7002
70013dfc:	e5832000 	str	r2, [r3]

                    break;
70013e00:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
70013e04:	ea0004a2 	b	70015094 <finsh_compile+0x36cc>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
70013e08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013e0c:	e5933010 	ldr	r3, [r3, #16]
70013e10:	e3530000 	cmp	r3, #0
70013e14:	0a00021e 	beq	70014694 <finsh_compile+0x2ccc>
70013e18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013e1c:	e5933010 	ldr	r3, [r3, #16]
70013e20:	e5d33000 	ldrb	r3, [r3]
70013e24:	e3530001 	cmp	r3, #1
70013e28:	1a000219 	bne	70014694 <finsh_compile+0x2ccc>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
70013e2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013e30:	e5933010 	ldr	r3, [r3, #16]
70013e34:	e5933008 	ldr	r3, [r3, #8]
70013e38:	e50b3020 	str	r3, [fp, #-32]

                switch (node->data_type)
70013e3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70013e40:	e5d33001 	ldrb	r3, [r3, #1]
70013e44:	e3530002 	cmp	r3, #2
70013e48:	0a0000ab 	beq	700140fc <finsh_compile+0x2734>
70013e4c:	e3530003 	cmp	r3, #3
70013e50:	0a000156 	beq	700143b0 <finsh_compile+0x29e8>
70013e54:	e3530001 	cmp	r3, #1
70013e58:	0a000000 	beq	70013e60 <finsh_compile+0x2498>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
70013e5c:	ea00048c 	b	70015094 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70013e60:	e30b341c 	movw	r3, #46108	; 0xb41c
70013e64:	e3473002 	movt	r3, #28674	; 0x7002
70013e68:	e5933000 	ldr	r3, [r3]
70013e6c:	e3a02024 	mov	r2, #36	; 0x24
70013e70:	e5c32000 	strb	r2, [r3]
70013e74:	e30b341c 	movw	r3, #46108	; 0xb41c
70013e78:	e3473002 	movt	r3, #28674	; 0x7002
70013e7c:	e5933000 	ldr	r3, [r3]
70013e80:	e2832001 	add	r2, r3, #1
70013e84:	e30b341c 	movw	r3, #46108	; 0xb41c
70013e88:	e3473002 	movt	r3, #28674	; 0x7002
70013e8c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
70013e90:	e30b341c 	movw	r3, #46108	; 0xb41c
70013e94:	e3473002 	movt	r3, #28674	; 0x7002
70013e98:	e5933000 	ldr	r3, [r3]
70013e9c:	e51b2020 	ldr	r2, [fp, #-32]
70013ea0:	e2822014 	add	r2, r2, #20
70013ea4:	e6ef2072 	uxtb	r2, r2
70013ea8:	e5c32000 	strb	r2, [r3]
70013eac:	e30b341c 	movw	r3, #46108	; 0xb41c
70013eb0:	e3473002 	movt	r3, #28674	; 0x7002
70013eb4:	e5933000 	ldr	r3, [r3]
70013eb8:	e2833001 	add	r3, r3, #1
70013ebc:	e51b2020 	ldr	r2, [fp, #-32]
70013ec0:	e2822014 	add	r2, r2, #20
70013ec4:	e1a02422 	lsr	r2, r2, #8
70013ec8:	e6ef2072 	uxtb	r2, r2
70013ecc:	e5c32000 	strb	r2, [r3]
70013ed0:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ed4:	e3473002 	movt	r3, #28674	; 0x7002
70013ed8:	e5933000 	ldr	r3, [r3]
70013edc:	e2833002 	add	r3, r3, #2
70013ee0:	e51b2020 	ldr	r2, [fp, #-32]
70013ee4:	e2822014 	add	r2, r2, #20
70013ee8:	e1a02822 	lsr	r2, r2, #16
70013eec:	e6ef2072 	uxtb	r2, r2
70013ef0:	e5c32000 	strb	r2, [r3]
70013ef4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ef8:	e3473002 	movt	r3, #28674	; 0x7002
70013efc:	e5933000 	ldr	r3, [r3]
70013f00:	e2833003 	add	r3, r3, #3
70013f04:	e51b2020 	ldr	r2, [fp, #-32]
70013f08:	e2822014 	add	r2, r2, #20
70013f0c:	e1a02c22 	lsr	r2, r2, #24
70013f10:	e6ef2072 	uxtb	r2, r2
70013f14:	e5c32000 	strb	r2, [r3]
70013f18:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f1c:	e3473002 	movt	r3, #28674	; 0x7002
70013f20:	e5933000 	ldr	r3, [r3]
70013f24:	e2832004 	add	r2, r3, #4
70013f28:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f2c:	e3473002 	movt	r3, #28674	; 0x7002
70013f30:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
70013f34:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f38:	e3473002 	movt	r3, #28674	; 0x7002
70013f3c:	e5933000 	ldr	r3, [r3]
70013f40:	e3a02025 	mov	r2, #37	; 0x25
70013f44:	e5c32000 	strb	r2, [r3]
70013f48:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f4c:	e3473002 	movt	r3, #28674	; 0x7002
70013f50:	e5933000 	ldr	r3, [r3]
70013f54:	e2832001 	add	r2, r3, #1
70013f58:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f5c:	e3473002 	movt	r3, #28674	; 0x7002
70013f60:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
70013f64:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f68:	e3473002 	movt	r3, #28674	; 0x7002
70013f6c:	e5933000 	ldr	r3, [r3]
70013f70:	e51b2020 	ldr	r2, [fp, #-32]
70013f74:	e2822014 	add	r2, r2, #20
70013f78:	e6ef2072 	uxtb	r2, r2
70013f7c:	e5c32000 	strb	r2, [r3]
70013f80:	e30b341c 	movw	r3, #46108	; 0xb41c
70013f84:	e3473002 	movt	r3, #28674	; 0x7002
70013f88:	e5933000 	ldr	r3, [r3]
70013f8c:	e2833001 	add	r3, r3, #1
70013f90:	e51b2020 	ldr	r2, [fp, #-32]
70013f94:	e2822014 	add	r2, r2, #20
70013f98:	e1a02422 	lsr	r2, r2, #8
70013f9c:	e6ef2072 	uxtb	r2, r2
70013fa0:	e5c32000 	strb	r2, [r3]
70013fa4:	e30b341c 	movw	r3, #46108	; 0xb41c
70013fa8:	e3473002 	movt	r3, #28674	; 0x7002
70013fac:	e5933000 	ldr	r3, [r3]
70013fb0:	e2833002 	add	r3, r3, #2
70013fb4:	e51b2020 	ldr	r2, [fp, #-32]
70013fb8:	e2822014 	add	r2, r2, #20
70013fbc:	e1a02822 	lsr	r2, r2, #16
70013fc0:	e6ef2072 	uxtb	r2, r2
70013fc4:	e5c32000 	strb	r2, [r3]
70013fc8:	e30b341c 	movw	r3, #46108	; 0xb41c
70013fcc:	e3473002 	movt	r3, #28674	; 0x7002
70013fd0:	e5933000 	ldr	r3, [r3]
70013fd4:	e2833003 	add	r3, r3, #3
70013fd8:	e51b2020 	ldr	r2, [fp, #-32]
70013fdc:	e2822014 	add	r2, r2, #20
70013fe0:	e1a02c22 	lsr	r2, r2, #24
70013fe4:	e6ef2072 	uxtb	r2, r2
70013fe8:	e5c32000 	strb	r2, [r3]
70013fec:	e30b341c 	movw	r3, #46108	; 0xb41c
70013ff0:	e3473002 	movt	r3, #28674	; 0x7002
70013ff4:	e5933000 	ldr	r3, [r3]
70013ff8:	e2832004 	add	r2, r3, #4
70013ffc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014000:	e3473002 	movt	r3, #28674	; 0x7002
70014004:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
70014008:	e30b341c 	movw	r3, #46108	; 0xb41c
7001400c:	e3473002 	movt	r3, #28674	; 0x7002
70014010:	e5933000 	ldr	r3, [r3]
70014014:	e3a02022 	mov	r2, #34	; 0x22
70014018:	e5c32000 	strb	r2, [r3]
7001401c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014020:	e3473002 	movt	r3, #28674	; 0x7002
70014024:	e5933000 	ldr	r3, [r3]
70014028:	e2832001 	add	r2, r3, #1
7001402c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014030:	e3473002 	movt	r3, #28674	; 0x7002
70014034:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
70014038:	e30b341c 	movw	r3, #46108	; 0xb41c
7001403c:	e3473002 	movt	r3, #28674	; 0x7002
70014040:	e5933000 	ldr	r3, [r3]
70014044:	e3a02001 	mov	r2, #1
70014048:	e5c32000 	strb	r2, [r3]
7001404c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014050:	e3473002 	movt	r3, #28674	; 0x7002
70014054:	e5933000 	ldr	r3, [r3]
70014058:	e2832001 	add	r2, r3, #1
7001405c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014060:	e3473002 	movt	r3, #28674	; 0x7002
70014064:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
70014068:	e30b341c 	movw	r3, #46108	; 0xb41c
7001406c:	e3473002 	movt	r3, #28674	; 0x7002
70014070:	e5933000 	ldr	r3, [r3]
70014074:	e3a02001 	mov	r2, #1
70014078:	e5c32000 	strb	r2, [r3]
7001407c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014080:	e3473002 	movt	r3, #28674	; 0x7002
70014084:	e5933000 	ldr	r3, [r3]
70014088:	e2832001 	add	r2, r3, #1
7001408c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014090:	e3473002 	movt	r3, #28674	; 0x7002
70014094:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
70014098:	e30b341c 	movw	r3, #46108	; 0xb41c
7001409c:	e3473002 	movt	r3, #28674	; 0x7002
700140a0:	e5933000 	ldr	r3, [r3]
700140a4:	e3a02028 	mov	r2, #40	; 0x28
700140a8:	e5c32000 	strb	r2, [r3]
700140ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700140b0:	e3473002 	movt	r3, #28674	; 0x7002
700140b4:	e5933000 	ldr	r3, [r3]
700140b8:	e2832001 	add	r2, r3, #1
700140bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700140c0:	e3473002 	movt	r3, #28674	; 0x7002
700140c4:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
700140c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700140cc:	e3473002 	movt	r3, #28674	; 0x7002
700140d0:	e5933000 	ldr	r3, [r3]
700140d4:	e3a0202b 	mov	r2, #43	; 0x2b
700140d8:	e5c32000 	strb	r2, [r3]
700140dc:	e30b341c 	movw	r3, #46108	; 0xb41c
700140e0:	e3473002 	movt	r3, #28674	; 0x7002
700140e4:	e5933000 	ldr	r3, [r3]
700140e8:	e2832001 	add	r2, r3, #1
700140ec:	e30b341c 	movw	r3, #46108	; 0xb41c
700140f0:	e3473002 	movt	r3, #28674	; 0x7002
700140f4:	e5832000 	str	r2, [r3]
                    break;
700140f8:	ea000165 	b	70014694 <finsh_compile+0x2ccc>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
700140fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014100:	e3473002 	movt	r3, #28674	; 0x7002
70014104:	e5933000 	ldr	r3, [r3]
70014108:	e3a02024 	mov	r2, #36	; 0x24
7001410c:	e5c32000 	strb	r2, [r3]
70014110:	e30b341c 	movw	r3, #46108	; 0xb41c
70014114:	e3473002 	movt	r3, #28674	; 0x7002
70014118:	e5933000 	ldr	r3, [r3]
7001411c:	e2832001 	add	r2, r3, #1
70014120:	e30b341c 	movw	r3, #46108	; 0xb41c
70014124:	e3473002 	movt	r3, #28674	; 0x7002
70014128:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
7001412c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014130:	e3473002 	movt	r3, #28674	; 0x7002
70014134:	e5933000 	ldr	r3, [r3]
70014138:	e51b2020 	ldr	r2, [fp, #-32]
7001413c:	e2822014 	add	r2, r2, #20
70014140:	e6ef2072 	uxtb	r2, r2
70014144:	e5c32000 	strb	r2, [r3]
70014148:	e30b341c 	movw	r3, #46108	; 0xb41c
7001414c:	e3473002 	movt	r3, #28674	; 0x7002
70014150:	e5933000 	ldr	r3, [r3]
70014154:	e2833001 	add	r3, r3, #1
70014158:	e51b2020 	ldr	r2, [fp, #-32]
7001415c:	e2822014 	add	r2, r2, #20
70014160:	e1a02422 	lsr	r2, r2, #8
70014164:	e6ef2072 	uxtb	r2, r2
70014168:	e5c32000 	strb	r2, [r3]
7001416c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014170:	e3473002 	movt	r3, #28674	; 0x7002
70014174:	e5933000 	ldr	r3, [r3]
70014178:	e2833002 	add	r3, r3, #2
7001417c:	e51b2020 	ldr	r2, [fp, #-32]
70014180:	e2822014 	add	r2, r2, #20
70014184:	e1a02822 	lsr	r2, r2, #16
70014188:	e6ef2072 	uxtb	r2, r2
7001418c:	e5c32000 	strb	r2, [r3]
70014190:	e30b341c 	movw	r3, #46108	; 0xb41c
70014194:	e3473002 	movt	r3, #28674	; 0x7002
70014198:	e5933000 	ldr	r3, [r3]
7001419c:	e2833003 	add	r3, r3, #3
700141a0:	e51b2020 	ldr	r2, [fp, #-32]
700141a4:	e2822014 	add	r2, r2, #20
700141a8:	e1a02c22 	lsr	r2, r2, #24
700141ac:	e6ef2072 	uxtb	r2, r2
700141b0:	e5c32000 	strb	r2, [r3]
700141b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700141b8:	e3473002 	movt	r3, #28674	; 0x7002
700141bc:	e5933000 	ldr	r3, [r3]
700141c0:	e2832004 	add	r2, r3, #4
700141c4:	e30b341c 	movw	r3, #46108	; 0xb41c
700141c8:	e3473002 	movt	r3, #28674	; 0x7002
700141cc:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
700141d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700141d4:	e3473002 	movt	r3, #28674	; 0x7002
700141d8:	e5933000 	ldr	r3, [r3]
700141dc:	e3a02026 	mov	r2, #38	; 0x26
700141e0:	e5c32000 	strb	r2, [r3]
700141e4:	e30b341c 	movw	r3, #46108	; 0xb41c
700141e8:	e3473002 	movt	r3, #28674	; 0x7002
700141ec:	e5933000 	ldr	r3, [r3]
700141f0:	e2832001 	add	r2, r3, #1
700141f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700141f8:	e3473002 	movt	r3, #28674	; 0x7002
700141fc:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
70014200:	e30b341c 	movw	r3, #46108	; 0xb41c
70014204:	e3473002 	movt	r3, #28674	; 0x7002
70014208:	e5933000 	ldr	r3, [r3]
7001420c:	e51b2020 	ldr	r2, [fp, #-32]
70014210:	e2822014 	add	r2, r2, #20
70014214:	e6ef2072 	uxtb	r2, r2
70014218:	e5c32000 	strb	r2, [r3]
7001421c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014220:	e3473002 	movt	r3, #28674	; 0x7002
70014224:	e5933000 	ldr	r3, [r3]
70014228:	e2833001 	add	r3, r3, #1
7001422c:	e51b2020 	ldr	r2, [fp, #-32]
70014230:	e2822014 	add	r2, r2, #20
70014234:	e1a02422 	lsr	r2, r2, #8
70014238:	e6ef2072 	uxtb	r2, r2
7001423c:	e5c32000 	strb	r2, [r3]
70014240:	e30b341c 	movw	r3, #46108	; 0xb41c
70014244:	e3473002 	movt	r3, #28674	; 0x7002
70014248:	e5933000 	ldr	r3, [r3]
7001424c:	e2833002 	add	r3, r3, #2
70014250:	e51b2020 	ldr	r2, [fp, #-32]
70014254:	e2822014 	add	r2, r2, #20
70014258:	e1a02822 	lsr	r2, r2, #16
7001425c:	e6ef2072 	uxtb	r2, r2
70014260:	e5c32000 	strb	r2, [r3]
70014264:	e30b341c 	movw	r3, #46108	; 0xb41c
70014268:	e3473002 	movt	r3, #28674	; 0x7002
7001426c:	e5933000 	ldr	r3, [r3]
70014270:	e2833003 	add	r3, r3, #3
70014274:	e51b2020 	ldr	r2, [fp, #-32]
70014278:	e2822014 	add	r2, r2, #20
7001427c:	e1a02c22 	lsr	r2, r2, #24
70014280:	e6ef2072 	uxtb	r2, r2
70014284:	e5c32000 	strb	r2, [r3]
70014288:	e30b341c 	movw	r3, #46108	; 0xb41c
7001428c:	e3473002 	movt	r3, #28674	; 0x7002
70014290:	e5933000 	ldr	r3, [r3]
70014294:	e2832004 	add	r2, r3, #4
70014298:	e30b341c 	movw	r3, #46108	; 0xb41c
7001429c:	e3473002 	movt	r3, #28674	; 0x7002
700142a0:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
700142a4:	e30b341c 	movw	r3, #46108	; 0xb41c
700142a8:	e3473002 	movt	r3, #28674	; 0x7002
700142ac:	e5933000 	ldr	r3, [r3]
700142b0:	e3a02023 	mov	r2, #35	; 0x23
700142b4:	e5c32000 	strb	r2, [r3]
700142b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700142bc:	e3473002 	movt	r3, #28674	; 0x7002
700142c0:	e5933000 	ldr	r3, [r3]
700142c4:	e2832001 	add	r2, r3, #1
700142c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700142cc:	e3473002 	movt	r3, #28674	; 0x7002
700142d0:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
700142d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700142d8:	e3473002 	movt	r3, #28674	; 0x7002
700142dc:	e5933000 	ldr	r3, [r3]
700142e0:	e3a02001 	mov	r2, #1
700142e4:	e5c32000 	strb	r2, [r3]
700142e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700142ec:	e3473002 	movt	r3, #28674	; 0x7002
700142f0:	e5933000 	ldr	r3, [r3]
700142f4:	e2833001 	add	r3, r3, #1
700142f8:	e3a02000 	mov	r2, #0
700142fc:	e5c32000 	strb	r2, [r3]
70014300:	e30b341c 	movw	r3, #46108	; 0xb41c
70014304:	e3473002 	movt	r3, #28674	; 0x7002
70014308:	e5933000 	ldr	r3, [r3]
7001430c:	e2832002 	add	r2, r3, #2
70014310:	e30b341c 	movw	r3, #46108	; 0xb41c
70014314:	e3473002 	movt	r3, #28674	; 0x7002
70014318:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
7001431c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014320:	e3473002 	movt	r3, #28674	; 0x7002
70014324:	e5933000 	ldr	r3, [r3]
70014328:	e3a02002 	mov	r2, #2
7001432c:	e5c32000 	strb	r2, [r3]
70014330:	e30b341c 	movw	r3, #46108	; 0xb41c
70014334:	e3473002 	movt	r3, #28674	; 0x7002
70014338:	e5933000 	ldr	r3, [r3]
7001433c:	e2832001 	add	r2, r3, #1
70014340:	e30b341c 	movw	r3, #46108	; 0xb41c
70014344:	e3473002 	movt	r3, #28674	; 0x7002
70014348:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
7001434c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014350:	e3473002 	movt	r3, #28674	; 0x7002
70014354:	e5933000 	ldr	r3, [r3]
70014358:	e3a02029 	mov	r2, #41	; 0x29
7001435c:	e5c32000 	strb	r2, [r3]
70014360:	e30b341c 	movw	r3, #46108	; 0xb41c
70014364:	e3473002 	movt	r3, #28674	; 0x7002
70014368:	e5933000 	ldr	r3, [r3]
7001436c:	e2832001 	add	r2, r3, #1
70014370:	e30b341c 	movw	r3, #46108	; 0xb41c
70014374:	e3473002 	movt	r3, #28674	; 0x7002
70014378:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
7001437c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014380:	e3473002 	movt	r3, #28674	; 0x7002
70014384:	e5933000 	ldr	r3, [r3]
70014388:	e3a0202b 	mov	r2, #43	; 0x2b
7001438c:	e5c32000 	strb	r2, [r3]
70014390:	e30b341c 	movw	r3, #46108	; 0xb41c
70014394:	e3473002 	movt	r3, #28674	; 0x7002
70014398:	e5933000 	ldr	r3, [r3]
7001439c:	e2832001 	add	r2, r3, #1
700143a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700143a4:	e3473002 	movt	r3, #28674	; 0x7002
700143a8:	e5832000 	str	r2, [r3]
                    break;
700143ac:	ea0000b8 	b	70014694 <finsh_compile+0x2ccc>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
700143b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700143b4:	e3473002 	movt	r3, #28674	; 0x7002
700143b8:	e5933000 	ldr	r3, [r3]
700143bc:	e3a02024 	mov	r2, #36	; 0x24
700143c0:	e5c32000 	strb	r2, [r3]
700143c4:	e30b341c 	movw	r3, #46108	; 0xb41c
700143c8:	e3473002 	movt	r3, #28674	; 0x7002
700143cc:	e5933000 	ldr	r3, [r3]
700143d0:	e2832001 	add	r2, r3, #1
700143d4:	e30b341c 	movw	r3, #46108	; 0xb41c
700143d8:	e3473002 	movt	r3, #28674	; 0x7002
700143dc:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
700143e0:	e30b341c 	movw	r3, #46108	; 0xb41c
700143e4:	e3473002 	movt	r3, #28674	; 0x7002
700143e8:	e5933000 	ldr	r3, [r3]
700143ec:	e51b2020 	ldr	r2, [fp, #-32]
700143f0:	e2822014 	add	r2, r2, #20
700143f4:	e6ef2072 	uxtb	r2, r2
700143f8:	e5c32000 	strb	r2, [r3]
700143fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014400:	e3473002 	movt	r3, #28674	; 0x7002
70014404:	e5933000 	ldr	r3, [r3]
70014408:	e2833001 	add	r3, r3, #1
7001440c:	e51b2020 	ldr	r2, [fp, #-32]
70014410:	e2822014 	add	r2, r2, #20
70014414:	e1a02422 	lsr	r2, r2, #8
70014418:	e6ef2072 	uxtb	r2, r2
7001441c:	e5c32000 	strb	r2, [r3]
70014420:	e30b341c 	movw	r3, #46108	; 0xb41c
70014424:	e3473002 	movt	r3, #28674	; 0x7002
70014428:	e5933000 	ldr	r3, [r3]
7001442c:	e2833002 	add	r3, r3, #2
70014430:	e51b2020 	ldr	r2, [fp, #-32]
70014434:	e2822014 	add	r2, r2, #20
70014438:	e1a02822 	lsr	r2, r2, #16
7001443c:	e6ef2072 	uxtb	r2, r2
70014440:	e5c32000 	strb	r2, [r3]
70014444:	e30b341c 	movw	r3, #46108	; 0xb41c
70014448:	e3473002 	movt	r3, #28674	; 0x7002
7001444c:	e5933000 	ldr	r3, [r3]
70014450:	e2833003 	add	r3, r3, #3
70014454:	e51b2020 	ldr	r2, [fp, #-32]
70014458:	e2822014 	add	r2, r2, #20
7001445c:	e1a02c22 	lsr	r2, r2, #24
70014460:	e6ef2072 	uxtb	r2, r2
70014464:	e5c32000 	strb	r2, [r3]
70014468:	e30b341c 	movw	r3, #46108	; 0xb41c
7001446c:	e3473002 	movt	r3, #28674	; 0x7002
70014470:	e5933000 	ldr	r3, [r3]
70014474:	e2832004 	add	r2, r3, #4
70014478:	e30b341c 	movw	r3, #46108	; 0xb41c
7001447c:	e3473002 	movt	r3, #28674	; 0x7002
70014480:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
70014484:	e30b341c 	movw	r3, #46108	; 0xb41c
70014488:	e3473002 	movt	r3, #28674	; 0x7002
7001448c:	e5933000 	ldr	r3, [r3]
70014490:	e3a02027 	mov	r2, #39	; 0x27
70014494:	e5c32000 	strb	r2, [r3]
70014498:	e30b341c 	movw	r3, #46108	; 0xb41c
7001449c:	e3473002 	movt	r3, #28674	; 0x7002
700144a0:	e5933000 	ldr	r3, [r3]
700144a4:	e2832001 	add	r2, r3, #1
700144a8:	e30b341c 	movw	r3, #46108	; 0xb41c
700144ac:	e3473002 	movt	r3, #28674	; 0x7002
700144b0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
700144b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700144b8:	e3473002 	movt	r3, #28674	; 0x7002
700144bc:	e5933000 	ldr	r3, [r3]
700144c0:	e51b2020 	ldr	r2, [fp, #-32]
700144c4:	e2822014 	add	r2, r2, #20
700144c8:	e6ef2072 	uxtb	r2, r2
700144cc:	e5c32000 	strb	r2, [r3]
700144d0:	e30b341c 	movw	r3, #46108	; 0xb41c
700144d4:	e3473002 	movt	r3, #28674	; 0x7002
700144d8:	e5933000 	ldr	r3, [r3]
700144dc:	e2833001 	add	r3, r3, #1
700144e0:	e51b2020 	ldr	r2, [fp, #-32]
700144e4:	e2822014 	add	r2, r2, #20
700144e8:	e1a02422 	lsr	r2, r2, #8
700144ec:	e6ef2072 	uxtb	r2, r2
700144f0:	e5c32000 	strb	r2, [r3]
700144f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700144f8:	e3473002 	movt	r3, #28674	; 0x7002
700144fc:	e5933000 	ldr	r3, [r3]
70014500:	e2833002 	add	r3, r3, #2
70014504:	e51b2020 	ldr	r2, [fp, #-32]
70014508:	e2822014 	add	r2, r2, #20
7001450c:	e1a02822 	lsr	r2, r2, #16
70014510:	e6ef2072 	uxtb	r2, r2
70014514:	e5c32000 	strb	r2, [r3]
70014518:	e30b341c 	movw	r3, #46108	; 0xb41c
7001451c:	e3473002 	movt	r3, #28674	; 0x7002
70014520:	e5933000 	ldr	r3, [r3]
70014524:	e2833003 	add	r3, r3, #3
70014528:	e51b2020 	ldr	r2, [fp, #-32]
7001452c:	e2822014 	add	r2, r2, #20
70014530:	e1a02c22 	lsr	r2, r2, #24
70014534:	e6ef2072 	uxtb	r2, r2
70014538:	e5c32000 	strb	r2, [r3]
7001453c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014540:	e3473002 	movt	r3, #28674	; 0x7002
70014544:	e5933000 	ldr	r3, [r3]
70014548:	e2832004 	add	r2, r3, #4
7001454c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014550:	e3473002 	movt	r3, #28674	; 0x7002
70014554:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70014558:	e30b341c 	movw	r3, #46108	; 0xb41c
7001455c:	e3473002 	movt	r3, #28674	; 0x7002
70014560:	e5933000 	ldr	r3, [r3]
70014564:	e3a02024 	mov	r2, #36	; 0x24
70014568:	e5c32000 	strb	r2, [r3]
7001456c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014570:	e3473002 	movt	r3, #28674	; 0x7002
70014574:	e5933000 	ldr	r3, [r3]
70014578:	e2832001 	add	r2, r3, #1
7001457c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014580:	e3473002 	movt	r3, #28674	; 0x7002
70014584:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
70014588:	e30b341c 	movw	r3, #46108	; 0xb41c
7001458c:	e3473002 	movt	r3, #28674	; 0x7002
70014590:	e5933000 	ldr	r3, [r3]
70014594:	e3a02001 	mov	r2, #1
70014598:	e5c32000 	strb	r2, [r3]
7001459c:	e30b341c 	movw	r3, #46108	; 0xb41c
700145a0:	e3473002 	movt	r3, #28674	; 0x7002
700145a4:	e5933000 	ldr	r3, [r3]
700145a8:	e2833001 	add	r3, r3, #1
700145ac:	e3a02000 	mov	r2, #0
700145b0:	e5c32000 	strb	r2, [r3]
700145b4:	e30b341c 	movw	r3, #46108	; 0xb41c
700145b8:	e3473002 	movt	r3, #28674	; 0x7002
700145bc:	e5933000 	ldr	r3, [r3]
700145c0:	e2833002 	add	r3, r3, #2
700145c4:	e3a02000 	mov	r2, #0
700145c8:	e5c32000 	strb	r2, [r3]
700145cc:	e30b341c 	movw	r3, #46108	; 0xb41c
700145d0:	e3473002 	movt	r3, #28674	; 0x7002
700145d4:	e5933000 	ldr	r3, [r3]
700145d8:	e2833003 	add	r3, r3, #3
700145dc:	e3a02000 	mov	r2, #0
700145e0:	e5c32000 	strb	r2, [r3]
700145e4:	e30b341c 	movw	r3, #46108	; 0xb41c
700145e8:	e3473002 	movt	r3, #28674	; 0x7002
700145ec:	e5933000 	ldr	r3, [r3]
700145f0:	e2832004 	add	r2, r3, #4
700145f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700145f8:	e3473002 	movt	r3, #28674	; 0x7002
700145fc:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
70014600:	e30b341c 	movw	r3, #46108	; 0xb41c
70014604:	e3473002 	movt	r3, #28674	; 0x7002
70014608:	e5933000 	ldr	r3, [r3]
7001460c:	e3a02003 	mov	r2, #3
70014610:	e5c32000 	strb	r2, [r3]
70014614:	e30b341c 	movw	r3, #46108	; 0xb41c
70014618:	e3473002 	movt	r3, #28674	; 0x7002
7001461c:	e5933000 	ldr	r3, [r3]
70014620:	e2832001 	add	r2, r3, #1
70014624:	e30b341c 	movw	r3, #46108	; 0xb41c
70014628:	e3473002 	movt	r3, #28674	; 0x7002
7001462c:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
70014630:	e30b341c 	movw	r3, #46108	; 0xb41c
70014634:	e3473002 	movt	r3, #28674	; 0x7002
70014638:	e5933000 	ldr	r3, [r3]
7001463c:	e3a0202a 	mov	r2, #42	; 0x2a
70014640:	e5c32000 	strb	r2, [r3]
70014644:	e30b341c 	movw	r3, #46108	; 0xb41c
70014648:	e3473002 	movt	r3, #28674	; 0x7002
7001464c:	e5933000 	ldr	r3, [r3]
70014650:	e2832001 	add	r2, r3, #1
70014654:	e30b341c 	movw	r3, #46108	; 0xb41c
70014658:	e3473002 	movt	r3, #28674	; 0x7002
7001465c:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
70014660:	e30b341c 	movw	r3, #46108	; 0xb41c
70014664:	e3473002 	movt	r3, #28674	; 0x7002
70014668:	e5933000 	ldr	r3, [r3]
7001466c:	e3a0202b 	mov	r2, #43	; 0x2b
70014670:	e5c32000 	strb	r2, [r3]
70014674:	e30b341c 	movw	r3, #46108	; 0xb41c
70014678:	e3473002 	movt	r3, #28674	; 0x7002
7001467c:	e5933000 	ldr	r3, [r3]
70014680:	e2832001 	add	r2, r3, #1
70014684:	e30b341c 	movw	r3, #46108	; 0xb41c
70014688:	e3473002 	movt	r3, #28674	; 0x7002
7001468c:	e5832000 	str	r2, [r3]
                    break;
70014690:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
70014694:	ea00027e 	b	70015094 <finsh_compile+0x36cc>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
70014698:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001469c:	e5933010 	ldr	r3, [r3, #16]
700146a0:	e3530000 	cmp	r3, #0
700146a4:	0a00021e 	beq	70014f24 <finsh_compile+0x355c>
700146a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700146ac:	e5933010 	ldr	r3, [r3, #16]
700146b0:	e5d33000 	ldrb	r3, [r3]
700146b4:	e3530001 	cmp	r3, #1
700146b8:	1a000219 	bne	70014f24 <finsh_compile+0x355c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
700146bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700146c0:	e5933010 	ldr	r3, [r3, #16]
700146c4:	e5933008 	ldr	r3, [r3, #8]
700146c8:	e50b3024 	str	r3, [fp, #-36]	; 0x24

                switch (node->data_type)
700146cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700146d0:	e5d33001 	ldrb	r3, [r3, #1]
700146d4:	e3530002 	cmp	r3, #2
700146d8:	0a0000ab 	beq	7001498c <finsh_compile+0x2fc4>
700146dc:	e3530003 	cmp	r3, #3
700146e0:	0a000156 	beq	70014c40 <finsh_compile+0x3278>
700146e4:	e3530001 	cmp	r3, #1
700146e8:	0a000000 	beq	700146f0 <finsh_compile+0x2d28>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
700146ec:	ea000268 	b	70015094 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
700146f0:	e30b341c 	movw	r3, #46108	; 0xb41c
700146f4:	e3473002 	movt	r3, #28674	; 0x7002
700146f8:	e5933000 	ldr	r3, [r3]
700146fc:	e3a02024 	mov	r2, #36	; 0x24
70014700:	e5c32000 	strb	r2, [r3]
70014704:	e30b341c 	movw	r3, #46108	; 0xb41c
70014708:	e3473002 	movt	r3, #28674	; 0x7002
7001470c:	e5933000 	ldr	r3, [r3]
70014710:	e2832001 	add	r2, r3, #1
70014714:	e30b341c 	movw	r3, #46108	; 0xb41c
70014718:	e3473002 	movt	r3, #28674	; 0x7002
7001471c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
70014720:	e30b341c 	movw	r3, #46108	; 0xb41c
70014724:	e3473002 	movt	r3, #28674	; 0x7002
70014728:	e5933000 	ldr	r3, [r3]
7001472c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014730:	e2822014 	add	r2, r2, #20
70014734:	e6ef2072 	uxtb	r2, r2
70014738:	e5c32000 	strb	r2, [r3]
7001473c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014740:	e3473002 	movt	r3, #28674	; 0x7002
70014744:	e5933000 	ldr	r3, [r3]
70014748:	e2833001 	add	r3, r3, #1
7001474c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014750:	e2822014 	add	r2, r2, #20
70014754:	e1a02422 	lsr	r2, r2, #8
70014758:	e6ef2072 	uxtb	r2, r2
7001475c:	e5c32000 	strb	r2, [r3]
70014760:	e30b341c 	movw	r3, #46108	; 0xb41c
70014764:	e3473002 	movt	r3, #28674	; 0x7002
70014768:	e5933000 	ldr	r3, [r3]
7001476c:	e2833002 	add	r3, r3, #2
70014770:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014774:	e2822014 	add	r2, r2, #20
70014778:	e1a02822 	lsr	r2, r2, #16
7001477c:	e6ef2072 	uxtb	r2, r2
70014780:	e5c32000 	strb	r2, [r3]
70014784:	e30b341c 	movw	r3, #46108	; 0xb41c
70014788:	e3473002 	movt	r3, #28674	; 0x7002
7001478c:	e5933000 	ldr	r3, [r3]
70014790:	e2833003 	add	r3, r3, #3
70014794:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014798:	e2822014 	add	r2, r2, #20
7001479c:	e1a02c22 	lsr	r2, r2, #24
700147a0:	e6ef2072 	uxtb	r2, r2
700147a4:	e5c32000 	strb	r2, [r3]
700147a8:	e30b341c 	movw	r3, #46108	; 0xb41c
700147ac:	e3473002 	movt	r3, #28674	; 0x7002
700147b0:	e5933000 	ldr	r3, [r3]
700147b4:	e2832004 	add	r2, r3, #4
700147b8:	e30b341c 	movw	r3, #46108	; 0xb41c
700147bc:	e3473002 	movt	r3, #28674	; 0x7002
700147c0:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
700147c4:	e30b341c 	movw	r3, #46108	; 0xb41c
700147c8:	e3473002 	movt	r3, #28674	; 0x7002
700147cc:	e5933000 	ldr	r3, [r3]
700147d0:	e3a02025 	mov	r2, #37	; 0x25
700147d4:	e5c32000 	strb	r2, [r3]
700147d8:	e30b341c 	movw	r3, #46108	; 0xb41c
700147dc:	e3473002 	movt	r3, #28674	; 0x7002
700147e0:	e5933000 	ldr	r3, [r3]
700147e4:	e2832001 	add	r2, r3, #1
700147e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700147ec:	e3473002 	movt	r3, #28674	; 0x7002
700147f0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
700147f4:	e30b341c 	movw	r3, #46108	; 0xb41c
700147f8:	e3473002 	movt	r3, #28674	; 0x7002
700147fc:	e5933000 	ldr	r3, [r3]
70014800:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014804:	e2822014 	add	r2, r2, #20
70014808:	e6ef2072 	uxtb	r2, r2
7001480c:	e5c32000 	strb	r2, [r3]
70014810:	e30b341c 	movw	r3, #46108	; 0xb41c
70014814:	e3473002 	movt	r3, #28674	; 0x7002
70014818:	e5933000 	ldr	r3, [r3]
7001481c:	e2833001 	add	r3, r3, #1
70014820:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014824:	e2822014 	add	r2, r2, #20
70014828:	e1a02422 	lsr	r2, r2, #8
7001482c:	e6ef2072 	uxtb	r2, r2
70014830:	e5c32000 	strb	r2, [r3]
70014834:	e30b341c 	movw	r3, #46108	; 0xb41c
70014838:	e3473002 	movt	r3, #28674	; 0x7002
7001483c:	e5933000 	ldr	r3, [r3]
70014840:	e2833002 	add	r3, r3, #2
70014844:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014848:	e2822014 	add	r2, r2, #20
7001484c:	e1a02822 	lsr	r2, r2, #16
70014850:	e6ef2072 	uxtb	r2, r2
70014854:	e5c32000 	strb	r2, [r3]
70014858:	e30b341c 	movw	r3, #46108	; 0xb41c
7001485c:	e3473002 	movt	r3, #28674	; 0x7002
70014860:	e5933000 	ldr	r3, [r3]
70014864:	e2833003 	add	r3, r3, #3
70014868:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
7001486c:	e2822014 	add	r2, r2, #20
70014870:	e1a02c22 	lsr	r2, r2, #24
70014874:	e6ef2072 	uxtb	r2, r2
70014878:	e5c32000 	strb	r2, [r3]
7001487c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014880:	e3473002 	movt	r3, #28674	; 0x7002
70014884:	e5933000 	ldr	r3, [r3]
70014888:	e2832004 	add	r2, r3, #4
7001488c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014890:	e3473002 	movt	r3, #28674	; 0x7002
70014894:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
70014898:	e30b341c 	movw	r3, #46108	; 0xb41c
7001489c:	e3473002 	movt	r3, #28674	; 0x7002
700148a0:	e5933000 	ldr	r3, [r3]
700148a4:	e3a02022 	mov	r2, #34	; 0x22
700148a8:	e5c32000 	strb	r2, [r3]
700148ac:	e30b341c 	movw	r3, #46108	; 0xb41c
700148b0:	e3473002 	movt	r3, #28674	; 0x7002
700148b4:	e5933000 	ldr	r3, [r3]
700148b8:	e2832001 	add	r2, r3, #1
700148bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700148c0:	e3473002 	movt	r3, #28674	; 0x7002
700148c4:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
700148c8:	e30b341c 	movw	r3, #46108	; 0xb41c
700148cc:	e3473002 	movt	r3, #28674	; 0x7002
700148d0:	e5933000 	ldr	r3, [r3]
700148d4:	e3a02001 	mov	r2, #1
700148d8:	e5c32000 	strb	r2, [r3]
700148dc:	e30b341c 	movw	r3, #46108	; 0xb41c
700148e0:	e3473002 	movt	r3, #28674	; 0x7002
700148e4:	e5933000 	ldr	r3, [r3]
700148e8:	e2832001 	add	r2, r3, #1
700148ec:	e30b341c 	movw	r3, #46108	; 0xb41c
700148f0:	e3473002 	movt	r3, #28674	; 0x7002
700148f4:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
700148f8:	e30b341c 	movw	r3, #46108	; 0xb41c
700148fc:	e3473002 	movt	r3, #28674	; 0x7002
70014900:	e5933000 	ldr	r3, [r3]
70014904:	e3a02004 	mov	r2, #4
70014908:	e5c32000 	strb	r2, [r3]
7001490c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014910:	e3473002 	movt	r3, #28674	; 0x7002
70014914:	e5933000 	ldr	r3, [r3]
70014918:	e2832001 	add	r2, r3, #1
7001491c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014920:	e3473002 	movt	r3, #28674	; 0x7002
70014924:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
70014928:	e30b341c 	movw	r3, #46108	; 0xb41c
7001492c:	e3473002 	movt	r3, #28674	; 0x7002
70014930:	e5933000 	ldr	r3, [r3]
70014934:	e3a02028 	mov	r2, #40	; 0x28
70014938:	e5c32000 	strb	r2, [r3]
7001493c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014940:	e3473002 	movt	r3, #28674	; 0x7002
70014944:	e5933000 	ldr	r3, [r3]
70014948:	e2832001 	add	r2, r3, #1
7001494c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014950:	e3473002 	movt	r3, #28674	; 0x7002
70014954:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
70014958:	e30b341c 	movw	r3, #46108	; 0xb41c
7001495c:	e3473002 	movt	r3, #28674	; 0x7002
70014960:	e5933000 	ldr	r3, [r3]
70014964:	e3a0202b 	mov	r2, #43	; 0x2b
70014968:	e5c32000 	strb	r2, [r3]
7001496c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014970:	e3473002 	movt	r3, #28674	; 0x7002
70014974:	e5933000 	ldr	r3, [r3]
70014978:	e2832001 	add	r2, r3, #1
7001497c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014980:	e3473002 	movt	r3, #28674	; 0x7002
70014984:	e5832000 	str	r2, [r3]
                    break;
70014988:	ea000165 	b	70014f24 <finsh_compile+0x355c>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
7001498c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014990:	e3473002 	movt	r3, #28674	; 0x7002
70014994:	e5933000 	ldr	r3, [r3]
70014998:	e3a02024 	mov	r2, #36	; 0x24
7001499c:	e5c32000 	strb	r2, [r3]
700149a0:	e30b341c 	movw	r3, #46108	; 0xb41c
700149a4:	e3473002 	movt	r3, #28674	; 0x7002
700149a8:	e5933000 	ldr	r3, [r3]
700149ac:	e2832001 	add	r2, r3, #1
700149b0:	e30b341c 	movw	r3, #46108	; 0xb41c
700149b4:	e3473002 	movt	r3, #28674	; 0x7002
700149b8:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
700149bc:	e30b341c 	movw	r3, #46108	; 0xb41c
700149c0:	e3473002 	movt	r3, #28674	; 0x7002
700149c4:	e5933000 	ldr	r3, [r3]
700149c8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
700149cc:	e2822014 	add	r2, r2, #20
700149d0:	e6ef2072 	uxtb	r2, r2
700149d4:	e5c32000 	strb	r2, [r3]
700149d8:	e30b341c 	movw	r3, #46108	; 0xb41c
700149dc:	e3473002 	movt	r3, #28674	; 0x7002
700149e0:	e5933000 	ldr	r3, [r3]
700149e4:	e2833001 	add	r3, r3, #1
700149e8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
700149ec:	e2822014 	add	r2, r2, #20
700149f0:	e1a02422 	lsr	r2, r2, #8
700149f4:	e6ef2072 	uxtb	r2, r2
700149f8:	e5c32000 	strb	r2, [r3]
700149fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a00:	e3473002 	movt	r3, #28674	; 0x7002
70014a04:	e5933000 	ldr	r3, [r3]
70014a08:	e2833002 	add	r3, r3, #2
70014a0c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014a10:	e2822014 	add	r2, r2, #20
70014a14:	e1a02822 	lsr	r2, r2, #16
70014a18:	e6ef2072 	uxtb	r2, r2
70014a1c:	e5c32000 	strb	r2, [r3]
70014a20:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a24:	e3473002 	movt	r3, #28674	; 0x7002
70014a28:	e5933000 	ldr	r3, [r3]
70014a2c:	e2833003 	add	r3, r3, #3
70014a30:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014a34:	e2822014 	add	r2, r2, #20
70014a38:	e1a02c22 	lsr	r2, r2, #24
70014a3c:	e6ef2072 	uxtb	r2, r2
70014a40:	e5c32000 	strb	r2, [r3]
70014a44:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a48:	e3473002 	movt	r3, #28674	; 0x7002
70014a4c:	e5933000 	ldr	r3, [r3]
70014a50:	e2832004 	add	r2, r3, #4
70014a54:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a58:	e3473002 	movt	r3, #28674	; 0x7002
70014a5c:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
70014a60:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a64:	e3473002 	movt	r3, #28674	; 0x7002
70014a68:	e5933000 	ldr	r3, [r3]
70014a6c:	e3a02026 	mov	r2, #38	; 0x26
70014a70:	e5c32000 	strb	r2, [r3]
70014a74:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a78:	e3473002 	movt	r3, #28674	; 0x7002
70014a7c:	e5933000 	ldr	r3, [r3]
70014a80:	e2832001 	add	r2, r3, #1
70014a84:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a88:	e3473002 	movt	r3, #28674	; 0x7002
70014a8c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
70014a90:	e30b341c 	movw	r3, #46108	; 0xb41c
70014a94:	e3473002 	movt	r3, #28674	; 0x7002
70014a98:	e5933000 	ldr	r3, [r3]
70014a9c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014aa0:	e2822014 	add	r2, r2, #20
70014aa4:	e6ef2072 	uxtb	r2, r2
70014aa8:	e5c32000 	strb	r2, [r3]
70014aac:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ab0:	e3473002 	movt	r3, #28674	; 0x7002
70014ab4:	e5933000 	ldr	r3, [r3]
70014ab8:	e2833001 	add	r3, r3, #1
70014abc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014ac0:	e2822014 	add	r2, r2, #20
70014ac4:	e1a02422 	lsr	r2, r2, #8
70014ac8:	e6ef2072 	uxtb	r2, r2
70014acc:	e5c32000 	strb	r2, [r3]
70014ad0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ad4:	e3473002 	movt	r3, #28674	; 0x7002
70014ad8:	e5933000 	ldr	r3, [r3]
70014adc:	e2833002 	add	r3, r3, #2
70014ae0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014ae4:	e2822014 	add	r2, r2, #20
70014ae8:	e1a02822 	lsr	r2, r2, #16
70014aec:	e6ef2072 	uxtb	r2, r2
70014af0:	e5c32000 	strb	r2, [r3]
70014af4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014af8:	e3473002 	movt	r3, #28674	; 0x7002
70014afc:	e5933000 	ldr	r3, [r3]
70014b00:	e2833003 	add	r3, r3, #3
70014b04:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014b08:	e2822014 	add	r2, r2, #20
70014b0c:	e1a02c22 	lsr	r2, r2, #24
70014b10:	e6ef2072 	uxtb	r2, r2
70014b14:	e5c32000 	strb	r2, [r3]
70014b18:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b1c:	e3473002 	movt	r3, #28674	; 0x7002
70014b20:	e5933000 	ldr	r3, [r3]
70014b24:	e2832004 	add	r2, r3, #4
70014b28:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b2c:	e3473002 	movt	r3, #28674	; 0x7002
70014b30:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
70014b34:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b38:	e3473002 	movt	r3, #28674	; 0x7002
70014b3c:	e5933000 	ldr	r3, [r3]
70014b40:	e3a02023 	mov	r2, #35	; 0x23
70014b44:	e5c32000 	strb	r2, [r3]
70014b48:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b4c:	e3473002 	movt	r3, #28674	; 0x7002
70014b50:	e5933000 	ldr	r3, [r3]
70014b54:	e2832001 	add	r2, r3, #1
70014b58:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b5c:	e3473002 	movt	r3, #28674	; 0x7002
70014b60:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
70014b64:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b68:	e3473002 	movt	r3, #28674	; 0x7002
70014b6c:	e5933000 	ldr	r3, [r3]
70014b70:	e3a02001 	mov	r2, #1
70014b74:	e5c32000 	strb	r2, [r3]
70014b78:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b7c:	e3473002 	movt	r3, #28674	; 0x7002
70014b80:	e5933000 	ldr	r3, [r3]
70014b84:	e2833001 	add	r3, r3, #1
70014b88:	e3a02000 	mov	r2, #0
70014b8c:	e5c32000 	strb	r2, [r3]
70014b90:	e30b341c 	movw	r3, #46108	; 0xb41c
70014b94:	e3473002 	movt	r3, #28674	; 0x7002
70014b98:	e5933000 	ldr	r3, [r3]
70014b9c:	e2832002 	add	r2, r3, #2
70014ba0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ba4:	e3473002 	movt	r3, #28674	; 0x7002
70014ba8:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
70014bac:	e30b341c 	movw	r3, #46108	; 0xb41c
70014bb0:	e3473002 	movt	r3, #28674	; 0x7002
70014bb4:	e5933000 	ldr	r3, [r3]
70014bb8:	e3a02005 	mov	r2, #5
70014bbc:	e5c32000 	strb	r2, [r3]
70014bc0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014bc4:	e3473002 	movt	r3, #28674	; 0x7002
70014bc8:	e5933000 	ldr	r3, [r3]
70014bcc:	e2832001 	add	r2, r3, #1
70014bd0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014bd4:	e3473002 	movt	r3, #28674	; 0x7002
70014bd8:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
70014bdc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014be0:	e3473002 	movt	r3, #28674	; 0x7002
70014be4:	e5933000 	ldr	r3, [r3]
70014be8:	e3a02029 	mov	r2, #41	; 0x29
70014bec:	e5c32000 	strb	r2, [r3]
70014bf0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014bf4:	e3473002 	movt	r3, #28674	; 0x7002
70014bf8:	e5933000 	ldr	r3, [r3]
70014bfc:	e2832001 	add	r2, r3, #1
70014c00:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c04:	e3473002 	movt	r3, #28674	; 0x7002
70014c08:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
70014c0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c10:	e3473002 	movt	r3, #28674	; 0x7002
70014c14:	e5933000 	ldr	r3, [r3]
70014c18:	e3a0202b 	mov	r2, #43	; 0x2b
70014c1c:	e5c32000 	strb	r2, [r3]
70014c20:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c24:	e3473002 	movt	r3, #28674	; 0x7002
70014c28:	e5933000 	ldr	r3, [r3]
70014c2c:	e2832001 	add	r2, r3, #1
70014c30:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c34:	e3473002 	movt	r3, #28674	; 0x7002
70014c38:	e5832000 	str	r2, [r3]
                    break;
70014c3c:	ea0000b8 	b	70014f24 <finsh_compile+0x355c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70014c40:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c44:	e3473002 	movt	r3, #28674	; 0x7002
70014c48:	e5933000 	ldr	r3, [r3]
70014c4c:	e3a02024 	mov	r2, #36	; 0x24
70014c50:	e5c32000 	strb	r2, [r3]
70014c54:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c58:	e3473002 	movt	r3, #28674	; 0x7002
70014c5c:	e5933000 	ldr	r3, [r3]
70014c60:	e2832001 	add	r2, r3, #1
70014c64:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c68:	e3473002 	movt	r3, #28674	; 0x7002
70014c6c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
70014c70:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c74:	e3473002 	movt	r3, #28674	; 0x7002
70014c78:	e5933000 	ldr	r3, [r3]
70014c7c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014c80:	e2822014 	add	r2, r2, #20
70014c84:	e6ef2072 	uxtb	r2, r2
70014c88:	e5c32000 	strb	r2, [r3]
70014c8c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014c90:	e3473002 	movt	r3, #28674	; 0x7002
70014c94:	e5933000 	ldr	r3, [r3]
70014c98:	e2833001 	add	r3, r3, #1
70014c9c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014ca0:	e2822014 	add	r2, r2, #20
70014ca4:	e1a02422 	lsr	r2, r2, #8
70014ca8:	e6ef2072 	uxtb	r2, r2
70014cac:	e5c32000 	strb	r2, [r3]
70014cb0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014cb4:	e3473002 	movt	r3, #28674	; 0x7002
70014cb8:	e5933000 	ldr	r3, [r3]
70014cbc:	e2833002 	add	r3, r3, #2
70014cc0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014cc4:	e2822014 	add	r2, r2, #20
70014cc8:	e1a02822 	lsr	r2, r2, #16
70014ccc:	e6ef2072 	uxtb	r2, r2
70014cd0:	e5c32000 	strb	r2, [r3]
70014cd4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014cd8:	e3473002 	movt	r3, #28674	; 0x7002
70014cdc:	e5933000 	ldr	r3, [r3]
70014ce0:	e2833003 	add	r3, r3, #3
70014ce4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014ce8:	e2822014 	add	r2, r2, #20
70014cec:	e1a02c22 	lsr	r2, r2, #24
70014cf0:	e6ef2072 	uxtb	r2, r2
70014cf4:	e5c32000 	strb	r2, [r3]
70014cf8:	e30b341c 	movw	r3, #46108	; 0xb41c
70014cfc:	e3473002 	movt	r3, #28674	; 0x7002
70014d00:	e5933000 	ldr	r3, [r3]
70014d04:	e2832004 	add	r2, r3, #4
70014d08:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d0c:	e3473002 	movt	r3, #28674	; 0x7002
70014d10:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
70014d14:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d18:	e3473002 	movt	r3, #28674	; 0x7002
70014d1c:	e5933000 	ldr	r3, [r3]
70014d20:	e3a02027 	mov	r2, #39	; 0x27
70014d24:	e5c32000 	strb	r2, [r3]
70014d28:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d2c:	e3473002 	movt	r3, #28674	; 0x7002
70014d30:	e5933000 	ldr	r3, [r3]
70014d34:	e2832001 	add	r2, r3, #1
70014d38:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d3c:	e3473002 	movt	r3, #28674	; 0x7002
70014d40:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
70014d44:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d48:	e3473002 	movt	r3, #28674	; 0x7002
70014d4c:	e5933000 	ldr	r3, [r3]
70014d50:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014d54:	e2822014 	add	r2, r2, #20
70014d58:	e6ef2072 	uxtb	r2, r2
70014d5c:	e5c32000 	strb	r2, [r3]
70014d60:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d64:	e3473002 	movt	r3, #28674	; 0x7002
70014d68:	e5933000 	ldr	r3, [r3]
70014d6c:	e2833001 	add	r3, r3, #1
70014d70:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014d74:	e2822014 	add	r2, r2, #20
70014d78:	e1a02422 	lsr	r2, r2, #8
70014d7c:	e6ef2072 	uxtb	r2, r2
70014d80:	e5c32000 	strb	r2, [r3]
70014d84:	e30b341c 	movw	r3, #46108	; 0xb41c
70014d88:	e3473002 	movt	r3, #28674	; 0x7002
70014d8c:	e5933000 	ldr	r3, [r3]
70014d90:	e2833002 	add	r3, r3, #2
70014d94:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014d98:	e2822014 	add	r2, r2, #20
70014d9c:	e1a02822 	lsr	r2, r2, #16
70014da0:	e6ef2072 	uxtb	r2, r2
70014da4:	e5c32000 	strb	r2, [r3]
70014da8:	e30b341c 	movw	r3, #46108	; 0xb41c
70014dac:	e3473002 	movt	r3, #28674	; 0x7002
70014db0:	e5933000 	ldr	r3, [r3]
70014db4:	e2833003 	add	r3, r3, #3
70014db8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70014dbc:	e2822014 	add	r2, r2, #20
70014dc0:	e1a02c22 	lsr	r2, r2, #24
70014dc4:	e6ef2072 	uxtb	r2, r2
70014dc8:	e5c32000 	strb	r2, [r3]
70014dcc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014dd0:	e3473002 	movt	r3, #28674	; 0x7002
70014dd4:	e5933000 	ldr	r3, [r3]
70014dd8:	e2832004 	add	r2, r3, #4
70014ddc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014de0:	e3473002 	movt	r3, #28674	; 0x7002
70014de4:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
70014de8:	e30b341c 	movw	r3, #46108	; 0xb41c
70014dec:	e3473002 	movt	r3, #28674	; 0x7002
70014df0:	e5933000 	ldr	r3, [r3]
70014df4:	e3a02024 	mov	r2, #36	; 0x24
70014df8:	e5c32000 	strb	r2, [r3]
70014dfc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e00:	e3473002 	movt	r3, #28674	; 0x7002
70014e04:	e5933000 	ldr	r3, [r3]
70014e08:	e2832001 	add	r2, r3, #1
70014e0c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e10:	e3473002 	movt	r3, #28674	; 0x7002
70014e14:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
70014e18:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e1c:	e3473002 	movt	r3, #28674	; 0x7002
70014e20:	e5933000 	ldr	r3, [r3]
70014e24:	e3a02001 	mov	r2, #1
70014e28:	e5c32000 	strb	r2, [r3]
70014e2c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e30:	e3473002 	movt	r3, #28674	; 0x7002
70014e34:	e5933000 	ldr	r3, [r3]
70014e38:	e2833001 	add	r3, r3, #1
70014e3c:	e3a02000 	mov	r2, #0
70014e40:	e5c32000 	strb	r2, [r3]
70014e44:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e48:	e3473002 	movt	r3, #28674	; 0x7002
70014e4c:	e5933000 	ldr	r3, [r3]
70014e50:	e2833002 	add	r3, r3, #2
70014e54:	e3a02000 	mov	r2, #0
70014e58:	e5c32000 	strb	r2, [r3]
70014e5c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e60:	e3473002 	movt	r3, #28674	; 0x7002
70014e64:	e5933000 	ldr	r3, [r3]
70014e68:	e2833003 	add	r3, r3, #3
70014e6c:	e3a02000 	mov	r2, #0
70014e70:	e5c32000 	strb	r2, [r3]
70014e74:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e78:	e3473002 	movt	r3, #28674	; 0x7002
70014e7c:	e5933000 	ldr	r3, [r3]
70014e80:	e2832004 	add	r2, r3, #4
70014e84:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e88:	e3473002 	movt	r3, #28674	; 0x7002
70014e8c:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
70014e90:	e30b341c 	movw	r3, #46108	; 0xb41c
70014e94:	e3473002 	movt	r3, #28674	; 0x7002
70014e98:	e5933000 	ldr	r3, [r3]
70014e9c:	e3a02006 	mov	r2, #6
70014ea0:	e5c32000 	strb	r2, [r3]
70014ea4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ea8:	e3473002 	movt	r3, #28674	; 0x7002
70014eac:	e5933000 	ldr	r3, [r3]
70014eb0:	e2832001 	add	r2, r3, #1
70014eb4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014eb8:	e3473002 	movt	r3, #28674	; 0x7002
70014ebc:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
70014ec0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ec4:	e3473002 	movt	r3, #28674	; 0x7002
70014ec8:	e5933000 	ldr	r3, [r3]
70014ecc:	e3a0202a 	mov	r2, #42	; 0x2a
70014ed0:	e5c32000 	strb	r2, [r3]
70014ed4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ed8:	e3473002 	movt	r3, #28674	; 0x7002
70014edc:	e5933000 	ldr	r3, [r3]
70014ee0:	e2832001 	add	r2, r3, #1
70014ee4:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ee8:	e3473002 	movt	r3, #28674	; 0x7002
70014eec:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
70014ef0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ef4:	e3473002 	movt	r3, #28674	; 0x7002
70014ef8:	e5933000 	ldr	r3, [r3]
70014efc:	e3a0202b 	mov	r2, #43	; 0x2b
70014f00:	e5c32000 	strb	r2, [r3]
70014f04:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f08:	e3473002 	movt	r3, #28674	; 0x7002
70014f0c:	e5933000 	ldr	r3, [r3]
70014f10:	e2832001 	add	r2, r3, #1
70014f14:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f18:	e3473002 	movt	r3, #28674	; 0x7002
70014f1c:	e5832000 	str	r2, [r3]
                    break;
70014f20:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
70014f24:	ea00005a 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
70014f28:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f2c:	e3473002 	movt	r3, #28674	; 0x7002
70014f30:	e5933000 	ldr	r3, [r3]
70014f34:	e3a02000 	mov	r2, #0
70014f38:	e5c32000 	strb	r2, [r3]
70014f3c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f40:	e3473002 	movt	r3, #28674	; 0x7002
70014f44:	e5933000 	ldr	r3, [r3]
70014f48:	e2833001 	add	r3, r3, #1
70014f4c:	e3a02000 	mov	r2, #0
70014f50:	e5c32000 	strb	r2, [r3]
70014f54:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f58:	e3473002 	movt	r3, #28674	; 0x7002
70014f5c:	e5933000 	ldr	r3, [r3]
70014f60:	e2833002 	add	r3, r3, #2
70014f64:	e3a02000 	mov	r2, #0
70014f68:	e5c32000 	strb	r2, [r3]
70014f6c:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f70:	e3473002 	movt	r3, #28674	; 0x7002
70014f74:	e5933000 	ldr	r3, [r3]
70014f78:	e2833003 	add	r3, r3, #3
70014f7c:	e3a02000 	mov	r2, #0
70014f80:	e5c32000 	strb	r2, [r3]
70014f84:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f88:	e3473002 	movt	r3, #28674	; 0x7002
70014f8c:	e5933000 	ldr	r3, [r3]
70014f90:	e2832004 	add	r2, r3, #4
70014f94:	e30b341c 	movw	r3, #46108	; 0xb41c
70014f98:	e3473002 	movt	r3, #28674	; 0x7002
70014f9c:	e5832000 	str	r2, [r3]
            break;
70014fa0:	ea00003b 	b	70015094 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
70014fa4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70014fa8:	e5d33002 	ldrb	r3, [r3, #2]
70014fac:	e2033008 	and	r3, r3, #8
70014fb0:	e3530000 	cmp	r3, #0
70014fb4:	1a00002f 	bne	70015078 <finsh_compile+0x36b0>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
70014fb8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70014fbc:	e5d33001 	ldrb	r3, [r3, #1]
70014fc0:	e3530002 	cmp	r3, #2
70014fc4:	0a000011 	beq	70015010 <finsh_compile+0x3648>
70014fc8:	e3530003 	cmp	r3, #3
70014fcc:	0a00001c 	beq	70015044 <finsh_compile+0x367c>
70014fd0:	e3530001 	cmp	r3, #1
70014fd4:	0a000000 	beq	70014fdc <finsh_compile+0x3614>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
70014fd8:	ea000026 	b	70015078 <finsh_compile+0x36b0>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
70014fdc:	e30b341c 	movw	r3, #46108	; 0xb41c
70014fe0:	e3473002 	movt	r3, #28674	; 0x7002
70014fe4:	e5933000 	ldr	r3, [r3]
70014fe8:	e3a0202d 	mov	r2, #45	; 0x2d
70014fec:	e5c32000 	strb	r2, [r3]
70014ff0:	e30b341c 	movw	r3, #46108	; 0xb41c
70014ff4:	e3473002 	movt	r3, #28674	; 0x7002
70014ff8:	e5933000 	ldr	r3, [r3]
70014ffc:	e2832001 	add	r2, r3, #1
70015000:	e30b341c 	movw	r3, #46108	; 0xb41c
70015004:	e3473002 	movt	r3, #28674	; 0x7002
70015008:	e5832000 	str	r2, [r3]
                    break;
7001500c:	ea000019 	b	70015078 <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
70015010:	e30b341c 	movw	r3, #46108	; 0xb41c
70015014:	e3473002 	movt	r3, #28674	; 0x7002
70015018:	e5933000 	ldr	r3, [r3]
7001501c:	e3a0202e 	mov	r2, #46	; 0x2e
70015020:	e5c32000 	strb	r2, [r3]
70015024:	e30b341c 	movw	r3, #46108	; 0xb41c
70015028:	e3473002 	movt	r3, #28674	; 0x7002
7001502c:	e5933000 	ldr	r3, [r3]
70015030:	e2832001 	add	r2, r3, #1
70015034:	e30b341c 	movw	r3, #46108	; 0xb41c
70015038:	e3473002 	movt	r3, #28674	; 0x7002
7001503c:	e5832000 	str	r2, [r3]
                    break;
70015040:	ea00000c 	b	70015078 <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
70015044:	e30b341c 	movw	r3, #46108	; 0xb41c
70015048:	e3473002 	movt	r3, #28674	; 0x7002
7001504c:	e5933000 	ldr	r3, [r3]
70015050:	e3a0202f 	mov	r2, #47	; 0x2f
70015054:	e5c32000 	strb	r2, [r3]
70015058:	e30b341c 	movw	r3, #46108	; 0xb41c
7001505c:	e3473002 	movt	r3, #28674	; 0x7002
70015060:	e5933000 	ldr	r3, [r3]
70015064:	e2832001 	add	r2, r3, #1
70015068:	e30b341c 	movw	r3, #46108	; 0xb41c
7001506c:	e3473002 	movt	r3, #28674	; 0x7002
70015070:	e5832000 	str	r2, [r3]
                    break;
70015074:	e1a00000 	nop			; (mov r0, r0)
                default:
                    break;
                }
            }
            break;
70015078:	ea000005 	b	70015094 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
7001507c:	e3a00008 	mov	r0, #8
70015080:	eb000136 	bl	70015560 <finsh_error_set>
            break;
70015084:	ea000002 	b	70015094 <finsh_compile+0x36cc>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
70015088:	e1a00000 	nop			; (mov r0, r0)
7001508c:	ea000000 	b	70015094 <finsh_compile+0x36cc>
                            break;
                        }
                    }
                }
            }
            break;
70015090:	e1a00000 	nop			; (mov r0, r0)
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
70015094:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70015098:	e593300c 	ldr	r3, [r3, #12]
7001509c:	e3530000 	cmp	r3, #0
700150a0:	0a000003 	beq	700150b4 <finsh_compile+0x36ec>
            finsh_compile(finsh_node_sibling(node));
700150a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700150a8:	e593300c 	ldr	r3, [r3, #12]
700150ac:	e1a00003 	mov	r0, r3
700150b0:	ebfff244 	bl	700119c8 <finsh_compile>
    }

    return 0;
700150b4:	e3a03000 	mov	r3, #0
}
700150b8:	e1a00003 	mov	r0, r3
700150bc:	e24bd004 	sub	sp, fp, #4
700150c0:	e8bd8800 	pop	{fp, pc}

700150c4 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
700150c4:	e92d4800 	push	{fp, lr}
700150c8:	e28db004 	add	fp, sp, #4
700150cc:	e24dd010 	sub	sp, sp, #16
700150d0:	e50b0010 	str	r0, [fp, #-16]
700150d4:	e1a03001 	mov	r3, r1
700150d8:	e54b3011 	strb	r3, [fp, #-17]
    if (node != NULL)
700150dc:	e51b3010 	ldr	r3, [fp, #-16]
700150e0:	e3530000 	cmp	r3, #0
700150e4:	0a0000d0 	beq	7001542c <finsh_type_check+0x368>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
700150e8:	e51b3010 	ldr	r3, [fp, #-16]
700150ec:	e5d33000 	ldrb	r3, [r3]
700150f0:	e3530013 	cmp	r3, #19
700150f4:	0a00000b 	beq	70015128 <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
700150f8:	e51b3010 	ldr	r3, [fp, #-16]
700150fc:	e5d33000 	ldrb	r3, [r3]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
70015100:	e3530015 	cmp	r3, #21
70015104:	0a000007 	beq	70015128 <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
70015108:	e51b3010 	ldr	r3, [fp, #-16]
7001510c:	e5d33000 	ldrb	r3, [r3]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
70015110:	e3530016 	cmp	r3, #22
70015114:	0a000003 	beq	70015128 <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
70015118:	e51b3010 	ldr	r3, [fp, #-16]
7001511c:	e5d33000 	ldrb	r3, [r3]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
70015120:	e353001a 	cmp	r3, #26
70015124:	1a000005 	bne	70015140 <finsh_type_check+0x7c>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
70015128:	e51b3010 	ldr	r3, [fp, #-16]
7001512c:	e5933010 	ldr	r3, [r3, #16]
70015130:	e1a00003 	mov	r0, r3
70015134:	e3a01008 	mov	r1, #8
70015138:	ebffffe1 	bl	700150c4 <finsh_type_check>
7001513c:	ea000012 	b	7001518c <finsh_type_check+0xc8>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
70015140:	e51b3010 	ldr	r3, [fp, #-16]
70015144:	e5d33000 	ldrb	r3, [r3]
70015148:	e3530019 	cmp	r3, #25
7001514c:	1a000008 	bne	70015174 <finsh_type_check+0xb0>
70015150:	e55b3011 	ldrb	r3, [fp, #-17]
70015154:	e3530000 	cmp	r3, #0
70015158:	0a000005 	beq	70015174 <finsh_type_check+0xb0>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
7001515c:	e51b3010 	ldr	r3, [fp, #-16]
70015160:	e5933010 	ldr	r3, [r3, #16]
70015164:	e1a00003 	mov	r0, r3
70015168:	e3a01000 	mov	r1, #0
7001516c:	ebffffd4 	bl	700150c4 <finsh_type_check>
70015170:	ea000005 	b	7001518c <finsh_type_check+0xc8>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
70015174:	e51b3010 	ldr	r3, [fp, #-16]
70015178:	e5932010 	ldr	r2, [r3, #16]
7001517c:	e55b3011 	ldrb	r3, [fp, #-17]
70015180:	e1a00002 	mov	r0, r2
70015184:	e1a01003 	mov	r1, r3
70015188:	ebffffcd 	bl	700150c4 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
7001518c:	e51b3010 	ldr	r3, [fp, #-16]
70015190:	e593300c 	ldr	r3, [r3, #12]
70015194:	e1a00003 	mov	r0, r3
70015198:	e3a01000 	mov	r1, #0
7001519c:	ebffffc8 	bl	700150c4 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
700151a0:	e51b3010 	ldr	r3, [fp, #-16]
700151a4:	e5d33002 	ldrb	r3, [r3, #2]
700151a8:	e3530004 	cmp	r3, #4
700151ac:	0a000006 	beq	700151cc <finsh_type_check+0x108>
700151b0:	e51b3010 	ldr	r3, [fp, #-16]
700151b4:	e5d32002 	ldrb	r2, [r3, #2]
700151b8:	e55b3011 	ldrb	r3, [fp, #-17]
700151bc:	e1823003 	orr	r3, r2, r3
700151c0:	e6ef2073 	uxtb	r2, r3
700151c4:	e51b3010 	ldr	r3, [fp, #-16]
700151c8:	e5c32002 	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
700151cc:	e51b3010 	ldr	r3, [fp, #-16]
700151d0:	e5933010 	ldr	r3, [r3, #16]
700151d4:	e3530000 	cmp	r3, #0
700151d8:	0a000006 	beq	700151f8 <finsh_type_check+0x134>
        {
            node->data_type = finsh_node_child(node)->data_type;
700151dc:	e51b3010 	ldr	r3, [fp, #-16]
700151e0:	e5933010 	ldr	r3, [r3, #16]
700151e4:	e5d32001 	ldrb	r2, [r3, #1]
700151e8:	e51b3010 	ldr	r3, [fp, #-16]
700151ec:	e5c32001 	strb	r2, [r3, #1]
            return 0;
700151f0:	e3a03000 	mov	r3, #0
700151f4:	ea00008d 	b	70015430 <finsh_type_check+0x36c>
        }

        if (node->node_type == FINSH_NODE_ID)
700151f8:	e51b3010 	ldr	r3, [fp, #-16]
700151fc:	e5d33000 	ldrb	r3, [r3]
70015200:	e3530001 	cmp	r3, #1
70015204:	1a00006d 	bne	700153c0 <finsh_type_check+0x2fc>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
70015208:	e51b3010 	ldr	r3, [fp, #-16]
7001520c:	e5d33002 	ldrb	r3, [r3, #2]
70015210:	e2033001 	and	r3, r3, #1
70015214:	e3530000 	cmp	r3, #0
70015218:	0a000031 	beq	700152e4 <finsh_type_check+0x220>
            {
                struct finsh_var* var;

                var = node->id.var;
7001521c:	e51b3010 	ldr	r3, [fp, #-16]
70015220:	e5933008 	ldr	r3, [r3, #8]
70015224:	e50b3008 	str	r3, [fp, #-8]
                if (var != NULL)
70015228:	e51b3008 	ldr	r3, [fp, #-8]
7001522c:	e3530000 	cmp	r3, #0
70015230:	0a00002a 	beq	700152e0 <finsh_type_check+0x21c>
                {
                    switch (var->type)
70015234:	e51b3008 	ldr	r3, [fp, #-8]
70015238:	e5d33011 	ldrb	r3, [r3, #17]
7001523c:	e2433001 	sub	r3, r3, #1
70015240:	e353000d 	cmp	r3, #13
70015244:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70015248:	ea000021 	b	700152d4 <finsh_type_check+0x210>
7001524c:	70015284 	.word	0x70015284
70015250:	700152c4 	.word	0x700152c4
70015254:	70015294 	.word	0x70015294
70015258:	70015294 	.word	0x70015294
7001525c:	700152c4 	.word	0x700152c4
70015260:	700152a4 	.word	0x700152a4
70015264:	700152a4 	.word	0x700152a4
70015268:	700152c4 	.word	0x700152c4
7001526c:	700152b4 	.word	0x700152b4
70015270:	700152b4 	.word	0x700152b4
70015274:	700152c4 	.word	0x700152c4
70015278:	700152b4 	.word	0x700152b4
7001527c:	700152b4 	.word	0x700152b4
70015280:	700152c4 	.word	0x700152c4
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
70015284:	e51b3010 	ldr	r3, [fp, #-16]
70015288:	e3a02000 	mov	r2, #0
7001528c:	e5c32001 	strb	r2, [r3, #1]
                        break;
70015290:	ea000012 	b	700152e0 <finsh_type_check+0x21c>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
70015294:	e51b3010 	ldr	r3, [fp, #-16]
70015298:	e3a02001 	mov	r2, #1
7001529c:	e5c32001 	strb	r2, [r3, #1]
                        break;
700152a0:	ea00000e 	b	700152e0 <finsh_type_check+0x21c>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
700152a4:	e51b3010 	ldr	r3, [fp, #-16]
700152a8:	e3a02002 	mov	r2, #2
700152ac:	e5c32001 	strb	r2, [r3, #1]
                        break;
700152b0:	ea00000a 	b	700152e0 <finsh_type_check+0x21c>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
700152b4:	e51b3010 	ldr	r3, [fp, #-16]
700152b8:	e3a02003 	mov	r2, #3
700152bc:	e5c32001 	strb	r2, [r3, #1]
                        break;
700152c0:	ea000006 	b	700152e0 <finsh_type_check+0x21c>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
700152c4:	e51b3010 	ldr	r3, [fp, #-16]
700152c8:	e3a02003 	mov	r2, #3
700152cc:	e5c32001 	strb	r2, [r3, #1]
                        break;
700152d0:	ea000002 	b	700152e0 <finsh_type_check+0x21c>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
700152d4:	e3a00003 	mov	r0, #3
700152d8:	eb0000a0 	bl	70015560 <finsh_error_set>
                        break;
700152dc:	e1a00000 	nop			; (mov r0, r0)
700152e0:	ea000051 	b	7001542c <finsh_type_check+0x368>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
700152e4:	e51b3010 	ldr	r3, [fp, #-16]
700152e8:	e5d33002 	ldrb	r3, [r3, #2]
700152ec:	e2033002 	and	r3, r3, #2
700152f0:	e3530000 	cmp	r3, #0
700152f4:	0a000030 	beq	700153bc <finsh_type_check+0x2f8>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
700152f8:	e51b3010 	ldr	r3, [fp, #-16]
700152fc:	e5933008 	ldr	r3, [r3, #8]
70015300:	e50b300c 	str	r3, [fp, #-12]
                if (sysvar != NULL)
70015304:	e51b300c 	ldr	r3, [fp, #-12]
70015308:	e3530000 	cmp	r3, #0
7001530c:	0a00002a 	beq	700153bc <finsh_type_check+0x2f8>
                {
                    switch (sysvar->type)
70015310:	e51b300c 	ldr	r3, [fp, #-12]
70015314:	e5d33008 	ldrb	r3, [r3, #8]
70015318:	e2433001 	sub	r3, r3, #1
7001531c:	e353000d 	cmp	r3, #13
70015320:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70015324:	ea000021 	b	700153b0 <finsh_type_check+0x2ec>
70015328:	70015360 	.word	0x70015360
7001532c:	700153a0 	.word	0x700153a0
70015330:	70015370 	.word	0x70015370
70015334:	70015370 	.word	0x70015370
70015338:	700153a0 	.word	0x700153a0
7001533c:	70015380 	.word	0x70015380
70015340:	70015380 	.word	0x70015380
70015344:	700153a0 	.word	0x700153a0
70015348:	70015390 	.word	0x70015390
7001534c:	70015390 	.word	0x70015390
70015350:	700153a0 	.word	0x700153a0
70015354:	70015390 	.word	0x70015390
70015358:	70015390 	.word	0x70015390
7001535c:	700153a0 	.word	0x700153a0
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
70015360:	e51b3010 	ldr	r3, [fp, #-16]
70015364:	e3a02000 	mov	r2, #0
70015368:	e5c32001 	strb	r2, [r3, #1]
                        break;
7001536c:	ea000012 	b	700153bc <finsh_type_check+0x2f8>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
70015370:	e51b3010 	ldr	r3, [fp, #-16]
70015374:	e3a02001 	mov	r2, #1
70015378:	e5c32001 	strb	r2, [r3, #1]
                        break;
7001537c:	ea00000e 	b	700153bc <finsh_type_check+0x2f8>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
70015380:	e51b3010 	ldr	r3, [fp, #-16]
70015384:	e3a02002 	mov	r2, #2
70015388:	e5c32001 	strb	r2, [r3, #1]
                        break;
7001538c:	ea00000a 	b	700153bc <finsh_type_check+0x2f8>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
70015390:	e51b3010 	ldr	r3, [fp, #-16]
70015394:	e3a02003 	mov	r2, #3
70015398:	e5c32001 	strb	r2, [r3, #1]
                        break;
7001539c:	ea000006 	b	700153bc <finsh_type_check+0x2f8>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
700153a0:	e51b3010 	ldr	r3, [fp, #-16]
700153a4:	e3a02003 	mov	r2, #3
700153a8:	e5c32001 	strb	r2, [r3, #1]
                        break;
700153ac:	ea000002 	b	700153bc <finsh_type_check+0x2f8>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
700153b0:	e3a00003 	mov	r0, #3
700153b4:	eb000069 	bl	70015560 <finsh_error_set>
                        break;
700153b8:	e1a00000 	nop			; (mov r0, r0)
700153bc:	ea00001a 	b	7001542c <finsh_type_check+0x368>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
700153c0:	e51b3010 	ldr	r3, [fp, #-16]
700153c4:	e5d33000 	ldrb	r3, [r3]
700153c8:	e3530002 	cmp	r3, #2
700153cc:	1a000003 	bne	700153e0 <finsh_type_check+0x31c>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
700153d0:	e51b3010 	ldr	r3, [fp, #-16]
700153d4:	e3a02001 	mov	r2, #1
700153d8:	e5c32001 	strb	r2, [r3, #1]
700153dc:	ea000012 	b	7001542c <finsh_type_check+0x368>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
700153e0:	e51b3010 	ldr	r3, [fp, #-16]
700153e4:	e5d33000 	ldrb	r3, [r3]
700153e8:	e3530003 	cmp	r3, #3
700153ec:	0a00000b 	beq	70015420 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
700153f0:	e51b3010 	ldr	r3, [fp, #-16]
700153f4:	e5d33000 	ldrb	r3, [r3]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
700153f8:	e3530004 	cmp	r3, #4
700153fc:	0a000007 	beq	70015420 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
70015400:	e51b3010 	ldr	r3, [fp, #-16]
70015404:	e5d33000 	ldrb	r3, [r3]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
70015408:	e3530005 	cmp	r3, #5
7001540c:	0a000003 	beq	70015420 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
70015410:	e51b3010 	ldr	r3, [fp, #-16]
70015414:	e5d33000 	ldrb	r3, [r3]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
70015418:	e3530006 	cmp	r3, #6
7001541c:	1a000002 	bne	7001542c <finsh_type_check+0x368>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
70015420:	e51b3010 	ldr	r3, [fp, #-16]
70015424:	e3a02003 	mov	r2, #3
70015428:	e5c32001 	strb	r2, [r3, #1]
        }
    }
    return 0;
7001542c:	e3a03000 	mov	r3, #0
}
70015430:	e1a00003 	mov	r0, r3
70015434:	e24bd004 	sub	sp, fp, #4
70015438:	e8bd8800 	pop	{fp, pc}

7001543c <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
7001543c:	e92d4800 	push	{fp, lr}
70015440:	e28db004 	add	fp, sp, #4
70015444:	e24dd010 	sub	sp, sp, #16
70015448:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
7001544c:	e51b0010 	ldr	r0, [fp, #-16]
70015450:	e3a01000 	mov	r1, #0
70015454:	ebffff1a 	bl	700150c4 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
70015458:	e30b06ac 	movw	r0, #46764	; 0xb6ac
7001545c:	e3470002 	movt	r0, #28674	; 0x7002
70015460:	e3a01000 	mov	r1, #0
70015464:	e3a02080 	mov	r2, #128	; 0x80
70015468:	fa003ab8 	blx	70023f50 <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
7001546c:	e30b072c 	movw	r0, #46892	; 0xb72c
70015470:	e3470002 	movt	r0, #28674	; 0x7002
70015474:	e3a01000 	mov	r1, #0
70015478:	e3a02004 	mov	r2, #4
7001547c:	fa003ab3 	blx	70023f50 <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
70015480:	e30b3420 	movw	r3, #46112	; 0xb420
70015484:	e3473002 	movt	r3, #28674	; 0x7002
70015488:	e30b272c 	movw	r2, #46892	; 0xb72c
7001548c:	e3472002 	movt	r2, #28674	; 0x7002
70015490:	e5832000 	str	r2, [r3]
    finsh_compile_pc = &text_segment[0];
70015494:	e30b341c 	movw	r3, #46108	; 0xb41c
70015498:	e3473002 	movt	r3, #28674	; 0x7002
7001549c:	e30b26ac 	movw	r2, #46764	; 0xb6ac
700154a0:	e3472002 	movt	r2, #28674	; 0x7002
700154a4:	e5832000 	str	r2, [r3]

    /* compile node */
    sibling = node;
700154a8:	e51b3010 	ldr	r3, [fp, #-16]
700154ac:	e50b3008 	str	r3, [fp, #-8]
    while (sibling != NULL)
700154b0:	ea000018 	b	70015518 <finsh_compiler_run+0xdc>
    {
        struct finsh_node* current_node;
        current_node = sibling;
700154b4:	e51b3008 	ldr	r3, [fp, #-8]
700154b8:	e50b300c 	str	r3, [fp, #-12]

        /* get sibling node */
        sibling = current_node->sibling;
700154bc:	e51b300c 	ldr	r3, [fp, #-12]
700154c0:	e593300c 	ldr	r3, [r3, #12]
700154c4:	e50b3008 	str	r3, [fp, #-8]

        /* clean sibling node */
        current_node->sibling = NULL;
700154c8:	e51b300c 	ldr	r3, [fp, #-12]
700154cc:	e3a02000 	mov	r2, #0
700154d0:	e583200c 	str	r2, [r3, #12]
        finsh_compile(current_node);
700154d4:	e51b000c 	ldr	r0, [fp, #-12]
700154d8:	ebfff13a 	bl	700119c8 <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
700154dc:	e51b3008 	ldr	r3, [fp, #-8]
700154e0:	e3530000 	cmp	r3, #0
700154e4:	0a00000b 	beq	70015518 <finsh_compiler_run+0xdc>
700154e8:	e30b341c 	movw	r3, #46108	; 0xb41c
700154ec:	e3473002 	movt	r3, #28674	; 0x7002
700154f0:	e5933000 	ldr	r3, [r3]
700154f4:	e3a0202b 	mov	r2, #43	; 0x2b
700154f8:	e5c32000 	strb	r2, [r3]
700154fc:	e30b341c 	movw	r3, #46108	; 0xb41c
70015500:	e3473002 	movt	r3, #28674	; 0x7002
70015504:	e5933000 	ldr	r3, [r3]
70015508:	e2832001 	add	r2, r3, #1
7001550c:	e30b341c 	movw	r3, #46108	; 0xb41c
70015510:	e3473002 	movt	r3, #28674	; 0x7002
70015514:	e5832000 	str	r2, [r3]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
70015518:	e51b3008 	ldr	r3, [fp, #-8]
7001551c:	e3530000 	cmp	r3, #0
70015520:	1affffe3 	bne	700154b4 <finsh_compiler_run+0x78>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
70015524:	e3a03000 	mov	r3, #0
}
70015528:	e1a00003 	mov	r0, r3
7001552c:	e24bd004 	sub	sp, fp, #4
70015530:	e8bd8800 	pop	{fp, pc}

70015534 <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
70015534:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015538:	e28db000 	add	fp, sp, #0
	global_errno = FINSH_ERROR_OK;
7001553c:	e30b3424 	movw	r3, #46116	; 0xb424
70015540:	e3473002 	movt	r3, #28674	; 0x7002
70015544:	e3a02000 	mov	r2, #0
70015548:	e5c32000 	strb	r2, [r3]

	return 0;
7001554c:	e3a03000 	mov	r3, #0
}
70015550:	e1a00003 	mov	r0, r3
70015554:	e24bd000 	sub	sp, fp, #0
70015558:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001555c:	e12fff1e 	bx	lr

70015560 <finsh_error_set>:

int finsh_error_set(u_char type)
{
70015560:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015564:	e28db000 	add	fp, sp, #0
70015568:	e24dd00c 	sub	sp, sp, #12
7001556c:	e1a03000 	mov	r3, r0
70015570:	e54b3005 	strb	r3, [fp, #-5]
	global_errno = type;
70015574:	e30b3424 	movw	r3, #46116	; 0xb424
70015578:	e3473002 	movt	r3, #28674	; 0x7002
7001557c:	e55b2005 	ldrb	r2, [fp, #-5]
70015580:	e5c32000 	strb	r2, [r3]

	return 0;
70015584:	e3a03000 	mov	r3, #0
}
70015588:	e1a00003 	mov	r0, r3
7001558c:	e24bd000 	sub	sp, fp, #0
70015590:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015594:	e12fff1e 	bx	lr

70015598 <finsh_errno>:

u_char finsh_errno()
{
70015598:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001559c:	e28db000 	add	fp, sp, #0
	return global_errno;
700155a0:	e30b3424 	movw	r3, #46116	; 0xb424
700155a4:	e3473002 	movt	r3, #28674	; 0x7002
700155a8:	e5d33000 	ldrb	r3, [r3]
}
700155ac:	e1a00003 	mov	r0, r3
700155b0:	e24bd000 	sub	sp, fp, #0
700155b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700155b8:	e12fff1e 	bx	lr

700155bc <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
700155bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700155c0:	e28db000 	add	fp, sp, #0
700155c4:	e24dd00c 	sub	sp, sp, #12
700155c8:	e1a03000 	mov	r3, r0
700155cc:	e54b3005 	strb	r3, [fp, #-5]
	return finsh_error_string_table[type];
700155d0:	e55b2005 	ldrb	r2, [fp, #-5]
700155d4:	e3083e1c 	movw	r3, #36380	; 0x8e1c
700155d8:	e3473002 	movt	r3, #28674	; 0x7002
700155dc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
700155e0:	e1a00003 	mov	r0, r3
700155e4:	e24bd000 	sub	sp, fp, #0
700155e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700155ec:	e12fff1e 	bx	lr

700155f0 <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
700155f0:	e92d4800 	push	{fp, lr}
700155f4:	e28db004 	add	fp, sp, #4
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
700155f8:	e30b0428 	movw	r0, #46120	; 0xb428
700155fc:	e3470002 	movt	r0, #28674	; 0x7002
70015600:	e3a01000 	mov	r1, #0
70015604:	e3a02080 	mov	r2, #128	; 0x80
70015608:	fa003a50 	blx	70023f50 <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
7001560c:	e30a3a20 	movw	r3, #43552	; 0xaa20
70015610:	e3473002 	movt	r3, #28674	; 0x7002
70015614:	e30b2428 	movw	r2, #46120	; 0xb428
70015618:	e3472002 	movt	r2, #28674	; 0x7002
7001561c:	e5832000 	str	r2, [r3]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
70015620:	e30a3a20 	movw	r3, #43552	; 0xaa20
70015624:	e3473002 	movt	r3, #28674	; 0x7002
70015628:	e5933000 	ldr	r3, [r3]
7001562c:	e3a02078 	mov	r2, #120	; 0x78
70015630:	e5832000 	str	r2, [r3]
    free_list->next     = NULL;
70015634:	e30a3a20 	movw	r3, #43552	; 0xaa20
70015638:	e3473002 	movt	r3, #28674	; 0x7002
7001563c:	e5933000 	ldr	r3, [r3]
70015640:	e3a02000 	mov	r2, #0
70015644:	e5832004 	str	r2, [r3, #4]

    allocate_list       = NULL;
70015648:	e30a3a24 	movw	r3, #43556	; 0xaa24
7001564c:	e3473002 	movt	r3, #28674	; 0x7002
70015650:	e3a02000 	mov	r2, #0
70015654:	e5832000 	str	r2, [r3]

    return 0;
70015658:	e3a03000 	mov	r3, #0
}
7001565c:	e1a00003 	mov	r0, r3
70015660:	e8bd8800 	pop	{fp, pc}

70015664 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
70015664:	e92d4800 	push	{fp, lr}
70015668:	e28db004 	add	fp, sp, #4
7001566c:	e24dd010 	sub	sp, sp, #16
70015670:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
70015674:	e51b3010 	ldr	r3, [fp, #-16]
70015678:	e2833003 	add	r3, r3, #3
7001567c:	e3c33003 	bic	r3, r3, #3
70015680:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = free_list;
70015684:	e30a3a20 	movw	r3, #43552	; 0xaa20
70015688:	e3473002 	movt	r3, #28674	; 0x7002
7001568c:	e5933000 	ldr	r3, [r3]
70015690:	e50b3008 	str	r3, [fp, #-8]
70015694:	ea000002 	b	700156a4 <finsh_heap_allocate+0x40>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
70015698:	e51b3008 	ldr	r3, [fp, #-8]
7001569c:	e5933004 	ldr	r3, [r3, #4]
700156a0:	e50b3008 	str	r3, [fp, #-8]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
700156a4:	e51b3008 	ldr	r3, [fp, #-8]
700156a8:	e3530000 	cmp	r3, #0
700156ac:	0a000005 	beq	700156c8 <finsh_heap_allocate+0x64>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
700156b0:	e51b3008 	ldr	r3, [fp, #-8]
700156b4:	e5932000 	ldr	r2, [r3]
700156b8:	e51b3010 	ldr	r3, [fp, #-16]
700156bc:	e2833008 	add	r3, r3, #8
700156c0:	e1520003 	cmp	r2, r3
700156c4:	9afffff3 	bls	70015698 <finsh_heap_allocate+0x34>
        header = header->next) ;

	if (header == NULL)
700156c8:	e51b3008 	ldr	r3, [fp, #-8]
700156cc:	e3530000 	cmp	r3, #0
700156d0:	1a000016 	bne	70015730 <finsh_heap_allocate+0xcc>
	{
		finsh_heap_gc();
700156d4:	eb000043 	bl	700157e8 <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
700156d8:	e30a3a20 	movw	r3, #43552	; 0xaa20
700156dc:	e3473002 	movt	r3, #28674	; 0x7002
700156e0:	e5933000 	ldr	r3, [r3]
700156e4:	e50b3008 	str	r3, [fp, #-8]
700156e8:	ea000002 	b	700156f8 <finsh_heap_allocate+0x94>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
700156ec:	e51b3008 	ldr	r3, [fp, #-8]
700156f0:	e5933004 	ldr	r3, [r3, #4]
700156f4:	e50b3008 	str	r3, [fp, #-8]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
700156f8:	e51b3008 	ldr	r3, [fp, #-8]
700156fc:	e3530000 	cmp	r3, #0
70015700:	0a000005 	beq	7001571c <finsh_heap_allocate+0xb8>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
70015704:	e51b3008 	ldr	r3, [fp, #-8]
70015708:	e5932000 	ldr	r2, [r3]
7001570c:	e51b3010 	ldr	r3, [fp, #-16]
70015710:	e2833008 	add	r3, r3, #8
70015714:	e1520003 	cmp	r2, r3
70015718:	3afffff3 	bcc	700156ec <finsh_heap_allocate+0x88>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
7001571c:	e51b3008 	ldr	r3, [fp, #-8]
70015720:	e3530000 	cmp	r3, #0
70015724:	1a000001 	bne	70015730 <finsh_heap_allocate+0xcc>
70015728:	e3a03000 	mov	r3, #0
7001572c:	ea000015 	b	70015788 <finsh_heap_allocate+0x124>
	}

    /* split block */
	finsh_block_split(header, size);
70015730:	e51b0008 	ldr	r0, [fp, #-8]
70015734:	e51b1010 	ldr	r1, [fp, #-16]
70015738:	eb0000d4 	bl	70015a90 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
7001573c:	e30a0a20 	movw	r0, #43552	; 0xaa20
70015740:	e3470002 	movt	r0, #28674	; 0x7002
70015744:	e51b1008 	ldr	r1, [fp, #-8]
70015748:	eb0000a5 	bl	700159e4 <finsh_block_remove>
	header->next = NULL;
7001574c:	e51b3008 	ldr	r3, [fp, #-8]
70015750:	e3a02000 	mov	r2, #0
70015754:	e5832004 	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
70015758:	e30a0a24 	movw	r0, #43556	; 0xaa24
7001575c:	e3470002 	movt	r0, #28674	; 0x7002
70015760:	e51b1008 	ldr	r1, [fp, #-8]
70015764:	eb000060 	bl	700158ec <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
70015768:	e51b3008 	ldr	r3, [fp, #-8]
7001576c:	e2833008 	add	r3, r3, #8
70015770:	e1a00003 	mov	r0, r3
70015774:	e3a01000 	mov	r1, #0
70015778:	e51b2010 	ldr	r2, [fp, #-16]
7001577c:	fa0039f3 	blx	70023f50 <memset>

	return finsh_block_get_data(header);
70015780:	e51b3008 	ldr	r3, [fp, #-8]
70015784:	e2833008 	add	r3, r3, #8
}
70015788:	e1a00003 	mov	r0, r3
7001578c:	e24bd004 	sub	sp, fp, #4
70015790:	e8bd8800 	pop	{fp, pc}

70015794 <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
70015794:	e92d4800 	push	{fp, lr}
70015798:	e28db004 	add	fp, sp, #4
7001579c:	e24dd010 	sub	sp, sp, #16
700157a0:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
700157a4:	e51b3010 	ldr	r3, [fp, #-16]
700157a8:	e2433008 	sub	r3, r3, #8
700157ac:	e50b3008 	str	r3, [fp, #-8]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
700157b0:	e30a0a24 	movw	r0, #43556	; 0xaa24
700157b4:	e3470002 	movt	r0, #28674	; 0x7002
700157b8:	e51b1008 	ldr	r1, [fp, #-8]
700157bc:	eb000088 	bl	700159e4 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
700157c0:	e30a0a20 	movw	r0, #43552	; 0xaa20
700157c4:	e3470002 	movt	r0, #28674	; 0x7002
700157c8:	e51b1008 	ldr	r1, [fp, #-8]
700157cc:	eb000046 	bl	700158ec <finsh_block_insert>
	finsh_block_merge(&free_list, header);
700157d0:	e30a0a20 	movw	r0, #43552	; 0xaa20
700157d4:	e3470002 	movt	r0, #28674	; 0x7002
700157d8:	e51b1008 	ldr	r1, [fp, #-8]
700157dc:	eb0000c9 	bl	70015b08 <finsh_block_merge>
}
700157e0:	e24bd004 	sub	sp, fp, #4
700157e4:	e8bd8800 	pop	{fp, pc}

700157e8 <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
700157e8:	e92d4800 	push	{fp, lr}
700157ec:	e28db004 	add	fp, sp, #4
700157f0:	e24dd010 	sub	sp, sp, #16
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
700157f4:	e3a03000 	mov	r3, #0
700157f8:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
700157fc:	e30a3a24 	movw	r3, #43556	; 0xaa24
70015800:	e3473002 	movt	r3, #28674	; 0x7002
70015804:	e5933000 	ldr	r3, [r3]
70015808:	e50b300c 	str	r3, [fp, #-12]
7001580c:	ea000031 	b	700158d8 <finsh_heap_gc+0xf0>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
70015810:	e3a03000 	mov	r3, #0
70015814:	e50b3008 	str	r3, [fp, #-8]
70015818:	ea00001f 	b	7001589c <finsh_heap_gc+0xb4>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
7001581c:	e30b25ec 	movw	r2, #46572	; 0xb5ec
70015820:	e3472002 	movt	r2, #28674	; 0x7002
70015824:	e51b1008 	ldr	r1, [fp, #-8]
70015828:	e3a00010 	mov	r0, #16
7001582c:	e1a03001 	mov	r3, r1
70015830:	e1a03083 	lsl	r3, r3, #1
70015834:	e0833001 	add	r3, r3, r1
70015838:	e1a03183 	lsl	r3, r3, #3
7001583c:	e0823003 	add	r3, r2, r3
70015840:	e0833000 	add	r3, r3, r0
70015844:	e5d33001 	ldrb	r3, [r3, #1]
70015848:	e3530000 	cmp	r3, #0
7001584c:	0a00000f 	beq	70015890 <finsh_heap_gc+0xa8>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
70015850:	e30b25ec 	movw	r2, #46572	; 0xb5ec
70015854:	e3472002 	movt	r2, #28674	; 0x7002
70015858:	e51b1008 	ldr	r1, [fp, #-8]
7001585c:	e3a00014 	mov	r0, #20
70015860:	e1a03001 	mov	r3, r1
70015864:	e1a03083 	lsl	r3, r3, #1
70015868:	e0833001 	add	r3, r3, r1
7001586c:	e1a03183 	lsl	r3, r3, #3
70015870:	e0823003 	add	r3, r2, r3
70015874:	e0833000 	add	r3, r3, r0
70015878:	e5932000 	ldr	r2, [r3]
7001587c:	e51b300c 	ldr	r3, [fp, #-12]
70015880:	e2833008 	add	r3, r3, #8
70015884:	e1520003 	cmp	r2, r3
70015888:	1a000000 	bne	70015890 <finsh_heap_gc+0xa8>
					break;
7001588c:	ea000005 	b	700158a8 <finsh_heap_gc+0xc0>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
70015890:	e51b3008 	ldr	r3, [fp, #-8]
70015894:	e2833001 	add	r3, r3, #1
70015898:	e50b3008 	str	r3, [fp, #-8]
7001589c:	e51b3008 	ldr	r3, [fp, #-8]
700158a0:	e3530007 	cmp	r3, #7
700158a4:	daffffdc 	ble	7001581c <finsh_heap_gc+0x34>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
700158a8:	e51b300c 	ldr	r3, [fp, #-12]
700158ac:	e50b3010 	str	r3, [fp, #-16]
		header = header->next;
700158b0:	e51b300c 	ldr	r3, [fp, #-12]
700158b4:	e5933004 	ldr	r3, [r3, #4]
700158b8:	e50b300c 	str	r3, [fp, #-12]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
700158bc:	e51b3008 	ldr	r3, [fp, #-8]
700158c0:	e3530008 	cmp	r3, #8
700158c4:	1a000003 	bne	700158d8 <finsh_heap_gc+0xf0>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
700158c8:	e51b3010 	ldr	r3, [fp, #-16]
700158cc:	e2833008 	add	r3, r3, #8
700158d0:	e1a00003 	mov	r0, r3
700158d4:	ebffffae 	bl	70015794 <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
700158d8:	e51b300c 	ldr	r3, [fp, #-12]
700158dc:	e3530000 	cmp	r3, #0
700158e0:	1affffca 	bne	70015810 <finsh_heap_gc+0x28>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
700158e4:	e24bd004 	sub	sp, fp, #4
700158e8:	e8bd8800 	pop	{fp, pc}

700158ec <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
700158ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700158f0:	e28db000 	add	fp, sp, #0
700158f4:	e24dd014 	sub	sp, sp, #20
700158f8:	e50b0010 	str	r0, [fp, #-16]
700158fc:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    if (*list == NULL)
70015900:	e51b3010 	ldr	r3, [fp, #-16]
70015904:	e5933000 	ldr	r3, [r3]
70015908:	e3530000 	cmp	r3, #0
7001590c:	1a000003 	bne	70015920 <finsh_block_insert+0x34>
    {
        *list = header;
70015910:	e51b3010 	ldr	r3, [fp, #-16]
70015914:	e51b2014 	ldr	r2, [fp, #-20]
70015918:	e5832000 	str	r2, [r3]
        return;
7001591c:	ea00002d 	b	700159d8 <finsh_block_insert+0xec>
    }

    /* find out insert point */
	node = *list;
70015920:	e51b3010 	ldr	r3, [fp, #-16]
70015924:	e5933000 	ldr	r3, [r3]
70015928:	e50b3008 	str	r3, [fp, #-8]

	if (node > header)
7001592c:	e51b2008 	ldr	r2, [fp, #-8]
70015930:	e51b3014 	ldr	r3, [fp, #-20]
70015934:	e1520003 	cmp	r2, r3
70015938:	9a000006 	bls	70015958 <finsh_block_insert+0x6c>
	{
		/* insert node in the header of list */
		header->next = node;
7001593c:	e51b3014 	ldr	r3, [fp, #-20]
70015940:	e51b2008 	ldr	r2, [fp, #-8]
70015944:	e5832004 	str	r2, [r3, #4]
		*list = header;
70015948:	e51b3010 	ldr	r3, [fp, #-16]
7001594c:	e51b2014 	ldr	r2, [fp, #-20]
70015950:	e5832000 	str	r2, [r3]

		return;
70015954:	ea00001f 	b	700159d8 <finsh_block_insert+0xec>
	}
	else
	{
		for (node = *list; node; node = node->next)
70015958:	e51b3010 	ldr	r3, [fp, #-16]
7001595c:	e5933000 	ldr	r3, [r3]
70015960:	e50b3008 	str	r3, [fp, #-8]
70015964:	ea00000d 	b	700159a0 <finsh_block_insert+0xb4>
		{
    		if (node->next > header) break;
70015968:	e51b3008 	ldr	r3, [fp, #-8]
7001596c:	e5932004 	ldr	r2, [r3, #4]
70015970:	e51b3014 	ldr	r3, [fp, #-20]
70015974:	e1520003 	cmp	r2, r3
70015978:	9a000000 	bls	70015980 <finsh_block_insert+0x94>
7001597c:	ea00000a 	b	700159ac <finsh_block_insert+0xc0>

    		if (node->next == NULL) break;
70015980:	e51b3008 	ldr	r3, [fp, #-8]
70015984:	e5933004 	ldr	r3, [r3, #4]
70015988:	e3530000 	cmp	r3, #0
7001598c:	1a000000 	bne	70015994 <finsh_block_insert+0xa8>
70015990:	ea000005 	b	700159ac <finsh_block_insert+0xc0>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
70015994:	e51b3008 	ldr	r3, [fp, #-8]
70015998:	e5933004 	ldr	r3, [r3, #4]
7001599c:	e50b3008 	str	r3, [fp, #-8]
700159a0:	e51b3008 	ldr	r3, [fp, #-8]
700159a4:	e3530000 	cmp	r3, #0
700159a8:	1affffee 	bne	70015968 <finsh_block_insert+0x7c>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
700159ac:	e51b3008 	ldr	r3, [fp, #-8]
700159b0:	e5933004 	ldr	r3, [r3, #4]
700159b4:	e3530000 	cmp	r3, #0
700159b8:	0a000003 	beq	700159cc <finsh_block_insert+0xe0>
700159bc:	e51b3008 	ldr	r3, [fp, #-8]
700159c0:	e5932004 	ldr	r2, [r3, #4]
700159c4:	e51b3014 	ldr	r3, [fp, #-20]
700159c8:	e5832004 	str	r2, [r3, #4]
    node->next      = header;
700159cc:	e51b3008 	ldr	r3, [fp, #-8]
700159d0:	e51b2014 	ldr	r2, [fp, #-20]
700159d4:	e5832004 	str	r2, [r3, #4]
}
700159d8:	e24bd000 	sub	sp, fp, #0
700159dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700159e0:	e12fff1e 	bx	lr

700159e4 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
700159e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700159e8:	e28db000 	add	fp, sp, #0
700159ec:	e24dd014 	sub	sp, sp, #20
700159f0:	e50b0010 	str	r0, [fp, #-16]
700159f4:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    node = *list;
700159f8:	e51b3010 	ldr	r3, [fp, #-16]
700159fc:	e5933000 	ldr	r3, [r3]
70015a00:	e50b3008 	str	r3, [fp, #-8]
    if (node == header)
70015a04:	e51b2008 	ldr	r2, [fp, #-8]
70015a08:	e51b3014 	ldr	r3, [fp, #-20]
70015a0c:	e1520003 	cmp	r2, r3
70015a10:	1a000007 	bne	70015a34 <finsh_block_remove+0x50>
    {
        /* remove list header */
        *list = header->next;
70015a14:	e51b3014 	ldr	r3, [fp, #-20]
70015a18:	e5932004 	ldr	r2, [r3, #4]
70015a1c:	e51b3010 	ldr	r3, [fp, #-16]
70015a20:	e5832000 	str	r2, [r3]
        header->next = NULL;
70015a24:	e51b3014 	ldr	r3, [fp, #-20]
70015a28:	e3a02000 	mov	r2, #0
70015a2c:	e5832004 	str	r2, [r3, #4]

        return;
70015a30:	ea000013 	b	70015a84 <finsh_block_remove+0xa0>
    }

    for (node = *list; node != NULL; node = node->next)
70015a34:	e51b3010 	ldr	r3, [fp, #-16]
70015a38:	e5933000 	ldr	r3, [r3]
70015a3c:	e50b3008 	str	r3, [fp, #-8]
70015a40:	ea00000c 	b	70015a78 <finsh_block_remove+0x94>
    {
        if (node->next == header)
70015a44:	e51b3008 	ldr	r3, [fp, #-8]
70015a48:	e5932004 	ldr	r2, [r3, #4]
70015a4c:	e51b3014 	ldr	r3, [fp, #-20]
70015a50:	e1520003 	cmp	r2, r3
70015a54:	1a000004 	bne	70015a6c <finsh_block_remove+0x88>
        {
            node->next = header->next;
70015a58:	e51b3014 	ldr	r3, [fp, #-20]
70015a5c:	e5932004 	ldr	r2, [r3, #4]
70015a60:	e51b3008 	ldr	r3, [fp, #-8]
70015a64:	e5832004 	str	r2, [r3, #4]
            break;
70015a68:	ea000005 	b	70015a84 <finsh_block_remove+0xa0>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
70015a6c:	e51b3008 	ldr	r3, [fp, #-8]
70015a70:	e5933004 	ldr	r3, [r3, #4]
70015a74:	e50b3008 	str	r3, [fp, #-8]
70015a78:	e51b3008 	ldr	r3, [fp, #-8]
70015a7c:	e3530000 	cmp	r3, #0
70015a80:	1affffef 	bne	70015a44 <finsh_block_remove+0x60>
        {
            node->next = header->next;
            break;
        }
    }
}
70015a84:	e24bd000 	sub	sp, fp, #0
70015a88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015a8c:	e12fff1e 	bx	lr

70015a90 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
70015a90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015a94:	e28db000 	add	fp, sp, #0
70015a98:	e24dd014 	sub	sp, sp, #20
70015a9c:	e50b0010 	str	r0, [fp, #-16]
70015aa0:	e50b1014 	str	r1, [fp, #-20]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
70015aa4:	e51b3014 	ldr	r3, [fp, #-20]
70015aa8:	e2833008 	add	r3, r3, #8
70015aac:	e51b2010 	ldr	r2, [fp, #-16]
70015ab0:	e0823003 	add	r3, r2, r3
70015ab4:	e50b3008 	str	r3, [fp, #-8]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
70015ab8:	e51b3010 	ldr	r3, [fp, #-16]
70015abc:	e5932000 	ldr	r2, [r3]
70015ac0:	e51b3014 	ldr	r3, [fp, #-20]
70015ac4:	e0633002 	rsb	r3, r3, r2
70015ac8:	e2432008 	sub	r2, r3, #8
70015acc:	e51b3008 	ldr	r3, [fp, #-8]
70015ad0:	e5832000 	str	r2, [r3]
    header->length = size;
70015ad4:	e51b3010 	ldr	r3, [fp, #-16]
70015ad8:	e51b2014 	ldr	r2, [fp, #-20]
70015adc:	e5832000 	str	r2, [r3]
    next->next = header->next;
70015ae0:	e51b3010 	ldr	r3, [fp, #-16]
70015ae4:	e5932004 	ldr	r2, [r3, #4]
70015ae8:	e51b3008 	ldr	r3, [fp, #-8]
70015aec:	e5832004 	str	r2, [r3, #4]

    header->next = next;
70015af0:	e51b3010 	ldr	r3, [fp, #-16]
70015af4:	e51b2008 	ldr	r2, [fp, #-8]
70015af8:	e5832004 	str	r2, [r3, #4]
}
70015afc:	e24bd000 	sub	sp, fp, #0
70015b00:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015b04:	e12fff1e 	bx	lr

70015b08 <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
70015b08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015b0c:	e28db000 	add	fp, sp, #0
70015b10:	e24dd014 	sub	sp, sp, #20
70015b14:	e50b0010 	str	r0, [fp, #-16]
70015b18:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
70015b1c:	e51b3014 	ldr	r3, [fp, #-20]
70015b20:	e5933004 	ldr	r3, [r3, #4]
70015b24:	e50b300c 	str	r3, [fp, #-12]

    if (*list == header) prev_node = NULL;
70015b28:	e51b3010 	ldr	r3, [fp, #-16]
70015b2c:	e5932000 	ldr	r2, [r3]
70015b30:	e51b3014 	ldr	r3, [fp, #-20]
70015b34:	e1520003 	cmp	r2, r3
70015b38:	1a000002 	bne	70015b48 <finsh_block_merge+0x40>
70015b3c:	e3a03000 	mov	r3, #0
70015b40:	e50b3008 	str	r3, [fp, #-8]
70015b44:	ea00000f 	b	70015b88 <finsh_block_merge+0x80>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
70015b48:	e51b3010 	ldr	r3, [fp, #-16]
70015b4c:	e5933000 	ldr	r3, [r3]
70015b50:	e50b3008 	str	r3, [fp, #-8]
70015b54:	ea000008 	b	70015b7c <finsh_block_merge+0x74>
        {
            if (prev_node->next == header)
70015b58:	e51b3008 	ldr	r3, [fp, #-8]
70015b5c:	e5932004 	ldr	r2, [r3, #4]
70015b60:	e51b3014 	ldr	r3, [fp, #-20]
70015b64:	e1520003 	cmp	r2, r3
70015b68:	1a000000 	bne	70015b70 <finsh_block_merge+0x68>
                break;
70015b6c:	ea000005 	b	70015b88 <finsh_block_merge+0x80>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
70015b70:	e51b3008 	ldr	r3, [fp, #-8]
70015b74:	e5933004 	ldr	r3, [r3, #4]
70015b78:	e50b3008 	str	r3, [fp, #-8]
70015b7c:	e51b3008 	ldr	r3, [fp, #-8]
70015b80:	e3530000 	cmp	r3, #0
70015b84:	1afffff3 	bne	70015b58 <finsh_block_merge+0x50>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
70015b88:	e51b3008 	ldr	r3, [fp, #-8]
70015b8c:	e3530000 	cmp	r3, #0
70015b90:	0a00002f 	beq	70015c54 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
70015b94:	e51b3008 	ldr	r3, [fp, #-8]
70015b98:	e5933000 	ldr	r3, [r3]
70015b9c:	e2833008 	add	r3, r3, #8
70015ba0:	e51b2008 	ldr	r2, [fp, #-8]
70015ba4:	e0822003 	add	r2, r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
70015ba8:	e51b3014 	ldr	r3, [fp, #-20]
70015bac:	e1520003 	cmp	r2, r3
70015bb0:	1a000027 	bne	70015c54 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
70015bb4:	e51b300c 	ldr	r3, [fp, #-12]
70015bb8:	e3530000 	cmp	r3, #0
70015bbc:	0a000017 	beq	70015c20 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
70015bc0:	e51b3014 	ldr	r3, [fp, #-20]
70015bc4:	e5933000 	ldr	r3, [r3]
70015bc8:	e2833008 	add	r3, r3, #8
70015bcc:	e51b2014 	ldr	r2, [fp, #-20]
70015bd0:	e0822003 	add	r2, r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
70015bd4:	e51b300c 	ldr	r3, [fp, #-12]
70015bd8:	e1520003 	cmp	r2, r3
70015bdc:	1a00000f 	bne	70015c20 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
70015be0:	e51b3008 	ldr	r3, [fp, #-8]
70015be4:	e5932000 	ldr	r2, [r3]
70015be8:	e51b3014 	ldr	r3, [fp, #-20]
70015bec:	e5931000 	ldr	r1, [r3]
70015bf0:	e51b300c 	ldr	r3, [fp, #-12]
70015bf4:	e5933000 	ldr	r3, [r3]
70015bf8:	e0813003 	add	r3, r1, r3
70015bfc:	e0823003 	add	r3, r2, r3
70015c00:	e2832010 	add	r2, r3, #16
70015c04:	e51b3008 	ldr	r3, [fp, #-8]
70015c08:	e5832000 	str	r2, [r3]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
70015c0c:	e51b300c 	ldr	r3, [fp, #-12]
70015c10:	e5932004 	ldr	r2, [r3, #4]
70015c14:	e51b3008 	ldr	r3, [fp, #-8]
70015c18:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
70015c1c:	ea000023 	b	70015cb0 <finsh_block_merge+0x1a8>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
70015c20:	e51b3008 	ldr	r3, [fp, #-8]
70015c24:	e5932000 	ldr	r2, [r3]
70015c28:	e51b3014 	ldr	r3, [fp, #-20]
70015c2c:	e5933000 	ldr	r3, [r3]
70015c30:	e0823003 	add	r3, r2, r3
70015c34:	e2832008 	add	r2, r3, #8
70015c38:	e51b3008 	ldr	r3, [fp, #-8]
70015c3c:	e5832000 	str	r2, [r3]
            prev_node->next = header->next;
70015c40:	e51b3014 	ldr	r3, [fp, #-20]
70015c44:	e5932004 	ldr	r2, [r3, #4]
70015c48:	e51b3008 	ldr	r3, [fp, #-8]
70015c4c:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
70015c50:	ea000016 	b	70015cb0 <finsh_block_merge+0x1a8>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
70015c54:	e51b300c 	ldr	r3, [fp, #-12]
70015c58:	e3530000 	cmp	r3, #0
70015c5c:	0a000013 	beq	70015cb0 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
70015c60:	e51b3014 	ldr	r3, [fp, #-20]
70015c64:	e5933000 	ldr	r3, [r3]
70015c68:	e2833008 	add	r3, r3, #8
70015c6c:	e51b2014 	ldr	r2, [fp, #-20]
70015c70:	e0822003 	add	r2, r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
70015c74:	e51b300c 	ldr	r3, [fp, #-12]
70015c78:	e1520003 	cmp	r2, r3
70015c7c:	1a00000b 	bne	70015cb0 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
70015c80:	e51b3014 	ldr	r3, [fp, #-20]
70015c84:	e5932000 	ldr	r2, [r3]
70015c88:	e51b300c 	ldr	r3, [fp, #-12]
70015c8c:	e5933000 	ldr	r3, [r3]
70015c90:	e0823003 	add	r3, r2, r3
70015c94:	e2832008 	add	r2, r3, #8
70015c98:	e51b3014 	ldr	r3, [fp, #-20]
70015c9c:	e5832000 	str	r2, [r3]
        header->next = next_node->next;
70015ca0:	e51b300c 	ldr	r3, [fp, #-12]
70015ca4:	e5932004 	ldr	r2, [r3, #4]
70015ca8:	e51b3014 	ldr	r3, [fp, #-20]
70015cac:	e5832004 	str	r2, [r3, #4]
    }
}
70015cb0:	e24bd000 	sub	sp, fp, #0
70015cb4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015cb8:	e12fff1e 	bx	lr

70015cbc <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
70015cbc:	e92d4800 	push	{fp, lr}
70015cc0:	e28db004 	add	fp, sp, #4
70015cc4:	e24dd008 	sub	sp, sp, #8
70015cc8:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
70015ccc:	e51b0008 	ldr	r0, [fp, #-8]
70015cd0:	eb000e07 	bl	700194f4 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
70015cd4:	eb000027 	bl	70015d78 <finsh_node_init>
	finsh_var_init();
70015cd8:	eb000e11 	bl	70019524 <finsh_var_init>
	finsh_error_init();
70015cdc:	ebfffe14 	bl	70015534 <finsh_error_init>
	finsh_heap_init();
70015ce0:	ebfffe42 	bl	700155f0 <finsh_heap_init>

	return 0;
70015ce4:	e3a03000 	mov	r3, #0
}
70015ce8:	e1a00003 	mov	r0, r3
70015cec:	e24bd004 	sub	sp, fp, #4
70015cf0:	e8bd8800 	pop	{fp, pc}

70015cf4 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
70015cf4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015cf8:	e28db000 	add	fp, sp, #0
    return finsh_vm_stack[0].long_value;
70015cfc:	e30b372c 	movw	r3, #46892	; 0xb72c
70015d00:	e3473002 	movt	r3, #28674	; 0x7002
70015d04:	e5933000 	ldr	r3, [r3]
}
70015d08:	e1a00003 	mov	r0, r3
70015d0c:	e24bd000 	sub	sp, fp, #0
70015d10:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015d14:	e12fff1e 	bx	lr

70015d18 <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
70015d18:	e92d4800 	push	{fp, lr}
70015d1c:	e28db004 	add	fp, sp, #4
70015d20:	e24dd008 	sub	sp, sp, #8
70015d24:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
70015d28:	e51b0008 	ldr	r0, [fp, #-8]
70015d2c:	eb000df0 	bl	700194f4 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
70015d30:	eb000010 	bl	70015d78 <finsh_node_init>
	finsh_error_init();
70015d34:	ebfffdfe 	bl	70015534 <finsh_error_init>

	return 0;
70015d38:	e3a03000 	mov	r3, #0
}
70015d3c:	e1a00003 	mov	r0, r3
70015d40:	e24bd004 	sub	sp, fp, #4
70015d44:	e8bd8800 	pop	{fp, pc}

70015d48 <finsh_reset>:

int finsh_reset(struct finsh_parser* parser)
{
70015d48:	e92d4800 	push	{fp, lr}
70015d4c:	e28db004 	add	fp, sp, #4
70015d50:	e24dd008 	sub	sp, sp, #8
70015d54:	e50b0008 	str	r0, [fp, #-8]
	/* finsh init */
	finsh_node_init();
70015d58:	eb000006 	bl	70015d78 <finsh_node_init>
	finsh_var_init();
70015d5c:	eb000df0 	bl	70019524 <finsh_var_init>
	finsh_error_init();
70015d60:	ebfffdf3 	bl	70015534 <finsh_error_init>
	finsh_heap_init();
70015d64:	ebfffe21 	bl	700155f0 <finsh_heap_init>

	return 0;
70015d68:	e3a03000 	mov	r3, #0
}
70015d6c:	e1a00003 	mov	r0, r3
70015d70:	e24bd004 	sub	sp, fp, #4
70015d74:	e8bd8800 	pop	{fp, pc}

70015d78 <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
70015d78:	e92d4800 	push	{fp, lr}
70015d7c:	e28db004 	add	fp, sp, #4
	memset(global_node_table, 0, sizeof(global_node_table));
70015d80:	e30b04a8 	movw	r0, #46248	; 0xb4a8
70015d84:	e3470002 	movt	r0, #28674	; 0x7002
70015d88:	e3a01000 	mov	r1, #0
70015d8c:	e3a02d05 	mov	r2, #320	; 0x140
70015d90:	fa00386e 	blx	70023f50 <memset>

	return 0;
70015d94:	e3a03000 	mov	r3, #0
}
70015d98:	e1a00003 	mov	r0, r3
70015d9c:	e8bd8800 	pop	{fp, pc}

70015da0 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
70015da0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70015da4:	e28db000 	add	fp, sp, #0
70015da8:	e24dd014 	sub	sp, sp, #20
70015dac:	e1a03000 	mov	r3, r0
70015db0:	e54b300d 	strb	r3, [fp, #-13]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
70015db4:	e3a03000 	mov	r3, #0
70015db8:	e50b3008 	str	r3, [fp, #-8]
70015dbc:	ea00000e 	b	70015dfc <finsh_node_allocate+0x5c>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
70015dc0:	e30b24a8 	movw	r2, #46248	; 0xb4a8
70015dc4:	e3472002 	movt	r2, #28674	; 0x7002
70015dc8:	e51b1008 	ldr	r1, [fp, #-8]
70015dcc:	e1a03001 	mov	r3, r1
70015dd0:	e1a03103 	lsl	r3, r3, #2
70015dd4:	e0833001 	add	r3, r3, r1
70015dd8:	e1a03103 	lsl	r3, r3, #2
70015ddc:	e0823003 	add	r3, r2, r3
70015de0:	e5d33000 	ldrb	r3, [r3]
70015de4:	e3530000 	cmp	r3, #0
70015de8:	1a000000 	bne	70015df0 <finsh_node_allocate+0x50>
70015dec:	ea000005 	b	70015e08 <finsh_node_allocate+0x68>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
70015df0:	e51b3008 	ldr	r3, [fp, #-8]
70015df4:	e2833001 	add	r3, r3, #1
70015df8:	e50b3008 	str	r3, [fp, #-8]
70015dfc:	e51b3008 	ldr	r3, [fp, #-8]
70015e00:	e353000f 	cmp	r3, #15
70015e04:	daffffed 	ble	70015dc0 <finsh_node_allocate+0x20>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
70015e08:	e51b3008 	ldr	r3, [fp, #-8]
70015e0c:	e3530010 	cmp	r3, #16
70015e10:	1a000001 	bne	70015e1c <finsh_node_allocate+0x7c>
70015e14:	e3a03000 	mov	r3, #0
70015e18:	ea000011 	b	70015e64 <finsh_node_allocate+0xc4>

	/* fill type field */
	global_node_table[i].node_type = type;
70015e1c:	e30b24a8 	movw	r2, #46248	; 0xb4a8
70015e20:	e3472002 	movt	r2, #28674	; 0x7002
70015e24:	e51b1008 	ldr	r1, [fp, #-8]
70015e28:	e1a03001 	mov	r3, r1
70015e2c:	e1a03103 	lsl	r3, r3, #2
70015e30:	e0833001 	add	r3, r3, r1
70015e34:	e1a03103 	lsl	r3, r3, #2
70015e38:	e0823003 	add	r3, r2, r3
70015e3c:	e55b200d 	ldrb	r2, [fp, #-13]
70015e40:	e5c32000 	strb	r2, [r3]

	/* return this allocated node */
	return &global_node_table[i];
70015e44:	e51b2008 	ldr	r2, [fp, #-8]
70015e48:	e1a03002 	mov	r3, r2
70015e4c:	e1a03103 	lsl	r3, r3, #2
70015e50:	e0833002 	add	r3, r3, r2
70015e54:	e1a03103 	lsl	r3, r3, #2
70015e58:	e30b24a8 	movw	r2, #46248	; 0xb4a8
70015e5c:	e3472002 	movt	r2, #28674	; 0x7002
70015e60:	e0833002 	add	r3, r3, r2
}
70015e64:	e1a00003 	mov	r0, r3
70015e68:	e24bd000 	sub	sp, fp, #0
70015e6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70015e70:	e12fff1e 	bx	lr

70015e74 <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
70015e74:	e92d4800 	push	{fp, lr}
70015e78:	e28db004 	add	fp, sp, #4
70015e7c:	e24dd018 	sub	sp, sp, #24
70015e80:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
70015e84:	e3a03000 	mov	r3, #0
70015e88:	e50b300c 	str	r3, [fp, #-12]
	type	= 0;
70015e8c:	e3a03000 	mov	r3, #0
70015e90:	e54b300d 	strb	r3, [fp, #-13]
	node	= NULL;
70015e94:	e3a03000 	mov	r3, #0
70015e98:	e50b3008 	str	r3, [fp, #-8]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
70015e9c:	e51b0018 	ldr	r0, [fp, #-24]
70015ea0:	eb000e31 	bl	7001976c <finsh_var_lookup>
70015ea4:	e50b000c 	str	r0, [fp, #-12]
	if (symbol == NULL)
70015ea8:	e51b300c 	ldr	r3, [fp, #-12]
70015eac:	e3530000 	cmp	r3, #0
70015eb0:	1a000011 	bne	70015efc <finsh_node_new_id+0x88>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
70015eb4:	e51b0018 	ldr	r0, [fp, #-24]
70015eb8:	eb000e88 	bl	700198e0 <finsh_sysvar_lookup>
70015ebc:	e50b000c 	str	r0, [fp, #-12]
		if (symbol == NULL)
70015ec0:	e51b300c 	ldr	r3, [fp, #-12]
70015ec4:	e3530000 	cmp	r3, #0
70015ec8:	1a000008 	bne	70015ef0 <finsh_node_new_id+0x7c>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
70015ecc:	e51b0018 	ldr	r0, [fp, #-24]
70015ed0:	eb000f18 	bl	70019b38 <finsh_syscall_lookup>
70015ed4:	e50b000c 	str	r0, [fp, #-12]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
70015ed8:	e51b300c 	ldr	r3, [fp, #-12]
70015edc:	e3530000 	cmp	r3, #0
70015ee0:	0a000007 	beq	70015f04 <finsh_node_new_id+0x90>
70015ee4:	e3a03004 	mov	r3, #4
70015ee8:	e54b300d 	strb	r3, [fp, #-13]
70015eec:	ea000004 	b	70015f04 <finsh_node_new_id+0x90>
		}
		else type = FINSH_IDTYPE_SYSVAR;
70015ef0:	e3a03002 	mov	r3, #2
70015ef4:	e54b300d 	strb	r3, [fp, #-13]
70015ef8:	ea000001 	b	70015f04 <finsh_node_new_id+0x90>
	}
	else type = FINSH_IDTYPE_VAR;
70015efc:	e3a03001 	mov	r3, #1
70015f00:	e54b300d 	strb	r3, [fp, #-13]

	if (symbol != NULL)
70015f04:	e51b300c 	ldr	r3, [fp, #-12]
70015f08:	e3530000 	cmp	r3, #0
70015f0c:	0a000020 	beq	70015f94 <finsh_node_new_id+0x120>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
70015f10:	e3a00001 	mov	r0, #1
70015f14:	ebffffa1 	bl	70015da0 <finsh_node_allocate>
70015f18:	e50b0008 	str	r0, [fp, #-8]

		/* allocate node error */
		if (node == NULL)
70015f1c:	e51b3008 	ldr	r3, [fp, #-8]
70015f20:	e3530000 	cmp	r3, #0
70015f24:	1a000003 	bne	70015f38 <finsh_node_new_id+0xc4>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
70015f28:	e3a00006 	mov	r0, #6
70015f2c:	ebfffd8b 	bl	70015560 <finsh_error_set>
			return NULL;
70015f30:	e3a03000 	mov	r3, #0
70015f34:	ea000019 	b	70015fa0 <finsh_node_new_id+0x12c>
		}

		/* fill node value according type */
		switch (type)
70015f38:	e55b300d 	ldrb	r3, [fp, #-13]
70015f3c:	e3530002 	cmp	r3, #2
70015f40:	0a000007 	beq	70015f64 <finsh_node_new_id+0xf0>
70015f44:	e3530004 	cmp	r3, #4
70015f48:	0a000009 	beq	70015f74 <finsh_node_new_id+0x100>
70015f4c:	e3530001 	cmp	r3, #1
70015f50:	1a00000b 	bne	70015f84 <finsh_node_new_id+0x110>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
70015f54:	e51b3008 	ldr	r3, [fp, #-8]
70015f58:	e51b200c 	ldr	r2, [fp, #-12]
70015f5c:	e5832008 	str	r2, [r3, #8]
			break;
70015f60:	ea000007 	b	70015f84 <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
70015f64:	e51b3008 	ldr	r3, [fp, #-8]
70015f68:	e51b200c 	ldr	r2, [fp, #-12]
70015f6c:	e5832008 	str	r2, [r3, #8]
			break;
70015f70:	ea000003 	b	70015f84 <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
70015f74:	e51b3008 	ldr	r3, [fp, #-8]
70015f78:	e51b200c 	ldr	r2, [fp, #-12]
70015f7c:	e5832008 	str	r2, [r3, #8]
			break;
70015f80:	e1a00000 	nop			; (mov r0, r0)
		}
		/* fill identifier type */
		node->idtype = type;
70015f84:	e51b3008 	ldr	r3, [fp, #-8]
70015f88:	e55b200d 	ldrb	r2, [fp, #-13]
70015f8c:	e5c32002 	strb	r2, [r3, #2]
70015f90:	ea000001 	b	70015f9c <finsh_node_new_id+0x128>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
70015f94:	e3a0000d 	mov	r0, #13
70015f98:	ebfffd70 	bl	70015560 <finsh_error_set>

	return node;
70015f9c:	e51b3008 	ldr	r3, [fp, #-8]
}
70015fa0:	e1a00003 	mov	r0, r3
70015fa4:	e24bd004 	sub	sp, fp, #4
70015fa8:	e8bd8800 	pop	{fp, pc}

70015fac <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
70015fac:	e92d4800 	push	{fp, lr}
70015fb0:	e28db004 	add	fp, sp, #4
70015fb4:	e24dd010 	sub	sp, sp, #16
70015fb8:	e1a03000 	mov	r3, r0
70015fbc:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
70015fc0:	e3a00002 	mov	r0, #2
70015fc4:	ebffff75 	bl	70015da0 <finsh_node_allocate>
70015fc8:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
70015fcc:	e51b3008 	ldr	r3, [fp, #-8]
70015fd0:	e3530000 	cmp	r3, #0
70015fd4:	1a000003 	bne	70015fe8 <finsh_node_new_char+0x3c>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
70015fd8:	e3a00006 	mov	r0, #6
70015fdc:	ebfffd5f 	bl	70015560 <finsh_error_set>
		return NULL;
70015fe0:	e3a03000 	mov	r3, #0
70015fe4:	ea000003 	b	70015ff8 <finsh_node_new_char+0x4c>
	}

	node->value.char_value = c;
70015fe8:	e51b3008 	ldr	r3, [fp, #-8]
70015fec:	e55b200d 	ldrb	r2, [fp, #-13]
70015ff0:	e5c32004 	strb	r2, [r3, #4]
	return node;
70015ff4:	e51b3008 	ldr	r3, [fp, #-8]
}
70015ff8:	e1a00003 	mov	r0, r3
70015ffc:	e24bd004 	sub	sp, fp, #4
70016000:	e8bd8800 	pop	{fp, pc}

70016004 <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
70016004:	e92d4800 	push	{fp, lr}
70016008:	e28db004 	add	fp, sp, #4
7001600c:	e24dd010 	sub	sp, sp, #16
70016010:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
70016014:	e3a00003 	mov	r0, #3
70016018:	ebffff60 	bl	70015da0 <finsh_node_allocate>
7001601c:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
70016020:	e51b3008 	ldr	r3, [fp, #-8]
70016024:	e3530000 	cmp	r3, #0
70016028:	1a000003 	bne	7001603c <finsh_node_new_int+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
7001602c:	e3a00006 	mov	r0, #6
70016030:	ebfffd4a 	bl	70015560 <finsh_error_set>
		return NULL;
70016034:	e3a03000 	mov	r3, #0
70016038:	ea000003 	b	7001604c <finsh_node_new_int+0x48>
	}

	node->value.int_value = i;
7001603c:	e51b3008 	ldr	r3, [fp, #-8]
70016040:	e51b2010 	ldr	r2, [fp, #-16]
70016044:	e5832004 	str	r2, [r3, #4]
	return node;
70016048:	e51b3008 	ldr	r3, [fp, #-8]
}
7001604c:	e1a00003 	mov	r0, r3
70016050:	e24bd004 	sub	sp, fp, #4
70016054:	e8bd8800 	pop	{fp, pc}

70016058 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
70016058:	e92d4800 	push	{fp, lr}
7001605c:	e28db004 	add	fp, sp, #4
70016060:	e24dd010 	sub	sp, sp, #16
70016064:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
70016068:	e3a00004 	mov	r0, #4
7001606c:	ebffff4b 	bl	70015da0 <finsh_node_allocate>
70016070:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
70016074:	e51b3008 	ldr	r3, [fp, #-8]
70016078:	e3530000 	cmp	r3, #0
7001607c:	1a000003 	bne	70016090 <finsh_node_new_long+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
70016080:	e3a00006 	mov	r0, #6
70016084:	ebfffd35 	bl	70015560 <finsh_error_set>
		return NULL;
70016088:	e3a03000 	mov	r3, #0
7001608c:	ea000003 	b	700160a0 <finsh_node_new_long+0x48>
	}

	node->value.long_value = l;
70016090:	e51b3008 	ldr	r3, [fp, #-8]
70016094:	e51b2010 	ldr	r2, [fp, #-16]
70016098:	e5832004 	str	r2, [r3, #4]
	return node;
7001609c:	e51b3008 	ldr	r3, [fp, #-8]
}
700160a0:	e1a00003 	mov	r0, r3
700160a4:	e24bd004 	sub	sp, fp, #4
700160a8:	e8bd8800 	pop	{fp, pc}

700160ac <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
700160ac:	e92d4810 	push	{r4, fp, lr}
700160b0:	e28db008 	add	fp, sp, #8
700160b4:	e24dd014 	sub	sp, sp, #20
700160b8:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
700160bc:	e3a00005 	mov	r0, #5
700160c0:	ebffff36 	bl	70015da0 <finsh_node_allocate>
700160c4:	e50b0010 	str	r0, [fp, #-16]
	if (node == NULL)
700160c8:	e51b3010 	ldr	r3, [fp, #-16]
700160cc:	e3530000 	cmp	r3, #0
700160d0:	1a000003 	bne	700160e4 <finsh_node_new_string+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
700160d4:	e3a00006 	mov	r0, #6
700160d8:	ebfffd20 	bl	70015560 <finsh_error_set>
		return NULL;
700160dc:	e3a03000 	mov	r3, #0
700160e0:	ea00001a 	b	70016150 <finsh_node_new_string+0xa4>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
700160e4:	e51b0018 	ldr	r0, [fp, #-24]
700160e8:	fa003891 	blx	70024334 <strlen>
700160ec:	e1a03000 	mov	r3, r0
700160f0:	e2833001 	add	r3, r3, #1
700160f4:	e1a00003 	mov	r0, r3
700160f8:	ebfffd59 	bl	70015664 <finsh_heap_allocate>
700160fc:	e1a02000 	mov	r2, r0
70016100:	e51b3010 	ldr	r3, [fp, #-16]
70016104:	e5832004 	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
70016108:	e51b3010 	ldr	r3, [fp, #-16]
7001610c:	e5934004 	ldr	r4, [r3, #4]
70016110:	e51b0018 	ldr	r0, [fp, #-24]
70016114:	fa003886 	blx	70024334 <strlen>
70016118:	e1a03000 	mov	r3, r0
7001611c:	e1a00004 	mov	r0, r4
70016120:	e51b1018 	ldr	r1, [fp, #-24]
70016124:	e1a02003 	mov	r2, r3
70016128:	fa0038c7 	blx	7002444c <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
7001612c:	e51b3010 	ldr	r3, [fp, #-16]
70016130:	e5934004 	ldr	r4, [r3, #4]
70016134:	e51b0018 	ldr	r0, [fp, #-24]
70016138:	fa00387d 	blx	70024334 <strlen>
7001613c:	e1a03000 	mov	r3, r0
70016140:	e0843003 	add	r3, r4, r3
70016144:	e3a02000 	mov	r2, #0
70016148:	e5c32000 	strb	r2, [r3]

	return node;
7001614c:	e51b3010 	ldr	r3, [fp, #-16]
}
70016150:	e1a00003 	mov	r0, r3
70016154:	e24bd008 	sub	sp, fp, #8
70016158:	e8bd8810 	pop	{r4, fp, pc}

7001615c <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
7001615c:	e92d4800 	push	{fp, lr}
70016160:	e28db004 	add	fp, sp, #4
70016164:	e24dd010 	sub	sp, sp, #16
70016168:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
7001616c:	e3a00006 	mov	r0, #6
70016170:	ebffff0a 	bl	70015da0 <finsh_node_allocate>
70016174:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
70016178:	e51b3008 	ldr	r3, [fp, #-8]
7001617c:	e3530000 	cmp	r3, #0
70016180:	1a000003 	bne	70016194 <finsh_node_new_ptr+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
70016184:	e3a00006 	mov	r0, #6
70016188:	ebfffcf4 	bl	70015560 <finsh_error_set>
		return NULL;
7001618c:	e3a03000 	mov	r3, #0
70016190:	ea000003 	b	700161a4 <finsh_node_new_ptr+0x48>
	}

	node->value.ptr = ptr;
70016194:	e51b3008 	ldr	r3, [fp, #-8]
70016198:	e51b2010 	ldr	r2, [fp, #-16]
7001619c:	e5832004 	str	r2, [r3, #4]
	return node;
700161a0:	e51b3008 	ldr	r3, [fp, #-8]
}
700161a4:	e1a00003 	mov	r0, r3
700161a8:	e24bd004 	sub	sp, fp, #4
700161ac:	e8bd8800 	pop	{fp, pc}

700161b0 <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
700161b0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700161b4:	e28db000 	add	fp, sp, #0
	/* none */
	return ;
700161b8:	e1a00000 	nop			; (mov r0, r0)
}
700161bc:	e24bd000 	sub	sp, fp, #0
700161c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700161c4:	e12fff1e 	bx	lr

700161c8 <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
700161c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700161cc:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(+);
700161d0:	e30b3830 	movw	r3, #47152	; 0xb830
700161d4:	e3473002 	movt	r3, #28674	; 0x7002
700161d8:	e5933000 	ldr	r3, [r3]
700161dc:	e2432008 	sub	r2, r3, #8
700161e0:	e30b3830 	movw	r3, #47152	; 0xb830
700161e4:	e3473002 	movt	r3, #28674	; 0x7002
700161e8:	e5933000 	ldr	r3, [r3]
700161ec:	e2433008 	sub	r3, r3, #8
700161f0:	e5d31000 	ldrb	r1, [r3]
700161f4:	e30b3830 	movw	r3, #47152	; 0xb830
700161f8:	e3473002 	movt	r3, #28674	; 0x7002
700161fc:	e5933000 	ldr	r3, [r3]
70016200:	e2433004 	sub	r3, r3, #4
70016204:	e5d33000 	ldrb	r3, [r3]
70016208:	e0813003 	add	r3, r1, r3
7001620c:	e6ef3073 	uxtb	r3, r3
70016210:	e5c23000 	strb	r3, [r2]
70016214:	e30b3830 	movw	r3, #47152	; 0xb830
70016218:	e3473002 	movt	r3, #28674	; 0x7002
7001621c:	e5933000 	ldr	r3, [r3]
70016220:	e2432004 	sub	r2, r3, #4
70016224:	e30b3830 	movw	r3, #47152	; 0xb830
70016228:	e3473002 	movt	r3, #28674	; 0x7002
7001622c:	e5832000 	str	r2, [r3]

	return ;
70016230:	e1a00000 	nop			; (mov r0, r0)
}
70016234:	e24bd000 	sub	sp, fp, #0
70016238:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001623c:	e12fff1e 	bx	lr

70016240 <OP_add_word>:

void OP_add_word()
{
70016240:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016244:	e28db000 	add	fp, sp, #0
    OP_BIN_WORD(+);
70016248:	e30b3830 	movw	r3, #47152	; 0xb830
7001624c:	e3473002 	movt	r3, #28674	; 0x7002
70016250:	e5933000 	ldr	r3, [r3]
70016254:	e2432008 	sub	r2, r3, #8
70016258:	e30b3830 	movw	r3, #47152	; 0xb830
7001625c:	e3473002 	movt	r3, #28674	; 0x7002
70016260:	e5933000 	ldr	r3, [r3]
70016264:	e2433008 	sub	r3, r3, #8
70016268:	e1d330b0 	ldrh	r3, [r3]
7001626c:	e6ff1073 	uxth	r1, r3
70016270:	e30b3830 	movw	r3, #47152	; 0xb830
70016274:	e3473002 	movt	r3, #28674	; 0x7002
70016278:	e5933000 	ldr	r3, [r3]
7001627c:	e2433004 	sub	r3, r3, #4
70016280:	e1d330b0 	ldrh	r3, [r3]
70016284:	e6ff3073 	uxth	r3, r3
70016288:	e0813003 	add	r3, r1, r3
7001628c:	e6ff3073 	uxth	r3, r3
70016290:	e6ff3073 	uxth	r3, r3
70016294:	e1c230b0 	strh	r3, [r2]
70016298:	e30b3830 	movw	r3, #47152	; 0xb830
7001629c:	e3473002 	movt	r3, #28674	; 0x7002
700162a0:	e5933000 	ldr	r3, [r3]
700162a4:	e2432004 	sub	r2, r3, #4
700162a8:	e30b3830 	movw	r3, #47152	; 0xb830
700162ac:	e3473002 	movt	r3, #28674	; 0x7002
700162b0:	e5832000 	str	r2, [r3]

	return ;
700162b4:	e1a00000 	nop			; (mov r0, r0)
}
700162b8:	e24bd000 	sub	sp, fp, #0
700162bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700162c0:	e12fff1e 	bx	lr

700162c4 <OP_add_dword>:

void OP_add_dword()
{
700162c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700162c8:	e28db000 	add	fp, sp, #0
    OP_BIN_DWORD(+);
700162cc:	e30b3830 	movw	r3, #47152	; 0xb830
700162d0:	e3473002 	movt	r3, #28674	; 0x7002
700162d4:	e5933000 	ldr	r3, [r3]
700162d8:	e2432008 	sub	r2, r3, #8
700162dc:	e30b3830 	movw	r3, #47152	; 0xb830
700162e0:	e3473002 	movt	r3, #28674	; 0x7002
700162e4:	e5933000 	ldr	r3, [r3]
700162e8:	e2433008 	sub	r3, r3, #8
700162ec:	e5931000 	ldr	r1, [r3]
700162f0:	e30b3830 	movw	r3, #47152	; 0xb830
700162f4:	e3473002 	movt	r3, #28674	; 0x7002
700162f8:	e5933000 	ldr	r3, [r3]
700162fc:	e2433004 	sub	r3, r3, #4
70016300:	e5933000 	ldr	r3, [r3]
70016304:	e0813003 	add	r3, r1, r3
70016308:	e5823000 	str	r3, [r2]
7001630c:	e30b3830 	movw	r3, #47152	; 0xb830
70016310:	e3473002 	movt	r3, #28674	; 0x7002
70016314:	e5933000 	ldr	r3, [r3]
70016318:	e2432004 	sub	r2, r3, #4
7001631c:	e30b3830 	movw	r3, #47152	; 0xb830
70016320:	e3473002 	movt	r3, #28674	; 0x7002
70016324:	e5832000 	str	r2, [r3]

	return ;
70016328:	e1a00000 	nop			; (mov r0, r0)
}
7001632c:	e24bd000 	sub	sp, fp, #0
70016330:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016334:	e12fff1e 	bx	lr

70016338 <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
70016338:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001633c:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(-);
70016340:	e30b3830 	movw	r3, #47152	; 0xb830
70016344:	e3473002 	movt	r3, #28674	; 0x7002
70016348:	e5933000 	ldr	r3, [r3]
7001634c:	e2432008 	sub	r2, r3, #8
70016350:	e30b3830 	movw	r3, #47152	; 0xb830
70016354:	e3473002 	movt	r3, #28674	; 0x7002
70016358:	e5933000 	ldr	r3, [r3]
7001635c:	e2433008 	sub	r3, r3, #8
70016360:	e5d31000 	ldrb	r1, [r3]
70016364:	e30b3830 	movw	r3, #47152	; 0xb830
70016368:	e3473002 	movt	r3, #28674	; 0x7002
7001636c:	e5933000 	ldr	r3, [r3]
70016370:	e2433004 	sub	r3, r3, #4
70016374:	e5d33000 	ldrb	r3, [r3]
70016378:	e0633001 	rsb	r3, r3, r1
7001637c:	e6ef3073 	uxtb	r3, r3
70016380:	e5c23000 	strb	r3, [r2]
70016384:	e30b3830 	movw	r3, #47152	; 0xb830
70016388:	e3473002 	movt	r3, #28674	; 0x7002
7001638c:	e5933000 	ldr	r3, [r3]
70016390:	e2432004 	sub	r2, r3, #4
70016394:	e30b3830 	movw	r3, #47152	; 0xb830
70016398:	e3473002 	movt	r3, #28674	; 0x7002
7001639c:	e5832000 	str	r2, [r3]

	return ;
700163a0:	e1a00000 	nop			; (mov r0, r0)
}
700163a4:	e24bd000 	sub	sp, fp, #0
700163a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700163ac:	e12fff1e 	bx	lr

700163b0 <OP_sub_word>:

void OP_sub_word()
{
700163b0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700163b4:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(-);
700163b8:	e30b3830 	movw	r3, #47152	; 0xb830
700163bc:	e3473002 	movt	r3, #28674	; 0x7002
700163c0:	e5933000 	ldr	r3, [r3]
700163c4:	e2432008 	sub	r2, r3, #8
700163c8:	e30b3830 	movw	r3, #47152	; 0xb830
700163cc:	e3473002 	movt	r3, #28674	; 0x7002
700163d0:	e5933000 	ldr	r3, [r3]
700163d4:	e2433008 	sub	r3, r3, #8
700163d8:	e1d330b0 	ldrh	r3, [r3]
700163dc:	e6ff1073 	uxth	r1, r3
700163e0:	e30b3830 	movw	r3, #47152	; 0xb830
700163e4:	e3473002 	movt	r3, #28674	; 0x7002
700163e8:	e5933000 	ldr	r3, [r3]
700163ec:	e2433004 	sub	r3, r3, #4
700163f0:	e1d330b0 	ldrh	r3, [r3]
700163f4:	e6ff3073 	uxth	r3, r3
700163f8:	e0633001 	rsb	r3, r3, r1
700163fc:	e6ff3073 	uxth	r3, r3
70016400:	e6ff3073 	uxth	r3, r3
70016404:	e1c230b0 	strh	r3, [r2]
70016408:	e30b3830 	movw	r3, #47152	; 0xb830
7001640c:	e3473002 	movt	r3, #28674	; 0x7002
70016410:	e5933000 	ldr	r3, [r3]
70016414:	e2432004 	sub	r2, r3, #4
70016418:	e30b3830 	movw	r3, #47152	; 0xb830
7001641c:	e3473002 	movt	r3, #28674	; 0x7002
70016420:	e5832000 	str	r2, [r3]

	return ;
70016424:	e1a00000 	nop			; (mov r0, r0)
}
70016428:	e24bd000 	sub	sp, fp, #0
7001642c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016430:	e12fff1e 	bx	lr

70016434 <OP_sub_dword>:

void OP_sub_dword()
{
70016434:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016438:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(-);
7001643c:	e30b3830 	movw	r3, #47152	; 0xb830
70016440:	e3473002 	movt	r3, #28674	; 0x7002
70016444:	e5933000 	ldr	r3, [r3]
70016448:	e2432008 	sub	r2, r3, #8
7001644c:	e30b3830 	movw	r3, #47152	; 0xb830
70016450:	e3473002 	movt	r3, #28674	; 0x7002
70016454:	e5933000 	ldr	r3, [r3]
70016458:	e2433008 	sub	r3, r3, #8
7001645c:	e5931000 	ldr	r1, [r3]
70016460:	e30b3830 	movw	r3, #47152	; 0xb830
70016464:	e3473002 	movt	r3, #28674	; 0x7002
70016468:	e5933000 	ldr	r3, [r3]
7001646c:	e2433004 	sub	r3, r3, #4
70016470:	e5933000 	ldr	r3, [r3]
70016474:	e0633001 	rsb	r3, r3, r1
70016478:	e5823000 	str	r3, [r2]
7001647c:	e30b3830 	movw	r3, #47152	; 0xb830
70016480:	e3473002 	movt	r3, #28674	; 0x7002
70016484:	e5933000 	ldr	r3, [r3]
70016488:	e2432004 	sub	r2, r3, #4
7001648c:	e30b3830 	movw	r3, #47152	; 0xb830
70016490:	e3473002 	movt	r3, #28674	; 0x7002
70016494:	e5832000 	str	r2, [r3]

	return ;
70016498:	e1a00000 	nop			; (mov r0, r0)
}
7001649c:	e24bd000 	sub	sp, fp, #0
700164a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700164a4:	e12fff1e 	bx	lr

700164a8 <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
700164a8:	e92d4818 	push	{r3, r4, fp, lr}
700164ac:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(/);
700164b0:	e30b3830 	movw	r3, #47152	; 0xb830
700164b4:	e3473002 	movt	r3, #28674	; 0x7002
700164b8:	e5933000 	ldr	r3, [r3]
700164bc:	e2434008 	sub	r4, r3, #8
700164c0:	e30b3830 	movw	r3, #47152	; 0xb830
700164c4:	e3473002 	movt	r3, #28674	; 0x7002
700164c8:	e5933000 	ldr	r3, [r3]
700164cc:	e2433008 	sub	r3, r3, #8
700164d0:	e5d32000 	ldrb	r2, [r3]
700164d4:	e30b3830 	movw	r3, #47152	; 0xb830
700164d8:	e3473002 	movt	r3, #28674	; 0x7002
700164dc:	e5933000 	ldr	r3, [r3]
700164e0:	e2433004 	sub	r3, r3, #4
700164e4:	e5d33000 	ldrb	r3, [r3]
700164e8:	e1a00002 	mov	r0, r2
700164ec:	e1a01003 	mov	r1, r3
700164f0:	fa0032d2 	blx	70023040 <__aeabi_uidiv>
700164f4:	e1a03000 	mov	r3, r0
700164f8:	e6ef3073 	uxtb	r3, r3
700164fc:	e5c43000 	strb	r3, [r4]
70016500:	e30b3830 	movw	r3, #47152	; 0xb830
70016504:	e3473002 	movt	r3, #28674	; 0x7002
70016508:	e5933000 	ldr	r3, [r3]
7001650c:	e2432004 	sub	r2, r3, #4
70016510:	e30b3830 	movw	r3, #47152	; 0xb830
70016514:	e3473002 	movt	r3, #28674	; 0x7002
70016518:	e5832000 	str	r2, [r3]

	return ;
7001651c:	e1a00000 	nop			; (mov r0, r0)
}
70016520:	e8bd8818 	pop	{r3, r4, fp, pc}

70016524 <OP_div_word>:

void OP_div_word()
{
70016524:	e92d4818 	push	{r3, r4, fp, lr}
70016528:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(/);
7001652c:	e30b3830 	movw	r3, #47152	; 0xb830
70016530:	e3473002 	movt	r3, #28674	; 0x7002
70016534:	e5933000 	ldr	r3, [r3]
70016538:	e2434008 	sub	r4, r3, #8
7001653c:	e30b3830 	movw	r3, #47152	; 0xb830
70016540:	e3473002 	movt	r3, #28674	; 0x7002
70016544:	e5933000 	ldr	r3, [r3]
70016548:	e2433008 	sub	r3, r3, #8
7001654c:	e1d330b0 	ldrh	r3, [r3]
70016550:	e6bf2073 	sxth	r2, r3
70016554:	e30b3830 	movw	r3, #47152	; 0xb830
70016558:	e3473002 	movt	r3, #28674	; 0x7002
7001655c:	e5933000 	ldr	r3, [r3]
70016560:	e2433004 	sub	r3, r3, #4
70016564:	e1d330b0 	ldrh	r3, [r3]
70016568:	e6bf3073 	sxth	r3, r3
7001656c:	e1a00002 	mov	r0, r2
70016570:	e1a01003 	mov	r1, r3
70016574:	fa00334f 	blx	700232b8 <__aeabi_idiv>
70016578:	e1a03000 	mov	r3, r0
7001657c:	e6ff3073 	uxth	r3, r3
70016580:	e1c430b0 	strh	r3, [r4]
70016584:	e30b3830 	movw	r3, #47152	; 0xb830
70016588:	e3473002 	movt	r3, #28674	; 0x7002
7001658c:	e5933000 	ldr	r3, [r3]
70016590:	e2432004 	sub	r2, r3, #4
70016594:	e30b3830 	movw	r3, #47152	; 0xb830
70016598:	e3473002 	movt	r3, #28674	; 0x7002
7001659c:	e5832000 	str	r2, [r3]

	return ;
700165a0:	e1a00000 	nop			; (mov r0, r0)
}
700165a4:	e8bd8818 	pop	{r3, r4, fp, pc}

700165a8 <OP_div_dword>:

void OP_div_dword()
{
700165a8:	e92d4818 	push	{r3, r4, fp, lr}
700165ac:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(/);
700165b0:	e30b3830 	movw	r3, #47152	; 0xb830
700165b4:	e3473002 	movt	r3, #28674	; 0x7002
700165b8:	e5933000 	ldr	r3, [r3]
700165bc:	e2434008 	sub	r4, r3, #8
700165c0:	e30b3830 	movw	r3, #47152	; 0xb830
700165c4:	e3473002 	movt	r3, #28674	; 0x7002
700165c8:	e5933000 	ldr	r3, [r3]
700165cc:	e2433008 	sub	r3, r3, #8
700165d0:	e5932000 	ldr	r2, [r3]
700165d4:	e30b3830 	movw	r3, #47152	; 0xb830
700165d8:	e3473002 	movt	r3, #28674	; 0x7002
700165dc:	e5933000 	ldr	r3, [r3]
700165e0:	e2433004 	sub	r3, r3, #4
700165e4:	e5933000 	ldr	r3, [r3]
700165e8:	e1a00002 	mov	r0, r2
700165ec:	e1a01003 	mov	r1, r3
700165f0:	fa003330 	blx	700232b8 <__aeabi_idiv>
700165f4:	e1a03000 	mov	r3, r0
700165f8:	e5843000 	str	r3, [r4]
700165fc:	e30b3830 	movw	r3, #47152	; 0xb830
70016600:	e3473002 	movt	r3, #28674	; 0x7002
70016604:	e5933000 	ldr	r3, [r3]
70016608:	e2432004 	sub	r2, r3, #4
7001660c:	e30b3830 	movw	r3, #47152	; 0xb830
70016610:	e3473002 	movt	r3, #28674	; 0x7002
70016614:	e5832000 	str	r2, [r3]

	return ;
70016618:	e1a00000 	nop			; (mov r0, r0)
}
7001661c:	e8bd8818 	pop	{r3, r4, fp, pc}

70016620 <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
70016620:	e92d4818 	push	{r3, r4, fp, lr}
70016624:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(%);
70016628:	e30b3830 	movw	r3, #47152	; 0xb830
7001662c:	e3473002 	movt	r3, #28674	; 0x7002
70016630:	e5933000 	ldr	r3, [r3]
70016634:	e2434008 	sub	r4, r3, #8
70016638:	e30b3830 	movw	r3, #47152	; 0xb830
7001663c:	e3473002 	movt	r3, #28674	; 0x7002
70016640:	e5933000 	ldr	r3, [r3]
70016644:	e2433008 	sub	r3, r3, #8
70016648:	e5d32000 	ldrb	r2, [r3]
7001664c:	e30b3830 	movw	r3, #47152	; 0xb830
70016650:	e3473002 	movt	r3, #28674	; 0x7002
70016654:	e5933000 	ldr	r3, [r3]
70016658:	e2433004 	sub	r3, r3, #4
7001665c:	e5d33000 	ldrb	r3, [r3]
70016660:	e1a00002 	mov	r0, r2
70016664:	e1a01003 	mov	r1, r3
70016668:	fa00330b 	blx	7002329c <__aeabi_uidivmod>
7001666c:	e1a03001 	mov	r3, r1
70016670:	e6ef3073 	uxtb	r3, r3
70016674:	e5c43000 	strb	r3, [r4]
70016678:	e30b3830 	movw	r3, #47152	; 0xb830
7001667c:	e3473002 	movt	r3, #28674	; 0x7002
70016680:	e5933000 	ldr	r3, [r3]
70016684:	e2432004 	sub	r2, r3, #4
70016688:	e30b3830 	movw	r3, #47152	; 0xb830
7001668c:	e3473002 	movt	r3, #28674	; 0x7002
70016690:	e5832000 	str	r2, [r3]

	return ;
70016694:	e1a00000 	nop			; (mov r0, r0)
}
70016698:	e8bd8818 	pop	{r3, r4, fp, pc}

7001669c <OP_mod_word>:

void OP_mod_word()
{
7001669c:	e92d4818 	push	{r3, r4, fp, lr}
700166a0:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(%);
700166a4:	e30b3830 	movw	r3, #47152	; 0xb830
700166a8:	e3473002 	movt	r3, #28674	; 0x7002
700166ac:	e5933000 	ldr	r3, [r3]
700166b0:	e2434008 	sub	r4, r3, #8
700166b4:	e30b3830 	movw	r3, #47152	; 0xb830
700166b8:	e3473002 	movt	r3, #28674	; 0x7002
700166bc:	e5933000 	ldr	r3, [r3]
700166c0:	e2433008 	sub	r3, r3, #8
700166c4:	e1d330b0 	ldrh	r3, [r3]
700166c8:	e6bf2073 	sxth	r2, r3
700166cc:	e30b3830 	movw	r3, #47152	; 0xb830
700166d0:	e3473002 	movt	r3, #28674	; 0x7002
700166d4:	e5933000 	ldr	r3, [r3]
700166d8:	e2433004 	sub	r3, r3, #4
700166dc:	e1d330b0 	ldrh	r3, [r3]
700166e0:	e6bf3073 	sxth	r3, r3
700166e4:	e1a00002 	mov	r0, r2
700166e8:	e1a01003 	mov	r1, r3
700166ec:	fa003396 	blx	7002354c <__aeabi_idivmod>
700166f0:	e1a03001 	mov	r3, r1
700166f4:	e6ff3073 	uxth	r3, r3
700166f8:	e1c430b0 	strh	r3, [r4]
700166fc:	e30b3830 	movw	r3, #47152	; 0xb830
70016700:	e3473002 	movt	r3, #28674	; 0x7002
70016704:	e5933000 	ldr	r3, [r3]
70016708:	e2432004 	sub	r2, r3, #4
7001670c:	e30b3830 	movw	r3, #47152	; 0xb830
70016710:	e3473002 	movt	r3, #28674	; 0x7002
70016714:	e5832000 	str	r2, [r3]

	return ;
70016718:	e1a00000 	nop			; (mov r0, r0)
}
7001671c:	e8bd8818 	pop	{r3, r4, fp, pc}

70016720 <OP_mod_dword>:

void OP_mod_dword()
{
70016720:	e92d4818 	push	{r3, r4, fp, lr}
70016724:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(%);
70016728:	e30b3830 	movw	r3, #47152	; 0xb830
7001672c:	e3473002 	movt	r3, #28674	; 0x7002
70016730:	e5933000 	ldr	r3, [r3]
70016734:	e2434008 	sub	r4, r3, #8
70016738:	e30b3830 	movw	r3, #47152	; 0xb830
7001673c:	e3473002 	movt	r3, #28674	; 0x7002
70016740:	e5933000 	ldr	r3, [r3]
70016744:	e2433008 	sub	r3, r3, #8
70016748:	e5932000 	ldr	r2, [r3]
7001674c:	e30b3830 	movw	r3, #47152	; 0xb830
70016750:	e3473002 	movt	r3, #28674	; 0x7002
70016754:	e5933000 	ldr	r3, [r3]
70016758:	e2433004 	sub	r3, r3, #4
7001675c:	e5933000 	ldr	r3, [r3]
70016760:	e1a00002 	mov	r0, r2
70016764:	e1a01003 	mov	r1, r3
70016768:	fa003377 	blx	7002354c <__aeabi_idivmod>
7001676c:	e1a03001 	mov	r3, r1
70016770:	e5843000 	str	r3, [r4]
70016774:	e30b3830 	movw	r3, #47152	; 0xb830
70016778:	e3473002 	movt	r3, #28674	; 0x7002
7001677c:	e5933000 	ldr	r3, [r3]
70016780:	e2432004 	sub	r2, r3, #4
70016784:	e30b3830 	movw	r3, #47152	; 0xb830
70016788:	e3473002 	movt	r3, #28674	; 0x7002
7001678c:	e5832000 	str	r2, [r3]

	return ;
70016790:	e1a00000 	nop			; (mov r0, r0)
}
70016794:	e8bd8818 	pop	{r3, r4, fp, pc}

70016798 <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
70016798:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001679c:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(*);
700167a0:	e30b3830 	movw	r3, #47152	; 0xb830
700167a4:	e3473002 	movt	r3, #28674	; 0x7002
700167a8:	e5933000 	ldr	r3, [r3]
700167ac:	e2432008 	sub	r2, r3, #8
700167b0:	e30b3830 	movw	r3, #47152	; 0xb830
700167b4:	e3473002 	movt	r3, #28674	; 0x7002
700167b8:	e5933000 	ldr	r3, [r3]
700167bc:	e2433008 	sub	r3, r3, #8
700167c0:	e5d31000 	ldrb	r1, [r3]
700167c4:	e30b3830 	movw	r3, #47152	; 0xb830
700167c8:	e3473002 	movt	r3, #28674	; 0x7002
700167cc:	e5933000 	ldr	r3, [r3]
700167d0:	e2433004 	sub	r3, r3, #4
700167d4:	e5d33000 	ldrb	r3, [r3]
700167d8:	e0030193 	mul	r3, r3, r1
700167dc:	e6ef3073 	uxtb	r3, r3
700167e0:	e5c23000 	strb	r3, [r2]
700167e4:	e30b3830 	movw	r3, #47152	; 0xb830
700167e8:	e3473002 	movt	r3, #28674	; 0x7002
700167ec:	e5933000 	ldr	r3, [r3]
700167f0:	e2432004 	sub	r2, r3, #4
700167f4:	e30b3830 	movw	r3, #47152	; 0xb830
700167f8:	e3473002 	movt	r3, #28674	; 0x7002
700167fc:	e5832000 	str	r2, [r3]

	return ;
70016800:	e1a00000 	nop			; (mov r0, r0)
}
70016804:	e24bd000 	sub	sp, fp, #0
70016808:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001680c:	e12fff1e 	bx	lr

70016810 <OP_mul_word>:

void OP_mul_word()
{
70016810:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016814:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(*);
70016818:	e30b3830 	movw	r3, #47152	; 0xb830
7001681c:	e3473002 	movt	r3, #28674	; 0x7002
70016820:	e5933000 	ldr	r3, [r3]
70016824:	e2432008 	sub	r2, r3, #8
70016828:	e30b3830 	movw	r3, #47152	; 0xb830
7001682c:	e3473002 	movt	r3, #28674	; 0x7002
70016830:	e5933000 	ldr	r3, [r3]
70016834:	e2433008 	sub	r3, r3, #8
70016838:	e1d330b0 	ldrh	r3, [r3]
7001683c:	e6ff1073 	uxth	r1, r3
70016840:	e30b3830 	movw	r3, #47152	; 0xb830
70016844:	e3473002 	movt	r3, #28674	; 0x7002
70016848:	e5933000 	ldr	r3, [r3]
7001684c:	e2433004 	sub	r3, r3, #4
70016850:	e1d330b0 	ldrh	r3, [r3]
70016854:	e6ff3073 	uxth	r3, r3
70016858:	e0030193 	mul	r3, r3, r1
7001685c:	e6ff3073 	uxth	r3, r3
70016860:	e6ff3073 	uxth	r3, r3
70016864:	e1c230b0 	strh	r3, [r2]
70016868:	e30b3830 	movw	r3, #47152	; 0xb830
7001686c:	e3473002 	movt	r3, #28674	; 0x7002
70016870:	e5933000 	ldr	r3, [r3]
70016874:	e2432004 	sub	r2, r3, #4
70016878:	e30b3830 	movw	r3, #47152	; 0xb830
7001687c:	e3473002 	movt	r3, #28674	; 0x7002
70016880:	e5832000 	str	r2, [r3]

	return ;
70016884:	e1a00000 	nop			; (mov r0, r0)
}
70016888:	e24bd000 	sub	sp, fp, #0
7001688c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016890:	e12fff1e 	bx	lr

70016894 <OP_mul_dword>:

void OP_mul_dword()
{
70016894:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016898:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(*);
7001689c:	e30b3830 	movw	r3, #47152	; 0xb830
700168a0:	e3473002 	movt	r3, #28674	; 0x7002
700168a4:	e5933000 	ldr	r3, [r3]
700168a8:	e2432008 	sub	r2, r3, #8
700168ac:	e30b3830 	movw	r3, #47152	; 0xb830
700168b0:	e3473002 	movt	r3, #28674	; 0x7002
700168b4:	e5933000 	ldr	r3, [r3]
700168b8:	e2433008 	sub	r3, r3, #8
700168bc:	e5931000 	ldr	r1, [r3]
700168c0:	e30b3830 	movw	r3, #47152	; 0xb830
700168c4:	e3473002 	movt	r3, #28674	; 0x7002
700168c8:	e5933000 	ldr	r3, [r3]
700168cc:	e2433004 	sub	r3, r3, #4
700168d0:	e5933000 	ldr	r3, [r3]
700168d4:	e0030193 	mul	r3, r3, r1
700168d8:	e5823000 	str	r3, [r2]
700168dc:	e30b3830 	movw	r3, #47152	; 0xb830
700168e0:	e3473002 	movt	r3, #28674	; 0x7002
700168e4:	e5933000 	ldr	r3, [r3]
700168e8:	e2432004 	sub	r2, r3, #4
700168ec:	e30b3830 	movw	r3, #47152	; 0xb830
700168f0:	e3473002 	movt	r3, #28674	; 0x7002
700168f4:	e5832000 	str	r2, [r3]

	return ;
700168f8:	e1a00000 	nop			; (mov r0, r0)
}
700168fc:	e24bd000 	sub	sp, fp, #0
70016900:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016904:	e12fff1e 	bx	lr

70016908 <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
70016908:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001690c:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(&);
70016910:	e30b3830 	movw	r3, #47152	; 0xb830
70016914:	e3473002 	movt	r3, #28674	; 0x7002
70016918:	e5933000 	ldr	r3, [r3]
7001691c:	e2432008 	sub	r2, r3, #8
70016920:	e30b3830 	movw	r3, #47152	; 0xb830
70016924:	e3473002 	movt	r3, #28674	; 0x7002
70016928:	e5933000 	ldr	r3, [r3]
7001692c:	e2433008 	sub	r3, r3, #8
70016930:	e5d31000 	ldrb	r1, [r3]
70016934:	e30b3830 	movw	r3, #47152	; 0xb830
70016938:	e3473002 	movt	r3, #28674	; 0x7002
7001693c:	e5933000 	ldr	r3, [r3]
70016940:	e2433004 	sub	r3, r3, #4
70016944:	e5d33000 	ldrb	r3, [r3]
70016948:	e0013003 	and	r3, r1, r3
7001694c:	e6ef3073 	uxtb	r3, r3
70016950:	e5c23000 	strb	r3, [r2]
70016954:	e30b3830 	movw	r3, #47152	; 0xb830
70016958:	e3473002 	movt	r3, #28674	; 0x7002
7001695c:	e5933000 	ldr	r3, [r3]
70016960:	e2432004 	sub	r2, r3, #4
70016964:	e30b3830 	movw	r3, #47152	; 0xb830
70016968:	e3473002 	movt	r3, #28674	; 0x7002
7001696c:	e5832000 	str	r2, [r3]

	return ;
70016970:	e1a00000 	nop			; (mov r0, r0)
}
70016974:	e24bd000 	sub	sp, fp, #0
70016978:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001697c:	e12fff1e 	bx	lr

70016980 <OP_and_word>:

void OP_and_word()
{
70016980:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016984:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(&);
70016988:	e30b3830 	movw	r3, #47152	; 0xb830
7001698c:	e3473002 	movt	r3, #28674	; 0x7002
70016990:	e5933000 	ldr	r3, [r3]
70016994:	e2432008 	sub	r2, r3, #8
70016998:	e30b3830 	movw	r3, #47152	; 0xb830
7001699c:	e3473002 	movt	r3, #28674	; 0x7002
700169a0:	e5933000 	ldr	r3, [r3]
700169a4:	e2433008 	sub	r3, r3, #8
700169a8:	e1d310b0 	ldrh	r1, [r3]
700169ac:	e30b3830 	movw	r3, #47152	; 0xb830
700169b0:	e3473002 	movt	r3, #28674	; 0x7002
700169b4:	e5933000 	ldr	r3, [r3]
700169b8:	e2433004 	sub	r3, r3, #4
700169bc:	e1d330b0 	ldrh	r3, [r3]
700169c0:	e0013003 	and	r3, r1, r3
700169c4:	e6ff3073 	uxth	r3, r3
700169c8:	e1c230b0 	strh	r3, [r2]
700169cc:	e30b3830 	movw	r3, #47152	; 0xb830
700169d0:	e3473002 	movt	r3, #28674	; 0x7002
700169d4:	e5933000 	ldr	r3, [r3]
700169d8:	e2432004 	sub	r2, r3, #4
700169dc:	e30b3830 	movw	r3, #47152	; 0xb830
700169e0:	e3473002 	movt	r3, #28674	; 0x7002
700169e4:	e5832000 	str	r2, [r3]

	return ;
700169e8:	e1a00000 	nop			; (mov r0, r0)
}
700169ec:	e24bd000 	sub	sp, fp, #0
700169f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700169f4:	e12fff1e 	bx	lr

700169f8 <OP_and_dword>:

void OP_and_dword()
{
700169f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700169fc:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(&);
70016a00:	e30b3830 	movw	r3, #47152	; 0xb830
70016a04:	e3473002 	movt	r3, #28674	; 0x7002
70016a08:	e5933000 	ldr	r3, [r3]
70016a0c:	e2432008 	sub	r2, r3, #8
70016a10:	e30b3830 	movw	r3, #47152	; 0xb830
70016a14:	e3473002 	movt	r3, #28674	; 0x7002
70016a18:	e5933000 	ldr	r3, [r3]
70016a1c:	e2433008 	sub	r3, r3, #8
70016a20:	e5931000 	ldr	r1, [r3]
70016a24:	e30b3830 	movw	r3, #47152	; 0xb830
70016a28:	e3473002 	movt	r3, #28674	; 0x7002
70016a2c:	e5933000 	ldr	r3, [r3]
70016a30:	e2433004 	sub	r3, r3, #4
70016a34:	e5933000 	ldr	r3, [r3]
70016a38:	e0013003 	and	r3, r1, r3
70016a3c:	e5823000 	str	r3, [r2]
70016a40:	e30b3830 	movw	r3, #47152	; 0xb830
70016a44:	e3473002 	movt	r3, #28674	; 0x7002
70016a48:	e5933000 	ldr	r3, [r3]
70016a4c:	e2432004 	sub	r2, r3, #4
70016a50:	e30b3830 	movw	r3, #47152	; 0xb830
70016a54:	e3473002 	movt	r3, #28674	; 0x7002
70016a58:	e5832000 	str	r2, [r3]

	return ;
70016a5c:	e1a00000 	nop			; (mov r0, r0)
}
70016a60:	e24bd000 	sub	sp, fp, #0
70016a64:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016a68:	e12fff1e 	bx	lr

70016a6c <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
70016a6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016a70:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(|);
70016a74:	e30b3830 	movw	r3, #47152	; 0xb830
70016a78:	e3473002 	movt	r3, #28674	; 0x7002
70016a7c:	e5933000 	ldr	r3, [r3]
70016a80:	e2432008 	sub	r2, r3, #8
70016a84:	e30b3830 	movw	r3, #47152	; 0xb830
70016a88:	e3473002 	movt	r3, #28674	; 0x7002
70016a8c:	e5933000 	ldr	r3, [r3]
70016a90:	e2433008 	sub	r3, r3, #8
70016a94:	e5d31000 	ldrb	r1, [r3]
70016a98:	e30b3830 	movw	r3, #47152	; 0xb830
70016a9c:	e3473002 	movt	r3, #28674	; 0x7002
70016aa0:	e5933000 	ldr	r3, [r3]
70016aa4:	e2433004 	sub	r3, r3, #4
70016aa8:	e5d33000 	ldrb	r3, [r3]
70016aac:	e1813003 	orr	r3, r1, r3
70016ab0:	e6ef3073 	uxtb	r3, r3
70016ab4:	e5c23000 	strb	r3, [r2]
70016ab8:	e30b3830 	movw	r3, #47152	; 0xb830
70016abc:	e3473002 	movt	r3, #28674	; 0x7002
70016ac0:	e5933000 	ldr	r3, [r3]
70016ac4:	e2432004 	sub	r2, r3, #4
70016ac8:	e30b3830 	movw	r3, #47152	; 0xb830
70016acc:	e3473002 	movt	r3, #28674	; 0x7002
70016ad0:	e5832000 	str	r2, [r3]

	return ;
70016ad4:	e1a00000 	nop			; (mov r0, r0)
}
70016ad8:	e24bd000 	sub	sp, fp, #0
70016adc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016ae0:	e12fff1e 	bx	lr

70016ae4 <OP_or_word>:

void OP_or_word()
{
70016ae4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016ae8:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(|);
70016aec:	e30b3830 	movw	r3, #47152	; 0xb830
70016af0:	e3473002 	movt	r3, #28674	; 0x7002
70016af4:	e5933000 	ldr	r3, [r3]
70016af8:	e2432008 	sub	r2, r3, #8
70016afc:	e30b3830 	movw	r3, #47152	; 0xb830
70016b00:	e3473002 	movt	r3, #28674	; 0x7002
70016b04:	e5933000 	ldr	r3, [r3]
70016b08:	e2433008 	sub	r3, r3, #8
70016b0c:	e1d310b0 	ldrh	r1, [r3]
70016b10:	e30b3830 	movw	r3, #47152	; 0xb830
70016b14:	e3473002 	movt	r3, #28674	; 0x7002
70016b18:	e5933000 	ldr	r3, [r3]
70016b1c:	e2433004 	sub	r3, r3, #4
70016b20:	e1d330b0 	ldrh	r3, [r3]
70016b24:	e1813003 	orr	r3, r1, r3
70016b28:	e6ff3073 	uxth	r3, r3
70016b2c:	e1c230b0 	strh	r3, [r2]
70016b30:	e30b3830 	movw	r3, #47152	; 0xb830
70016b34:	e3473002 	movt	r3, #28674	; 0x7002
70016b38:	e5933000 	ldr	r3, [r3]
70016b3c:	e2432004 	sub	r2, r3, #4
70016b40:	e30b3830 	movw	r3, #47152	; 0xb830
70016b44:	e3473002 	movt	r3, #28674	; 0x7002
70016b48:	e5832000 	str	r2, [r3]

	return ;
70016b4c:	e1a00000 	nop			; (mov r0, r0)
}
70016b50:	e24bd000 	sub	sp, fp, #0
70016b54:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016b58:	e12fff1e 	bx	lr

70016b5c <OP_or_dword>:

void OP_or_dword()
{
70016b5c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016b60:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(|);
70016b64:	e30b3830 	movw	r3, #47152	; 0xb830
70016b68:	e3473002 	movt	r3, #28674	; 0x7002
70016b6c:	e5933000 	ldr	r3, [r3]
70016b70:	e2432008 	sub	r2, r3, #8
70016b74:	e30b3830 	movw	r3, #47152	; 0xb830
70016b78:	e3473002 	movt	r3, #28674	; 0x7002
70016b7c:	e5933000 	ldr	r3, [r3]
70016b80:	e2433008 	sub	r3, r3, #8
70016b84:	e5931000 	ldr	r1, [r3]
70016b88:	e30b3830 	movw	r3, #47152	; 0xb830
70016b8c:	e3473002 	movt	r3, #28674	; 0x7002
70016b90:	e5933000 	ldr	r3, [r3]
70016b94:	e2433004 	sub	r3, r3, #4
70016b98:	e5933000 	ldr	r3, [r3]
70016b9c:	e1813003 	orr	r3, r1, r3
70016ba0:	e5823000 	str	r3, [r2]
70016ba4:	e30b3830 	movw	r3, #47152	; 0xb830
70016ba8:	e3473002 	movt	r3, #28674	; 0x7002
70016bac:	e5933000 	ldr	r3, [r3]
70016bb0:	e2432004 	sub	r2, r3, #4
70016bb4:	e30b3830 	movw	r3, #47152	; 0xb830
70016bb8:	e3473002 	movt	r3, #28674	; 0x7002
70016bbc:	e5832000 	str	r2, [r3]

	return ;
70016bc0:	e1a00000 	nop			; (mov r0, r0)
}
70016bc4:	e24bd000 	sub	sp, fp, #0
70016bc8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016bcc:	e12fff1e 	bx	lr

70016bd0 <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
70016bd0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016bd4:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(^);
70016bd8:	e30b3830 	movw	r3, #47152	; 0xb830
70016bdc:	e3473002 	movt	r3, #28674	; 0x7002
70016be0:	e5933000 	ldr	r3, [r3]
70016be4:	e2432008 	sub	r2, r3, #8
70016be8:	e30b3830 	movw	r3, #47152	; 0xb830
70016bec:	e3473002 	movt	r3, #28674	; 0x7002
70016bf0:	e5933000 	ldr	r3, [r3]
70016bf4:	e2433008 	sub	r3, r3, #8
70016bf8:	e5d31000 	ldrb	r1, [r3]
70016bfc:	e30b3830 	movw	r3, #47152	; 0xb830
70016c00:	e3473002 	movt	r3, #28674	; 0x7002
70016c04:	e5933000 	ldr	r3, [r3]
70016c08:	e2433004 	sub	r3, r3, #4
70016c0c:	e5d33000 	ldrb	r3, [r3]
70016c10:	e0213003 	eor	r3, r1, r3
70016c14:	e6ef3073 	uxtb	r3, r3
70016c18:	e5c23000 	strb	r3, [r2]
70016c1c:	e30b3830 	movw	r3, #47152	; 0xb830
70016c20:	e3473002 	movt	r3, #28674	; 0x7002
70016c24:	e5933000 	ldr	r3, [r3]
70016c28:	e2432004 	sub	r2, r3, #4
70016c2c:	e30b3830 	movw	r3, #47152	; 0xb830
70016c30:	e3473002 	movt	r3, #28674	; 0x7002
70016c34:	e5832000 	str	r2, [r3]

	return ;
70016c38:	e1a00000 	nop			; (mov r0, r0)
}
70016c3c:	e24bd000 	sub	sp, fp, #0
70016c40:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016c44:	e12fff1e 	bx	lr

70016c48 <OP_xor_word>:

void OP_xor_word()
{
70016c48:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016c4c:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(^);
70016c50:	e30b3830 	movw	r3, #47152	; 0xb830
70016c54:	e3473002 	movt	r3, #28674	; 0x7002
70016c58:	e5933000 	ldr	r3, [r3]
70016c5c:	e2432008 	sub	r2, r3, #8
70016c60:	e30b3830 	movw	r3, #47152	; 0xb830
70016c64:	e3473002 	movt	r3, #28674	; 0x7002
70016c68:	e5933000 	ldr	r3, [r3]
70016c6c:	e2433008 	sub	r3, r3, #8
70016c70:	e1d310b0 	ldrh	r1, [r3]
70016c74:	e30b3830 	movw	r3, #47152	; 0xb830
70016c78:	e3473002 	movt	r3, #28674	; 0x7002
70016c7c:	e5933000 	ldr	r3, [r3]
70016c80:	e2433004 	sub	r3, r3, #4
70016c84:	e1d330b0 	ldrh	r3, [r3]
70016c88:	e0213003 	eor	r3, r1, r3
70016c8c:	e6ff3073 	uxth	r3, r3
70016c90:	e1c230b0 	strh	r3, [r2]
70016c94:	e30b3830 	movw	r3, #47152	; 0xb830
70016c98:	e3473002 	movt	r3, #28674	; 0x7002
70016c9c:	e5933000 	ldr	r3, [r3]
70016ca0:	e2432004 	sub	r2, r3, #4
70016ca4:	e30b3830 	movw	r3, #47152	; 0xb830
70016ca8:	e3473002 	movt	r3, #28674	; 0x7002
70016cac:	e5832000 	str	r2, [r3]

	return ;
70016cb0:	e1a00000 	nop			; (mov r0, r0)
}
70016cb4:	e24bd000 	sub	sp, fp, #0
70016cb8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016cbc:	e12fff1e 	bx	lr

70016cc0 <OP_xor_dword>:

void OP_xor_dword()
{
70016cc0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016cc4:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(^);
70016cc8:	e30b3830 	movw	r3, #47152	; 0xb830
70016ccc:	e3473002 	movt	r3, #28674	; 0x7002
70016cd0:	e5933000 	ldr	r3, [r3]
70016cd4:	e2432008 	sub	r2, r3, #8
70016cd8:	e30b3830 	movw	r3, #47152	; 0xb830
70016cdc:	e3473002 	movt	r3, #28674	; 0x7002
70016ce0:	e5933000 	ldr	r3, [r3]
70016ce4:	e2433008 	sub	r3, r3, #8
70016ce8:	e5931000 	ldr	r1, [r3]
70016cec:	e30b3830 	movw	r3, #47152	; 0xb830
70016cf0:	e3473002 	movt	r3, #28674	; 0x7002
70016cf4:	e5933000 	ldr	r3, [r3]
70016cf8:	e2433004 	sub	r3, r3, #4
70016cfc:	e5933000 	ldr	r3, [r3]
70016d00:	e0213003 	eor	r3, r1, r3
70016d04:	e5823000 	str	r3, [r2]
70016d08:	e30b3830 	movw	r3, #47152	; 0xb830
70016d0c:	e3473002 	movt	r3, #28674	; 0x7002
70016d10:	e5933000 	ldr	r3, [r3]
70016d14:	e2432004 	sub	r2, r3, #4
70016d18:	e30b3830 	movw	r3, #47152	; 0xb830
70016d1c:	e3473002 	movt	r3, #28674	; 0x7002
70016d20:	e5832000 	str	r2, [r3]

	return ;
70016d24:	e1a00000 	nop			; (mov r0, r0)
}
70016d28:	e24bd000 	sub	sp, fp, #0
70016d2c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016d30:	e12fff1e 	bx	lr

70016d34 <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
70016d34:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016d38:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
70016d3c:	e30b3830 	movw	r3, #47152	; 0xb830
70016d40:	e3473002 	movt	r3, #28674	; 0x7002
70016d44:	e5933000 	ldr	r3, [r3]
70016d48:	e2432004 	sub	r2, r3, #4
70016d4c:	e30b3830 	movw	r3, #47152	; 0xb830
70016d50:	e3473002 	movt	r3, #28674	; 0x7002
70016d54:	e5933000 	ldr	r3, [r3]
70016d58:	e2433004 	sub	r3, r3, #4
70016d5c:	e5d33000 	ldrb	r3, [r3]
70016d60:	e1e03003 	mvn	r3, r3
70016d64:	e6ef3073 	uxtb	r3, r3
70016d68:	e5c23000 	strb	r3, [r2]

	return ;
70016d6c:	e1a00000 	nop			; (mov r0, r0)
}
70016d70:	e24bd000 	sub	sp, fp, #0
70016d74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016d78:	e12fff1e 	bx	lr

70016d7c <OP_bw_word>:

void OP_bw_word()
{
70016d7c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016d80:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
70016d84:	e30b3830 	movw	r3, #47152	; 0xb830
70016d88:	e3473002 	movt	r3, #28674	; 0x7002
70016d8c:	e5933000 	ldr	r3, [r3]
70016d90:	e2432004 	sub	r2, r3, #4
70016d94:	e30b3830 	movw	r3, #47152	; 0xb830
70016d98:	e3473002 	movt	r3, #28674	; 0x7002
70016d9c:	e5933000 	ldr	r3, [r3]
70016da0:	e2433004 	sub	r3, r3, #4
70016da4:	e1d330b0 	ldrh	r3, [r3]
70016da8:	e1e03003 	mvn	r3, r3
70016dac:	e6ff3073 	uxth	r3, r3
70016db0:	e1c230b0 	strh	r3, [r2]

	return ;
70016db4:	e1a00000 	nop			; (mov r0, r0)
}
70016db8:	e24bd000 	sub	sp, fp, #0
70016dbc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016dc0:	e12fff1e 	bx	lr

70016dc4 <OP_bw_dword>:

void OP_bw_dword()
{
70016dc4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016dc8:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
70016dcc:	e30b3830 	movw	r3, #47152	; 0xb830
70016dd0:	e3473002 	movt	r3, #28674	; 0x7002
70016dd4:	e5933000 	ldr	r3, [r3]
70016dd8:	e2432004 	sub	r2, r3, #4
70016ddc:	e30b3830 	movw	r3, #47152	; 0xb830
70016de0:	e3473002 	movt	r3, #28674	; 0x7002
70016de4:	e5933000 	ldr	r3, [r3]
70016de8:	e2433004 	sub	r3, r3, #4
70016dec:	e5933000 	ldr	r3, [r3]
70016df0:	e1e03003 	mvn	r3, r3
70016df4:	e5823000 	str	r3, [r2]

	return ;
70016df8:	e1a00000 	nop			; (mov r0, r0)
}
70016dfc:	e24bd000 	sub	sp, fp, #0
70016e00:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016e04:	e12fff1e 	bx	lr

70016e08 <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
70016e08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016e0c:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(<<);
70016e10:	e30b3830 	movw	r3, #47152	; 0xb830
70016e14:	e3473002 	movt	r3, #28674	; 0x7002
70016e18:	e5933000 	ldr	r3, [r3]
70016e1c:	e2432008 	sub	r2, r3, #8
70016e20:	e30b3830 	movw	r3, #47152	; 0xb830
70016e24:	e3473002 	movt	r3, #28674	; 0x7002
70016e28:	e5933000 	ldr	r3, [r3]
70016e2c:	e2433008 	sub	r3, r3, #8
70016e30:	e5d33000 	ldrb	r3, [r3]
70016e34:	e1a01003 	mov	r1, r3
70016e38:	e30b3830 	movw	r3, #47152	; 0xb830
70016e3c:	e3473002 	movt	r3, #28674	; 0x7002
70016e40:	e5933000 	ldr	r3, [r3]
70016e44:	e2433004 	sub	r3, r3, #4
70016e48:	e5d33000 	ldrb	r3, [r3]
70016e4c:	e1a03311 	lsl	r3, r1, r3
70016e50:	e6ef3073 	uxtb	r3, r3
70016e54:	e5c23000 	strb	r3, [r2]
70016e58:	e30b3830 	movw	r3, #47152	; 0xb830
70016e5c:	e3473002 	movt	r3, #28674	; 0x7002
70016e60:	e5933000 	ldr	r3, [r3]
70016e64:	e2432004 	sub	r2, r3, #4
70016e68:	e30b3830 	movw	r3, #47152	; 0xb830
70016e6c:	e3473002 	movt	r3, #28674	; 0x7002
70016e70:	e5832000 	str	r2, [r3]

	return ;
70016e74:	e1a00000 	nop			; (mov r0, r0)
}
70016e78:	e24bd000 	sub	sp, fp, #0
70016e7c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016e80:	e12fff1e 	bx	lr

70016e84 <OP_shl_word>:

void OP_shl_word()
{
70016e84:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016e88:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(<<);
70016e8c:	e30b3830 	movw	r3, #47152	; 0xb830
70016e90:	e3473002 	movt	r3, #28674	; 0x7002
70016e94:	e5933000 	ldr	r3, [r3]
70016e98:	e2432008 	sub	r2, r3, #8
70016e9c:	e30b3830 	movw	r3, #47152	; 0xb830
70016ea0:	e3473002 	movt	r3, #28674	; 0x7002
70016ea4:	e5933000 	ldr	r3, [r3]
70016ea8:	e2433008 	sub	r3, r3, #8
70016eac:	e1d330b0 	ldrh	r3, [r3]
70016eb0:	e6bf1073 	sxth	r1, r3
70016eb4:	e30b3830 	movw	r3, #47152	; 0xb830
70016eb8:	e3473002 	movt	r3, #28674	; 0x7002
70016ebc:	e5933000 	ldr	r3, [r3]
70016ec0:	e2433004 	sub	r3, r3, #4
70016ec4:	e1d330b0 	ldrh	r3, [r3]
70016ec8:	e6bf3073 	sxth	r3, r3
70016ecc:	e1a03311 	lsl	r3, r1, r3
70016ed0:	e6ff3073 	uxth	r3, r3
70016ed4:	e1c230b0 	strh	r3, [r2]
70016ed8:	e30b3830 	movw	r3, #47152	; 0xb830
70016edc:	e3473002 	movt	r3, #28674	; 0x7002
70016ee0:	e5933000 	ldr	r3, [r3]
70016ee4:	e2432004 	sub	r2, r3, #4
70016ee8:	e30b3830 	movw	r3, #47152	; 0xb830
70016eec:	e3473002 	movt	r3, #28674	; 0x7002
70016ef0:	e5832000 	str	r2, [r3]

	return ;
70016ef4:	e1a00000 	nop			; (mov r0, r0)
}
70016ef8:	e24bd000 	sub	sp, fp, #0
70016efc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016f00:	e12fff1e 	bx	lr

70016f04 <OP_shl_dword>:

void OP_shl_dword()
{
70016f04:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016f08:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(<<);
70016f0c:	e30b3830 	movw	r3, #47152	; 0xb830
70016f10:	e3473002 	movt	r3, #28674	; 0x7002
70016f14:	e5933000 	ldr	r3, [r3]
70016f18:	e2432008 	sub	r2, r3, #8
70016f1c:	e30b3830 	movw	r3, #47152	; 0xb830
70016f20:	e3473002 	movt	r3, #28674	; 0x7002
70016f24:	e5933000 	ldr	r3, [r3]
70016f28:	e2433008 	sub	r3, r3, #8
70016f2c:	e5931000 	ldr	r1, [r3]
70016f30:	e30b3830 	movw	r3, #47152	; 0xb830
70016f34:	e3473002 	movt	r3, #28674	; 0x7002
70016f38:	e5933000 	ldr	r3, [r3]
70016f3c:	e2433004 	sub	r3, r3, #4
70016f40:	e5933000 	ldr	r3, [r3]
70016f44:	e1a03311 	lsl	r3, r1, r3
70016f48:	e5823000 	str	r3, [r2]
70016f4c:	e30b3830 	movw	r3, #47152	; 0xb830
70016f50:	e3473002 	movt	r3, #28674	; 0x7002
70016f54:	e5933000 	ldr	r3, [r3]
70016f58:	e2432004 	sub	r2, r3, #4
70016f5c:	e30b3830 	movw	r3, #47152	; 0xb830
70016f60:	e3473002 	movt	r3, #28674	; 0x7002
70016f64:	e5832000 	str	r2, [r3]

	return ;
70016f68:	e1a00000 	nop			; (mov r0, r0)
}
70016f6c:	e24bd000 	sub	sp, fp, #0
70016f70:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016f74:	e12fff1e 	bx	lr

70016f78 <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
70016f78:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016f7c:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(>>);
70016f80:	e30b3830 	movw	r3, #47152	; 0xb830
70016f84:	e3473002 	movt	r3, #28674	; 0x7002
70016f88:	e5933000 	ldr	r3, [r3]
70016f8c:	e2432008 	sub	r2, r3, #8
70016f90:	e30b3830 	movw	r3, #47152	; 0xb830
70016f94:	e3473002 	movt	r3, #28674	; 0x7002
70016f98:	e5933000 	ldr	r3, [r3]
70016f9c:	e2433008 	sub	r3, r3, #8
70016fa0:	e5d33000 	ldrb	r3, [r3]
70016fa4:	e1a01003 	mov	r1, r3
70016fa8:	e30b3830 	movw	r3, #47152	; 0xb830
70016fac:	e3473002 	movt	r3, #28674	; 0x7002
70016fb0:	e5933000 	ldr	r3, [r3]
70016fb4:	e2433004 	sub	r3, r3, #4
70016fb8:	e5d33000 	ldrb	r3, [r3]
70016fbc:	e1a03351 	asr	r3, r1, r3
70016fc0:	e6ef3073 	uxtb	r3, r3
70016fc4:	e5c23000 	strb	r3, [r2]
70016fc8:	e30b3830 	movw	r3, #47152	; 0xb830
70016fcc:	e3473002 	movt	r3, #28674	; 0x7002
70016fd0:	e5933000 	ldr	r3, [r3]
70016fd4:	e2432004 	sub	r2, r3, #4
70016fd8:	e30b3830 	movw	r3, #47152	; 0xb830
70016fdc:	e3473002 	movt	r3, #28674	; 0x7002
70016fe0:	e5832000 	str	r2, [r3]

	return ;
70016fe4:	e1a00000 	nop			; (mov r0, r0)
}
70016fe8:	e24bd000 	sub	sp, fp, #0
70016fec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70016ff0:	e12fff1e 	bx	lr

70016ff4 <OP_shr_word>:

void OP_shr_word()
{
70016ff4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70016ff8:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(>>);
70016ffc:	e30b3830 	movw	r3, #47152	; 0xb830
70017000:	e3473002 	movt	r3, #28674	; 0x7002
70017004:	e5933000 	ldr	r3, [r3]
70017008:	e2432008 	sub	r2, r3, #8
7001700c:	e30b3830 	movw	r3, #47152	; 0xb830
70017010:	e3473002 	movt	r3, #28674	; 0x7002
70017014:	e5933000 	ldr	r3, [r3]
70017018:	e2433008 	sub	r3, r3, #8
7001701c:	e1d330b0 	ldrh	r3, [r3]
70017020:	e6bf1073 	sxth	r1, r3
70017024:	e30b3830 	movw	r3, #47152	; 0xb830
70017028:	e3473002 	movt	r3, #28674	; 0x7002
7001702c:	e5933000 	ldr	r3, [r3]
70017030:	e2433004 	sub	r3, r3, #4
70017034:	e1d330b0 	ldrh	r3, [r3]
70017038:	e6bf3073 	sxth	r3, r3
7001703c:	e1a03351 	asr	r3, r1, r3
70017040:	e6ff3073 	uxth	r3, r3
70017044:	e1c230b0 	strh	r3, [r2]
70017048:	e30b3830 	movw	r3, #47152	; 0xb830
7001704c:	e3473002 	movt	r3, #28674	; 0x7002
70017050:	e5933000 	ldr	r3, [r3]
70017054:	e2432004 	sub	r2, r3, #4
70017058:	e30b3830 	movw	r3, #47152	; 0xb830
7001705c:	e3473002 	movt	r3, #28674	; 0x7002
70017060:	e5832000 	str	r2, [r3]

	return ;
70017064:	e1a00000 	nop			; (mov r0, r0)
}
70017068:	e24bd000 	sub	sp, fp, #0
7001706c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70017070:	e12fff1e 	bx	lr

70017074 <OP_shr_dword>:

void OP_shr_dword()
{
70017074:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70017078:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(>>);
7001707c:	e30b3830 	movw	r3, #47152	; 0xb830
70017080:	e3473002 	movt	r3, #28674	; 0x7002
70017084:	e5933000 	ldr	r3, [r3]
70017088:	e2432008 	sub	r2, r3, #8
7001708c:	e30b3830 	movw	r3, #47152	; 0xb830
70017090:	e3473002 	movt	r3, #28674	; 0x7002
70017094:	e5933000 	ldr	r3, [r3]
70017098:	e2433008 	sub	r3, r3, #8
7001709c:	e5931000 	ldr	r1, [r3]
700170a0:	e30b3830 	movw	r3, #47152	; 0xb830
700170a4:	e3473002 	movt	r3, #28674	; 0x7002
700170a8:	e5933000 	ldr	r3, [r3]
700170ac:	e2433004 	sub	r3, r3, #4
700170b0:	e5933000 	ldr	r3, [r3]
700170b4:	e1a03351 	asr	r3, r1, r3
700170b8:	e5823000 	str	r3, [r2]
700170bc:	e30b3830 	movw	r3, #47152	; 0xb830
700170c0:	e3473002 	movt	r3, #28674	; 0x7002
700170c4:	e5933000 	ldr	r3, [r3]
700170c8:	e2432004 	sub	r2, r3, #4
700170cc:	e30b3830 	movw	r3, #47152	; 0xb830
700170d0:	e3473002 	movt	r3, #28674	; 0x7002
700170d4:	e5832000 	str	r2, [r3]

	return ;
700170d8:	e1a00000 	nop			; (mov r0, r0)
}
700170dc:	e24bd000 	sub	sp, fp, #0
700170e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700170e4:	e12fff1e 	bx	lr

700170e8 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
700170e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700170ec:	e28db000 	add	fp, sp, #0
	finsh_sp->char_value = *finsh_pc;
700170f0:	e30b3830 	movw	r3, #47152	; 0xb830
700170f4:	e3473002 	movt	r3, #28674	; 0x7002
700170f8:	e5932000 	ldr	r2, [r3]
700170fc:	e30b382c 	movw	r3, #47148	; 0xb82c
70017100:	e3473002 	movt	r3, #28674	; 0x7002
70017104:	e5933000 	ldr	r3, [r3]
70017108:	e5d33000 	ldrb	r3, [r3]
7001710c:	e5c23000 	strb	r3, [r2]

	finsh_sp++;
70017110:	e30b3830 	movw	r3, #47152	; 0xb830
70017114:	e3473002 	movt	r3, #28674	; 0x7002
70017118:	e5933000 	ldr	r3, [r3]
7001711c:	e2832004 	add	r2, r3, #4
70017120:	e30b3830 	movw	r3, #47152	; 0xb830
70017124:	e3473002 	movt	r3, #28674	; 0x7002
70017128:	e5832000 	str	r2, [r3]
	finsh_pc++;
7001712c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017130:	e3473002 	movt	r3, #28674	; 0x7002
70017134:	e5933000 	ldr	r3, [r3]
70017138:	e2832001 	add	r2, r3, #1
7001713c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017140:	e3473002 	movt	r3, #28674	; 0x7002
70017144:	e5832000 	str	r2, [r3]

	return ;
70017148:	e1a00000 	nop			; (mov r0, r0)
}
7001714c:	e24bd000 	sub	sp, fp, #0
70017150:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70017154:	e12fff1e 	bx	lr

70017158 <OP_ld_word>:

void OP_ld_word()
{
70017158:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001715c:	e28db000 	add	fp, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
70017160:	e30b3830 	movw	r3, #47152	; 0xb830
70017164:	e3473002 	movt	r3, #28674	; 0x7002
70017168:	e5932000 	ldr	r2, [r3]
7001716c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017170:	e3473002 	movt	r3, #28674	; 0x7002
70017174:	e5933000 	ldr	r3, [r3]
70017178:	e5d33000 	ldrb	r3, [r3]
7001717c:	e1a01003 	mov	r1, r3
70017180:	e30b382c 	movw	r3, #47148	; 0xb82c
70017184:	e3473002 	movt	r3, #28674	; 0x7002
70017188:	e5933000 	ldr	r3, [r3]
7001718c:	e2833001 	add	r3, r3, #1
70017190:	e5d33000 	ldrb	r3, [r3]
70017194:	e1a03403 	lsl	r3, r3, #8
70017198:	e6ff3073 	uxth	r3, r3
7001719c:	e1813003 	orr	r3, r1, r3
700171a0:	e6ff3073 	uxth	r3, r3
700171a4:	e1c230b0 	strh	r3, [r2]

	finsh_sp ++;
700171a8:	e30b3830 	movw	r3, #47152	; 0xb830
700171ac:	e3473002 	movt	r3, #28674	; 0x7002
700171b0:	e5933000 	ldr	r3, [r3]
700171b4:	e2832004 	add	r2, r3, #4
700171b8:	e30b3830 	movw	r3, #47152	; 0xb830
700171bc:	e3473002 	movt	r3, #28674	; 0x7002
700171c0:	e5832000 	str	r2, [r3]
	finsh_pc += 2;
700171c4:	e30b382c 	movw	r3, #47148	; 0xb82c
700171c8:	e3473002 	movt	r3, #28674	; 0x7002
700171cc:	e5933000 	ldr	r3, [r3]
700171d0:	e2832002 	add	r2, r3, #2
700171d4:	e30b382c 	movw	r3, #47148	; 0xb82c
700171d8:	e3473002 	movt	r3, #28674	; 0x7002
700171dc:	e5832000 	str	r2, [r3]

	return ;
700171e0:	e1a00000 	nop			; (mov r0, r0)
}
700171e4:	e24bd000 	sub	sp, fp, #0
700171e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700171ec:	e12fff1e 	bx	lr

700171f0 <OP_ld_dword>:

void OP_ld_dword()
{
700171f0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700171f4:	e28db000 	add	fp, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
700171f8:	e30b3830 	movw	r3, #47152	; 0xb830
700171fc:	e3473002 	movt	r3, #28674	; 0x7002
70017200:	e5932000 	ldr	r2, [r3]
70017204:	e30b382c 	movw	r3, #47148	; 0xb82c
70017208:	e3473002 	movt	r3, #28674	; 0x7002
7001720c:	e5933000 	ldr	r3, [r3]
70017210:	e5d33000 	ldrb	r3, [r3]
70017214:	e1a01003 	mov	r1, r3
70017218:	e30b382c 	movw	r3, #47148	; 0xb82c
7001721c:	e3473002 	movt	r3, #28674	; 0x7002
70017220:	e5933000 	ldr	r3, [r3]
70017224:	e2833001 	add	r3, r3, #1
70017228:	e5d33000 	ldrb	r3, [r3]
7001722c:	e1a03403 	lsl	r3, r3, #8
70017230:	e1811003 	orr	r1, r1, r3
70017234:	e30b382c 	movw	r3, #47148	; 0xb82c
70017238:	e3473002 	movt	r3, #28674	; 0x7002
7001723c:	e5933000 	ldr	r3, [r3]
70017240:	e2833002 	add	r3, r3, #2
70017244:	e5d33000 	ldrb	r3, [r3]
70017248:	e1a03803 	lsl	r3, r3, #16
7001724c:	e1811003 	orr	r1, r1, r3
70017250:	e30b382c 	movw	r3, #47148	; 0xb82c
70017254:	e3473002 	movt	r3, #28674	; 0x7002
70017258:	e5933000 	ldr	r3, [r3]
7001725c:	e2833003 	add	r3, r3, #3
70017260:	e5d33000 	ldrb	r3, [r3]
70017264:	e1a03c03 	lsl	r3, r3, #24
70017268:	e1813003 	orr	r3, r1, r3
7001726c:	e5823000 	str	r3, [r2]

	finsh_sp ++;
70017270:	e30b3830 	movw	r3, #47152	; 0xb830
70017274:	e3473002 	movt	r3, #28674	; 0x7002
70017278:	e5933000 	ldr	r3, [r3]
7001727c:	e2832004 	add	r2, r3, #4
70017280:	e30b3830 	movw	r3, #47152	; 0xb830
70017284:	e3473002 	movt	r3, #28674	; 0x7002
70017288:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
7001728c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017290:	e3473002 	movt	r3, #28674	; 0x7002
70017294:	e5933000 	ldr	r3, [r3]
70017298:	e2832004 	add	r2, r3, #4
7001729c:	e30b382c 	movw	r3, #47148	; 0xb82c
700172a0:	e3473002 	movt	r3, #28674	; 0x7002
700172a4:	e5832000 	str	r2, [r3]

	return ;
700172a8:	e1a00000 	nop			; (mov r0, r0)
}
700172ac:	e24bd000 	sub	sp, fp, #0
700172b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700172b4:	e12fff1e 	bx	lr

700172b8 <OP_ld_value_byte>:

void OP_ld_value_byte()
{
700172b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700172bc:	e28db000 	add	fp, sp, #0
700172c0:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
700172c4:	e30b382c 	movw	r3, #47148	; 0xb82c
700172c8:	e3473002 	movt	r3, #28674	; 0x7002
700172cc:	e5933000 	ldr	r3, [r3]
700172d0:	e5d33000 	ldrb	r3, [r3]
700172d4:	e1a02003 	mov	r2, r3
700172d8:	e30b382c 	movw	r3, #47148	; 0xb82c
700172dc:	e3473002 	movt	r3, #28674	; 0x7002
700172e0:	e5933000 	ldr	r3, [r3]
700172e4:	e2833001 	add	r3, r3, #1
700172e8:	e5d33000 	ldrb	r3, [r3]
700172ec:	e1a03403 	lsl	r3, r3, #8
700172f0:	e1822003 	orr	r2, r2, r3
700172f4:	e30b382c 	movw	r3, #47148	; 0xb82c
700172f8:	e3473002 	movt	r3, #28674	; 0x7002
700172fc:	e5933000 	ldr	r3, [r3]
70017300:	e2833002 	add	r3, r3, #2
70017304:	e5d33000 	ldrb	r3, [r3]
70017308:	e1a03803 	lsl	r3, r3, #16
7001730c:	e1822003 	orr	r2, r2, r3
70017310:	e30b382c 	movw	r3, #47148	; 0xb82c
70017314:	e3473002 	movt	r3, #28674	; 0x7002
70017318:	e5933000 	ldr	r3, [r3]
7001731c:	e2833003 	add	r3, r3, #3
70017320:	e5d33000 	ldrb	r3, [r3]
70017324:	e1a03c03 	lsl	r3, r3, #24
70017328:	e1823003 	orr	r3, r2, r3
7001732c:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->char_value = *c;
70017330:	e30b3830 	movw	r3, #47152	; 0xb830
70017334:	e3473002 	movt	r3, #28674	; 0x7002
70017338:	e5933000 	ldr	r3, [r3]
7001733c:	e51b2008 	ldr	r2, [fp, #-8]
70017340:	e5d22000 	ldrb	r2, [r2]
70017344:	e5c32000 	strb	r2, [r3]

	finsh_sp ++;
70017348:	e30b3830 	movw	r3, #47152	; 0xb830
7001734c:	e3473002 	movt	r3, #28674	; 0x7002
70017350:	e5933000 	ldr	r3, [r3]
70017354:	e2832004 	add	r2, r3, #4
70017358:	e30b3830 	movw	r3, #47152	; 0xb830
7001735c:	e3473002 	movt	r3, #28674	; 0x7002
70017360:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
70017364:	e30b382c 	movw	r3, #47148	; 0xb82c
70017368:	e3473002 	movt	r3, #28674	; 0x7002
7001736c:	e5933000 	ldr	r3, [r3]
70017370:	e2832004 	add	r2, r3, #4
70017374:	e30b382c 	movw	r3, #47148	; 0xb82c
70017378:	e3473002 	movt	r3, #28674	; 0x7002
7001737c:	e5832000 	str	r2, [r3]

	return;
70017380:	e1a00000 	nop			; (mov r0, r0)
}
70017384:	e24bd000 	sub	sp, fp, #0
70017388:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001738c:	e12fff1e 	bx	lr

70017390 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
70017390:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70017394:	e28db000 	add	fp, sp, #0
70017398:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
7001739c:	e30b3830 	movw	r3, #47152	; 0xb830
700173a0:	e3473002 	movt	r3, #28674	; 0x7002
700173a4:	e5933000 	ldr	r3, [r3]
700173a8:	e2433004 	sub	r3, r3, #4
700173ac:	e5933000 	ldr	r3, [r3]
700173b0:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->char_value = *c;
700173b4:	e30b3830 	movw	r3, #47152	; 0xb830
700173b8:	e3473002 	movt	r3, #28674	; 0x7002
700173bc:	e5933000 	ldr	r3, [r3]
700173c0:	e2433004 	sub	r3, r3, #4
700173c4:	e51b2008 	ldr	r2, [fp, #-8]
700173c8:	e5d22000 	ldrb	r2, [r2]
700173cc:	e5c32000 	strb	r2, [r3]

	return;
700173d0:	e1a00000 	nop			; (mov r0, r0)
}
700173d4:	e24bd000 	sub	sp, fp, #0
700173d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700173dc:	e12fff1e 	bx	lr

700173e0 <OP_ld_value_word>:

void OP_ld_value_word()
{
700173e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700173e4:	e28db000 	add	fp, sp, #0
700173e8:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
700173ec:	e30b382c 	movw	r3, #47148	; 0xb82c
700173f0:	e3473002 	movt	r3, #28674	; 0x7002
700173f4:	e5933000 	ldr	r3, [r3]
700173f8:	e5d33000 	ldrb	r3, [r3]
700173fc:	e1a02003 	mov	r2, r3
70017400:	e30b382c 	movw	r3, #47148	; 0xb82c
70017404:	e3473002 	movt	r3, #28674	; 0x7002
70017408:	e5933000 	ldr	r3, [r3]
7001740c:	e2833001 	add	r3, r3, #1
70017410:	e5d33000 	ldrb	r3, [r3]
70017414:	e1a03403 	lsl	r3, r3, #8
70017418:	e1822003 	orr	r2, r2, r3
7001741c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017420:	e3473002 	movt	r3, #28674	; 0x7002
70017424:	e5933000 	ldr	r3, [r3]
70017428:	e2833002 	add	r3, r3, #2
7001742c:	e5d33000 	ldrb	r3, [r3]
70017430:	e1a03803 	lsl	r3, r3, #16
70017434:	e1822003 	orr	r2, r2, r3
70017438:	e30b382c 	movw	r3, #47148	; 0xb82c
7001743c:	e3473002 	movt	r3, #28674	; 0x7002
70017440:	e5933000 	ldr	r3, [r3]
70017444:	e2833003 	add	r3, r3, #3
70017448:	e5d33000 	ldrb	r3, [r3]
7001744c:	e1a03c03 	lsl	r3, r3, #24
70017450:	e1823003 	orr	r3, r2, r3
70017454:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->short_value = *s;
70017458:	e30b3830 	movw	r3, #47152	; 0xb830
7001745c:	e3473002 	movt	r3, #28674	; 0x7002
70017460:	e5933000 	ldr	r3, [r3]
70017464:	e51b2008 	ldr	r2, [fp, #-8]
70017468:	e1d220b0 	ldrh	r2, [r2]
7001746c:	e1c320b0 	strh	r2, [r3]

	finsh_sp ++;
70017470:	e30b3830 	movw	r3, #47152	; 0xb830
70017474:	e3473002 	movt	r3, #28674	; 0x7002
70017478:	e5933000 	ldr	r3, [r3]
7001747c:	e2832004 	add	r2, r3, #4
70017480:	e30b3830 	movw	r3, #47152	; 0xb830
70017484:	e3473002 	movt	r3, #28674	; 0x7002
70017488:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
7001748c:	e30b382c 	movw	r3, #47148	; 0xb82c
70017490:	e3473002 	movt	r3, #28674	; 0x7002
70017494:	e5933000 	ldr	r3, [r3]
70017498:	e2832004 	add	r2, r3, #4
7001749c:	e30b382c 	movw	r3, #47148	; 0xb82c
700174a0:	e3473002 	movt	r3, #28674	; 0x7002
700174a4:	e5832000 	str	r2, [r3]

	return;
700174a8:	e1a00000 	nop			; (mov r0, r0)
}
700174ac:	e24bd000 	sub	sp, fp, #0
700174b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700174b4:	e12fff1e 	bx	lr

700174b8 <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
700174b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700174bc:	e28db000 	add	fp, sp, #0
700174c0:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
700174c4:	e30b3830 	movw	r3, #47152	; 0xb830
700174c8:	e3473002 	movt	r3, #28674	; 0x7002
700174cc:	e5933000 	ldr	r3, [r3]
700174d0:	e2433004 	sub	r3, r3, #4
700174d4:	e5933000 	ldr	r3, [r3]
700174d8:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->short_value = *s;
700174dc:	e30b3830 	movw	r3, #47152	; 0xb830
700174e0:	e3473002 	movt	r3, #28674	; 0x7002
700174e4:	e5933000 	ldr	r3, [r3]
700174e8:	e2433004 	sub	r3, r3, #4
700174ec:	e51b2008 	ldr	r2, [fp, #-8]
700174f0:	e1d220b0 	ldrh	r2, [r2]
700174f4:	e1c320b0 	strh	r2, [r3]

	return;
700174f8:	e1a00000 	nop			; (mov r0, r0)
}
700174fc:	e24bd000 	sub	sp, fp, #0
70017500:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70017504:	e12fff1e 	bx	lr

70017508 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
70017508:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001750c:	e28db000 	add	fp, sp, #0
70017510:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
70017514:	e30b382c 	movw	r3, #47148	; 0xb82c
70017518:	e3473002 	movt	r3, #28674	; 0x7002
7001751c:	e5933000 	ldr	r3, [r3]
70017520:	e5d33000 	ldrb	r3, [r3]
70017524:	e1a02003 	mov	r2, r3
70017528:	e30b382c 	movw	r3, #47148	; 0xb82c
7001752c:	e3473002 	movt	r3, #28674	; 0x7002
70017530:	e5933000 	ldr	r3, [r3]
70017534:	e2833001 	add	r3, r3, #1
70017538:	e5d33000 	ldrb	r3, [r3]
7001753c:	e1a03403 	lsl	r3, r3, #8
70017540:	e1822003 	orr	r2, r2, r3
70017544:	e30b382c 	movw	r3, #47148	; 0xb82c
70017548:	e3473002 	movt	r3, #28674	; 0x7002
7001754c:	e5933000 	ldr	r3, [r3]
70017550:	e2833002 	add	r3, r3, #2
70017554:	e5d33000 	ldrb	r3, [r3]
70017558:	e1a03803 	lsl	r3, r3, #16
7001755c:	e1822003 	orr	r2, r2, r3
70017560:	e30b382c 	movw	r3, #47148	; 0xb82c
70017564:	e3473002 	movt	r3, #28674	; 0x7002
70017568:	e5933000 	ldr	r3, [r3]
7001756c:	e2833003 	add	r3, r3, #3
70017570:	e5d33000 	ldrb	r3, [r3]
70017574:	e1a03c03 	lsl	r3, r3, #24
70017578:	e1823003 	orr	r3, r2, r3
7001757c:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->long_value = *l;
70017580:	e30b3830 	movw	r3, #47152	; 0xb830
70017584:	e3473002 	movt	r3, #28674	; 0x7002
70017588:	e5933000 	ldr	r3, [r3]
7001758c:	e51b2008 	ldr	r2, [fp, #-8]
70017590:	e5922000 	ldr	r2, [r2]
70017594:	e5832000 	str	r2, [r3]

	finsh_sp ++;
70017598:	e30b3830 	movw	r3, #47152	; 0xb830
7001759c:	e3473002 	movt	r3, #28674	; 0x7002
700175a0:	e5933000 	ldr	r3, [r3]
700175a4:	e2832004 	add	r2, r3, #4
700175a8:	e30b3830 	movw	r3, #47152	; 0xb830
700175ac:	e3473002 	movt	r3, #28674	; 0x7002
700175b0:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
700175b4:	e30b382c 	movw	r3, #47148	; 0xb82c
700175b8:	e3473002 	movt	r3, #28674	; 0x7002
700175bc:	e5933000 	ldr	r3, [r3]
700175c0:	e2832004 	add	r2, r3, #4
700175c4:	e30b382c 	movw	r3, #47148	; 0xb82c
700175c8:	e3473002 	movt	r3, #28674	; 0x7002
700175cc:	e5832000 	str	r2, [r3]

	return;
700175d0:	e1a00000 	nop			; (mov r0, r0)
}
700175d4:	e24bd000 	sub	sp, fp, #0
700175d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700175dc:	e12fff1e 	bx	lr

700175e0 <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
700175e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700175e4:	e28db000 	add	fp, sp, #0
700175e8:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
700175ec:	e30b3830 	movw	r3, #47152	; 0xb830
700175f0:	e3473002 	movt	r3, #28674	; 0x7002
700175f4:	e5933000 	ldr	r3, [r3]
700175f8:	e2433004 	sub	r3, r3, #4
700175fc:	e5933000 	ldr	r3, [r3]
70017600:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->long_value = *l;
70017604:	e30b3830 	movw	r3, #47152	; 0xb830
70017608:	e3473002 	movt	r3, #28674	; 0x7002
7001760c:	e5933000 	ldr	r3, [r3]
70017610:	e2433004 	sub	r3, r3, #4
70017614:	e51b2008 	ldr	r2, [fp, #-8]
70017618:	e5922000 	ldr	r2, [r2]
7001761c:	e5832000 	str	r2, [r3]

	return;
70017620:	e1a00000 	nop			; (mov r0, r0)
}
70017624:	e24bd000 	sub	sp, fp, #0
70017628:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001762c:	e12fff1e 	bx	lr

70017630 <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
70017630:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70017634:	e28db000 	add	fp, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
70017638:	e30b3830 	movw	r3, #47152	; 0xb830
7001763c:	e3473002 	movt	r3, #28674	; 0x7002
70017640:	e5933000 	ldr	r3, [r3]
70017644:	e2433008 	sub	r3, r3, #8
70017648:	e5933000 	ldr	r3, [r3]
7001764c:	e1a02003 	mov	r2, r3
70017650:	e30b3830 	movw	r3, #47152	; 0xb830
70017654:	e3473002 	movt	r3, #28674	; 0x7002
70017658:	e5933000 	ldr	r3, [r3]
7001765c:	e2433004 	sub	r3, r3, #4
70017660:	e5d33000 	ldrb	r3, [r3]
70017664:	e5c23000 	strb	r3, [r2]
	finsh_sp --;
70017668:	e30b3830 	movw	r3, #47152	; 0xb830
7001766c:	e3473002 	movt	r3, #28674	; 0x7002
70017670:	e5933000 	ldr	r3, [r3]
70017674:	e2432004 	sub	r2, r3, #4
70017678:	e30b3830 	movw	r3, #47152	; 0xb830
7001767c:	e3473002 	movt	r3, #28674	; 0x7002
70017680:	e5832000 	str	r2, [r3]

	return ;
70017684:	e1a00000 	nop			; (mov r0, r0)
}
70017688:	e24bd000 	sub	sp, fp, #0
7001768c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70017690:	e12fff1e 	bx	lr

70017694 <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
70017694:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70017698:	e28db000 	add	fp, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
7001769c:	e30b3830 	movw	r3, #47152	; 0xb830
700176a0:	e3473002 	movt	r3, #28674	; 0x7002
700176a4:	e5933000 	ldr	r3, [r3]
700176a8:	e2433008 	sub	r3, r3, #8
700176ac:	e5933000 	ldr	r3, [r3]
700176b0:	e1a02003 	mov	r2, r3
700176b4:	e30b3830 	movw	r3, #47152	; 0xb830
700176b8:	e3473002 	movt	r3, #28674	; 0x7002
700176bc:	e5933000 	ldr	r3, [r3]
700176c0:	e2433004 	sub	r3, r3, #4
700176c4:	e1d330b0 	ldrh	r3, [r3]
700176c8:	e1c230b0 	strh	r3, [r2]
	finsh_sp --;
700176cc:	e30b3830 	movw	r3, #47152	; 0xb830
700176d0:	e3473002 	movt	r3, #28674	; 0x7002
700176d4:	e5933000 	ldr	r3, [r3]
700176d8:	e2432004 	sub	r2, r3, #4
700176dc:	e30b3830 	movw	r3, #47152	; 0xb830
700176e0:	e3473002 	movt	r3, #28674	; 0x7002
700176e4:	e5832000 	str	r2, [r3]

	return ;
700176e8:	e1a00000 	nop			; (mov r0, r0)
}
700176ec:	e24bd000 	sub	sp, fp, #0
700176f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700176f4:	e12fff1e 	bx	lr

700176f8 <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
700176f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700176fc:	e28db000 	add	fp, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
70017700:	e30b3830 	movw	r3, #47152	; 0xb830
70017704:	e3473002 	movt	r3, #28674	; 0x7002
70017708:	e5933000 	ldr	r3, [r3]
7001770c:	e2433008 	sub	r3, r3, #8
70017710:	e5933000 	ldr	r3, [r3]
70017714:	e1a02003 	mov	r2, r3
70017718:	e30b3830 	movw	r3, #47152	; 0xb830
7001771c:	e3473002 	movt	r3, #28674	; 0x7002
70017720:	e5933000 	ldr	r3, [r3]
70017724:	e2433004 	sub	r3, r3, #4
70017728:	e5933000 	ldr	r3, [r3]
7001772c:	e5823000 	str	r3, [r2]
	finsh_sp --;
70017730:	e30b3830 	movw	r3, #47152	; 0xb830
70017734:	e3473002 	movt	r3, #28674	; 0x7002
70017738:	e5933000 	ldr	r3, [r3]
7001773c:	e2432004 	sub	r2, r3, #4
70017740:	e30b3830 	movw	r3, #47152	; 0xb830
70017744:	e3473002 	movt	r3, #28674	; 0x7002
70017748:	e5832000 	str	r2, [r3]

	return ;
7001774c:	e1a00000 	nop			; (mov r0, r0)
}
70017750:	e24bd000 	sub	sp, fp, #0
70017754:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70017758:	e12fff1e 	bx	lr

7001775c <OP_pop>:

/* --- pop --- */
void OP_pop()
{
7001775c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70017760:	e28db000 	add	fp, sp, #0
	finsh_sp --;
70017764:	e30b3830 	movw	r3, #47152	; 0xb830
70017768:	e3473002 	movt	r3, #28674	; 0x7002
7001776c:	e5933000 	ldr	r3, [r3]
70017770:	e2432004 	sub	r2, r3, #4
70017774:	e30b3830 	movw	r3, #47152	; 0xb830
70017778:	e3473002 	movt	r3, #28674	; 0x7002
7001777c:	e5832000 	str	r2, [r3]
	return ;
70017780:	e1a00000 	nop			; (mov r0, r0)
}
70017784:	e24bd000 	sub	sp, fp, #0
70017788:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001778c:	e12fff1e 	bx	lr

70017790 <OP_call>:

/* --- call --- */
void OP_call()
{
70017790:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
70017794:	e28db020 	add	fp, sp, #32
70017798:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
7001779c:	e30b382c 	movw	r3, #47148	; 0xb82c
700177a0:	e3473002 	movt	r3, #28674	; 0x7002
700177a4:	e5933000 	ldr	r3, [r3]
700177a8:	e1a02003 	mov	r2, r3
700177ac:	e2821001 	add	r1, r2, #1
700177b0:	e30b382c 	movw	r3, #47148	; 0xb82c
700177b4:	e3473002 	movt	r3, #28674	; 0x7002
700177b8:	e5831000 	str	r1, [r3]
700177bc:	e5d23000 	ldrb	r3, [r2]
700177c0:	e50b3030 	str	r3, [fp, #-48]	; 0x30

	i = 0; finsh_sp --;
700177c4:	e3a03000 	mov	r3, #0
700177c8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
700177cc:	e30b3830 	movw	r3, #47152	; 0xb830
700177d0:	e3473002 	movt	r3, #28674	; 0x7002
700177d4:	e5933000 	ldr	r3, [r3]
700177d8:	e2432004 	sub	r2, r3, #4
700177dc:	e30b3830 	movw	r3, #47152	; 0xb830
700177e0:	e3473002 	movt	r3, #28674	; 0x7002
700177e4:	e5832000 	str	r2, [r3]
	while (i < parameters)
700177e8:	ea000018 	b	70017850 <OP_call+0xc0>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
700177ec:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
700177f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700177f4:	e0633002 	rsb	r3, r3, r2
700177f8:	e2431001 	sub	r1, r3, #1
700177fc:	e30b3830 	movw	r3, #47152	; 0xb830
70017800:	e3473002 	movt	r3, #28674	; 0x7002
70017804:	e5933000 	ldr	r3, [r3]
70017808:	e5933000 	ldr	r3, [r3]
7001780c:	e1a02003 	mov	r2, r3
70017810:	e3e0304f 	mvn	r3, #79	; 0x4f
70017814:	e1a01101 	lsl	r1, r1, #2
70017818:	e24b0024 	sub	r0, fp, #36	; 0x24
7001781c:	e0801001 	add	r1, r0, r1
70017820:	e0813003 	add	r3, r1, r3
70017824:	e5832000 	str	r2, [r3]
		finsh_sp --;
70017828:	e30b3830 	movw	r3, #47152	; 0xb830
7001782c:	e3473002 	movt	r3, #28674	; 0x7002
70017830:	e5933000 	ldr	r3, [r3]
70017834:	e2432004 	sub	r2, r3, #4
70017838:	e30b3830 	movw	r3, #47152	; 0xb830
7001783c:	e3473002 	movt	r3, #28674	; 0x7002
70017840:	e5832000 	str	r2, [r3]
		i++;
70017844:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70017848:	e2833001 	add	r3, r3, #1
7001784c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
70017850:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70017854:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70017858:	e1520003 	cmp	r2, r3
7001785c:	3affffe2 	bcc	700177ec <OP_call+0x5c>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
70017860:	e30b3830 	movw	r3, #47152	; 0xb830
70017864:	e3473002 	movt	r3, #28674	; 0x7002
70017868:	e5933000 	ldr	r3, [r3]
7001786c:	e5933000 	ldr	r3, [r3]
70017870:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	switch (parameters)
70017874:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70017878:	e3530010 	cmp	r3, #16
7001787c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70017880:	ea000142 	b	70017d90 <OP_call+0x600>
70017884:	700178c8 	.word	0x700178c8
70017888:	700178dc 	.word	0x700178dc
7001788c:	700178f4 	.word	0x700178f4
70017890:	70017914 	.word	0x70017914
70017894:	70017930 	.word	0x70017930
70017898:	70017950 	.word	0x70017950
7001789c:	70017978 	.word	0x70017978
700178a0:	700179a8 	.word	0x700179a8
700178a4:	700179e0 	.word	0x700179e0
700178a8:	70017a20 	.word	0x70017a20
700178ac:	70017a68 	.word	0x70017a68
700178b0:	70017ab8 	.word	0x70017ab8
700178b4:	70017b10 	.word	0x70017b10
700178b8:	70017b70 	.word	0x70017b70
700178bc:	70017bd8 	.word	0x70017bd8
700178c0:	70017c58 	.word	0x70017c58
700178c4:	70017ce8 	.word	0x70017ce8
	{
	case 0:
		r = f(0);
700178c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
700178cc:	e3a00000 	mov	r0, #0
700178d0:	e12fff33 	blx	r3
700178d4:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
700178d8:	ea00012f 	b	70017d9c <OP_call+0x60c>

	case 1:
		r = f(parameterv[0]);
700178dc:	e51b2074 	ldr	r2, [fp, #-116]	; 0x74
700178e0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
700178e4:	e1a00002 	mov	r0, r2
700178e8:	e12fff33 	blx	r3
700178ec:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
700178f0:	ea000129 	b	70017d9c <OP_call+0x60c>

	case 2:
		r = f(parameterv[0], parameterv[1]);
700178f4:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
700178f8:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
700178fc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
70017900:	e1a00001 	mov	r0, r1
70017904:	e1a01002 	mov	r1, r2
70017908:	e12fff33 	blx	r3
7001790c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
70017910:	ea000121 	b	70017d9c <OP_call+0x60c>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
70017914:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017918:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
7001791c:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017920:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
70017924:	e12fff33 	blx	r3
70017928:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
7001792c:	ea00011a 	b	70017d9c <OP_call+0x60c>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
70017930:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017934:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017938:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
7001793c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017940:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017944:	e12fff3c 	blx	ip
70017948:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
7001794c:	ea000112 	b	70017d9c <OP_call+0x60c>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017950:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017954:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017958:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
7001795c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017960:	e51bc064 	ldr	ip, [fp, #-100]	; 0x64
70017964:	e58dc000 	str	ip, [sp]
70017968:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
7001796c:	e12fff3c 	blx	ip
70017970:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4]);
		break;
70017974:	ea000108 	b	70017d9c <OP_call+0x60c>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017978:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
7001797c:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017980:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017984:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017988:	e51be064 	ldr	lr, [fp, #-100]	; 0x64
7001798c:	e51bc060 	ldr	ip, [fp, #-96]	; 0x60
70017990:	e58de000 	str	lr, [sp]
70017994:	e58dc004 	str	ip, [sp, #4]
70017998:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
7001799c:	e12fff3c 	blx	ip
700179a0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5]);
		break;
700179a4:	ea0000fc 	b	70017d9c <OP_call+0x60c>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
700179a8:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
700179ac:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
700179b0:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
700179b4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
700179b8:	e51b4064 	ldr	r4, [fp, #-100]	; 0x64
700179bc:	e51be060 	ldr	lr, [fp, #-96]	; 0x60
700179c0:	e51bc05c 	ldr	ip, [fp, #-92]	; 0x5c
700179c4:	e58d4000 	str	r4, [sp]
700179c8:	e58de004 	str	lr, [sp, #4]
700179cc:	e58dc008 	str	ip, [sp, #8]
700179d0:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
700179d4:	e12fff3c 	blx	ip
700179d8:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6]);
		break;
700179dc:	ea0000ee 	b	70017d9c <OP_call+0x60c>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
700179e0:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
700179e4:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
700179e8:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
700179ec:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
700179f0:	e51b5064 	ldr	r5, [fp, #-100]	; 0x64
700179f4:	e51b4060 	ldr	r4, [fp, #-96]	; 0x60
700179f8:	e51be05c 	ldr	lr, [fp, #-92]	; 0x5c
700179fc:	e51bc058 	ldr	ip, [fp, #-88]	; 0x58
70017a00:	e58d5000 	str	r5, [sp]
70017a04:	e58d4004 	str	r4, [sp, #4]
70017a08:	e58de008 	str	lr, [sp, #8]
70017a0c:	e58dc00c 	str	ip, [sp, #12]
70017a10:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017a14:	e12fff3c 	blx	ip
70017a18:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
70017a1c:	ea0000de 	b	70017d9c <OP_call+0x60c>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017a20:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017a24:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017a28:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017a2c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017a30:	e51b6064 	ldr	r6, [fp, #-100]	; 0x64
70017a34:	e51b5060 	ldr	r5, [fp, #-96]	; 0x60
70017a38:	e51b405c 	ldr	r4, [fp, #-92]	; 0x5c
70017a3c:	e51be058 	ldr	lr, [fp, #-88]	; 0x58
70017a40:	e51bc054 	ldr	ip, [fp, #-84]	; 0x54
70017a44:	e58d6000 	str	r6, [sp]
70017a48:	e58d5004 	str	r5, [sp, #4]
70017a4c:	e58d4008 	str	r4, [sp, #8]
70017a50:	e58de00c 	str	lr, [sp, #12]
70017a54:	e58dc010 	str	ip, [sp, #16]
70017a58:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017a5c:	e12fff3c 	blx	ip
70017a60:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
70017a64:	ea0000cc 	b	70017d9c <OP_call+0x60c>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017a68:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017a6c:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017a70:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017a74:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017a78:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
70017a7c:	e51b6060 	ldr	r6, [fp, #-96]	; 0x60
70017a80:	e51b505c 	ldr	r5, [fp, #-92]	; 0x5c
70017a84:	e51b4058 	ldr	r4, [fp, #-88]	; 0x58
70017a88:	e51be054 	ldr	lr, [fp, #-84]	; 0x54
70017a8c:	e51bc050 	ldr	ip, [fp, #-80]	; 0x50
70017a90:	e58d7000 	str	r7, [sp]
70017a94:	e58d6004 	str	r6, [sp, #4]
70017a98:	e58d5008 	str	r5, [sp, #8]
70017a9c:	e58d400c 	str	r4, [sp, #12]
70017aa0:	e58de010 	str	lr, [sp, #16]
70017aa4:	e58dc014 	str	ip, [sp, #20]
70017aa8:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017aac:	e12fff3c 	blx	ip
70017ab0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
70017ab4:	ea0000b8 	b	70017d9c <OP_call+0x60c>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017ab8:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017abc:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017ac0:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017ac4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017ac8:	e51b8064 	ldr	r8, [fp, #-100]	; 0x64
70017acc:	e51b7060 	ldr	r7, [fp, #-96]	; 0x60
70017ad0:	e51b605c 	ldr	r6, [fp, #-92]	; 0x5c
70017ad4:	e51b5058 	ldr	r5, [fp, #-88]	; 0x58
70017ad8:	e51b4054 	ldr	r4, [fp, #-84]	; 0x54
70017adc:	e51be050 	ldr	lr, [fp, #-80]	; 0x50
70017ae0:	e51bc04c 	ldr	ip, [fp, #-76]	; 0x4c
70017ae4:	e58d8000 	str	r8, [sp]
70017ae8:	e58d7004 	str	r7, [sp, #4]
70017aec:	e58d6008 	str	r6, [sp, #8]
70017af0:	e58d500c 	str	r5, [sp, #12]
70017af4:	e58d4010 	str	r4, [sp, #16]
70017af8:	e58de014 	str	lr, [sp, #20]
70017afc:	e58dc018 	str	ip, [sp, #24]
70017b00:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017b04:	e12fff3c 	blx	ip
70017b08:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
70017b0c:	ea0000a2 	b	70017d9c <OP_call+0x60c>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017b10:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017b14:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017b18:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017b1c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017b20:	e51b9064 	ldr	r9, [fp, #-100]	; 0x64
70017b24:	e51b8060 	ldr	r8, [fp, #-96]	; 0x60
70017b28:	e51b705c 	ldr	r7, [fp, #-92]	; 0x5c
70017b2c:	e51b6058 	ldr	r6, [fp, #-88]	; 0x58
70017b30:	e51b5054 	ldr	r5, [fp, #-84]	; 0x54
70017b34:	e51b4050 	ldr	r4, [fp, #-80]	; 0x50
70017b38:	e51be04c 	ldr	lr, [fp, #-76]	; 0x4c
70017b3c:	e51bc048 	ldr	ip, [fp, #-72]	; 0x48
70017b40:	e58d9000 	str	r9, [sp]
70017b44:	e58d8004 	str	r8, [sp, #4]
70017b48:	e58d7008 	str	r7, [sp, #8]
70017b4c:	e58d600c 	str	r6, [sp, #12]
70017b50:	e58d5010 	str	r5, [sp, #16]
70017b54:	e58d4014 	str	r4, [sp, #20]
70017b58:	e58de018 	str	lr, [sp, #24]
70017b5c:	e58dc01c 	str	ip, [sp, #28]
70017b60:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017b64:	e12fff3c 	blx	ip
70017b68:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
70017b6c:	ea00008a 	b	70017d9c <OP_call+0x60c>

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017b70:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017b74:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017b78:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017b7c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017b80:	e51ba064 	ldr	sl, [fp, #-100]	; 0x64
70017b84:	e51b9060 	ldr	r9, [fp, #-96]	; 0x60
70017b88:	e51b805c 	ldr	r8, [fp, #-92]	; 0x5c
70017b8c:	e51b7058 	ldr	r7, [fp, #-88]	; 0x58
70017b90:	e51b6054 	ldr	r6, [fp, #-84]	; 0x54
70017b94:	e51b5050 	ldr	r5, [fp, #-80]	; 0x50
70017b98:	e51b404c 	ldr	r4, [fp, #-76]	; 0x4c
70017b9c:	e51be048 	ldr	lr, [fp, #-72]	; 0x48
70017ba0:	e51bc044 	ldr	ip, [fp, #-68]	; 0x44
70017ba4:	e58da000 	str	sl, [sp]
70017ba8:	e58d9004 	str	r9, [sp, #4]
70017bac:	e58d8008 	str	r8, [sp, #8]
70017bb0:	e58d700c 	str	r7, [sp, #12]
70017bb4:	e58d6010 	str	r6, [sp, #16]
70017bb8:	e58d5014 	str	r5, [sp, #20]
70017bbc:	e58d4018 	str	r4, [sp, #24]
70017bc0:	e58de01c 	str	lr, [sp, #28]
70017bc4:	e58dc020 	str	ip, [sp, #32]
70017bc8:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017bcc:	e12fff3c 	blx	ip
70017bd0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
70017bd4:	ea000070 	b	70017d9c <OP_call+0x60c>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017bd8:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017bdc:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017be0:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
70017be4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
70017be8:	e50b3090 	str	r3, [fp, #-144]	; 0x90
70017bec:	e51bc064 	ldr	ip, [fp, #-100]	; 0x64
70017bf0:	e50bc078 	str	ip, [fp, #-120]	; 0x78
70017bf4:	e51ba060 	ldr	sl, [fp, #-96]	; 0x60
70017bf8:	e51b905c 	ldr	r9, [fp, #-92]	; 0x5c
70017bfc:	e51b8058 	ldr	r8, [fp, #-88]	; 0x58
70017c00:	e51b7054 	ldr	r7, [fp, #-84]	; 0x54
70017c04:	e51b6050 	ldr	r6, [fp, #-80]	; 0x50
70017c08:	e51b504c 	ldr	r5, [fp, #-76]	; 0x4c
70017c0c:	e51b4048 	ldr	r4, [fp, #-72]	; 0x48
70017c10:	e51be044 	ldr	lr, [fp, #-68]	; 0x44
70017c14:	e51bc040 	ldr	ip, [fp, #-64]	; 0x40
70017c18:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
70017c1c:	e58d3000 	str	r3, [sp]
70017c20:	e58da004 	str	sl, [sp, #4]
70017c24:	e58d9008 	str	r9, [sp, #8]
70017c28:	e58d800c 	str	r8, [sp, #12]
70017c2c:	e58d7010 	str	r7, [sp, #16]
70017c30:	e58d6014 	str	r6, [sp, #20]
70017c34:	e58d5018 	str	r5, [sp, #24]
70017c38:	e58d401c 	str	r4, [sp, #28]
70017c3c:	e58de020 	str	lr, [sp, #32]
70017c40:	e58dc024 	str	ip, [sp, #36]	; 0x24
70017c44:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017c48:	e51b3090 	ldr	r3, [fp, #-144]	; 0x90
70017c4c:	e12fff3c 	blx	ip
70017c50:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
70017c54:	ea000050 	b	70017d9c <OP_call+0x60c>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017c58:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
70017c5c:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
70017c60:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
70017c64:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
70017c68:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
70017c6c:	e51bc060 	ldr	ip, [fp, #-96]	; 0x60
70017c70:	e50bc07c 	str	ip, [fp, #-124]	; 0x7c
70017c74:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
70017c78:	e50b3080 	str	r3, [fp, #-128]	; 0x80
70017c7c:	e51ba058 	ldr	sl, [fp, #-88]	; 0x58
70017c80:	e51b9054 	ldr	r9, [fp, #-84]	; 0x54
70017c84:	e51b8050 	ldr	r8, [fp, #-80]	; 0x50
70017c88:	e51b704c 	ldr	r7, [fp, #-76]	; 0x4c
70017c8c:	e51b6048 	ldr	r6, [fp, #-72]	; 0x48
70017c90:	e51b5044 	ldr	r5, [fp, #-68]	; 0x44
70017c94:	e51bc040 	ldr	ip, [fp, #-64]	; 0x40
70017c98:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70017c9c:	e58d2000 	str	r2, [sp]
70017ca0:	e51b207c 	ldr	r2, [fp, #-124]	; 0x7c
70017ca4:	e58d2004 	str	r2, [sp, #4]
70017ca8:	e51b2080 	ldr	r2, [fp, #-128]	; 0x80
70017cac:	e58d2008 	str	r2, [sp, #8]
70017cb0:	e58da00c 	str	sl, [sp, #12]
70017cb4:	e58d9010 	str	r9, [sp, #16]
70017cb8:	e58d8014 	str	r8, [sp, #20]
70017cbc:	e58d7018 	str	r7, [sp, #24]
70017cc0:	e58d601c 	str	r6, [sp, #28]
70017cc4:	e58d5020 	str	r5, [sp, #32]
70017cc8:	e58dc024 	str	ip, [sp, #36]	; 0x24
70017ccc:	e58d3028 	str	r3, [sp, #40]	; 0x28
70017cd0:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017cd4:	e1a02004 	mov	r2, r4
70017cd8:	e1a0300e 	mov	r3, lr
70017cdc:	e12fff3c 	blx	ip
70017ce0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
70017ce4:	ea00002c 	b	70017d9c <OP_call+0x60c>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
70017ce8:	e51b6074 	ldr	r6, [fp, #-116]	; 0x74
70017cec:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
70017cf0:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
70017cf4:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
70017cf8:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
70017cfc:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
70017d00:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
70017d04:	e50b3084 	str	r3, [fp, #-132]	; 0x84
70017d08:	e51bc058 	ldr	ip, [fp, #-88]	; 0x58
70017d0c:	e50bc088 	str	ip, [fp, #-136]	; 0x88
70017d10:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
70017d14:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
70017d18:	e51ba050 	ldr	sl, [fp, #-80]	; 0x50
70017d1c:	e51b904c 	ldr	r9, [fp, #-76]	; 0x4c
70017d20:	e51b8048 	ldr	r8, [fp, #-72]	; 0x48
70017d24:	e51b7044 	ldr	r7, [fp, #-68]	; 0x44
70017d28:	e51bc040 	ldr	ip, [fp, #-64]	; 0x40
70017d2c:	e51b103c 	ldr	r1, [fp, #-60]	; 0x3c
70017d30:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70017d34:	e58d2000 	str	r2, [sp]
70017d38:	e58d0004 	str	r0, [sp, #4]
70017d3c:	e51b0084 	ldr	r0, [fp, #-132]	; 0x84
70017d40:	e58d0008 	str	r0, [sp, #8]
70017d44:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
70017d48:	e58d200c 	str	r2, [sp, #12]
70017d4c:	e51b008c 	ldr	r0, [fp, #-140]	; 0x8c
70017d50:	e58d0010 	str	r0, [sp, #16]
70017d54:	e58da014 	str	sl, [sp, #20]
70017d58:	e58d9018 	str	r9, [sp, #24]
70017d5c:	e58d801c 	str	r8, [sp, #28]
70017d60:	e58d7020 	str	r7, [sp, #32]
70017d64:	e58dc024 	str	ip, [sp, #36]	; 0x24
70017d68:	e58d1028 	str	r1, [sp, #40]	; 0x28
70017d6c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
70017d70:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
70017d74:	e1a00006 	mov	r0, r6
70017d78:	e1a01005 	mov	r1, r5
70017d7c:	e1a02004 	mov	r2, r4
70017d80:	e1a0300e 	mov	r3, lr
70017d84:	e12fff3c 	blx	ip
70017d88:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
70017d8c:	ea000002 	b	70017d9c <OP_call+0x60c>

	default:
		r = 0;
70017d90:	e3a03000 	mov	r3, #0
70017d94:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
		break;
70017d98:	e1a00000 	nop			; (mov r0, r0)
	}

	finsh_sp->long_value = r;
70017d9c:	e30b3830 	movw	r3, #47152	; 0xb830
70017da0:	e3473002 	movt	r3, #28674	; 0x7002
70017da4:	e5933000 	ldr	r3, [r3]
70017da8:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
70017dac:	e5832000 	str	r2, [r3]
	finsh_sp ++;
70017db0:	e30b3830 	movw	r3, #47152	; 0xb830
70017db4:	e3473002 	movt	r3, #28674	; 0x7002
70017db8:	e5933000 	ldr	r3, [r3]
70017dbc:	e2832004 	add	r2, r3, #4
70017dc0:	e30b3830 	movw	r3, #47152	; 0xb830
70017dc4:	e3473002 	movt	r3, #28674	; 0x7002
70017dc8:	e5832000 	str	r2, [r3]

	return ;
70017dcc:	e1a00000 	nop			; (mov r0, r0)
}
70017dd0:	e24bd020 	sub	sp, fp, #32
70017dd4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

70017dd8 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
70017dd8:	e92d4800 	push	{fp, lr}
70017ddc:	e28db004 	add	fp, sp, #4
70017de0:	e24dd040 	sub	sp, sp, #64	; 0x40
70017de4:	e50b0040 	str	r0, [fp, #-64]	; 0x40

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
70017de8:	e3a03000 	mov	r3, #0
70017dec:	e50b300c 	str	r3, [fp, #-12]
	end  = NULL;
70017df0:	e3a03000 	mov	r3, #0
70017df4:	e50b3010 	str	r3, [fp, #-16]

	/* get type */
	type = proc_type(self);
70017df8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017dfc:	eb00010b 	bl	70018230 <proc_type>
70017e00:	e1a03000 	mov	r3, r0
70017e04:	e54b3011 	strb	r3, [fp, #-17]

	/*process id.*/
	if (proc_identifier(self, id) == 0)
70017e08:	e24b3038 	sub	r3, fp, #56	; 0x38
70017e0c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017e10:	e1a01003 	mov	r1, r3
70017e14:	eb0001af 	bl	700184d8 <proc_identifier>
70017e18:	e1a03000 	mov	r3, r0
70017e1c:	e3530000 	cmp	r3, #0
70017e20:	1a000009 	bne	70017e4c <proc_variable_decl+0x74>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
70017e24:	e55b3011 	ldrb	r3, [fp, #-17]
70017e28:	e24b2038 	sub	r2, fp, #56	; 0x38
70017e2c:	e1a00002 	mov	r0, r2
70017e30:	e1a01003 	mov	r1, r3
70017e34:	eb0005c4 	bl	7001954c <finsh_var_insert>
70017e38:	e1a03000 	mov	r3, r0
70017e3c:	e3530000 	cmp	r3, #0
70017e40:	aa000001 	bge	70017e4c <proc_variable_decl+0x74>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
70017e44:	e3a00004 	mov	r0, #4
70017e48:	ebfff5c4 	bl	70015560 <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
70017e4c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70017e50:	e2833004 	add	r3, r3, #4
70017e54:	e1a00003 	mov	r0, r3
70017e58:	eb00077e 	bl	70019c58 <finsh_token_token>
70017e5c:	e1a03000 	mov	r3, r0
70017e60:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
70017e64:	e55b3005 	ldrb	r3, [fp, #-5]
70017e68:	e3530004 	cmp	r3, #4
70017e6c:	0a0000e7 	beq	70018210 <proc_variable_decl+0x438>
70017e70:	e353000c 	cmp	r3, #12
70017e74:	0a000080 	beq	7001807c <proc_variable_decl+0x2a4>
70017e78:	e3530003 	cmp	r3, #3
70017e7c:	1a0000e5 	bne	70018218 <proc_variable_decl+0x440>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
70017e80:	e24b3038 	sub	r3, fp, #56	; 0x38
70017e84:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017e88:	e1a01003 	mov	r1, r3
70017e8c:	eb000191 	bl	700184d8 <proc_identifier>
70017e90:	e1a03000 	mov	r3, r0
70017e94:	e3530000 	cmp	r3, #0
70017e98:	1a000009 	bne	70017ec4 <proc_variable_decl+0xec>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
70017e9c:	e55b3011 	ldrb	r3, [fp, #-17]
70017ea0:	e24b2038 	sub	r2, fp, #56	; 0x38
70017ea4:	e1a00002 	mov	r0, r2
70017ea8:	e1a01003 	mov	r1, r3
70017eac:	eb0005a6 	bl	7001954c <finsh_var_insert>
70017eb0:	e1a03000 	mov	r3, r0
70017eb4:	e3530000 	cmp	r3, #0
70017eb8:	aa000001 	bge	70017ec4 <proc_variable_decl+0xec>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
70017ebc:	e3a00004 	mov	r0, #4
70017ec0:	ebfff5a6 	bl	70015560 <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
70017ec4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70017ec8:	e2833004 	add	r3, r3, #4
70017ecc:	e1a00003 	mov	r0, r3
70017ed0:	eb000760 	bl	70019c58 <finsh_token_token>
70017ed4:	e1a03000 	mov	r3, r0
70017ed8:	e54b3005 	strb	r3, [fp, #-5]
		if ( token == finsh_token_type_assign )
70017edc:	e55b3005 	ldrb	r3, [fp, #-5]
70017ee0:	e353000c 	cmp	r3, #12
70017ee4:	1a000017 	bne	70017f48 <proc_variable_decl+0x170>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
70017ee8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017eec:	eb0001c7 	bl	70018610 <proc_assign_expr>
70017ef0:	e50b0018 	str	r0, [fp, #-24]

			if (assign != NULL)
70017ef4:	e51b3018 	ldr	r3, [fp, #-24]
70017ef8:	e3530000 	cmp	r3, #0
70017efc:	0a000011 	beq	70017f48 <proc_variable_decl+0x170>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
70017f00:	e24b3038 	sub	r3, fp, #56	; 0x38
70017f04:	e1a00003 	mov	r0, r3
70017f08:	ebfff7d9 	bl	70015e74 <finsh_node_new_id>
70017f0c:	e50b001c 	str	r0, [fp, #-28]
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
70017f10:	e3a00013 	mov	r0, #19
70017f14:	e51b101c 	ldr	r1, [fp, #-28]
70017f18:	e51b2018 	ldr	r2, [fp, #-24]
70017f1c:	eb0004bb 	bl	70019210 <make_sys_node>
70017f20:	e50b0010 	str	r0, [fp, #-16]
				node = end;
70017f24:	e51b3010 	ldr	r3, [fp, #-16]
70017f28:	e50b300c 	str	r3, [fp, #-12]

				next_token(token, &(self->token));
70017f2c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70017f30:	e2833004 	add	r3, r3, #4
70017f34:	e1a00003 	mov	r0, r3
70017f38:	eb000746 	bl	70019c58 <finsh_token_token>
70017f3c:	e1a03000 	mov	r3, r0
70017f40:	e54b3005 	strb	r3, [fp, #-5]
			}
		}

		while ( token == finsh_token_type_comma )
70017f44:	ea00003f 	b	70018048 <proc_variable_decl+0x270>
70017f48:	ea00003e 	b	70018048 <proc_variable_decl+0x270>
		{
			if (proc_identifier(self, id) == 0)
70017f4c:	e24b3038 	sub	r3, fp, #56	; 0x38
70017f50:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017f54:	e1a01003 	mov	r1, r3
70017f58:	eb00015e 	bl	700184d8 <proc_identifier>
70017f5c:	e1a03000 	mov	r3, r0
70017f60:	e3530000 	cmp	r3, #0
70017f64:	1a000009 	bne	70017f90 <proc_variable_decl+0x1b8>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
70017f68:	e55b3011 	ldrb	r3, [fp, #-17]
70017f6c:	e24b2038 	sub	r2, fp, #56	; 0x38
70017f70:	e1a00002 	mov	r0, r2
70017f74:	e1a01003 	mov	r1, r3
70017f78:	eb000573 	bl	7001954c <finsh_var_insert>
70017f7c:	e1a03000 	mov	r3, r0
70017f80:	e3530000 	cmp	r3, #0
70017f84:	aa000001 	bge	70017f90 <proc_variable_decl+0x1b8>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
70017f88:	e3a00004 	mov	r0, #4
70017f8c:	ebfff573 	bl	70015560 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
70017f90:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70017f94:	e2833004 	add	r3, r3, #4
70017f98:	e1a00003 	mov	r0, r3
70017f9c:	eb00072d 	bl	70019c58 <finsh_token_token>
70017fa0:	e1a03000 	mov	r3, r0
70017fa4:	e54b3005 	strb	r3, [fp, #-5]
			if ( token == finsh_token_type_assign )
70017fa8:	e55b3005 	ldrb	r3, [fp, #-5]
70017fac:	e353000c 	cmp	r3, #12
70017fb0:	1a000024 	bne	70018048 <proc_variable_decl+0x270>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
70017fb4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70017fb8:	eb000194 	bl	70018610 <proc_assign_expr>
70017fbc:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
70017fc0:	e51b3018 	ldr	r3, [fp, #-24]
70017fc4:	e3530000 	cmp	r3, #0
70017fc8:	0a00001e 	beq	70018048 <proc_variable_decl+0x270>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
70017fcc:	e24b3038 	sub	r3, fp, #56	; 0x38
70017fd0:	e1a00003 	mov	r0, r3
70017fd4:	ebfff7a6 	bl	70015e74 <finsh_node_new_id>
70017fd8:	e50b0020 	str	r0, [fp, #-32]

					/* make assign expression node */
					if (node != NULL)
70017fdc:	e51b300c 	ldr	r3, [fp, #-12]
70017fe0:	e3530000 	cmp	r3, #0
70017fe4:	0a00000a 	beq	70018014 <proc_variable_decl+0x23c>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
70017fe8:	e3a00013 	mov	r0, #19
70017fec:	e51b1020 	ldr	r1, [fp, #-32]
70017ff0:	e51b2018 	ldr	r2, [fp, #-24]
70017ff4:	eb000485 	bl	70019210 <make_sys_node>
70017ff8:	e1a02000 	mov	r2, r0
70017ffc:	e51b3010 	ldr	r3, [fp, #-16]
70018000:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
70018004:	e51b3010 	ldr	r3, [fp, #-16]
70018008:	e593300c 	ldr	r3, [r3, #12]
7001800c:	e50b3010 	str	r3, [fp, #-16]
70018010:	ea000006 	b	70018030 <proc_variable_decl+0x258>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
70018014:	e3a00013 	mov	r0, #19
70018018:	e51b1020 	ldr	r1, [fp, #-32]
7001801c:	e51b2018 	ldr	r2, [fp, #-24]
70018020:	eb00047a 	bl	70019210 <make_sys_node>
70018024:	e50b0010 	str	r0, [fp, #-16]
						node = end;
70018028:	e51b3010 	ldr	r3, [fp, #-16]
7001802c:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
70018030:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70018034:	e2833004 	add	r3, r3, #4
70018038:	e1a00003 	mov	r0, r3
7001803c:	eb000705 	bl	70019c58 <finsh_token_token>
70018040:	e1a03000 	mov	r3, r0
70018044:	e54b3005 	strb	r3, [fp, #-5]

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
70018048:	e55b3005 	ldrb	r3, [fp, #-5]
7001804c:	e3530003 	cmp	r3, #3
70018050:	0affffbd 	beq	70017f4c <proc_variable_decl+0x174>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
70018054:	e55b3005 	ldrb	r3, [fp, #-5]
70018058:	e3530004 	cmp	r3, #4
7001805c:	0a000004 	beq	70018074 <proc_variable_decl+0x29c>
70018060:	e3a00001 	mov	r0, #1
70018064:	ebfff53d 	bl	70015560 <finsh_error_set>
70018068:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
7001806c:	e3a02001 	mov	r2, #1
70018070:	e5c32005 	strb	r2, [r3, #5]
		return node;
70018074:	e51b300c 	ldr	r3, [fp, #-12]
70018078:	ea000069 	b	70018224 <proc_variable_decl+0x44c>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
7001807c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
70018080:	eb000162 	bl	70018610 <proc_assign_expr>
70018084:	e50b0018 	str	r0, [fp, #-24]
		if (assign != NULL)
70018088:	e51b3018 	ldr	r3, [fp, #-24]
7001808c:	e3530000 	cmp	r3, #0
70018090:	0a000011 	beq	700180dc <proc_variable_decl+0x304>
		{
			idnode = finsh_node_new_id(id);
70018094:	e24b3038 	sub	r3, fp, #56	; 0x38
70018098:	e1a00003 	mov	r0, r3
7001809c:	ebfff774 	bl	70015e74 <finsh_node_new_id>
700180a0:	e50b0024 	str	r0, [fp, #-36]	; 0x24

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
700180a4:	e3a00013 	mov	r0, #19
700180a8:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
700180ac:	e51b2018 	ldr	r2, [fp, #-24]
700180b0:	eb000456 	bl	70019210 <make_sys_node>
700180b4:	e50b0010 	str	r0, [fp, #-16]
			node = end;
700180b8:	e51b3010 	ldr	r3, [fp, #-16]
700180bc:	e50b300c 	str	r3, [fp, #-12]

			next_token(token, &(self->token));
700180c0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
700180c4:	e2833004 	add	r3, r3, #4
700180c8:	e1a00003 	mov	r0, r3
700180cc:	eb0006e1 	bl	70019c58 <finsh_token_token>
700180d0:	e1a03000 	mov	r3, r0
700180d4:	e54b3005 	strb	r3, [fp, #-5]
		}

		while ( token == finsh_token_type_comma )
700180d8:	ea00003f 	b	700181dc <proc_variable_decl+0x404>
700180dc:	ea00003e 	b	700181dc <proc_variable_decl+0x404>
		{
			if (proc_identifier(self, id) == 0)
700180e0:	e24b3038 	sub	r3, fp, #56	; 0x38
700180e4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
700180e8:	e1a01003 	mov	r1, r3
700180ec:	eb0000f9 	bl	700184d8 <proc_identifier>
700180f0:	e1a03000 	mov	r3, r0
700180f4:	e3530000 	cmp	r3, #0
700180f8:	1a000009 	bne	70018124 <proc_variable_decl+0x34c>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
700180fc:	e55b3011 	ldrb	r3, [fp, #-17]
70018100:	e24b2038 	sub	r2, fp, #56	; 0x38
70018104:	e1a00002 	mov	r0, r2
70018108:	e1a01003 	mov	r1, r3
7001810c:	eb00050e 	bl	7001954c <finsh_var_insert>
70018110:	e1a03000 	mov	r3, r0
70018114:	e3530000 	cmp	r3, #0
70018118:	aa000001 	bge	70018124 <proc_variable_decl+0x34c>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
7001811c:	e3a00004 	mov	r0, #4
70018120:	ebfff50e 	bl	70015560 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
70018124:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70018128:	e2833004 	add	r3, r3, #4
7001812c:	e1a00003 	mov	r0, r3
70018130:	eb0006c8 	bl	70019c58 <finsh_token_token>
70018134:	e1a03000 	mov	r3, r0
70018138:	e54b3005 	strb	r3, [fp, #-5]
			if (token == finsh_token_type_assign)
7001813c:	e55b3005 	ldrb	r3, [fp, #-5]
70018140:	e353000c 	cmp	r3, #12
70018144:	1a000024 	bne	700181dc <proc_variable_decl+0x404>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
70018148:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
7001814c:	eb00012f 	bl	70018610 <proc_assign_expr>
70018150:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
70018154:	e51b3018 	ldr	r3, [fp, #-24]
70018158:	e3530000 	cmp	r3, #0
7001815c:	0a00001e 	beq	700181dc <proc_variable_decl+0x404>
				{
					idnode = finsh_node_new_id(id);
70018160:	e24b3038 	sub	r3, fp, #56	; 0x38
70018164:	e1a00003 	mov	r0, r3
70018168:	ebfff741 	bl	70015e74 <finsh_node_new_id>
7001816c:	e50b0024 	str	r0, [fp, #-36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
70018170:	e51b300c 	ldr	r3, [fp, #-12]
70018174:	e3530000 	cmp	r3, #0
70018178:	0a00000a 	beq	700181a8 <proc_variable_decl+0x3d0>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
7001817c:	e3a00013 	mov	r0, #19
70018180:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
70018184:	e51b2018 	ldr	r2, [fp, #-24]
70018188:	eb000420 	bl	70019210 <make_sys_node>
7001818c:	e1a02000 	mov	r2, r0
70018190:	e51b3010 	ldr	r3, [fp, #-16]
70018194:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
70018198:	e51b3010 	ldr	r3, [fp, #-16]
7001819c:	e593300c 	ldr	r3, [r3, #12]
700181a0:	e50b3010 	str	r3, [fp, #-16]
700181a4:	ea000006 	b	700181c4 <proc_variable_decl+0x3ec>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
700181a8:	e3a00013 	mov	r0, #19
700181ac:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
700181b0:	e51b2018 	ldr	r2, [fp, #-24]
700181b4:	eb000415 	bl	70019210 <make_sys_node>
700181b8:	e50b0010 	str	r0, [fp, #-16]
						node = end;
700181bc:	e51b3010 	ldr	r3, [fp, #-16]
700181c0:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
700181c4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
700181c8:	e2833004 	add	r3, r3, #4
700181cc:	e1a00003 	mov	r0, r3
700181d0:	eb0006a0 	bl	70019c58 <finsh_token_token>
700181d4:	e1a03000 	mov	r3, r0
700181d8:	e54b3005 	strb	r3, [fp, #-5]
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
700181dc:	e55b3005 	ldrb	r3, [fp, #-5]
700181e0:	e3530003 	cmp	r3, #3
700181e4:	0affffbd 	beq	700180e0 <proc_variable_decl+0x308>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
700181e8:	e55b3005 	ldrb	r3, [fp, #-5]
700181ec:	e3530004 	cmp	r3, #4
700181f0:	0a000004 	beq	70018208 <proc_variable_decl+0x430>
700181f4:	e3a00001 	mov	r0, #1
700181f8:	ebfff4d8 	bl	70015560 <finsh_error_set>
700181fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
70018200:	e3a02001 	mov	r2, #1
70018204:	e5c32005 	strb	r2, [r3, #5]
		return node;
70018208:	e51b300c 	ldr	r3, [fp, #-12]
7001820c:	ea000004 	b	70018224 <proc_variable_decl+0x44c>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
70018210:	e51b300c 	ldr	r3, [fp, #-12]
70018214:	ea000002 	b	70018224 <proc_variable_decl+0x44c>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
70018218:	e3a00002 	mov	r0, #2
7001821c:	ebfff4cf 	bl	70015560 <finsh_error_set>

		return NULL;
70018220:	e3a03000 	mov	r3, #0
	}
}
70018224:	e1a00003 	mov	r0, r3
70018228:	e24bd004 	sub	sp, fp, #4
7001822c:	e8bd8800 	pop	{fp, pc}

70018230 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
70018230:	e92d4800 	push	{fp, lr}
70018234:	e28db004 	add	fp, sp, #4
70018238:	e24dd010 	sub	sp, sp, #16
7001823c:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
70018240:	e3a03000 	mov	r3, #0
70018244:	e54b3005 	strb	r3, [fp, #-5]

	next_token(token, &(self->token));
70018248:	e51b3010 	ldr	r3, [fp, #-16]
7001824c:	e2833004 	add	r3, r3, #4
70018250:	e1a00003 	mov	r0, r3
70018254:	eb00067f 	bl	70019c58 <finsh_token_token>
70018258:	e1a03000 	mov	r3, r0
7001825c:	e54b3006 	strb	r3, [fp, #-6]
	if ( is_base_type(token) ) /* base_type */
70018260:	e55b3006 	ldrb	r3, [fp, #-6]
70018264:	e3530014 	cmp	r3, #20
70018268:	0a00000b 	beq	7001829c <proc_type+0x6c>
7001826c:	e55b3006 	ldrb	r3, [fp, #-6]
70018270:	e3530015 	cmp	r3, #21
70018274:	0a000008 	beq	7001829c <proc_type+0x6c>
70018278:	e55b3006 	ldrb	r3, [fp, #-6]
7001827c:	e3530016 	cmp	r3, #22
70018280:	0a000005 	beq	7001829c <proc_type+0x6c>
70018284:	e55b3006 	ldrb	r3, [fp, #-6]
70018288:	e3530017 	cmp	r3, #23
7001828c:	0a000002 	beq	7001829c <proc_type+0x6c>
70018290:	e55b3006 	ldrb	r3, [fp, #-6]
70018294:	e3530018 	cmp	r3, #24
70018298:	1a000019 	bne	70018304 <proc_type+0xd4>
	{
		switch (token)
7001829c:	e55b3006 	ldrb	r3, [fp, #-6]
700182a0:	e2433014 	sub	r3, r3, #20
700182a4:	e3530004 	cmp	r3, #4
700182a8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
700182ac:	ea00007d 	b	700184a8 <proc_type+0x278>
700182b0:	700182c4 	.word	0x700182c4
700182b4:	700182d0 	.word	0x700182d0
700182b8:	700182dc 	.word	0x700182dc
700182bc:	700182e8 	.word	0x700182e8
700182c0:	700182f4 	.word	0x700182f4
		{
		case finsh_token_type_void:
			type = finsh_type_void;
700182c4:	e3a03001 	mov	r3, #1
700182c8:	e54b3005 	strb	r3, [fp, #-5]
			break;
700182cc:	ea00000b 	b	70018300 <proc_type+0xd0>

		case finsh_token_type_char:
			type = finsh_type_char;
700182d0:	e3a03003 	mov	r3, #3
700182d4:	e54b3005 	strb	r3, [fp, #-5]
			break;
700182d8:	ea000008 	b	70018300 <proc_type+0xd0>

		case finsh_token_type_short:
			type = finsh_type_short;
700182dc:	e3a03006 	mov	r3, #6
700182e0:	e54b3005 	strb	r3, [fp, #-5]
			break;
700182e4:	ea000005 	b	70018300 <proc_type+0xd0>

		case finsh_token_type_int:
			type = finsh_type_int;
700182e8:	e3a03009 	mov	r3, #9
700182ec:	e54b3005 	strb	r3, [fp, #-5]
			break;
700182f0:	ea000002 	b	70018300 <proc_type+0xd0>

		case finsh_token_type_long:
			type = finsh_type_long;
700182f4:	e3a0300c 	mov	r3, #12
700182f8:	e54b3005 	strb	r3, [fp, #-5]
			break;
700182fc:	e1a00000 	nop			; (mov r0, r0)

		default:
			goto __return;
		}
	}
70018300:	ea000035 	b	700183dc <proc_type+0x1ac>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
70018304:	e55b3006 	ldrb	r3, [fp, #-6]
70018308:	e3530019 	cmp	r3, #25
7001830c:	1a000031 	bne	700183d8 <proc_type+0x1a8>
	{
		next_token(token, &(self->token));
70018310:	e51b3010 	ldr	r3, [fp, #-16]
70018314:	e2833004 	add	r3, r3, #4
70018318:	e1a00003 	mov	r0, r3
7001831c:	eb00064d 	bl	70019c58 <finsh_token_token>
70018320:	e1a03000 	mov	r3, r0
70018324:	e54b3006 	strb	r3, [fp, #-6]
		if ( is_base_type(token) )
70018328:	e55b3006 	ldrb	r3, [fp, #-6]
7001832c:	e3530014 	cmp	r3, #20
70018330:	0a00000b 	beq	70018364 <proc_type+0x134>
70018334:	e55b3006 	ldrb	r3, [fp, #-6]
70018338:	e3530015 	cmp	r3, #21
7001833c:	0a000008 	beq	70018364 <proc_type+0x134>
70018340:	e55b3006 	ldrb	r3, [fp, #-6]
70018344:	e3530016 	cmp	r3, #22
70018348:	0a000005 	beq	70018364 <proc_type+0x134>
7001834c:	e55b3006 	ldrb	r3, [fp, #-6]
70018350:	e3530017 	cmp	r3, #23
70018354:	0a000002 	beq	70018364 <proc_type+0x134>
70018358:	e55b3006 	ldrb	r3, [fp, #-6]
7001835c:	e3530018 	cmp	r3, #24
70018360:	1a000016 	bne	700183c0 <proc_type+0x190>
		{
			switch (token)
70018364:	e55b3006 	ldrb	r3, [fp, #-6]
70018368:	e2433015 	sub	r3, r3, #21
7001836c:	e3530003 	cmp	r3, #3
70018370:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70018374:	ea00004d 	b	700184b0 <proc_type+0x280>
70018378:	70018388 	.word	0x70018388
7001837c:	70018394 	.word	0x70018394
70018380:	700183a0 	.word	0x700183a0
70018384:	700183ac 	.word	0x700183ac
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
70018388:	e3a03004 	mov	r3, #4
7001838c:	e54b3005 	strb	r3, [fp, #-5]
				break;
70018390:	ea000008 	b	700183b8 <proc_type+0x188>

			case finsh_token_type_short:
				type = finsh_type_ushort;
70018394:	e3a03007 	mov	r3, #7
70018398:	e54b3005 	strb	r3, [fp, #-5]
				break;
7001839c:	ea000005 	b	700183b8 <proc_type+0x188>

			case finsh_token_type_int:
				type = finsh_type_uint;
700183a0:	e3a0300a 	mov	r3, #10
700183a4:	e54b3005 	strb	r3, [fp, #-5]
				break;
700183a8:	ea000002 	b	700183b8 <proc_type+0x188>

			case finsh_token_type_long:
				type = finsh_type_ulong;
700183ac:	e3a0300d 	mov	r3, #13
700183b0:	e54b3005 	strb	r3, [fp, #-5]
				break;
700183b4:	e1a00000 	nop			; (mov r0, r0)

			default:
				goto __return;
			}
		}
700183b8:	e1a00000 	nop			; (mov r0, r0)
700183bc:	ea000006 	b	700183dc <proc_type+0x1ac>
		else
		{
			finsh_token_replay(&(self->token));
700183c0:	e51b3010 	ldr	r3, [fp, #-16]
700183c4:	e3a02001 	mov	r2, #1
700183c8:	e5c32005 	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
700183cc:	e3a00002 	mov	r0, #2
700183d0:	ebfff462 	bl	70015560 <finsh_error_set>
700183d4:	ea000000 	b	700183dc <proc_type+0x1ac>
		}
	}
	else
	{
		goto __return;
700183d8:	ea000035 	b	700184b4 <proc_type+0x284>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
700183dc:	e51b3010 	ldr	r3, [fp, #-16]
700183e0:	e2833004 	add	r3, r3, #4
700183e4:	e1a00003 	mov	r0, r3
700183e8:	eb00061a 	bl	70019c58 <finsh_token_token>
700183ec:	e1a03000 	mov	r3, r0
700183f0:	e54b3006 	strb	r3, [fp, #-6]
	if (token == finsh_token_type_mul)
700183f4:	e55b3006 	ldrb	r3, [fp, #-6]
700183f8:	e3530005 	cmp	r3, #5
700183fc:	1a000024 	bne	70018494 <proc_type+0x264>
	{
		switch (type)
70018400:	e55b3005 	ldrb	r3, [fp, #-5]
70018404:	e2433001 	sub	r3, r3, #1
70018408:	e353000c 	cmp	r3, #12
7001840c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70018410:	ea00001b 	b	70018484 <proc_type+0x254>
70018414:	70018448 	.word	0x70018448
70018418:	70018484 	.word	0x70018484
7001841c:	70018454 	.word	0x70018454
70018420:	70018454 	.word	0x70018454
70018424:	70018484 	.word	0x70018484
70018428:	70018460 	.word	0x70018460
7001842c:	70018460 	.word	0x70018460
70018430:	70018484 	.word	0x70018484
70018434:	7001846c 	.word	0x7001846c
70018438:	7001846c 	.word	0x7001846c
7001843c:	70018484 	.word	0x70018484
70018440:	70018478 	.word	0x70018478
70018444:	70018478 	.word	0x70018478
		{
		case finsh_type_void:
			type = finsh_type_voidp;
70018448:	e3a03002 	mov	r3, #2
7001844c:	e54b3005 	strb	r3, [fp, #-5]
			break;
70018450:	ea00000e 	b	70018490 <proc_type+0x260>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
70018454:	e3a03005 	mov	r3, #5
70018458:	e54b3005 	strb	r3, [fp, #-5]
			break;
7001845c:	ea00000b 	b	70018490 <proc_type+0x260>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
70018460:	e3a03008 	mov	r3, #8
70018464:	e54b3005 	strb	r3, [fp, #-5]
			break;
70018468:	ea000008 	b	70018490 <proc_type+0x260>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
7001846c:	e3a0300b 	mov	r3, #11
70018470:	e54b3005 	strb	r3, [fp, #-5]
			break;
70018474:	ea000005 	b	70018490 <proc_type+0x260>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
70018478:	e3a0300e 	mov	r3, #14
7001847c:	e54b3005 	strb	r3, [fp, #-5]
			break;
70018480:	ea000002 	b	70018490 <proc_type+0x260>

		default:
			type = finsh_type_voidp;
70018484:	e3a03002 	mov	r3, #2
70018488:	e54b3005 	strb	r3, [fp, #-5]
			break;
7001848c:	e1a00000 	nop			; (mov r0, r0)
70018490:	ea000002 	b	700184a0 <proc_type+0x270>
		}
	}
	else finsh_token_replay(&(self->token));
70018494:	e51b3010 	ldr	r3, [fp, #-16]
70018498:	e3a02001 	mov	r2, #1
7001849c:	e5c32005 	strb	r2, [r3, #5]

	return type;
700184a0:	e55b3005 	ldrb	r3, [fp, #-5]
700184a4:	ea000008 	b	700184cc <proc_type+0x29c>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
700184a8:	e1a00000 	nop			; (mov r0, r0)
700184ac:	ea000000 	b	700184b4 <proc_type+0x284>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
700184b0:	e1a00000 	nop			; (mov r0, r0)
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
700184b4:	e51b3010 	ldr	r3, [fp, #-16]
700184b8:	e3a02001 	mov	r2, #1
700184bc:	e5c32005 	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
700184c0:	e3a00003 	mov	r0, #3
700184c4:	ebfff425 	bl	70015560 <finsh_error_set>

	return type;
700184c8:	e55b3005 	ldrb	r3, [fp, #-5]
}
700184cc:	e1a00003 	mov	r0, r3
700184d0:	e24bd004 	sub	sp, fp, #4
700184d4:	e8bd8800 	pop	{fp, pc}

700184d8 <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
700184d8:	e92d4800 	push	{fp, lr}
700184dc:	e28db004 	add	fp, sp, #4
700184e0:	e24dd010 	sub	sp, sp, #16
700184e4:	e50b0010 	str	r0, [fp, #-16]
700184e8:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
700184ec:	e51b3010 	ldr	r3, [fp, #-16]
700184f0:	e2833004 	add	r3, r3, #4
700184f4:	e1a00003 	mov	r0, r3
700184f8:	eb0005d6 	bl	70019c58 <finsh_token_token>
700184fc:	e1a03000 	mov	r3, r0
70018500:	e54b3005 	strb	r3, [fp, #-5]
70018504:	e55b3005 	ldrb	r3, [fp, #-5]
70018508:	e353001f 	cmp	r3, #31
7001850c:	0a000004 	beq	70018524 <proc_identifier+0x4c>
70018510:	e3a00001 	mov	r0, #1
70018514:	ebfff411 	bl	70015560 <finsh_error_set>
70018518:	e51b3010 	ldr	r3, [fp, #-16]
7001851c:	e3a02001 	mov	r2, #1
70018520:	e5c32005 	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
70018524:	e51b3010 	ldr	r3, [fp, #-16]
70018528:	e2833014 	add	r3, r3, #20
7001852c:	e51b0014 	ldr	r0, [fp, #-20]
70018530:	e1a01003 	mov	r1, r3
70018534:	e3a02010 	mov	r2, #16
70018538:	fa002fc3 	blx	7002444c <strncpy>

	return 0;
7001853c:	e3a03000 	mov	r3, #0
}
70018540:	e1a00003 	mov	r0, r3
70018544:	e24bd004 	sub	sp, fp, #4
70018548:	e8bd8800 	pop	{fp, pc}

7001854c <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
7001854c:	e92d4800 	push	{fp, lr}
70018550:	e28db004 	add	fp, sp, #4
70018554:	e24dd010 	sub	sp, sp, #16
70018558:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
7001855c:	e3a03000 	mov	r3, #0
70018560:	e50b3008 	str	r3, [fp, #-8]
	next_token(token, &(self->token));
70018564:	e51b3010 	ldr	r3, [fp, #-16]
70018568:	e2833004 	add	r3, r3, #4
7001856c:	e1a00003 	mov	r0, r3
70018570:	eb0005b8 	bl	70019c58 <finsh_token_token>
70018574:	e1a03000 	mov	r3, r0
70018578:	e54b3009 	strb	r3, [fp, #-9]
	if ( token != finsh_token_type_semicolon )
7001857c:	e55b3009 	ldrb	r3, [fp, #-9]
70018580:	e3530004 	cmp	r3, #4
70018584:	0a000013 	beq	700185d8 <proc_expr_statement+0x8c>
	{
		finsh_token_replay(&(self->token));
70018588:	e51b3010 	ldr	r3, [fp, #-16]
7001858c:	e3a02001 	mov	r2, #1
70018590:	e5c32005 	strb	r2, [r3, #5]
		expr = proc_expr(self);
70018594:	e51b0010 	ldr	r0, [fp, #-16]
70018598:	eb000012 	bl	700185e8 <proc_expr>
7001859c:	e50b0008 	str	r0, [fp, #-8]

		match_token(token, &(self->token), finsh_token_type_semicolon);
700185a0:	e51b3010 	ldr	r3, [fp, #-16]
700185a4:	e2833004 	add	r3, r3, #4
700185a8:	e1a00003 	mov	r0, r3
700185ac:	eb0005a9 	bl	70019c58 <finsh_token_token>
700185b0:	e1a03000 	mov	r3, r0
700185b4:	e54b3009 	strb	r3, [fp, #-9]
700185b8:	e55b3009 	ldrb	r3, [fp, #-9]
700185bc:	e3530004 	cmp	r3, #4
700185c0:	0a000004 	beq	700185d8 <proc_expr_statement+0x8c>
700185c4:	e3a00001 	mov	r0, #1
700185c8:	ebfff3e4 	bl	70015560 <finsh_error_set>
700185cc:	e51b3010 	ldr	r3, [fp, #-16]
700185d0:	e3a02001 	mov	r2, #1
700185d4:	e5c32005 	strb	r2, [r3, #5]
	}

	return expr;
700185d8:	e51b3008 	ldr	r3, [fp, #-8]
}
700185dc:	e1a00003 	mov	r0, r3
700185e0:	e24bd004 	sub	sp, fp, #4
700185e4:	e8bd8800 	pop	{fp, pc}

700185e8 <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
700185e8:	e92d4800 	push	{fp, lr}
700185ec:	e28db004 	add	fp, sp, #4
700185f0:	e24dd008 	sub	sp, sp, #8
700185f4:	e50b0008 	str	r0, [fp, #-8]
	return proc_assign_expr(self);
700185f8:	e51b0008 	ldr	r0, [fp, #-8]
700185fc:	eb000003 	bl	70018610 <proc_assign_expr>
70018600:	e1a03000 	mov	r3, r0
}
70018604:	e1a00003 	mov	r0, r3
70018608:	e24bd004 	sub	sp, fp, #4
7001860c:	e8bd8800 	pop	{fp, pc}

70018610 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
70018610:	e92d4800 	push	{fp, lr}
70018614:	e28db004 	add	fp, sp, #4
70018618:	e24dd018 	sub	sp, sp, #24
7001861c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
70018620:	e51b0018 	ldr	r0, [fp, #-24]
70018624:	eb000019 	bl	70018690 <proc_inclusive_or_expr>
70018628:	e50b0008 	str	r0, [fp, #-8]

	next_token(token, &(self->token));
7001862c:	e51b3018 	ldr	r3, [fp, #-24]
70018630:	e2833004 	add	r3, r3, #4
70018634:	e1a00003 	mov	r0, r3
70018638:	eb000586 	bl	70019c58 <finsh_token_token>
7001863c:	e1a03000 	mov	r3, r0
70018640:	e54b3009 	strb	r3, [fp, #-9]

	if (token == finsh_token_type_assign)
70018644:	e55b3009 	ldrb	r3, [fp, #-9]
70018648:	e353000c 	cmp	r3, #12
7001864c:	1a000008 	bne	70018674 <proc_assign_expr+0x64>
	{
		assign = proc_assign_expr(self);
70018650:	e51b0018 	ldr	r0, [fp, #-24]
70018654:	ebffffed 	bl	70018610 <proc_assign_expr>
70018658:	e50b0010 	str	r0, [fp, #-16]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
7001865c:	e3a00013 	mov	r0, #19
70018660:	e51b1008 	ldr	r1, [fp, #-8]
70018664:	e51b2010 	ldr	r2, [fp, #-16]
70018668:	eb0002e8 	bl	70019210 <make_sys_node>
7001866c:	e1a03000 	mov	r3, r0
70018670:	ea000003 	b	70018684 <proc_assign_expr+0x74>
	}
	else finsh_token_replay(&(self->token));
70018674:	e51b3018 	ldr	r3, [fp, #-24]
70018678:	e3a02001 	mov	r2, #1
7001867c:	e5c32005 	strb	r2, [r3, #5]

	return or;
70018680:	e51b3008 	ldr	r3, [fp, #-8]
}
70018684:	e1a00003 	mov	r0, r3
70018688:	e24bd004 	sub	sp, fp, #4
7001868c:	e8bd8800 	pop	{fp, pc}

70018690 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
70018690:	e92d4800 	push	{fp, lr}
70018694:	e28db004 	add	fp, sp, #4
70018698:	e24dd018 	sub	sp, sp, #24
7001869c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
700186a0:	e51b0018 	ldr	r0, [fp, #-24]
700186a4:	eb000025 	bl	70018740 <proc_exclusive_or_expr>
700186a8:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
700186ac:	e51b3018 	ldr	r3, [fp, #-24]
700186b0:	e2833004 	add	r3, r3, #4
700186b4:	e1a00003 	mov	r0, r3
700186b8:	eb000566 	bl	70019c58 <finsh_token_token>
700186bc:	e1a03000 	mov	r3, r0
700186c0:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_or )
700186c4:	ea000013 	b	70018718 <proc_inclusive_or_expr+0x88>
	{
		xor_new = proc_exclusive_or_expr(self);
700186c8:	e51b0018 	ldr	r0, [fp, #-24]
700186cc:	eb00001b 	bl	70018740 <proc_exclusive_or_expr>
700186d0:	e50b0010 	str	r0, [fp, #-16]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
700186d4:	e51b3010 	ldr	r3, [fp, #-16]
700186d8:	e3530000 	cmp	r3, #0
700186dc:	1a000002 	bne	700186ec <proc_inclusive_or_expr+0x5c>
700186e0:	e3a00005 	mov	r0, #5
700186e4:	ebfff39d 	bl	70015560 <finsh_error_set>
700186e8:	ea000004 	b	70018700 <proc_inclusive_or_expr+0x70>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
700186ec:	e3a0000d 	mov	r0, #13
700186f0:	e51b100c 	ldr	r1, [fp, #-12]
700186f4:	e51b2010 	ldr	r2, [fp, #-16]
700186f8:	eb0002c4 	bl	70019210 <make_sys_node>
700186fc:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
70018700:	e51b3018 	ldr	r3, [fp, #-24]
70018704:	e2833004 	add	r3, r3, #4
70018708:	e1a00003 	mov	r0, r3
7001870c:	eb000551 	bl	70019c58 <finsh_token_token>
70018710:	e1a03000 	mov	r3, r0
70018714:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
70018718:	e55b3005 	ldrb	r3, [fp, #-5]
7001871c:	e353000e 	cmp	r3, #14
70018720:	0affffe8 	beq	700186c8 <proc_inclusive_or_expr+0x38>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018724:	e51b3018 	ldr	r3, [fp, #-24]
70018728:	e3a02001 	mov	r2, #1
7001872c:	e5c32005 	strb	r2, [r3, #5]
	return xor;
70018730:	e51b300c 	ldr	r3, [fp, #-12]
}
70018734:	e1a00003 	mov	r0, r3
70018738:	e24bd004 	sub	sp, fp, #4
7001873c:	e8bd8800 	pop	{fp, pc}

70018740 <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
70018740:	e92d4800 	push	{fp, lr}
70018744:	e28db004 	add	fp, sp, #4
70018748:	e24dd018 	sub	sp, sp, #24
7001874c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
70018750:	e51b0018 	ldr	r0, [fp, #-24]
70018754:	eb000025 	bl	700187f0 <proc_and_expr>
70018758:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
7001875c:	e51b3018 	ldr	r3, [fp, #-24]
70018760:	e2833004 	add	r3, r3, #4
70018764:	e1a00003 	mov	r0, r3
70018768:	eb00053a 	bl	70019c58 <finsh_token_token>
7001876c:	e1a03000 	mov	r3, r0
70018770:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_xor )
70018774:	ea000013 	b	700187c8 <proc_exclusive_or_expr+0x88>
	{
		and_new = proc_and_expr(self);
70018778:	e51b0018 	ldr	r0, [fp, #-24]
7001877c:	eb00001b 	bl	700187f0 <proc_and_expr>
70018780:	e50b0010 	str	r0, [fp, #-16]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018784:	e51b3010 	ldr	r3, [fp, #-16]
70018788:	e3530000 	cmp	r3, #0
7001878c:	1a000002 	bne	7001879c <proc_exclusive_or_expr+0x5c>
70018790:	e3a00005 	mov	r0, #5
70018794:	ebfff371 	bl	70015560 <finsh_error_set>
70018798:	ea000004 	b	700187b0 <proc_exclusive_or_expr+0x70>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
7001879c:	e3a0000e 	mov	r0, #14
700187a0:	e51b100c 	ldr	r1, [fp, #-12]
700187a4:	e51b2010 	ldr	r2, [fp, #-16]
700187a8:	eb000298 	bl	70019210 <make_sys_node>
700187ac:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
700187b0:	e51b3018 	ldr	r3, [fp, #-24]
700187b4:	e2833004 	add	r3, r3, #4
700187b8:	e1a00003 	mov	r0, r3
700187bc:	eb000525 	bl	70019c58 <finsh_token_token>
700187c0:	e1a03000 	mov	r3, r0
700187c4:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
700187c8:	e55b3005 	ldrb	r3, [fp, #-5]
700187cc:	e353000f 	cmp	r3, #15
700187d0:	0affffe8 	beq	70018778 <proc_exclusive_or_expr+0x38>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
700187d4:	e51b3018 	ldr	r3, [fp, #-24]
700187d8:	e3a02001 	mov	r2, #1
700187dc:	e5c32005 	strb	r2, [r3, #5]
	return and;
700187e0:	e51b300c 	ldr	r3, [fp, #-12]
}
700187e4:	e1a00003 	mov	r0, r3
700187e8:	e24bd004 	sub	sp, fp, #4
700187ec:	e8bd8800 	pop	{fp, pc}

700187f0 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
700187f0:	e92d4800 	push	{fp, lr}
700187f4:	e28db004 	add	fp, sp, #4
700187f8:	e24dd018 	sub	sp, sp, #24
700187fc:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
70018800:	e51b0018 	ldr	r0, [fp, #-24]
70018804:	eb000025 	bl	700188a0 <proc_shift_expr>
70018808:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
7001880c:	e51b3018 	ldr	r3, [fp, #-24]
70018810:	e2833004 	add	r3, r3, #4
70018814:	e1a00003 	mov	r0, r3
70018818:	eb00050e 	bl	70019c58 <finsh_token_token>
7001881c:	e1a03000 	mov	r3, r0
70018820:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_and )
70018824:	ea000013 	b	70018878 <proc_and_expr+0x88>
	{
		shift_new = proc_shift_expr(self);
70018828:	e51b0018 	ldr	r0, [fp, #-24]
7001882c:	eb00001b 	bl	700188a0 <proc_shift_expr>
70018830:	e50b0010 	str	r0, [fp, #-16]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018834:	e51b3010 	ldr	r3, [fp, #-16]
70018838:	e3530000 	cmp	r3, #0
7001883c:	1a000002 	bne	7001884c <proc_and_expr+0x5c>
70018840:	e3a00005 	mov	r0, #5
70018844:	ebfff345 	bl	70015560 <finsh_error_set>
70018848:	ea000004 	b	70018860 <proc_and_expr+0x70>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
7001884c:	e3a0000c 	mov	r0, #12
70018850:	e51b100c 	ldr	r1, [fp, #-12]
70018854:	e51b2010 	ldr	r2, [fp, #-16]
70018858:	eb00026c 	bl	70019210 <make_sys_node>
7001885c:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
70018860:	e51b3018 	ldr	r3, [fp, #-24]
70018864:	e2833004 	add	r3, r3, #4
70018868:	e1a00003 	mov	r0, r3
7001886c:	eb0004f9 	bl	70019c58 <finsh_token_token>
70018870:	e1a03000 	mov	r3, r0
70018874:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
70018878:	e55b3005 	ldrb	r3, [fp, #-5]
7001887c:	e353000d 	cmp	r3, #13
70018880:	0affffe8 	beq	70018828 <proc_and_expr+0x38>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018884:	e51b3018 	ldr	r3, [fp, #-24]
70018888:	e3a02001 	mov	r2, #1
7001888c:	e5c32005 	strb	r2, [r3, #5]
	return shift;
70018890:	e51b300c 	ldr	r3, [fp, #-12]
}
70018894:	e1a00003 	mov	r0, r3
70018898:	e24bd004 	sub	sp, fp, #4
7001889c:	e8bd8800 	pop	{fp, pc}

700188a0 <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
700188a0:	e92d4800 	push	{fp, lr}
700188a4:	e28db004 	add	fp, sp, #4
700188a8:	e24dd018 	sub	sp, sp, #24
700188ac:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
700188b0:	e51b0018 	ldr	r0, [fp, #-24]
700188b4:	eb000038 	bl	7001899c <proc_additive_expr>
700188b8:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
700188bc:	e51b3018 	ldr	r3, [fp, #-24]
700188c0:	e2833004 	add	r3, r3, #4
700188c4:	e1a00003 	mov	r0, r3
700188c8:	eb0004e2 	bl	70019c58 <finsh_token_token>
700188cc:	e1a03000 	mov	r3, r0
700188d0:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
700188d4:	ea000023 	b	70018968 <proc_shift_expr+0xc8>
	{
		add_new = proc_additive_expr(self);
700188d8:	e51b0018 	ldr	r0, [fp, #-24]
700188dc:	eb00002e 	bl	7001899c <proc_additive_expr>
700188e0:	e50b0010 	str	r0, [fp, #-16]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
700188e4:	e51b3010 	ldr	r3, [fp, #-16]
700188e8:	e3530000 	cmp	r3, #0
700188ec:	1a000002 	bne	700188fc <proc_shift_expr+0x5c>
700188f0:	e3a00005 	mov	r0, #5
700188f4:	ebfff319 	bl	70015560 <finsh_error_set>
700188f8:	ea000014 	b	70018950 <proc_shift_expr+0xb0>
		else
		{
			switch (token)
700188fc:	e55b3005 	ldrb	r3, [fp, #-5]
70018900:	e3530011 	cmp	r3, #17
70018904:	0a000002 	beq	70018914 <proc_shift_expr+0x74>
70018908:	e3530012 	cmp	r3, #18
7001890c:	0a000006 	beq	7001892c <proc_shift_expr+0x8c>
70018910:	ea00000b 	b	70018944 <proc_shift_expr+0xa4>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
70018914:	e3a00010 	mov	r0, #16
70018918:	e51b100c 	ldr	r1, [fp, #-12]
7001891c:	e51b2010 	ldr	r2, [fp, #-16]
70018920:	eb00023a 	bl	70019210 <make_sys_node>
70018924:	e50b000c 	str	r0, [fp, #-12]
				break;
70018928:	ea000008 	b	70018950 <proc_shift_expr+0xb0>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
7001892c:	e3a00011 	mov	r0, #17
70018930:	e51b100c 	ldr	r1, [fp, #-12]
70018934:	e51b2010 	ldr	r2, [fp, #-16]
70018938:	eb000234 	bl	70019210 <make_sys_node>
7001893c:	e50b000c 	str	r0, [fp, #-12]
				break;
70018940:	ea000002 	b	70018950 <proc_shift_expr+0xb0>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018944:	e3a00005 	mov	r0, #5
70018948:	ebfff304 	bl	70015560 <finsh_error_set>
				break;
7001894c:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
70018950:	e51b3018 	ldr	r3, [fp, #-24]
70018954:	e2833004 	add	r3, r3, #4
70018958:	e1a00003 	mov	r0, r3
7001895c:	eb0004bd 	bl	70019c58 <finsh_token_token>
70018960:	e1a03000 	mov	r3, r0
70018964:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
70018968:	e55b3005 	ldrb	r3, [fp, #-5]
7001896c:	e3530011 	cmp	r3, #17
70018970:	0affffd8 	beq	700188d8 <proc_shift_expr+0x38>
70018974:	e55b3005 	ldrb	r3, [fp, #-5]
70018978:	e3530012 	cmp	r3, #18
7001897c:	0affffd5 	beq	700188d8 <proc_shift_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018980:	e51b3018 	ldr	r3, [fp, #-24]
70018984:	e3a02001 	mov	r2, #1
70018988:	e5c32005 	strb	r2, [r3, #5]
	return add;
7001898c:	e51b300c 	ldr	r3, [fp, #-12]
}
70018990:	e1a00003 	mov	r0, r3
70018994:	e24bd004 	sub	sp, fp, #4
70018998:	e8bd8800 	pop	{fp, pc}

7001899c <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
7001899c:	e92d4800 	push	{fp, lr}
700189a0:	e28db004 	add	fp, sp, #4
700189a4:	e24dd018 	sub	sp, sp, #24
700189a8:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
700189ac:	e51b0018 	ldr	r0, [fp, #-24]
700189b0:	eb000037 	bl	70018a94 <proc_multiplicative_expr>
700189b4:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
700189b8:	e51b3018 	ldr	r3, [fp, #-24]
700189bc:	e2833004 	add	r3, r3, #4
700189c0:	e1a00003 	mov	r0, r3
700189c4:	eb0004a3 	bl	70019c58 <finsh_token_token>
700189c8:	e1a03000 	mov	r3, r0
700189cc:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
700189d0:	ea000022 	b	70018a60 <proc_additive_expr+0xc4>
	{
		mul_new = proc_multiplicative_expr(self);
700189d4:	e51b0018 	ldr	r0, [fp, #-24]
700189d8:	eb00002d 	bl	70018a94 <proc_multiplicative_expr>
700189dc:	e50b0010 	str	r0, [fp, #-16]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
700189e0:	e51b3010 	ldr	r3, [fp, #-16]
700189e4:	e3530000 	cmp	r3, #0
700189e8:	1a000002 	bne	700189f8 <proc_additive_expr+0x5c>
700189ec:	e3a00005 	mov	r0, #5
700189f0:	ebfff2da 	bl	70015560 <finsh_error_set>
700189f4:	ea000013 	b	70018a48 <proc_additive_expr+0xac>
		else
		{
			switch (token)
700189f8:	e55b3005 	ldrb	r3, [fp, #-5]
700189fc:	e3530006 	cmp	r3, #6
70018a00:	0a000007 	beq	70018a24 <proc_additive_expr+0x88>
70018a04:	e3530008 	cmp	r3, #8
70018a08:	1a00000b 	bne	70018a3c <proc_additive_expr+0xa0>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
70018a0c:	e3a00008 	mov	r0, #8
70018a10:	e51b100c 	ldr	r1, [fp, #-12]
70018a14:	e51b2010 	ldr	r2, [fp, #-16]
70018a18:	eb0001fc 	bl	70019210 <make_sys_node>
70018a1c:	e50b000c 	str	r0, [fp, #-12]
				break;
70018a20:	ea000008 	b	70018a48 <proc_additive_expr+0xac>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
70018a24:	e3a00007 	mov	r0, #7
70018a28:	e51b100c 	ldr	r1, [fp, #-12]
70018a2c:	e51b2010 	ldr	r2, [fp, #-16]
70018a30:	eb0001f6 	bl	70019210 <make_sys_node>
70018a34:	e50b000c 	str	r0, [fp, #-12]
				break;
70018a38:	ea000002 	b	70018a48 <proc_additive_expr+0xac>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018a3c:	e3a00005 	mov	r0, #5
70018a40:	ebfff2c6 	bl	70015560 <finsh_error_set>
				break;
70018a44:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
70018a48:	e51b3018 	ldr	r3, [fp, #-24]
70018a4c:	e2833004 	add	r3, r3, #4
70018a50:	e1a00003 	mov	r0, r3
70018a54:	eb00047f 	bl	70019c58 <finsh_token_token>
70018a58:	e1a03000 	mov	r3, r0
70018a5c:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
70018a60:	e55b3005 	ldrb	r3, [fp, #-5]
70018a64:	e3530008 	cmp	r3, #8
70018a68:	0affffd9 	beq	700189d4 <proc_additive_expr+0x38>
70018a6c:	e55b3005 	ldrb	r3, [fp, #-5]
70018a70:	e3530006 	cmp	r3, #6
70018a74:	0affffd6 	beq	700189d4 <proc_additive_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018a78:	e51b3018 	ldr	r3, [fp, #-24]
70018a7c:	e3a02001 	mov	r2, #1
70018a80:	e5c32005 	strb	r2, [r3, #5]
	return mul;
70018a84:	e51b300c 	ldr	r3, [fp, #-12]
}
70018a88:	e1a00003 	mov	r0, r3
70018a8c:	e24bd004 	sub	sp, fp, #4
70018a90:	e8bd8800 	pop	{fp, pc}

70018a94 <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
70018a94:	e92d4800 	push	{fp, lr}
70018a98:	e28db004 	add	fp, sp, #4
70018a9c:	e24dd018 	sub	sp, sp, #24
70018aa0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
70018aa4:	e51b0018 	ldr	r0, [fp, #-24]
70018aa8:	eb000042 	bl	70018bb8 <proc_cast_expr>
70018aac:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
70018ab0:	e51b3018 	ldr	r3, [fp, #-24]
70018ab4:	e2833004 	add	r3, r3, #4
70018ab8:	e1a00003 	mov	r0, r3
70018abc:	eb000465 	bl	70019c58 <finsh_token_token>
70018ac0:	e1a03000 	mov	r3, r0
70018ac4:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_mul ||
70018ac8:	ea00002a 	b	70018b78 <proc_multiplicative_expr+0xe4>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
70018acc:	e51b0018 	ldr	r0, [fp, #-24]
70018ad0:	eb000038 	bl	70018bb8 <proc_cast_expr>
70018ad4:	e50b0010 	str	r0, [fp, #-16]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018ad8:	e51b3010 	ldr	r3, [fp, #-16]
70018adc:	e3530000 	cmp	r3, #0
70018ae0:	1a000002 	bne	70018af0 <proc_multiplicative_expr+0x5c>
70018ae4:	e3a00005 	mov	r0, #5
70018ae8:	ebfff29c 	bl	70015560 <finsh_error_set>
70018aec:	ea00001b 	b	70018b60 <proc_multiplicative_expr+0xcc>
		else
		{
			switch (token)
70018af0:	e55b3005 	ldrb	r3, [fp, #-5]
70018af4:	e353000a 	cmp	r3, #10
70018af8:	0a000009 	beq	70018b24 <proc_multiplicative_expr+0x90>
70018afc:	e353000b 	cmp	r3, #11
70018b00:	0a00000d 	beq	70018b3c <proc_multiplicative_expr+0xa8>
70018b04:	e3530005 	cmp	r3, #5
70018b08:	1a000011 	bne	70018b54 <proc_multiplicative_expr+0xc0>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
70018b0c:	e3a00009 	mov	r0, #9
70018b10:	e51b100c 	ldr	r1, [fp, #-12]
70018b14:	e51b2010 	ldr	r2, [fp, #-16]
70018b18:	eb0001bc 	bl	70019210 <make_sys_node>
70018b1c:	e50b000c 	str	r0, [fp, #-12]
				break;
70018b20:	ea00000e 	b	70018b60 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
70018b24:	e3a0000a 	mov	r0, #10
70018b28:	e51b100c 	ldr	r1, [fp, #-12]
70018b2c:	e51b2010 	ldr	r2, [fp, #-16]
70018b30:	eb0001b6 	bl	70019210 <make_sys_node>
70018b34:	e50b000c 	str	r0, [fp, #-12]
				break;
70018b38:	ea000008 	b	70018b60 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
70018b3c:	e3a0000b 	mov	r0, #11
70018b40:	e51b100c 	ldr	r1, [fp, #-12]
70018b44:	e51b2010 	ldr	r2, [fp, #-16]
70018b48:	eb0001b0 	bl	70019210 <make_sys_node>
70018b4c:	e50b000c 	str	r0, [fp, #-12]
				break;
70018b50:	ea000002 	b	70018b60 <proc_multiplicative_expr+0xcc>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
70018b54:	e3a00005 	mov	r0, #5
70018b58:	ebfff280 	bl	70015560 <finsh_error_set>
				break;
70018b5c:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
70018b60:	e51b3018 	ldr	r3, [fp, #-24]
70018b64:	e2833004 	add	r3, r3, #4
70018b68:	e1a00003 	mov	r0, r3
70018b6c:	eb000439 	bl	70019c58 <finsh_token_token>
70018b70:	e1a03000 	mov	r3, r0
70018b74:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
70018b78:	e55b3005 	ldrb	r3, [fp, #-5]
70018b7c:	e3530005 	cmp	r3, #5
70018b80:	0affffd1 	beq	70018acc <proc_multiplicative_expr+0x38>
70018b84:	e55b3005 	ldrb	r3, [fp, #-5]
70018b88:	e353000a 	cmp	r3, #10
70018b8c:	0affffce 	beq	70018acc <proc_multiplicative_expr+0x38>
		token == finsh_token_type_div ||
70018b90:	e55b3005 	ldrb	r3, [fp, #-5]
70018b94:	e353000b 	cmp	r3, #11
70018b98:	0affffcb 	beq	70018acc <proc_multiplicative_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018b9c:	e51b3018 	ldr	r3, [fp, #-24]
70018ba0:	e3a02001 	mov	r2, #1
70018ba4:	e5c32005 	strb	r2, [r3, #5]
	return cast;
70018ba8:	e51b300c 	ldr	r3, [fp, #-12]
}
70018bac:	e1a00003 	mov	r0, r3
70018bb0:	e24bd004 	sub	sp, fp, #4
70018bb4:	e8bd8800 	pop	{fp, pc}

70018bb8 <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
70018bb8:	e92d4800 	push	{fp, lr}
70018bbc:	e28db004 	add	fp, sp, #4
70018bc0:	e24dd010 	sub	sp, sp, #16
70018bc4:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
70018bc8:	e51b3010 	ldr	r3, [fp, #-16]
70018bcc:	e2833004 	add	r3, r3, #4
70018bd0:	e1a00003 	mov	r0, r3
70018bd4:	eb00041f 	bl	70019c58 <finsh_token_token>
70018bd8:	e1a03000 	mov	r3, r0
70018bdc:	e54b3005 	strb	r3, [fp, #-5]
	if (token == finsh_token_type_left_paren)
70018be0:	e55b3005 	ldrb	r3, [fp, #-5]
70018be4:	e3530001 	cmp	r3, #1
70018be8:	1a00001c 	bne	70018c60 <proc_cast_expr+0xa8>
	{
		type = proc_type(self);
70018bec:	e51b0010 	ldr	r0, [fp, #-16]
70018bf0:	ebfffd8e 	bl	70018230 <proc_type>
70018bf4:	e1a03000 	mov	r3, r0
70018bf8:	e54b3006 	strb	r3, [fp, #-6]
		match_token(token, &(self->token), finsh_token_type_right_paren);
70018bfc:	e51b3010 	ldr	r3, [fp, #-16]
70018c00:	e2833004 	add	r3, r3, #4
70018c04:	e1a00003 	mov	r0, r3
70018c08:	eb000412 	bl	70019c58 <finsh_token_token>
70018c0c:	e1a03000 	mov	r3, r0
70018c10:	e54b3005 	strb	r3, [fp, #-5]
70018c14:	e55b3005 	ldrb	r3, [fp, #-5]
70018c18:	e3530002 	cmp	r3, #2
70018c1c:	0a000004 	beq	70018c34 <proc_cast_expr+0x7c>
70018c20:	e3a00001 	mov	r0, #1
70018c24:	ebfff24d 	bl	70015560 <finsh_error_set>
70018c28:	e51b3010 	ldr	r3, [fp, #-16]
70018c2c:	e3a02001 	mov	r2, #1
70018c30:	e5c32005 	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
70018c34:	e51b0010 	ldr	r0, [fp, #-16]
70018c38:	ebffffde 	bl	70018bb8 <proc_cast_expr>
70018c3c:	e50b000c 	str	r0, [fp, #-12]
		if (cast != NULL)
70018c40:	e51b300c 	ldr	r3, [fp, #-12]
70018c44:	e3530000 	cmp	r3, #0
70018c48:	0a000004 	beq	70018c60 <proc_cast_expr+0xa8>
		{
			cast->data_type = type;
70018c4c:	e51b300c 	ldr	r3, [fp, #-12]
70018c50:	e55b2006 	ldrb	r2, [fp, #-6]
70018c54:	e5c32001 	strb	r2, [r3, #1]
			return cast;
70018c58:	e51b300c 	ldr	r3, [fp, #-12]
70018c5c:	ea000005 	b	70018c78 <proc_cast_expr+0xc0>
		}
	}

	finsh_token_replay(&(self->token));
70018c60:	e51b3010 	ldr	r3, [fp, #-16]
70018c64:	e3a02001 	mov	r2, #1
70018c68:	e5c32005 	strb	r2, [r3, #5]
	return proc_unary_expr(self);
70018c6c:	e51b0010 	ldr	r0, [fp, #-16]
70018c70:	eb000003 	bl	70018c84 <proc_unary_expr>
70018c74:	e1a03000 	mov	r3, r0
}
70018c78:	e1a00003 	mov	r0, r3
70018c7c:	e24bd004 	sub	sp, fp, #4
70018c80:	e8bd8800 	pop	{fp, pc}

70018c84 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
70018c84:	e92d4800 	push	{fp, lr}
70018c88:	e28db004 	add	fp, sp, #4
70018c8c:	e24dd010 	sub	sp, sp, #16
70018c90:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
70018c94:	e51b3010 	ldr	r3, [fp, #-16]
70018c98:	e2833004 	add	r3, r3, #4
70018c9c:	e1a00003 	mov	r0, r3
70018ca0:	eb0003ec 	bl	70019c58 <finsh_token_token>
70018ca4:	e1a03000 	mov	r3, r0
70018ca8:	e54b3005 	strb	r3, [fp, #-5]
	switch (token)
70018cac:	e55b3005 	ldrb	r3, [fp, #-5]
70018cb0:	e2433005 	sub	r3, r3, #5
70018cb4:	e353000b 	cmp	r3, #11
70018cb8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70018cbc:	ea000049 	b	70018de8 <proc_unary_expr+0x164>
70018cc0:	70018da0 	.word	0x70018da0
70018cc4:	70018cf0 	.word	0x70018cf0
70018cc8:	70018d04 	.word	0x70018d04
70018ccc:	70018d28 	.word	0x70018d28
70018cd0:	70018d58 	.word	0x70018d58
70018cd4:	70018de8 	.word	0x70018de8
70018cd8:	70018de8 	.word	0x70018de8
70018cdc:	70018de8 	.word	0x70018de8
70018ce0:	70018dc4 	.word	0x70018dc4
70018ce4:	70018de8 	.word	0x70018de8
70018ce8:	70018de8 	.word	0x70018de8
70018cec:	70018d7c 	.word	0x70018d7c
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
70018cf0:	e51b0010 	ldr	r0, [fp, #-16]
70018cf4:	ebffffaf 	bl	70018bb8 <proc_cast_expr>
70018cf8:	e50b000c 	str	r0, [fp, #-12]
		return cast;
70018cfc:	e51b300c 	ldr	r3, [fp, #-12]
70018d00:	ea00003e 	b	70018e00 <proc_unary_expr+0x17c>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
70018d04:	e51b0010 	ldr	r0, [fp, #-16]
70018d08:	ebffffaa 	bl	70018bb8 <proc_cast_expr>
70018d0c:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
70018d10:	e3a00015 	mov	r0, #21
70018d14:	e51b100c 	ldr	r1, [fp, #-12]
70018d18:	e3a02000 	mov	r2, #0
70018d1c:	eb00013b 	bl	70019210 <make_sys_node>
70018d20:	e1a03000 	mov	r3, r0
70018d24:	ea000035 	b	70018e00 <proc_unary_expr+0x17c>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
70018d28:	e51b0010 	ldr	r0, [fp, #-16]
70018d2c:	ebffffa1 	bl	70018bb8 <proc_cast_expr>
70018d30:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
70018d34:	e3a00000 	mov	r0, #0
70018d38:	ebfff4c6 	bl	70016058 <finsh_node_new_long>
70018d3c:	e1a03000 	mov	r3, r0
70018d40:	e3a00008 	mov	r0, #8
70018d44:	e1a01003 	mov	r1, r3
70018d48:	e51b200c 	ldr	r2, [fp, #-12]
70018d4c:	eb00012f 	bl	70019210 <make_sys_node>
70018d50:	e1a03000 	mov	r3, r0
70018d54:	ea000029 	b	70018e00 <proc_unary_expr+0x17c>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
70018d58:	e51b0010 	ldr	r0, [fp, #-16]
70018d5c:	ebffff95 	bl	70018bb8 <proc_cast_expr>
70018d60:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
70018d64:	e3a00016 	mov	r0, #22
70018d68:	e51b100c 	ldr	r1, [fp, #-12]
70018d6c:	e3a02000 	mov	r2, #0
70018d70:	eb000126 	bl	70019210 <make_sys_node>
70018d74:	e1a03000 	mov	r3, r0
70018d78:	ea000020 	b	70018e00 <proc_unary_expr+0x17c>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
70018d7c:	e51b0010 	ldr	r0, [fp, #-16]
70018d80:	ebffff8c 	bl	70018bb8 <proc_cast_expr>
70018d84:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
70018d88:	e3a0000f 	mov	r0, #15
70018d8c:	e51b100c 	ldr	r1, [fp, #-12]
70018d90:	e3a02000 	mov	r2, #0
70018d94:	eb00011d 	bl	70019210 <make_sys_node>
70018d98:	e1a03000 	mov	r3, r0
70018d9c:	ea000017 	b	70018e00 <proc_unary_expr+0x17c>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
70018da0:	e51b0010 	ldr	r0, [fp, #-16]
70018da4:	ebffff83 	bl	70018bb8 <proc_cast_expr>
70018da8:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
70018dac:	e3a00019 	mov	r0, #25
70018db0:	e51b100c 	ldr	r1, [fp, #-12]
70018db4:	e3a02000 	mov	r2, #0
70018db8:	eb000114 	bl	70019210 <make_sys_node>
70018dbc:	e1a03000 	mov	r3, r0
70018dc0:	ea00000e 	b	70018e00 <proc_unary_expr+0x17c>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
70018dc4:	e51b0010 	ldr	r0, [fp, #-16]
70018dc8:	ebffff7a 	bl	70018bb8 <proc_cast_expr>
70018dcc:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
70018dd0:	e3a0001a 	mov	r0, #26
70018dd4:	e51b100c 	ldr	r1, [fp, #-12]
70018dd8:	e3a02000 	mov	r2, #0
70018ddc:	eb00010b 	bl	70019210 <make_sys_node>
70018de0:	e1a03000 	mov	r3, r0
70018de4:	ea000005 	b	70018e00 <proc_unary_expr+0x17c>

	default:
		finsh_token_replay(&(self->token));
70018de8:	e51b3010 	ldr	r3, [fp, #-16]
70018dec:	e3a02001 	mov	r2, #1
70018df0:	e5c32005 	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
70018df4:	e51b0010 	ldr	r0, [fp, #-16]
70018df8:	eb000003 	bl	70018e0c <proc_postfix_expr>
70018dfc:	e1a03000 	mov	r3, r0
	}
}
70018e00:	e1a00003 	mov	r0, r3
70018e04:	e24bd004 	sub	sp, fp, #4
70018e08:	e8bd8800 	pop	{fp, pc}

70018e0c <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
70018e0c:	e92d4800 	push	{fp, lr}
70018e10:	e28db004 	add	fp, sp, #4
70018e14:	e24dd018 	sub	sp, sp, #24
70018e18:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
70018e1c:	e51b0018 	ldr	r0, [fp, #-24]
70018e20:	eb000056 	bl	70018f80 <proc_primary_expr>
70018e24:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
70018e28:	e51b3018 	ldr	r3, [fp, #-24]
70018e2c:	e2833004 	add	r3, r3, #4
70018e30:	e1a00003 	mov	r0, r3
70018e34:	eb000387 	bl	70019c58 <finsh_token_token>
70018e38:	e1a03000 	mov	r3, r0
70018e3c:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_inc 	||
70018e40:	ea00003e 	b	70018f40 <proc_postfix_expr+0x134>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
70018e44:	e55b3005 	ldrb	r3, [fp, #-5]
70018e48:	e3530007 	cmp	r3, #7
70018e4c:	0a000004 	beq	70018e64 <proc_postfix_expr+0x58>
70018e50:	e3530009 	cmp	r3, #9
70018e54:	0a000008 	beq	70018e7c <proc_postfix_expr+0x70>
70018e58:	e3530001 	cmp	r3, #1
70018e5c:	0a00000c 	beq	70018e94 <proc_postfix_expr+0x88>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
70018e60:	ea000030 	b	70018f28 <proc_postfix_expr+0x11c>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
70018e64:	e3a00017 	mov	r0, #23
70018e68:	e51b100c 	ldr	r1, [fp, #-12]
70018e6c:	e3a02000 	mov	r2, #0
70018e70:	eb0000e6 	bl	70019210 <make_sys_node>
70018e74:	e50b000c 	str	r0, [fp, #-12]
			break;
70018e78:	ea00002a 	b	70018f28 <proc_postfix_expr+0x11c>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
70018e7c:	e3a00018 	mov	r0, #24
70018e80:	e51b100c 	ldr	r1, [fp, #-12]
70018e84:	e3a02000 	mov	r2, #0
70018e88:	eb0000e0 	bl	70019210 <make_sys_node>
70018e8c:	e50b000c 	str	r0, [fp, #-12]
			break;
70018e90:	ea000024 	b	70018f28 <proc_postfix_expr+0x11c>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
70018e94:	e3a03000 	mov	r3, #0
70018e98:	e50b3010 	str	r3, [fp, #-16]
				next_token(token, &(self->token));
70018e9c:	e51b3018 	ldr	r3, [fp, #-24]
70018ea0:	e2833004 	add	r3, r3, #4
70018ea4:	e1a00003 	mov	r0, r3
70018ea8:	eb00036a 	bl	70019c58 <finsh_token_token>
70018eac:	e1a03000 	mov	r3, r0
70018eb0:	e54b3005 	strb	r3, [fp, #-5]
				if (token != finsh_token_type_right_paren)
70018eb4:	e55b3005 	ldrb	r3, [fp, #-5]
70018eb8:	e3530002 	cmp	r3, #2
70018ebc:	0a000013 	beq	70018f10 <proc_postfix_expr+0x104>
				{
					finsh_token_replay(&(self->token));
70018ec0:	e51b3018 	ldr	r3, [fp, #-24]
70018ec4:	e3a02001 	mov	r2, #1
70018ec8:	e5c32005 	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
70018ecc:	e51b0018 	ldr	r0, [fp, #-24]
70018ed0:	eb00009a 	bl	70019140 <proc_param_list>
70018ed4:	e50b0010 	str	r0, [fp, #-16]

					match_token(token, &(self->token), finsh_token_type_right_paren);
70018ed8:	e51b3018 	ldr	r3, [fp, #-24]
70018edc:	e2833004 	add	r3, r3, #4
70018ee0:	e1a00003 	mov	r0, r3
70018ee4:	eb00035b 	bl	70019c58 <finsh_token_token>
70018ee8:	e1a03000 	mov	r3, r0
70018eec:	e54b3005 	strb	r3, [fp, #-5]
70018ef0:	e55b3005 	ldrb	r3, [fp, #-5]
70018ef4:	e3530002 	cmp	r3, #2
70018ef8:	0a000004 	beq	70018f10 <proc_postfix_expr+0x104>
70018efc:	e3a00001 	mov	r0, #1
70018f00:	ebfff196 	bl	70015560 <finsh_error_set>
70018f04:	e51b3018 	ldr	r3, [fp, #-24]
70018f08:	e3a02001 	mov	r2, #1
70018f0c:	e5c32005 	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
70018f10:	e3a00012 	mov	r0, #18
70018f14:	e51b100c 	ldr	r1, [fp, #-12]
70018f18:	e51b2010 	ldr	r2, [fp, #-16]
70018f1c:	eb0000bb 	bl	70019210 <make_sys_node>
70018f20:	e50b000c 	str	r0, [fp, #-12]
			}
			break;
70018f24:	e1a00000 	nop			; (mov r0, r0)

		default:
			break;
		}

		next_token(token, &(self->token));
70018f28:	e51b3018 	ldr	r3, [fp, #-24]
70018f2c:	e2833004 	add	r3, r3, #4
70018f30:	e1a00003 	mov	r0, r3
70018f34:	eb000347 	bl	70019c58 <finsh_token_token>
70018f38:	e1a03000 	mov	r3, r0
70018f3c:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
70018f40:	e55b3005 	ldrb	r3, [fp, #-5]
70018f44:	e3530007 	cmp	r3, #7
70018f48:	0affffbd 	beq	70018e44 <proc_postfix_expr+0x38>
70018f4c:	e55b3005 	ldrb	r3, [fp, #-5]
70018f50:	e3530009 	cmp	r3, #9
70018f54:	0affffba 	beq	70018e44 <proc_postfix_expr+0x38>
		token == finsh_token_type_dec 		||
70018f58:	e55b3005 	ldrb	r3, [fp, #-5]
70018f5c:	e3530001 	cmp	r3, #1
70018f60:	0affffb7 	beq	70018e44 <proc_postfix_expr+0x38>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
70018f64:	e51b3018 	ldr	r3, [fp, #-24]
70018f68:	e3a02001 	mov	r2, #1
70018f6c:	e5c32005 	strb	r2, [r3, #5]
	return postfix;
70018f70:	e51b300c 	ldr	r3, [fp, #-12]
}
70018f74:	e1a00003 	mov	r0, r3
70018f78:	e24bd004 	sub	sp, fp, #4
70018f7c:	e8bd8800 	pop	{fp, pc}

70018f80 <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
70018f80:	e92d4800 	push	{fp, lr}
70018f84:	e28db004 	add	fp, sp, #4
70018f88:	e24dd028 	sub	sp, sp, #40	; 0x28
70018f8c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
70018f90:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70018f94:	e2833004 	add	r3, r3, #4
70018f98:	e1a00003 	mov	r0, r3
70018f9c:	eb00032d 	bl	70019c58 <finsh_token_token>
70018fa0:	e1a03000 	mov	r3, r0
70018fa4:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
70018fa8:	e55b3005 	ldrb	r3, [fp, #-5]
70018fac:	e2433001 	sub	r3, r3, #1
70018fb0:	e353001e 	cmp	r3, #30
70018fb4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70018fb8:	ea000059 	b	70019124 <proc_primary_expr+0x1a4>
70018fbc:	70019068 	.word	0x70019068
70018fc0:	70019124 	.word	0x70019124
70018fc4:	70019124 	.word	0x70019124
70018fc8:	70019124 	.word	0x70019124
70018fcc:	70019124 	.word	0x70019124
70018fd0:	70019124 	.word	0x70019124
70018fd4:	70019124 	.word	0x70019124
70018fd8:	70019124 	.word	0x70019124
70018fdc:	70019124 	.word	0x70019124
70018fe0:	70019124 	.word	0x70019124
70018fe4:	70019124 	.word	0x70019124
70018fe8:	70019124 	.word	0x70019124
70018fec:	70019124 	.word	0x70019124
70018ff0:	70019124 	.word	0x70019124
70018ff4:	70019124 	.word	0x70019124
70018ff8:	70019124 	.word	0x70019124
70018ffc:	70019124 	.word	0x70019124
70019000:	70019124 	.word	0x70019124
70019004:	70019124 	.word	0x70019124
70019008:	70019124 	.word	0x70019124
7001900c:	70019124 	.word	0x70019124
70019010:	70019124 	.word	0x70019124
70019014:	70019124 	.word	0x70019124
70019018:	70019124 	.word	0x70019124
7001901c:	70019124 	.word	0x70019124
70019020:	700190e4 	.word	0x700190e4
70019024:	700190b4 	.word	0x700190b4
70019028:	700190cc 	.word	0x700190cc
7001902c:	700190fc 	.word	0x700190fc
70019030:	70019114 	.word	0x70019114
70019034:	70019038 	.word	0x70019038
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
70019038:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001903c:	e3a02001 	mov	r2, #1
70019040:	e5c32005 	strb	r2, [r3, #5]
			proc_identifier(self, id);
70019044:	e24b3020 	sub	r3, fp, #32
70019048:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
7001904c:	e1a01003 	mov	r1, r3
70019050:	ebfffd20 	bl	700184d8 <proc_identifier>
			return finsh_node_new_id(id);
70019054:	e24b3020 	sub	r3, fp, #32
70019058:	e1a00003 	mov	r0, r3
7001905c:	ebfff384 	bl	70015e74 <finsh_node_new_id>
70019060:	e1a03000 	mov	r3, r0
70019064:	ea000032 	b	70019134 <proc_primary_expr+0x1b4>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
70019068:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
7001906c:	ebfffd5d 	bl	700185e8 <proc_expr>
70019070:	e50b000c 	str	r0, [fp, #-12]
		match_token(token, &(self->token), finsh_token_type_right_paren);
70019074:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70019078:	e2833004 	add	r3, r3, #4
7001907c:	e1a00003 	mov	r0, r3
70019080:	eb0002f4 	bl	70019c58 <finsh_token_token>
70019084:	e1a03000 	mov	r3, r0
70019088:	e54b3005 	strb	r3, [fp, #-5]
7001908c:	e55b3005 	ldrb	r3, [fp, #-5]
70019090:	e3530002 	cmp	r3, #2
70019094:	0a000004 	beq	700190ac <proc_primary_expr+0x12c>
70019098:	e3a00001 	mov	r0, #1
7001909c:	ebfff12f 	bl	70015560 <finsh_error_set>
700190a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700190a4:	e3a02001 	mov	r2, #1
700190a8:	e5c32005 	strb	r2, [r3, #5]
		return expr;
700190ac:	e51b300c 	ldr	r3, [fp, #-12]
700190b0:	ea00001f 	b	70019134 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
700190b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700190b8:	e5933010 	ldr	r3, [r3, #16]
700190bc:	e1a00003 	mov	r0, r3
700190c0:	ebfff3cf 	bl	70016004 <finsh_node_new_int>
700190c4:	e1a03000 	mov	r3, r0
700190c8:	ea000019 	b	70019134 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
700190cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700190d0:	e5933010 	ldr	r3, [r3, #16]
700190d4:	e1a00003 	mov	r0, r3
700190d8:	ebfff3de 	bl	70016058 <finsh_node_new_long>
700190dc:	e1a03000 	mov	r3, r0
700190e0:	ea000013 	b	70019134 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
700190e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700190e8:	e5d33010 	ldrb	r3, [r3, #16]
700190ec:	e1a00003 	mov	r0, r3
700190f0:	ebfff3ad 	bl	70015fac <finsh_node_new_char>
700190f4:	e1a03000 	mov	r3, r0
700190f8:	ea00000d 	b	70019134 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
700190fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70019100:	e2833014 	add	r3, r3, #20
70019104:	e1a00003 	mov	r0, r3
70019108:	ebfff3e7 	bl	700160ac <finsh_node_new_string>
7001910c:	e1a03000 	mov	r3, r0
70019110:	ea000007 	b	70019134 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
70019114:	e3a00000 	mov	r0, #0
70019118:	ebfff40f 	bl	7001615c <finsh_node_new_ptr>
7001911c:	e1a03000 	mov	r3, r0
70019120:	ea000003 	b	70019134 <proc_primary_expr+0x1b4>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
70019124:	e3a00001 	mov	r0, #1
70019128:	ebfff10c 	bl	70015560 <finsh_error_set>
		break;
7001912c:	e1a00000 	nop			; (mov r0, r0)
	}

	return NULL;
70019130:	e3a03000 	mov	r3, #0
}
70019134:	e1a00003 	mov	r0, r3
70019138:	e24bd004 	sub	sp, fp, #4
7001913c:	e8bd8800 	pop	{fp, pc}

70019140 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
70019140:	e92d4800 	push	{fp, lr}
70019144:	e28db004 	add	fp, sp, #4
70019148:	e24dd018 	sub	sp, sp, #24
7001914c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
70019150:	e51b0018 	ldr	r0, [fp, #-24]
70019154:	ebfffd2d 	bl	70018610 <proc_assign_expr>
70019158:	e50b000c 	str	r0, [fp, #-12]
	if (assign == NULL) return NULL;
7001915c:	e51b300c 	ldr	r3, [fp, #-12]
70019160:	e3530000 	cmp	r3, #0
70019164:	1a000001 	bne	70019170 <proc_param_list+0x30>
70019168:	e3a03000 	mov	r3, #0
7001916c:	ea000024 	b	70019204 <proc_param_list+0xc4>
	node = assign;
70019170:	e51b300c 	ldr	r3, [fp, #-12]
70019174:	e50b3010 	str	r3, [fp, #-16]

	next_token(token, &(self->token));
70019178:	e51b3018 	ldr	r3, [fp, #-24]
7001917c:	e2833004 	add	r3, r3, #4
70019180:	e1a00003 	mov	r0, r3
70019184:	eb0002b3 	bl	70019c58 <finsh_token_token>
70019188:	e1a03000 	mov	r3, r0
7001918c:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_comma )
70019190:	ea000014 	b	700191e8 <proc_param_list+0xa8>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
70019194:	e51b0018 	ldr	r0, [fp, #-24]
70019198:	ebfffd1c 	bl	70018610 <proc_assign_expr>
7001919c:	e1a02000 	mov	r2, r0
700191a0:	e51b300c 	ldr	r3, [fp, #-12]
700191a4:	e583200c 	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
700191a8:	e51b300c 	ldr	r3, [fp, #-12]
700191ac:	e593300c 	ldr	r3, [r3, #12]
700191b0:	e3530000 	cmp	r3, #0
700191b4:	0a000003 	beq	700191c8 <proc_param_list+0x88>
700191b8:	e51b300c 	ldr	r3, [fp, #-12]
700191bc:	e593300c 	ldr	r3, [r3, #12]
700191c0:	e50b300c 	str	r3, [fp, #-12]
700191c4:	ea000001 	b	700191d0 <proc_param_list+0x90>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
700191c8:	e3a00005 	mov	r0, #5
700191cc:	ebfff0e3 	bl	70015560 <finsh_error_set>

		next_token(token, &(self->token));
700191d0:	e51b3018 	ldr	r3, [fp, #-24]
700191d4:	e2833004 	add	r3, r3, #4
700191d8:	e1a00003 	mov	r0, r3
700191dc:	eb00029d 	bl	70019c58 <finsh_token_token>
700191e0:	e1a03000 	mov	r3, r0
700191e4:	e54b3005 	strb	r3, [fp, #-5]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
700191e8:	e55b3005 	ldrb	r3, [fp, #-5]
700191ec:	e3530003 	cmp	r3, #3
700191f0:	0affffe7 	beq	70019194 <proc_param_list+0x54>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
700191f4:	e51b3018 	ldr	r3, [fp, #-24]
700191f8:	e3a02001 	mov	r2, #1
700191fc:	e5c32005 	strb	r2, [r3, #5]

	return node;
70019200:	e51b3010 	ldr	r3, [fp, #-16]
}
70019204:	e1a00003 	mov	r0, r3
70019208:	e24bd004 	sub	sp, fp, #4
7001920c:	e8bd8800 	pop	{fp, pc}

70019210 <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
70019210:	e92d4800 	push	{fp, lr}
70019214:	e28db004 	add	fp, sp, #4
70019218:	e24dd018 	sub	sp, sp, #24
7001921c:	e1a03000 	mov	r3, r0
70019220:	e50b1014 	str	r1, [fp, #-20]
70019224:	e50b2018 	str	r2, [fp, #-24]
70019228:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
7001922c:	e55b300d 	ldrb	r3, [fp, #-13]
70019230:	e1a00003 	mov	r0, r3
70019234:	ebfff2d9 	bl	70015da0 <finsh_node_allocate>
70019238:	e50b0008 	str	r0, [fp, #-8]

	if ((node1 != NULL) && (node != NULL))
7001923c:	e51b3014 	ldr	r3, [fp, #-20]
70019240:	e3530000 	cmp	r3, #0
70019244:	0a000009 	beq	70019270 <make_sys_node+0x60>
70019248:	e51b3008 	ldr	r3, [fp, #-8]
7001924c:	e3530000 	cmp	r3, #0
70019250:	0a000006 	beq	70019270 <make_sys_node+0x60>
	{
		finsh_node_child(node) = node1;
70019254:	e51b3008 	ldr	r3, [fp, #-8]
70019258:	e51b2014 	ldr	r2, [fp, #-20]
7001925c:	e5832010 	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
70019260:	e51b3014 	ldr	r3, [fp, #-20]
70019264:	e51b2018 	ldr	r2, [fp, #-24]
70019268:	e583200c 	str	r2, [r3, #12]
7001926c:	ea000001 	b	70019278 <make_sys_node+0x68>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
70019270:	e3a0000e 	mov	r0, #14
70019274:	ebfff0b9 	bl	70015560 <finsh_error_set>

	return node;
70019278:	e51b3008 	ldr	r3, [fp, #-8]
}
7001927c:	e1a00003 	mov	r0, r3
70019280:	e24bd004 	sub	sp, fp, #4
70019284:	e8bd8800 	pop	{fp, pc}

70019288 <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
70019288:	e92d4800 	push	{fp, lr}
7001928c:	e28db004 	add	fp, sp, #4
70019290:	e24dd010 	sub	sp, sp, #16
70019294:	e50b0010 	str	r0, [fp, #-16]
70019298:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
7001929c:	e3a03000 	mov	r3, #0
700192a0:	e50b300c 	str	r3, [fp, #-12]

	/* init parser */
	self->parser_string = (u_char*)string;
700192a4:	e51b3010 	ldr	r3, [fp, #-16]
700192a8:	e51b2014 	ldr	r2, [fp, #-20]
700192ac:	e5832000 	str	r2, [r3]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
700192b0:	e51b3010 	ldr	r3, [fp, #-16]
700192b4:	e2832004 	add	r2, r3, #4
700192b8:	e51b3010 	ldr	r3, [fp, #-16]
700192bc:	e5933000 	ldr	r3, [r3]
700192c0:	e1a00002 	mov	r0, r2
700192c4:	e1a01003 	mov	r1, r3
700192c8:	eb000254 	bl	70019c20 <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
700192cc:	e51b3010 	ldr	r3, [fp, #-16]
700192d0:	e2833004 	add	r3, r3, #4
700192d4:	e1a00003 	mov	r0, r3
700192d8:	eb00025e 	bl	70019c58 <finsh_token_token>
700192dc:	e1a03000 	mov	r3, r0
700192e0:	e54b3005 	strb	r3, [fp, #-5]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
700192e4:	ea00007a 	b	700194d4 <finsh_parser_run+0x24c>
	{
		switch (token)
700192e8:	e55b3005 	ldrb	r3, [fp, #-5]
700192ec:	e353001f 	cmp	r3, #31
700192f0:	1a00001b 	bne	70019364 <finsh_parser_run+0xdc>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
700192f4:	e51b3010 	ldr	r3, [fp, #-16]
700192f8:	e3a02001 	mov	r2, #1
700192fc:	e5c32005 	strb	r2, [r3, #5]

			if (self->root != NULL)
70019300:	e51b3010 	ldr	r3, [fp, #-16]
70019304:	e5933098 	ldr	r3, [r3, #152]	; 0x98
70019308:	e3530000 	cmp	r3, #0
7001930c:	0a00000c 	beq	70019344 <finsh_parser_run+0xbc>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
70019310:	e51b0010 	ldr	r0, [fp, #-16]
70019314:	ebfffc8c 	bl	7001854c <proc_expr_statement>
70019318:	e1a02000 	mov	r2, r0
7001931c:	e51b300c 	ldr	r3, [fp, #-12]
70019320:	e583200c 	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
70019324:	e51b300c 	ldr	r3, [fp, #-12]
70019328:	e593300c 	ldr	r3, [r3, #12]
7001932c:	e3530000 	cmp	r3, #0
70019330:	0a00000a 	beq	70019360 <finsh_parser_run+0xd8>
					node = finsh_node_sibling(node);
70019334:	e51b300c 	ldr	r3, [fp, #-12]
70019338:	e593300c 	ldr	r3, [r3, #12]
7001933c:	e50b300c 	str	r3, [fp, #-12]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
70019340:	ea000058 	b	700194a8 <finsh_parser_run+0x220>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
70019344:	e51b0010 	ldr	r0, [fp, #-16]
70019348:	ebfffc7f 	bl	7001854c <proc_expr_statement>
7001934c:	e50b000c 	str	r0, [fp, #-12]
				self->root = node;
70019350:	e51b3010 	ldr	r3, [fp, #-16]
70019354:	e51b200c 	ldr	r2, [fp, #-12]
70019358:	e5832098 	str	r2, [r3, #152]	; 0x98
			}
            break;
7001935c:	ea000051 	b	700194a8 <finsh_parser_run+0x220>
70019360:	ea000050 	b	700194a8 <finsh_parser_run+0x220>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
70019364:	e55b3005 	ldrb	r3, [fp, #-5]
70019368:	e3530014 	cmp	r3, #20
7001936c:	0a00000e 	beq	700193ac <finsh_parser_run+0x124>
70019370:	e55b3005 	ldrb	r3, [fp, #-5]
70019374:	e3530015 	cmp	r3, #21
70019378:	0a00000b 	beq	700193ac <finsh_parser_run+0x124>
7001937c:	e55b3005 	ldrb	r3, [fp, #-5]
70019380:	e3530016 	cmp	r3, #22
70019384:	0a000008 	beq	700193ac <finsh_parser_run+0x124>
70019388:	e55b3005 	ldrb	r3, [fp, #-5]
7001938c:	e3530017 	cmp	r3, #23
70019390:	0a000005 	beq	700193ac <finsh_parser_run+0x124>
70019394:	e55b3005 	ldrb	r3, [fp, #-5]
70019398:	e3530018 	cmp	r3, #24
7001939c:	0a000002 	beq	700193ac <finsh_parser_run+0x124>
700193a0:	e55b3005 	ldrb	r3, [fp, #-5]
700193a4:	e3530019 	cmp	r3, #25
700193a8:	1a00001b 	bne	7001941c <finsh_parser_run+0x194>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
700193ac:	e51b3010 	ldr	r3, [fp, #-16]
700193b0:	e3a02001 	mov	r2, #1
700193b4:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
700193b8:	e51b3010 	ldr	r3, [fp, #-16]
700193bc:	e5933098 	ldr	r3, [r3, #152]	; 0x98
700193c0:	e3530000 	cmp	r3, #0
700193c4:	0a00000c 	beq	700193fc <finsh_parser_run+0x174>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
700193c8:	e51b0010 	ldr	r0, [fp, #-16]
700193cc:	ebfffa81 	bl	70017dd8 <proc_variable_decl>
700193d0:	e1a02000 	mov	r2, r0
700193d4:	e51b300c 	ldr	r3, [fp, #-12]
700193d8:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
700193dc:	e51b300c 	ldr	r3, [fp, #-12]
700193e0:	e593300c 	ldr	r3, [r3, #12]
700193e4:	e3530000 	cmp	r3, #0
700193e8:	0a00000a 	beq	70019418 <finsh_parser_run+0x190>
						node = finsh_node_sibling(node);
700193ec:	e51b300c 	ldr	r3, [fp, #-12]
700193f0:	e593300c 	ldr	r3, [r3, #12]
700193f4:	e50b300c 	str	r3, [fp, #-12]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
700193f8:	ea000029 	b	700194a4 <finsh_parser_run+0x21c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
700193fc:	e51b0010 	ldr	r0, [fp, #-16]
70019400:	ebfffa74 	bl	70017dd8 <proc_variable_decl>
70019404:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
70019408:	e51b3010 	ldr	r3, [fp, #-16]
7001940c:	e51b200c 	ldr	r2, [fp, #-12]
70019410:	e5832098 	str	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
70019414:	ea000022 	b	700194a4 <finsh_parser_run+0x21c>
70019418:	ea000021 	b	700194a4 <finsh_parser_run+0x21c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
7001941c:	e51b3010 	ldr	r3, [fp, #-16]
70019420:	e3a02001 	mov	r2, #1
70019424:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
70019428:	e51b3010 	ldr	r3, [fp, #-16]
7001942c:	e5933098 	ldr	r3, [r3, #152]	; 0x98
70019430:	e3530000 	cmp	r3, #0
70019434:	0a000013 	beq	70019488 <finsh_parser_run+0x200>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
70019438:	e51b0010 	ldr	r0, [fp, #-16]
7001943c:	ebfffc42 	bl	7001854c <proc_expr_statement>
70019440:	e1a02000 	mov	r2, r0
70019444:	e51b300c 	ldr	r3, [fp, #-12]
70019448:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
7001944c:	e51b300c 	ldr	r3, [fp, #-12]
70019450:	e593300c 	ldr	r3, [r3, #12]
70019454:	e3530000 	cmp	r3, #0
70019458:	0a000003 	beq	7001946c <finsh_parser_run+0x1e4>
						node = finsh_node_sibling(node);
7001945c:	e51b300c 	ldr	r3, [fp, #-12]
70019460:	e593300c 	ldr	r3, [r3, #12]
70019464:	e50b300c 	str	r3, [fp, #-12]
70019468:	ea00000d 	b	700194a4 <finsh_parser_run+0x21c>
					else next_token(token, &(self->token));
7001946c:	e51b3010 	ldr	r3, [fp, #-16]
70019470:	e2833004 	add	r3, r3, #4
70019474:	e1a00003 	mov	r0, r3
70019478:	eb0001f6 	bl	70019c58 <finsh_token_token>
7001947c:	e1a03000 	mov	r3, r0
70019480:	e54b3005 	strb	r3, [fp, #-5]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
70019484:	ea000006 	b	700194a4 <finsh_parser_run+0x21c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
70019488:	e51b0010 	ldr	r0, [fp, #-16]
7001948c:	ebfffc2e 	bl	7001854c <proc_expr_statement>
70019490:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
70019494:	e51b3010 	ldr	r3, [fp, #-16]
70019498:	e51b200c 	ldr	r2, [fp, #-12]
7001949c:	e5832098 	str	r2, [r3, #152]	; 0x98
				}
            }

			break;
700194a0:	eaffffff 	b	700194a4 <finsh_parser_run+0x21c>
700194a4:	e1a00000 	nop			; (mov r0, r0)
		}

		/* no root found, break out */
		if (self->root == NULL) break;
700194a8:	e51b3010 	ldr	r3, [fp, #-16]
700194ac:	e5933098 	ldr	r3, [r3, #152]	; 0x98
700194b0:	e3530000 	cmp	r3, #0
700194b4:	1a000000 	bne	700194bc <finsh_parser_run+0x234>
700194b8:	ea00000b 	b	700194ec <finsh_parser_run+0x264>

        /* get next token */
		next_token(token, &(self->token));
700194bc:	e51b3010 	ldr	r3, [fp, #-16]
700194c0:	e2833004 	add	r3, r3, #4
700194c4:	e1a00003 	mov	r0, r3
700194c8:	eb0001e2 	bl	70019c58 <finsh_token_token>
700194cc:	e1a03000 	mov	r3, r0
700194d0:	e54b3005 	strb	r3, [fp, #-5]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
700194d4:	e55b3005 	ldrb	r3, [fp, #-5]
700194d8:	e3530021 	cmp	r3, #33	; 0x21
700194dc:	0a000002 	beq	700194ec <finsh_parser_run+0x264>
700194e0:	e55b3005 	ldrb	r3, [fp, #-5]
700194e4:	e3530020 	cmp	r3, #32
700194e8:	1affff7e 	bne	700192e8 <finsh_parser_run+0x60>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
700194ec:	e24bd004 	sub	sp, fp, #4
700194f0:	e8bd8800 	pop	{fp, pc}

700194f4 <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
700194f4:	e92d4800 	push	{fp, lr}
700194f8:	e28db004 	add	fp, sp, #4
700194fc:	e24dd008 	sub	sp, sp, #8
70019500:	e50b0008 	str	r0, [fp, #-8]
	memset(self, 0, sizeof(struct finsh_parser));
70019504:	e51b0008 	ldr	r0, [fp, #-8]
70019508:	e3a01000 	mov	r1, #0
7001950c:	e3a0209c 	mov	r2, #156	; 0x9c
70019510:	fa002a8e 	blx	70023f50 <memset>

	return 0;
70019514:	e3a03000 	mov	r3, #0
}
70019518:	e1a00003 	mov	r0, r3
7001951c:	e24bd004 	sub	sp, fp, #4
70019520:	e8bd8800 	pop	{fp, pc}

70019524 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
70019524:	e92d4800 	push	{fp, lr}
70019528:	e28db004 	add	fp, sp, #4
	memset(global_variable, 0, sizeof(global_variable));
7001952c:	e30b05ec 	movw	r0, #46572	; 0xb5ec
70019530:	e3470002 	movt	r0, #28674	; 0x7002
70019534:	e3a01000 	mov	r1, #0
70019538:	e3a020c0 	mov	r2, #192	; 0xc0
7001953c:	fa002a83 	blx	70023f50 <memset>

	return 0;
70019540:	e3a03000 	mov	r3, #0
}
70019544:	e1a00003 	mov	r0, r3
70019548:	e8bd8800 	pop	{fp, pc}

7001954c <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
7001954c:	e92d4800 	push	{fp, lr}
70019550:	e28db004 	add	fp, sp, #4
70019554:	e24dd010 	sub	sp, sp, #16
70019558:	e50b0010 	str	r0, [fp, #-16]
7001955c:	e50b1014 	str	r1, [fp, #-20]
	int i, empty;

	empty = -1;
70019560:	e3e03000 	mvn	r3, #0
70019564:	e50b300c 	str	r3, [fp, #-12]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
70019568:	e3a03000 	mov	r3, #0
7001956c:	e50b3008 	str	r3, [fp, #-8]
70019570:	ea000025 	b	7001960c <finsh_var_insert+0xc0>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
70019574:	e51b2008 	ldr	r2, [fp, #-8]
70019578:	e1a03002 	mov	r3, r2
7001957c:	e1a03083 	lsl	r3, r3, #1
70019580:	e0833002 	add	r3, r3, r2
70019584:	e1a03183 	lsl	r3, r3, #3
70019588:	e30b25ec 	movw	r2, #46572	; 0xb5ec
7001958c:	e3472002 	movt	r2, #28674	; 0x7002
70019590:	e0833002 	add	r3, r3, r2
70019594:	e1a00003 	mov	r0, r3
70019598:	e51b1010 	ldr	r1, [fp, #-16]
7001959c:	e3a02010 	mov	r2, #16
700195a0:	fa002b7b 	blx	70024394 <strncmp>
700195a4:	e1a03000 	mov	r3, r0
700195a8:	e3530000 	cmp	r3, #0
700195ac:	1a000001 	bne	700195b8 <finsh_var_insert+0x6c>
			return -1;
700195b0:	e3e03000 	mvn	r3, #0
700195b4:	ea000037 	b	70019698 <finsh_var_insert+0x14c>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
700195b8:	e30b25ec 	movw	r2, #46572	; 0xb5ec
700195bc:	e3472002 	movt	r2, #28674	; 0x7002
700195c0:	e51b1008 	ldr	r1, [fp, #-8]
700195c4:	e3a00010 	mov	r0, #16
700195c8:	e1a03001 	mov	r3, r1
700195cc:	e1a03083 	lsl	r3, r3, #1
700195d0:	e0833001 	add	r3, r3, r1
700195d4:	e1a03183 	lsl	r3, r3, #3
700195d8:	e0823003 	add	r3, r2, r3
700195dc:	e0833000 	add	r3, r3, r0
700195e0:	e5d33001 	ldrb	r3, [r3, #1]
700195e4:	e3530000 	cmp	r3, #0
700195e8:	1a000004 	bne	70019600 <finsh_var_insert+0xb4>
700195ec:	e51b300c 	ldr	r3, [fp, #-12]
700195f0:	e3730001 	cmn	r3, #1
700195f4:	1a000001 	bne	70019600 <finsh_var_insert+0xb4>
		{
			empty = i;
700195f8:	e51b3008 	ldr	r3, [fp, #-8]
700195fc:	e50b300c 	str	r3, [fp, #-12]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
70019600:	e51b3008 	ldr	r3, [fp, #-8]
70019604:	e2833001 	add	r3, r3, #1
70019608:	e50b3008 	str	r3, [fp, #-8]
7001960c:	e51b3008 	ldr	r3, [fp, #-8]
70019610:	e3530007 	cmp	r3, #7
70019614:	daffffd6 	ble	70019574 <finsh_var_insert+0x28>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
70019618:	e51b300c 	ldr	r3, [fp, #-12]
7001961c:	e3730001 	cmn	r3, #1
70019620:	1a000001 	bne	7001962c <finsh_var_insert+0xe0>
70019624:	e3e03000 	mvn	r3, #0
70019628:	ea00001a 	b	70019698 <finsh_var_insert+0x14c>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
7001962c:	e51b200c 	ldr	r2, [fp, #-12]
70019630:	e1a03002 	mov	r3, r2
70019634:	e1a03083 	lsl	r3, r3, #1
70019638:	e0833002 	add	r3, r3, r2
7001963c:	e1a03183 	lsl	r3, r3, #3
70019640:	e30b25ec 	movw	r2, #46572	; 0xb5ec
70019644:	e3472002 	movt	r2, #28674	; 0x7002
70019648:	e0833002 	add	r3, r3, r2
7001964c:	e1a00003 	mov	r0, r3
70019650:	e51b1010 	ldr	r1, [fp, #-16]
70019654:	e3a02010 	mov	r2, #16
70019658:	fa002b7b 	blx	7002444c <strncpy>
	global_variable[empty].type = type;
7001965c:	e51b3014 	ldr	r3, [fp, #-20]
70019660:	e6ef0073 	uxtb	r0, r3
70019664:	e30b25ec 	movw	r2, #46572	; 0xb5ec
70019668:	e3472002 	movt	r2, #28674	; 0x7002
7001966c:	e51b100c 	ldr	r1, [fp, #-12]
70019670:	e3a0c010 	mov	ip, #16
70019674:	e1a03001 	mov	r3, r1
70019678:	e1a03083 	lsl	r3, r3, #1
7001967c:	e0833001 	add	r3, r3, r1
70019680:	e1a03183 	lsl	r3, r3, #3
70019684:	e0823003 	add	r3, r2, r3
70019688:	e083300c 	add	r3, r3, ip
7001968c:	e1a02000 	mov	r2, r0
70019690:	e5c32001 	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
70019694:	e51b300c 	ldr	r3, [fp, #-12]
}
70019698:	e1a00003 	mov	r0, r3
7001969c:	e24bd004 	sub	sp, fp, #4
700196a0:	e8bd8800 	pop	{fp, pc}

700196a4 <finsh_var_delete>:

int finsh_var_delete(const char* name)
{
700196a4:	e92d4800 	push	{fp, lr}
700196a8:	e28db004 	add	fp, sp, #4
700196ac:	e24dd010 	sub	sp, sp, #16
700196b0:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
700196b4:	e3a03000 	mov	r3, #0
700196b8:	e50b3008 	str	r3, [fp, #-8]
700196bc:	ea000012 	b	7001970c <finsh_var_delete+0x68>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
700196c0:	e51b2008 	ldr	r2, [fp, #-8]
700196c4:	e1a03002 	mov	r3, r2
700196c8:	e1a03083 	lsl	r3, r3, #1
700196cc:	e0833002 	add	r3, r3, r2
700196d0:	e1a03183 	lsl	r3, r3, #3
700196d4:	e30b25ec 	movw	r2, #46572	; 0xb5ec
700196d8:	e3472002 	movt	r2, #28674	; 0x7002
700196dc:	e0833002 	add	r3, r3, r2
700196e0:	e1a00003 	mov	r0, r3
700196e4:	e51b1010 	ldr	r1, [fp, #-16]
700196e8:	e3a02010 	mov	r2, #16
700196ec:	fa002b28 	blx	70024394 <strncmp>
700196f0:	e1a03000 	mov	r3, r0
700196f4:	e3530000 	cmp	r3, #0
700196f8:	1a000000 	bne	70019700 <finsh_var_delete+0x5c>
			break;
700196fc:	ea000005 	b	70019718 <finsh_var_delete+0x74>

int finsh_var_delete(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
70019700:	e51b3008 	ldr	r3, [fp, #-8]
70019704:	e2833001 	add	r3, r3, #1
70019708:	e50b3008 	str	r3, [fp, #-8]
7001970c:	e51b3008 	ldr	r3, [fp, #-8]
70019710:	e3530007 	cmp	r3, #7
70019714:	daffffe9 	ble	700196c0 <finsh_var_delete+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return -1;
70019718:	e51b3008 	ldr	r3, [fp, #-8]
7001971c:	e3530008 	cmp	r3, #8
70019720:	1a000001 	bne	7001972c <finsh_var_delete+0x88>
70019724:	e3e03000 	mvn	r3, #0
70019728:	ea00000c 	b	70019760 <finsh_var_delete+0xbc>

	memset(&global_variable[i], 0, sizeof(struct finsh_var));
7001972c:	e51b2008 	ldr	r2, [fp, #-8]
70019730:	e1a03002 	mov	r3, r2
70019734:	e1a03083 	lsl	r3, r3, #1
70019738:	e0833002 	add	r3, r3, r2
7001973c:	e1a03183 	lsl	r3, r3, #3
70019740:	e30b25ec 	movw	r2, #46572	; 0xb5ec
70019744:	e3472002 	movt	r2, #28674	; 0x7002
70019748:	e0833002 	add	r3, r3, r2
7001974c:	e1a00003 	mov	r0, r3
70019750:	e3a01000 	mov	r1, #0
70019754:	e3a02018 	mov	r2, #24
70019758:	fa0029fc 	blx	70023f50 <memset>

	return 0;
7001975c:	e3a03000 	mov	r3, #0
}
70019760:	e1a00003 	mov	r0, r3
70019764:	e24bd004 	sub	sp, fp, #4
70019768:	e8bd8800 	pop	{fp, pc}

7001976c <finsh_var_lookup>:

struct finsh_var* finsh_var_lookup(const char* name)
{
7001976c:	e92d4800 	push	{fp, lr}
70019770:	e28db004 	add	fp, sp, #4
70019774:	e24dd010 	sub	sp, sp, #16
70019778:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
7001977c:	e3a03000 	mov	r3, #0
70019780:	e50b3008 	str	r3, [fp, #-8]
70019784:	ea000012 	b	700197d4 <finsh_var_lookup+0x68>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
70019788:	e51b2008 	ldr	r2, [fp, #-8]
7001978c:	e1a03002 	mov	r3, r2
70019790:	e1a03083 	lsl	r3, r3, #1
70019794:	e0833002 	add	r3, r3, r2
70019798:	e1a03183 	lsl	r3, r3, #3
7001979c:	e30b25ec 	movw	r2, #46572	; 0xb5ec
700197a0:	e3472002 	movt	r2, #28674	; 0x7002
700197a4:	e0833002 	add	r3, r3, r2
700197a8:	e1a00003 	mov	r0, r3
700197ac:	e51b1010 	ldr	r1, [fp, #-16]
700197b0:	e3a02010 	mov	r2, #16
700197b4:	fa002af6 	blx	70024394 <strncmp>
700197b8:	e1a03000 	mov	r3, r0
700197bc:	e3530000 	cmp	r3, #0
700197c0:	1a000000 	bne	700197c8 <finsh_var_lookup+0x5c>
			break;
700197c4:	ea000005 	b	700197e0 <finsh_var_lookup+0x74>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
700197c8:	e51b3008 	ldr	r3, [fp, #-8]
700197cc:	e2833001 	add	r3, r3, #1
700197d0:	e50b3008 	str	r3, [fp, #-8]
700197d4:	e51b3008 	ldr	r3, [fp, #-8]
700197d8:	e3530007 	cmp	r3, #7
700197dc:	daffffe9 	ble	70019788 <finsh_var_lookup+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
700197e0:	e51b3008 	ldr	r3, [fp, #-8]
700197e4:	e3530008 	cmp	r3, #8
700197e8:	1a000001 	bne	700197f4 <finsh_var_lookup+0x88>
700197ec:	e3a03000 	mov	r3, #0
700197f0:	ea000007 	b	70019814 <finsh_var_lookup+0xa8>

	return &global_variable[i];
700197f4:	e51b2008 	ldr	r2, [fp, #-8]
700197f8:	e1a03002 	mov	r3, r2
700197fc:	e1a03083 	lsl	r3, r3, #1
70019800:	e0833002 	add	r3, r3, r2
70019804:	e1a03183 	lsl	r3, r3, #3
70019808:	e30b25ec 	movw	r2, #46572	; 0xb5ec
7001980c:	e3472002 	movt	r2, #28674	; 0x7002
70019810:	e0833002 	add	r3, r3, r2
}
70019814:	e1a00003 	mov	r0, r3
70019818:	e24bd004 	sub	sp, fp, #4
7001981c:	e8bd8800 	pop	{fp, pc}

70019820 <finsh_sysvar_append>:

#ifdef RT_USING_HEAP
void finsh_sysvar_append(const char* name, u_char type, void* var_addr)
{
70019820:	e92d4800 	push	{fp, lr}
70019824:	e28db004 	add	fp, sp, #4
70019828:	e24dd018 	sub	sp, sp, #24
7001982c:	e50b0010 	str	r0, [fp, #-16]
70019830:	e1a03001 	mov	r3, r1
70019834:	e50b2018 	str	r2, [fp, #-24]
70019838:	e54b3011 	strb	r3, [fp, #-17]
	/* create a sysvar */
	struct finsh_sysvar_item* item;

	item = (struct finsh_sysvar_item*) rt_malloc (sizeof(struct finsh_sysvar_item));
7001983c:	e3a00014 	mov	r0, #20
70019840:	ebffba1d 	bl	700080bc <rt_malloc>
70019844:	e50b0008 	str	r0, [fp, #-8]
	if (item != NULL)
70019848:	e51b3008 	ldr	r3, [fp, #-8]
7001984c:	e3530000 	cmp	r3, #0
70019850:	0a000020 	beq	700198d8 <finsh_sysvar_append+0xb8>
	{
		item->next = NULL;
70019854:	e51b3008 	ldr	r3, [fp, #-8]
70019858:	e3a02000 	mov	r2, #0
7001985c:	e5832000 	str	r2, [r3]
		item->sysvar.name = rt_strdup(name);
70019860:	e51b0010 	ldr	r0, [fp, #-16]
70019864:	ebffb3f4 	bl	7000683c <rt_strdup>
70019868:	e1a02000 	mov	r2, r0
7001986c:	e51b3008 	ldr	r3, [fp, #-8]
70019870:	e5832004 	str	r2, [r3, #4]
		item->sysvar.type = type;
70019874:	e51b3008 	ldr	r3, [fp, #-8]
70019878:	e55b2011 	ldrb	r2, [fp, #-17]
7001987c:	e5c3200c 	strb	r2, [r3, #12]
		item->sysvar.var = var_addr;
70019880:	e51b3008 	ldr	r3, [fp, #-8]
70019884:	e51b2018 	ldr	r2, [fp, #-24]
70019888:	e5832010 	str	r2, [r3, #16]

		if (global_sysvar_list == NULL)
7001988c:	e30b35e8 	movw	r3, #46568	; 0xb5e8
70019890:	e3473002 	movt	r3, #28674	; 0x7002
70019894:	e5933000 	ldr	r3, [r3]
70019898:	e3530000 	cmp	r3, #0
7001989c:	1a000004 	bne	700198b4 <finsh_sysvar_append+0x94>
		{
			global_sysvar_list = item;
700198a0:	e30b35e8 	movw	r3, #46568	; 0xb5e8
700198a4:	e3473002 	movt	r3, #28674	; 0x7002
700198a8:	e51b2008 	ldr	r2, [fp, #-8]
700198ac:	e5832000 	str	r2, [r3]
700198b0:	ea000008 	b	700198d8 <finsh_sysvar_append+0xb8>
		}
		else
		{
			item->next = global_sysvar_list;
700198b4:	e30b35e8 	movw	r3, #46568	; 0xb5e8
700198b8:	e3473002 	movt	r3, #28674	; 0x7002
700198bc:	e5932000 	ldr	r2, [r3]
700198c0:	e51b3008 	ldr	r3, [fp, #-8]
700198c4:	e5832000 	str	r2, [r3]
			global_sysvar_list = item;
700198c8:	e30b35e8 	movw	r3, #46568	; 0xb5e8
700198cc:	e3473002 	movt	r3, #28674	; 0x7002
700198d0:	e51b2008 	ldr	r2, [fp, #-8]
700198d4:	e5832000 	str	r2, [r3]
		}
	}
}
700198d8:	e24bd004 	sub	sp, fp, #4
700198dc:	e8bd8800 	pop	{fp, pc}

700198e0 <finsh_sysvar_lookup>:
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
700198e0:	e92d4810 	push	{r4, fp, lr}
700198e4:	e28db008 	add	fp, sp, #8
700198e8:	e24dd014 	sub	sp, sp, #20
700198ec:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
700198f0:	e30a3a14 	movw	r3, #43540	; 0xaa14
700198f4:	e3473002 	movt	r3, #28674	; 0x7002
700198f8:	e5933000 	ldr	r3, [r3]
700198fc:	e50b3010 	str	r3, [fp, #-16]
70019900:	ea00000c 	b	70019938 <finsh_sysvar_lookup+0x58>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
70019904:	e51b3010 	ldr	r3, [fp, #-16]
70019908:	e5933000 	ldr	r3, [r3]
7001990c:	e1a00003 	mov	r0, r3
70019910:	e51b1018 	ldr	r1, [fp, #-24]
70019914:	fa00253a 	blx	70022e04 <strcmp>
70019918:	e1a03000 	mov	r3, r0
7001991c:	e3530000 	cmp	r3, #0
70019920:	1a000001 	bne	7001992c <finsh_sysvar_lookup+0x4c>
			return index;
70019924:	e51b3010 	ldr	r3, [fp, #-16]
70019928:	ea000023 	b	700199bc <finsh_sysvar_lookup+0xdc>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
7001992c:	e51b3010 	ldr	r3, [fp, #-16]
70019930:	e2833010 	add	r3, r3, #16
70019934:	e50b3010 	str	r3, [fp, #-16]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
70019938:	e30a3a18 	movw	r3, #43544	; 0xaa18
7001993c:	e3473002 	movt	r3, #28674	; 0x7002
70019940:	e5933000 	ldr	r3, [r3]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
70019944:	e51b2010 	ldr	r2, [fp, #-16]
70019948:	e1520003 	cmp	r2, r3
7001994c:	3affffec 	bcc	70019904 <finsh_sysvar_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
70019950:	e30b35e8 	movw	r3, #46568	; 0xb5e8
70019954:	e3473002 	movt	r3, #28674	; 0x7002
70019958:	e5933000 	ldr	r3, [r3]
7001995c:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
70019960:	ea000011 	b	700199ac <finsh_sysvar_lookup+0xcc>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
70019964:	e51b3014 	ldr	r3, [fp, #-20]
70019968:	e5934004 	ldr	r4, [r3, #4]
7001996c:	e51b0018 	ldr	r0, [fp, #-24]
70019970:	fa002a6f 	blx	70024334 <strlen>
70019974:	e1a03000 	mov	r3, r0
70019978:	e1a00004 	mov	r0, r4
7001997c:	e51b1018 	ldr	r1, [fp, #-24]
70019980:	e1a02003 	mov	r2, r3
70019984:	fa002a82 	blx	70024394 <strncmp>
70019988:	e1a03000 	mov	r3, r0
7001998c:	e3530000 	cmp	r3, #0
70019990:	1a000002 	bne	700199a0 <finsh_sysvar_lookup+0xc0>
		{
			return &(item->sysvar);
70019994:	e51b3014 	ldr	r3, [fp, #-20]
70019998:	e2833004 	add	r3, r3, #4
7001999c:	ea000006 	b	700199bc <finsh_sysvar_lookup+0xdc>
		}

		/* move to next item */
		item = item->next;
700199a0:	e51b3014 	ldr	r3, [fp, #-20]
700199a4:	e5933000 	ldr	r3, [r3]
700199a8:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
700199ac:	e51b3014 	ldr	r3, [fp, #-20]
700199b0:	e3530000 	cmp	r3, #0
700199b4:	1affffea 	bne	70019964 <finsh_sysvar_lookup+0x84>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
700199b8:	e3a03000 	mov	r3, #0
}
700199bc:	e1a00003 	mov	r0, r3
700199c0:	e24bd008 	sub	sp, fp, #8
700199c4:	e8bd8810 	pop	{r4, fp, pc}

700199c8 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
700199c8:	e92d4800 	push	{fp, lr}
700199cc:	e28db004 	add	fp, sp, #4
700199d0:	e24dd008 	sub	sp, sp, #8
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
700199d4:	e30b3830 	movw	r3, #47152	; 0xb830
700199d8:	e3473002 	movt	r3, #28674	; 0x7002
700199dc:	e30b272c 	movw	r2, #46892	; 0xb72c
700199e0:	e3472002 	movt	r2, #28674	; 0x7002
700199e4:	e5832000 	str	r2, [r3]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
700199e8:	e30b382c 	movw	r3, #47148	; 0xb82c
700199ec:	e3473002 	movt	r3, #28674	; 0x7002
700199f0:	e30b26ac 	movw	r2, #46764	; 0xb6ac
700199f4:	e3472002 	movt	r2, #28674	; 0x7002
700199f8:	e5832000 	str	r2, [r3]

	while ((finsh_pc - &text_segment[0] >= 0) &&
700199fc:	ea00000e 	b	70019a3c <finsh_vm_run+0x74>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
70019a00:	e30b382c 	movw	r3, #47148	; 0xb82c
70019a04:	e3473002 	movt	r3, #28674	; 0x7002
70019a08:	e5933000 	ldr	r3, [r3]
70019a0c:	e1a02003 	mov	r2, r3
70019a10:	e2821001 	add	r1, r2, #1
70019a14:	e30b382c 	movw	r3, #47148	; 0xb82c
70019a18:	e3473002 	movt	r3, #28674	; 0x7002
70019a1c:	e5831000 	str	r1, [r3]
70019a20:	e5d23000 	ldrb	r3, [r2]
70019a24:	e54b3005 	strb	r3, [fp, #-5]

		/* call op function */
		op_table[op]();
70019a28:	e55b2005 	ldrb	r2, [fp, #-5]
70019a2c:	e3083078 	movw	r3, #32888	; 0x8078
70019a30:	e3473002 	movt	r3, #28674	; 0x7002
70019a34:	e7933102 	ldr	r3, [r3, r2, lsl #2]
70019a38:	e12fff33 	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
70019a3c:	e30b382c 	movw	r3, #47148	; 0xb82c
70019a40:	e3473002 	movt	r3, #28674	; 0x7002
70019a44:	e5933000 	ldr	r3, [r3]
70019a48:	e1a02003 	mov	r2, r3
70019a4c:	e30b36ac 	movw	r3, #46764	; 0xb6ac
70019a50:	e3473002 	movt	r3, #28674	; 0x7002
70019a54:	e0633002 	rsb	r3, r3, r2
70019a58:	e3530000 	cmp	r3, #0
70019a5c:	ba000008 	blt	70019a84 <finsh_vm_run+0xbc>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
70019a60:	e30b382c 	movw	r3, #47148	; 0xb82c
70019a64:	e3473002 	movt	r3, #28674	; 0x7002
70019a68:	e5933000 	ldr	r3, [r3]
70019a6c:	e1a02003 	mov	r2, r3
70019a70:	e30b36ac 	movw	r3, #46764	; 0xb6ac
70019a74:	e3473002 	movt	r3, #28674	; 0x7002
70019a78:	e0633002 	rsb	r3, r3, r2
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
70019a7c:	e353007f 	cmp	r3, #127	; 0x7f
70019a80:	daffffde 	ble	70019a00 <finsh_vm_run+0x38>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
70019a84:	e24bd004 	sub	sp, fp, #4
70019a88:	e8bd8800 	pop	{fp, pc}

70019a8c <finsh_syscall_append>:

#ifdef RT_USING_HEAP
void finsh_syscall_append(const char* name, syscall_func func)
{
70019a8c:	e92d4800 	push	{fp, lr}
70019a90:	e28db004 	add	fp, sp, #4
70019a94:	e24dd010 	sub	sp, sp, #16
70019a98:	e50b0010 	str	r0, [fp, #-16]
70019a9c:	e50b1014 	str	r1, [fp, #-20]
	/* create the syscall */
	struct finsh_syscall_item* item;

	item = (struct finsh_syscall_item*)rt_malloc(sizeof(struct finsh_syscall_item));
70019aa0:	e3a00010 	mov	r0, #16
70019aa4:	ebffb984 	bl	700080bc <rt_malloc>
70019aa8:	e50b0008 	str	r0, [fp, #-8]
	if (item != RT_NULL)
70019aac:	e51b3008 	ldr	r3, [fp, #-8]
70019ab0:	e3530000 	cmp	r3, #0
70019ab4:	0a00001d 	beq	70019b30 <finsh_syscall_append+0xa4>
	{
		item->next = NULL;
70019ab8:	e51b3008 	ldr	r3, [fp, #-8]
70019abc:	e3a02000 	mov	r2, #0
70019ac0:	e5832000 	str	r2, [r3]
		item->syscall.name = rt_strdup(name);
70019ac4:	e51b0010 	ldr	r0, [fp, #-16]
70019ac8:	ebffb35b 	bl	7000683c <rt_strdup>
70019acc:	e1a02000 	mov	r2, r0
70019ad0:	e51b3008 	ldr	r3, [fp, #-8]
70019ad4:	e5832004 	str	r2, [r3, #4]
		item->syscall.func = func;
70019ad8:	e51b3008 	ldr	r3, [fp, #-8]
70019adc:	e51b2014 	ldr	r2, [fp, #-20]
70019ae0:	e583200c 	str	r2, [r3, #12]

		if (global_syscall_list == NULL)
70019ae4:	e30a3a28 	movw	r3, #43560	; 0xaa28
70019ae8:	e3473002 	movt	r3, #28674	; 0x7002
70019aec:	e5933000 	ldr	r3, [r3]
70019af0:	e3530000 	cmp	r3, #0
70019af4:	1a000004 	bne	70019b0c <finsh_syscall_append+0x80>
		{
			global_syscall_list = item;
70019af8:	e30a3a28 	movw	r3, #43560	; 0xaa28
70019afc:	e3473002 	movt	r3, #28674	; 0x7002
70019b00:	e51b2008 	ldr	r2, [fp, #-8]
70019b04:	e5832000 	str	r2, [r3]
70019b08:	ea000008 	b	70019b30 <finsh_syscall_append+0xa4>
		}
		else
		{
			item->next = global_syscall_list;
70019b0c:	e30a3a28 	movw	r3, #43560	; 0xaa28
70019b10:	e3473002 	movt	r3, #28674	; 0x7002
70019b14:	e5932000 	ldr	r2, [r3]
70019b18:	e51b3008 	ldr	r3, [fp, #-8]
70019b1c:	e5832000 	str	r2, [r3]
			global_syscall_list = item;
70019b20:	e30a3a28 	movw	r3, #43560	; 0xaa28
70019b24:	e3473002 	movt	r3, #28674	; 0x7002
70019b28:	e51b2008 	ldr	r2, [fp, #-8]
70019b2c:	e5832000 	str	r2, [r3]
		}
	}
}
70019b30:	e24bd004 	sub	sp, fp, #4
70019b34:	e8bd8800 	pop	{fp, pc}

70019b38 <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
70019b38:	e92d4810 	push	{r4, fp, lr}
70019b3c:	e28db008 	add	fp, sp, #8
70019b40:	e24dd014 	sub	sp, sp, #20
70019b44:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
70019b48:	e30a3a0c 	movw	r3, #43532	; 0xaa0c
70019b4c:	e3473002 	movt	r3, #28674	; 0x7002
70019b50:	e5933000 	ldr	r3, [r3]
70019b54:	e50b3010 	str	r3, [fp, #-16]
70019b58:	ea00000c 	b	70019b90 <finsh_syscall_lookup+0x58>
	{
		if (strcmp(index->name, name) == 0)
70019b5c:	e51b3010 	ldr	r3, [fp, #-16]
70019b60:	e5933000 	ldr	r3, [r3]
70019b64:	e1a00003 	mov	r0, r3
70019b68:	e51b1018 	ldr	r1, [fp, #-24]
70019b6c:	fa0024a4 	blx	70022e04 <strcmp>
70019b70:	e1a03000 	mov	r3, r0
70019b74:	e3530000 	cmp	r3, #0
70019b78:	1a000001 	bne	70019b84 <finsh_syscall_lookup+0x4c>
			return index;
70019b7c:	e51b3010 	ldr	r3, [fp, #-16]
70019b80:	ea000023 	b	70019c14 <finsh_syscall_lookup+0xdc>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
70019b84:	e51b3010 	ldr	r3, [fp, #-16]
70019b88:	e283300c 	add	r3, r3, #12
70019b8c:	e50b3010 	str	r3, [fp, #-16]
70019b90:	e30a3a10 	movw	r3, #43536	; 0xaa10
70019b94:	e3473002 	movt	r3, #28674	; 0x7002
70019b98:	e5933000 	ldr	r3, [r3]
70019b9c:	e51b2010 	ldr	r2, [fp, #-16]
70019ba0:	e1520003 	cmp	r2, r3
70019ba4:	3affffec 	bcc	70019b5c <finsh_syscall_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
70019ba8:	e30a3a28 	movw	r3, #43560	; 0xaa28
70019bac:	e3473002 	movt	r3, #28674	; 0x7002
70019bb0:	e5933000 	ldr	r3, [r3]
70019bb4:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
70019bb8:	ea000011 	b	70019c04 <finsh_syscall_lookup+0xcc>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
70019bbc:	e51b3014 	ldr	r3, [fp, #-20]
70019bc0:	e5934004 	ldr	r4, [r3, #4]
70019bc4:	e51b0018 	ldr	r0, [fp, #-24]
70019bc8:	fa0029d9 	blx	70024334 <strlen>
70019bcc:	e1a03000 	mov	r3, r0
70019bd0:	e1a00004 	mov	r0, r4
70019bd4:	e51b1018 	ldr	r1, [fp, #-24]
70019bd8:	e1a02003 	mov	r2, r3
70019bdc:	fa0029ec 	blx	70024394 <strncmp>
70019be0:	e1a03000 	mov	r3, r0
70019be4:	e3530000 	cmp	r3, #0
70019be8:	1a000002 	bne	70019bf8 <finsh_syscall_lookup+0xc0>
		{
			return &(item->syscall);
70019bec:	e51b3014 	ldr	r3, [fp, #-20]
70019bf0:	e2833004 	add	r3, r3, #4
70019bf4:	ea000006 	b	70019c14 <finsh_syscall_lookup+0xdc>
		}

		item = item->next;
70019bf8:	e51b3014 	ldr	r3, [fp, #-20]
70019bfc:	e5933000 	ldr	r3, [r3]
70019c00:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
70019c04:	e51b3014 	ldr	r3, [fp, #-20]
70019c08:	e3530000 	cmp	r3, #0
70019c0c:	1affffea 	bne	70019bbc <finsh_syscall_lookup+0x84>
		}

		item = item->next;
	}

	return NULL;
70019c10:	e3a03000 	mov	r3, #0
}
70019c14:	e1a00003 	mov	r0, r3
70019c18:	e24bd008 	sub	sp, fp, #8
70019c1c:	e8bd8810 	pop	{r4, fp, pc}

70019c20 <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
70019c20:	e92d4800 	push	{fp, lr}
70019c24:	e28db004 	add	fp, sp, #4
70019c28:	e24dd008 	sub	sp, sp, #8
70019c2c:	e50b0008 	str	r0, [fp, #-8]
70019c30:	e50b100c 	str	r1, [fp, #-12]
	memset(self, 0, sizeof(struct finsh_token));
70019c34:	e51b0008 	ldr	r0, [fp, #-8]
70019c38:	e3a01000 	mov	r1, #0
70019c3c:	e3a02094 	mov	r2, #148	; 0x94
70019c40:	fa0028c2 	blx	70023f50 <memset>

	self->line = line;
70019c44:	e51b3008 	ldr	r3, [fp, #-8]
70019c48:	e51b200c 	ldr	r2, [fp, #-12]
70019c4c:	e5832090 	str	r2, [r3, #144]	; 0x90
}
70019c50:	e24bd004 	sub	sp, fp, #4
70019c54:	e8bd8800 	pop	{fp, pc}

70019c58 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
70019c58:	e92d4800 	push	{fp, lr}
70019c5c:	e28db004 	add	fp, sp, #4
70019c60:	e24dd008 	sub	sp, sp, #8
70019c64:	e50b0008 	str	r0, [fp, #-8]
	if ( self->replay )	self->replay = 0;
70019c68:	e51b3008 	ldr	r3, [fp, #-8]
70019c6c:	e5d33001 	ldrb	r3, [r3, #1]
70019c70:	e3530000 	cmp	r3, #0
70019c74:	0a000003 	beq	70019c88 <finsh_token_token+0x30>
70019c78:	e51b3008 	ldr	r3, [fp, #-8]
70019c7c:	e3a02000 	mov	r2, #0
70019c80:	e5c32001 	strb	r2, [r3, #1]
70019c84:	ea000001 	b	70019c90 <finsh_token_token+0x38>
	else token_run(self);
70019c88:	e51b0008 	ldr	r0, [fp, #-8]
70019c8c:	eb0000a3 	bl	70019f20 <token_run>

	return (enum finsh_token_type)self->current_token;
70019c90:	e51b3008 	ldr	r3, [fp, #-8]
70019c94:	e5d33008 	ldrb	r3, [r3, #8]
}
70019c98:	e1a00003 	mov	r0, r3
70019c9c:	e24bd004 	sub	sp, fp, #4
70019ca0:	e8bd8800 	pop	{fp, pc}

70019ca4 <finsh_token_get_token>:

void finsh_token_get_token(struct finsh_token* self, u_char* token)
{
70019ca4:	e92d4800 	push	{fp, lr}
70019ca8:	e28db004 	add	fp, sp, #4
70019cac:	e24dd008 	sub	sp, sp, #8
70019cb0:	e50b0008 	str	r0, [fp, #-8]
70019cb4:	e50b100c 	str	r1, [fp, #-12]
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
70019cb8:	e51b3008 	ldr	r3, [fp, #-8]
70019cbc:	e2833010 	add	r3, r3, #16
70019cc0:	e51b000c 	ldr	r0, [fp, #-12]
70019cc4:	e1a01003 	mov	r1, r3
70019cc8:	e3a02010 	mov	r2, #16
70019ccc:	fa0029de 	blx	7002444c <strncpy>
}
70019cd0:	e24bd004 	sub	sp, fp, #4
70019cd4:	e8bd8800 	pop	{fp, pc}

70019cd8 <token_get_string>:

int token_get_string(struct finsh_token* self, u_char* str)
{
70019cd8:	e92d4800 	push	{fp, lr}
70019cdc:	e28db004 	add	fp, sp, #4
70019ce0:	e24dd010 	sub	sp, sp, #16
70019ce4:	e50b0010 	str	r0, [fp, #-16]
70019ce8:	e50b1014 	str	r1, [fp, #-20]
	unsigned char *p=str;
70019cec:	e51b3014 	ldr	r3, [fp, #-20]
70019cf0:	e50b3008 	str	r3, [fp, #-8]
	char ch;

	ch = token_next_char(self);
70019cf4:	e51b0010 	ldr	r0, [fp, #-16]
70019cf8:	eb000043 	bl	70019e0c <token_next_char>
70019cfc:	e1a03000 	mov	r3, r0
70019d00:	e54b3009 	strb	r3, [fp, #-9]
	if (is_eof(self)) return -1;
70019d04:	e51b3010 	ldr	r3, [fp, #-16]
70019d08:	e5d33000 	ldrb	r3, [r3]
70019d0c:	e3530000 	cmp	r3, #0
70019d10:	0a000001 	beq	70019d1c <token_get_string+0x44>
70019d14:	e3e03000 	mvn	r3, #0
70019d18:	ea000038 	b	70019e00 <token_get_string+0x128>

	str[0] = '\0';
70019d1c:	e51b3014 	ldr	r3, [fp, #-20]
70019d20:	e3a02000 	mov	r2, #0
70019d24:	e5c32000 	strb	r2, [r3]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
70019d28:	e55b3009 	ldrb	r3, [fp, #-9]
70019d2c:	e353002f 	cmp	r3, #47	; 0x2f
70019d30:	9a000006 	bls	70019d50 <token_get_string+0x78>
70019d34:	e55b3009 	ldrb	r3, [fp, #-9]
70019d38:	e3530039 	cmp	r3, #57	; 0x39
70019d3c:	8a000003 	bhi	70019d50 <token_get_string+0x78>
	{
		token_prev_char(self);
70019d40:	e51b0010 	ldr	r0, [fp, #-16]
70019d44:	eb00005f 	bl	70019ec8 <token_prev_char>
		return -1;
70019d48:	e3e03000 	mvn	r3, #0
70019d4c:	ea00002b 	b	70019e00 <token_get_string+0x128>
	}

	while (!is_separator(ch) && !is_eof(self))
70019d50:	ea000008 	b	70019d78 <token_get_string+0xa0>
	{
		*p++ = ch;
70019d54:	e51b3008 	ldr	r3, [fp, #-8]
70019d58:	e2832001 	add	r2, r3, #1
70019d5c:	e50b2008 	str	r2, [fp, #-8]
70019d60:	e55b2009 	ldrb	r2, [fp, #-9]
70019d64:	e5c32000 	strb	r2, [r3]

		ch = token_next_char(self);
70019d68:	e51b0010 	ldr	r0, [fp, #-16]
70019d6c:	eb000026 	bl	70019e0c <token_next_char>
70019d70:	e1a03000 	mov	r3, r0
70019d74:	e54b3009 	strb	r3, [fp, #-9]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
70019d78:	e55b3009 	ldrb	r3, [fp, #-9]
70019d7c:	e3530060 	cmp	r3, #96	; 0x60
70019d80:	9a000002 	bls	70019d90 <token_get_string+0xb8>
70019d84:	e55b3009 	ldrb	r3, [fp, #-9]
70019d88:	e353007a 	cmp	r3, #122	; 0x7a
70019d8c:	9a00000e 	bls	70019dcc <token_get_string+0xf4>
70019d90:	e55b3009 	ldrb	r3, [fp, #-9]
70019d94:	e3530040 	cmp	r3, #64	; 0x40
70019d98:	9a000002 	bls	70019da8 <token_get_string+0xd0>
70019d9c:	e55b3009 	ldrb	r3, [fp, #-9]
70019da0:	e353005a 	cmp	r3, #90	; 0x5a
70019da4:	9a000008 	bls	70019dcc <token_get_string+0xf4>
70019da8:	e55b3009 	ldrb	r3, [fp, #-9]
70019dac:	e353002f 	cmp	r3, #47	; 0x2f
70019db0:	9a000002 	bls	70019dc0 <token_get_string+0xe8>
70019db4:	e55b3009 	ldrb	r3, [fp, #-9]
70019db8:	e3530039 	cmp	r3, #57	; 0x39
70019dbc:	9a000002 	bls	70019dcc <token_get_string+0xf4>
70019dc0:	e55b3009 	ldrb	r3, [fp, #-9]
70019dc4:	e353005f 	cmp	r3, #95	; 0x5f
70019dc8:	1a000003 	bne	70019ddc <token_get_string+0x104>
70019dcc:	e51b3010 	ldr	r3, [fp, #-16]
70019dd0:	e5d33000 	ldrb	r3, [r3]
70019dd4:	e3530000 	cmp	r3, #0
70019dd8:	0affffdd 	beq	70019d54 <token_get_string+0x7c>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
70019ddc:	e51b3010 	ldr	r3, [fp, #-16]
70019de0:	e3a02000 	mov	r2, #0
70019de4:	e5c32000 	strb	r2, [r3]

	token_prev_char(self);
70019de8:	e51b0010 	ldr	r0, [fp, #-16]
70019dec:	eb000035 	bl	70019ec8 <token_prev_char>
	*p = '\0';
70019df0:	e51b3008 	ldr	r3, [fp, #-8]
70019df4:	e3a02000 	mov	r2, #0
70019df8:	e5c32000 	strb	r2, [r3]

	return 0;
70019dfc:	e3a03000 	mov	r3, #0
}
70019e00:	e1a00003 	mov	r0, r3
70019e04:	e24bd004 	sub	sp, fp, #4
70019e08:	e8bd8800 	pop	{fp, pc}

70019e0c <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
70019e0c:	e92d4810 	push	{r4, fp, lr}
70019e10:	e28db008 	add	fp, sp, #8
70019e14:	e24dd00c 	sub	sp, sp, #12
70019e18:	e50b0010 	str	r0, [fp, #-16]
	if (self->eof) return '\0';
70019e1c:	e51b3010 	ldr	r3, [fp, #-16]
70019e20:	e5d33000 	ldrb	r3, [r3]
70019e24:	e3530000 	cmp	r3, #0
70019e28:	0a000001 	beq	70019e34 <token_next_char+0x28>
70019e2c:	e3a03000 	mov	r3, #0
70019e30:	ea000021 	b	70019ebc <token_next_char+0xb0>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
70019e34:	e51b3010 	ldr	r3, [fp, #-16]
70019e38:	e5934004 	ldr	r4, [r3, #4]
70019e3c:	e51b3010 	ldr	r3, [fp, #-16]
70019e40:	e5933090 	ldr	r3, [r3, #144]	; 0x90
70019e44:	e1a00003 	mov	r0, r3
70019e48:	fa002939 	blx	70024334 <strlen>
70019e4c:	e1a03000 	mov	r3, r0
70019e50:	e1540003 	cmp	r4, r3
70019e54:	0a000007 	beq	70019e78 <token_next_char+0x6c>
70019e58:	e51b3010 	ldr	r3, [fp, #-16]
70019e5c:	e5932090 	ldr	r2, [r3, #144]	; 0x90
70019e60:	e51b3010 	ldr	r3, [fp, #-16]
70019e64:	e5933004 	ldr	r3, [r3, #4]
70019e68:	e0823003 	add	r3, r2, r3
70019e6c:	e5d33000 	ldrb	r3, [r3]
70019e70:	e353000a 	cmp	r3, #10
70019e74:	1a000007 	bne	70019e98 <token_next_char+0x8c>
	{
			self->eof = 1;
70019e78:	e51b3010 	ldr	r3, [fp, #-16]
70019e7c:	e3a02001 	mov	r2, #1
70019e80:	e5c32000 	strb	r2, [r3]
			self->position = 0;
70019e84:	e51b3010 	ldr	r3, [fp, #-16]
70019e88:	e3a02000 	mov	r2, #0
70019e8c:	e5832004 	str	r2, [r3, #4]
			return '\0';
70019e90:	e3a03000 	mov	r3, #0
70019e94:	ea000008 	b	70019ebc <token_next_char+0xb0>
	}

	return self->line[self->position++];
70019e98:	e51b3010 	ldr	r3, [fp, #-16]
70019e9c:	e5932090 	ldr	r2, [r3, #144]	; 0x90
70019ea0:	e51b3010 	ldr	r3, [fp, #-16]
70019ea4:	e5933004 	ldr	r3, [r3, #4]
70019ea8:	e2830001 	add	r0, r3, #1
70019eac:	e51b1010 	ldr	r1, [fp, #-16]
70019eb0:	e5810004 	str	r0, [r1, #4]
70019eb4:	e0823003 	add	r3, r2, r3
70019eb8:	e5d33000 	ldrb	r3, [r3]
}
70019ebc:	e1a00003 	mov	r0, r3
70019ec0:	e24bd008 	sub	sp, fp, #8
70019ec4:	e8bd8810 	pop	{r4, fp, pc}

70019ec8 <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
70019ec8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70019ecc:	e28db000 	add	fp, sp, #0
70019ed0:	e24dd00c 	sub	sp, sp, #12
70019ed4:	e50b0008 	str	r0, [fp, #-8]
	if ( self->eof ) return;
70019ed8:	e51b3008 	ldr	r3, [fp, #-8]
70019edc:	e5d33000 	ldrb	r3, [r3]
70019ee0:	e3530000 	cmp	r3, #0
70019ee4:	0a000000 	beq	70019eec <token_prev_char+0x24>
70019ee8:	ea000009 	b	70019f14 <token_prev_char+0x4c>

	if ( self->position == 0 ) return;
70019eec:	e51b3008 	ldr	r3, [fp, #-8]
70019ef0:	e5933004 	ldr	r3, [r3, #4]
70019ef4:	e3530000 	cmp	r3, #0
70019ef8:	1a000000 	bne	70019f00 <token_prev_char+0x38>
70019efc:	ea000004 	b	70019f14 <token_prev_char+0x4c>
    else self->position--;
70019f00:	e51b3008 	ldr	r3, [fp, #-8]
70019f04:	e5933004 	ldr	r3, [r3, #4]
70019f08:	e2432001 	sub	r2, r3, #1
70019f0c:	e51b3008 	ldr	r3, [fp, #-8]
70019f10:	e5832004 	str	r2, [r3, #4]
}
70019f14:	e24bd000 	sub	sp, fp, #0
70019f18:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70019f1c:	e12fff1e 	bx	lr

70019f20 <token_run>:

static void token_run(struct finsh_token* self)
{
70019f20:	e92d4800 	push	{fp, lr}
70019f24:	e28db004 	add	fp, sp, #4
70019f28:	e24dd010 	sub	sp, sp, #16
70019f2c:	e50b0010 	str	r0, [fp, #-16]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
70019f30:	e51b0010 	ldr	r0, [fp, #-16]
70019f34:	eb00014e 	bl	7001a474 <token_trim_space>
	token_get_string(self, &(self->string[0]));
70019f38:	e51b3010 	ldr	r3, [fp, #-16]
70019f3c:	e2833010 	add	r3, r3, #16
70019f40:	e51b0010 	ldr	r0, [fp, #-16]
70019f44:	e1a01003 	mov	r1, r3
70019f48:	ebffff62 	bl	70019cd8 <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
70019f4c:	e51b3010 	ldr	r3, [fp, #-16]
70019f50:	e5d33000 	ldrb	r3, [r3]
70019f54:	e3530000 	cmp	r3, #0
70019f58:	0a000003 	beq	70019f6c <token_run+0x4c>
	{
		self->current_token = finsh_token_type_eof;
70019f5c:	e51b3010 	ldr	r3, [fp, #-16]
70019f60:	e3a02021 	mov	r2, #33	; 0x21
70019f64:	e5c32008 	strb	r2, [r3, #8]
		return ;
70019f68:	ea000117 	b	7001a3cc <token_run+0x4ac>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
70019f6c:	e51b3010 	ldr	r3, [fp, #-16]
70019f70:	e5d33010 	ldrb	r3, [r3, #16]
70019f74:	e3530000 	cmp	r3, #0
70019f78:	0a00000b 	beq	70019fac <token_run+0x8c>
	{
		if ( !token_match_name(self, (char*)self->string) )
70019f7c:	e51b3010 	ldr	r3, [fp, #-16]
70019f80:	e2833010 	add	r3, r3, #16
70019f84:	e51b0010 	ldr	r0, [fp, #-16]
70019f88:	e1a01003 	mov	r1, r3
70019f8c:	eb000110 	bl	7001a3d4 <token_match_name>
70019f90:	e1a03000 	mov	r3, r0
70019f94:	e3530000 	cmp	r3, #0
70019f98:	1a00010b 	bne	7001a3cc <token_run+0x4ac>
		{
			self->current_token = finsh_token_type_identifier;
70019f9c:	e51b3010 	ldr	r3, [fp, #-16]
70019fa0:	e3a0201f 	mov	r2, #31
70019fa4:	e5c32008 	strb	r2, [r3, #8]
70019fa8:	ea000107 	b	7001a3cc <token_run+0x4ac>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
70019fac:	e51b0010 	ldr	r0, [fp, #-16]
70019fb0:	ebffff95 	bl	70019e0c <token_next_char>
70019fb4:	e1a03000 	mov	r3, r0
70019fb8:	e54b3005 	strb	r3, [fp, #-5]

		switch ( ch )
70019fbc:	e55b3005 	ldrb	r3, [fp, #-5]
70019fc0:	e2433022 	sub	r3, r3, #34	; 0x22
70019fc4:	e353005c 	cmp	r3, #92	; 0x5c
70019fc8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
70019fcc:	ea0000ed 	b	7001a388 <token_run+0x468>
70019fd0:	7001a370 	.word	0x7001a370
70019fd4:	7001a388 	.word	0x7001a388
70019fd8:	7001a388 	.word	0x7001a388
70019fdc:	7001a308 	.word	0x7001a308
70019fe0:	7001a184 	.word	0x7001a184
70019fe4:	7001a348 	.word	0x7001a348
70019fe8:	7001a144 	.word	0x7001a144
70019fec:	7001a154 	.word	0x7001a154
70019ff0:	7001a194 	.word	0x7001a194
70019ff4:	7001a1a4 	.word	0x7001a1a4
70019ff8:	7001a164 	.word	0x7001a164
70019ffc:	7001a1e8 	.word	0x7001a1e8
7001a000:	7001a388 	.word	0x7001a388
7001a004:	7001a22c 	.word	0x7001a22c
7001a008:	7001a388 	.word	0x7001a388
7001a00c:	7001a388 	.word	0x7001a388
7001a010:	7001a388 	.word	0x7001a388
7001a014:	7001a388 	.word	0x7001a388
7001a018:	7001a388 	.word	0x7001a388
7001a01c:	7001a388 	.word	0x7001a388
7001a020:	7001a388 	.word	0x7001a388
7001a024:	7001a388 	.word	0x7001a388
7001a028:	7001a388 	.word	0x7001a388
7001a02c:	7001a388 	.word	0x7001a388
7001a030:	7001a388 	.word	0x7001a388
7001a034:	7001a174 	.word	0x7001a174
7001a038:	7001a270 	.word	0x7001a270
7001a03c:	7001a338 	.word	0x7001a338
7001a040:	7001a2b4 	.word	0x7001a2b4
7001a044:	7001a388 	.word	0x7001a388
7001a048:	7001a388 	.word	0x7001a388
7001a04c:	7001a388 	.word	0x7001a388
7001a050:	7001a388 	.word	0x7001a388
7001a054:	7001a388 	.word	0x7001a388
7001a058:	7001a388 	.word	0x7001a388
7001a05c:	7001a388 	.word	0x7001a388
7001a060:	7001a388 	.word	0x7001a388
7001a064:	7001a388 	.word	0x7001a388
7001a068:	7001a388 	.word	0x7001a388
7001a06c:	7001a388 	.word	0x7001a388
7001a070:	7001a388 	.word	0x7001a388
7001a074:	7001a388 	.word	0x7001a388
7001a078:	7001a388 	.word	0x7001a388
7001a07c:	7001a388 	.word	0x7001a388
7001a080:	7001a388 	.word	0x7001a388
7001a084:	7001a388 	.word	0x7001a388
7001a088:	7001a388 	.word	0x7001a388
7001a08c:	7001a388 	.word	0x7001a388
7001a090:	7001a388 	.word	0x7001a388
7001a094:	7001a388 	.word	0x7001a388
7001a098:	7001a388 	.word	0x7001a388
7001a09c:	7001a388 	.word	0x7001a388
7001a0a0:	7001a388 	.word	0x7001a388
7001a0a4:	7001a388 	.word	0x7001a388
7001a0a8:	7001a388 	.word	0x7001a388
7001a0ac:	7001a388 	.word	0x7001a388
7001a0b0:	7001a388 	.word	0x7001a388
7001a0b4:	7001a388 	.word	0x7001a388
7001a0b8:	7001a388 	.word	0x7001a388
7001a0bc:	7001a388 	.word	0x7001a388
7001a0c0:	7001a328 	.word	0x7001a328
7001a0c4:	7001a388 	.word	0x7001a388
7001a0c8:	7001a388 	.word	0x7001a388
7001a0cc:	7001a388 	.word	0x7001a388
7001a0d0:	7001a388 	.word	0x7001a388
7001a0d4:	7001a388 	.word	0x7001a388
7001a0d8:	7001a388 	.word	0x7001a388
7001a0dc:	7001a388 	.word	0x7001a388
7001a0e0:	7001a388 	.word	0x7001a388
7001a0e4:	7001a388 	.word	0x7001a388
7001a0e8:	7001a388 	.word	0x7001a388
7001a0ec:	7001a388 	.word	0x7001a388
7001a0f0:	7001a388 	.word	0x7001a388
7001a0f4:	7001a388 	.word	0x7001a388
7001a0f8:	7001a388 	.word	0x7001a388
7001a0fc:	7001a388 	.word	0x7001a388
7001a100:	7001a388 	.word	0x7001a388
7001a104:	7001a388 	.word	0x7001a388
7001a108:	7001a388 	.word	0x7001a388
7001a10c:	7001a388 	.word	0x7001a388
7001a110:	7001a388 	.word	0x7001a388
7001a114:	7001a388 	.word	0x7001a388
7001a118:	7001a388 	.word	0x7001a388
7001a11c:	7001a388 	.word	0x7001a388
7001a120:	7001a388 	.word	0x7001a388
7001a124:	7001a388 	.word	0x7001a388
7001a128:	7001a388 	.word	0x7001a388
7001a12c:	7001a388 	.word	0x7001a388
7001a130:	7001a388 	.word	0x7001a388
7001a134:	7001a388 	.word	0x7001a388
7001a138:	7001a2f8 	.word	0x7001a2f8
7001a13c:	7001a388 	.word	0x7001a388
7001a140:	7001a318 	.word	0x7001a318
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
7001a144:	e51b3010 	ldr	r3, [fp, #-16]
7001a148:	e3a02001 	mov	r2, #1
7001a14c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a150:	ea00009d 	b	7001a3cc <token_run+0x4ac>

		case ')':
			self->current_token = finsh_token_type_right_paren;
7001a154:	e51b3010 	ldr	r3, [fp, #-16]
7001a158:	e3a02002 	mov	r2, #2
7001a15c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a160:	ea000099 	b	7001a3cc <token_run+0x4ac>

		case ',':
			self->current_token = finsh_token_type_comma;
7001a164:	e51b3010 	ldr	r3, [fp, #-16]
7001a168:	e3a02003 	mov	r2, #3
7001a16c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a170:	ea000095 	b	7001a3cc <token_run+0x4ac>

		case ';':
			self->current_token = finsh_token_type_semicolon;
7001a174:	e51b3010 	ldr	r3, [fp, #-16]
7001a178:	e3a02004 	mov	r2, #4
7001a17c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a180:	ea000091 	b	7001a3cc <token_run+0x4ac>

		case '&':
			self->current_token = finsh_token_type_and;
7001a184:	e51b3010 	ldr	r3, [fp, #-16]
7001a188:	e3a0200d 	mov	r2, #13
7001a18c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a190:	ea00008d 	b	7001a3cc <token_run+0x4ac>

		case '*':
			self->current_token = finsh_token_type_mul;
7001a194:	e51b3010 	ldr	r3, [fp, #-16]
7001a198:	e3a02005 	mov	r2, #5
7001a19c:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a1a0:	ea000089 	b	7001a3cc <token_run+0x4ac>

		case '+':
			ch = token_next_char(self);
7001a1a4:	e51b0010 	ldr	r0, [fp, #-16]
7001a1a8:	ebffff17 	bl	70019e0c <token_next_char>
7001a1ac:	e1a03000 	mov	r3, r0
7001a1b0:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '+' )
7001a1b4:	e55b3005 	ldrb	r3, [fp, #-5]
7001a1b8:	e353002b 	cmp	r3, #43	; 0x2b
7001a1bc:	1a000003 	bne	7001a1d0 <token_run+0x2b0>
			{
				self->current_token = finsh_token_type_inc;
7001a1c0:	e51b3010 	ldr	r3, [fp, #-16]
7001a1c4:	e3a02007 	mov	r2, #7
7001a1c8:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
7001a1cc:	ea00007e 	b	7001a3cc <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
7001a1d0:	e51b0010 	ldr	r0, [fp, #-16]
7001a1d4:	ebffff3b 	bl	70019ec8 <token_prev_char>
				self->current_token = finsh_token_type_add;
7001a1d8:	e51b3010 	ldr	r3, [fp, #-16]
7001a1dc:	e3a02006 	mov	r2, #6
7001a1e0:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
7001a1e4:	ea000078 	b	7001a3cc <token_run+0x4ac>

		case '-':
			ch = token_next_char(self);
7001a1e8:	e51b0010 	ldr	r0, [fp, #-16]
7001a1ec:	ebffff06 	bl	70019e0c <token_next_char>
7001a1f0:	e1a03000 	mov	r3, r0
7001a1f4:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '-' )
7001a1f8:	e55b3005 	ldrb	r3, [fp, #-5]
7001a1fc:	e353002d 	cmp	r3, #45	; 0x2d
7001a200:	1a000003 	bne	7001a214 <token_run+0x2f4>
			{
				self->current_token = finsh_token_type_dec;
7001a204:	e51b3010 	ldr	r3, [fp, #-16]
7001a208:	e3a02009 	mov	r2, #9
7001a20c:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
7001a210:	ea00006d 	b	7001a3cc <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
7001a214:	e51b0010 	ldr	r0, [fp, #-16]
7001a218:	ebffff2a 	bl	70019ec8 <token_prev_char>
				self->current_token = finsh_token_type_sub;
7001a21c:	e51b3010 	ldr	r3, [fp, #-16]
7001a220:	e3a02008 	mov	r2, #8
7001a224:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
7001a228:	ea000067 	b	7001a3cc <token_run+0x4ac>

		case '/':
			ch = token_next_char(self);
7001a22c:	e51b0010 	ldr	r0, [fp, #-16]
7001a230:	ebfffef5 	bl	70019e0c <token_next_char>
7001a234:	e1a03000 	mov	r3, r0
7001a238:	e54b3005 	strb	r3, [fp, #-5]
			if (ch == '/')
7001a23c:	e55b3005 	ldrb	r3, [fp, #-5]
7001a240:	e353002f 	cmp	r3, #47	; 0x2f
7001a244:	1a000003 	bne	7001a258 <token_run+0x338>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
7001a248:	e51b3010 	ldr	r3, [fp, #-16]
7001a24c:	e3a02021 	mov	r2, #33	; 0x21
7001a250:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
7001a254:	ea00005c 	b	7001a3cc <token_run+0x4ac>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
7001a258:	e51b0010 	ldr	r0, [fp, #-16]
7001a25c:	ebffff19 	bl	70019ec8 <token_prev_char>
				self->current_token = finsh_token_type_div;
7001a260:	e51b3010 	ldr	r3, [fp, #-16]
7001a264:	e3a0200a 	mov	r2, #10
7001a268:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
7001a26c:	ea000056 	b	7001a3cc <token_run+0x4ac>

		case '<':
			ch = token_next_char(self);
7001a270:	e51b0010 	ldr	r0, [fp, #-16]
7001a274:	ebfffee4 	bl	70019e0c <token_next_char>
7001a278:	e1a03000 	mov	r3, r0
7001a27c:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '<' )
7001a280:	e55b3005 	ldrb	r3, [fp, #-5]
7001a284:	e353003c 	cmp	r3, #60	; 0x3c
7001a288:	1a000003 	bne	7001a29c <token_run+0x37c>
			{
				self->current_token = finsh_token_type_shl;
7001a28c:	e51b3010 	ldr	r3, [fp, #-16]
7001a290:	e3a02011 	mov	r2, #17
7001a294:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
7001a298:	ea00004b 	b	7001a3cc <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
7001a29c:	e51b0010 	ldr	r0, [fp, #-16]
7001a2a0:	ebffff08 	bl	70019ec8 <token_prev_char>
				self->current_token = finsh_token_type_bad;
7001a2a4:	e51b3010 	ldr	r3, [fp, #-16]
7001a2a8:	e3a02020 	mov	r2, #32
7001a2ac:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
7001a2b0:	ea000045 	b	7001a3cc <token_run+0x4ac>

		case '>':
			ch = token_next_char(self);
7001a2b4:	e51b0010 	ldr	r0, [fp, #-16]
7001a2b8:	ebfffed3 	bl	70019e0c <token_next_char>
7001a2bc:	e1a03000 	mov	r3, r0
7001a2c0:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '>' )
7001a2c4:	e55b3005 	ldrb	r3, [fp, #-5]
7001a2c8:	e353003e 	cmp	r3, #62	; 0x3e
7001a2cc:	1a000003 	bne	7001a2e0 <token_run+0x3c0>
			{
				self->current_token = finsh_token_type_shr;
7001a2d0:	e51b3010 	ldr	r3, [fp, #-16]
7001a2d4:	e3a02012 	mov	r2, #18
7001a2d8:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
7001a2dc:	ea00003a 	b	7001a3cc <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
7001a2e0:	e51b0010 	ldr	r0, [fp, #-16]
7001a2e4:	ebfffef7 	bl	70019ec8 <token_prev_char>
				self->current_token = finsh_token_type_bad;
7001a2e8:	e51b3010 	ldr	r3, [fp, #-16]
7001a2ec:	e3a02020 	mov	r2, #32
7001a2f0:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
7001a2f4:	ea000034 	b	7001a3cc <token_run+0x4ac>

		case '|':
			self->current_token = finsh_token_type_or;
7001a2f8:	e51b3010 	ldr	r3, [fp, #-16]
7001a2fc:	e3a0200e 	mov	r2, #14
7001a300:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a304:	ea000030 	b	7001a3cc <token_run+0x4ac>

		case '%':
			self->current_token = finsh_token_type_mod;
7001a308:	e51b3010 	ldr	r3, [fp, #-16]
7001a30c:	e3a0200b 	mov	r2, #11
7001a310:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a314:	ea00002c 	b	7001a3cc <token_run+0x4ac>

		case '~':
			self->current_token = finsh_token_type_bitwise;
7001a318:	e51b3010 	ldr	r3, [fp, #-16]
7001a31c:	e3a02010 	mov	r2, #16
7001a320:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a324:	ea000028 	b	7001a3cc <token_run+0x4ac>

		case '^':
			self->current_token = finsh_token_type_xor;
7001a328:	e51b3010 	ldr	r3, [fp, #-16]
7001a32c:	e3a0200f 	mov	r2, #15
7001a330:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a334:	ea000024 	b	7001a3cc <token_run+0x4ac>

		case '=':
			self->current_token = finsh_token_type_assign;
7001a338:	e51b3010 	ldr	r3, [fp, #-16]
7001a33c:	e3a0200c 	mov	r2, #12
7001a340:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a344:	ea000020 	b	7001a3cc <token_run+0x4ac>

		case '\'':
			self->value.char_value = token_proc_char(self);
7001a348:	e51b0010 	ldr	r0, [fp, #-16]
7001a34c:	eb00005d 	bl	7001a4c8 <token_proc_char>
7001a350:	e1a03000 	mov	r3, r0
7001a354:	e1a02003 	mov	r2, r3
7001a358:	e51b3010 	ldr	r3, [fp, #-16]
7001a35c:	e5c3200c 	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
7001a360:	e51b3010 	ldr	r3, [fp, #-16]
7001a364:	e3a0201a 	mov	r2, #26
7001a368:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a36c:	ea000016 	b	7001a3cc <token_run+0x4ac>

		case '"':
			token_proc_string(self);
7001a370:	e51b0010 	ldr	r0, [fp, #-16]
7001a374:	eb0000b4 	bl	7001a64c <token_proc_string>
			self->current_token = finsh_token_type_value_string;
7001a378:	e51b3010 	ldr	r3, [fp, #-16]
7001a37c:	e3a0201d 	mov	r2, #29
7001a380:	e5c32008 	strb	r2, [r3, #8]
			break;
7001a384:	ea000010 	b	7001a3cc <token_run+0x4ac>

		default:
			if ( is_digit(ch) )
7001a388:	e55b3005 	ldrb	r3, [fp, #-5]
7001a38c:	e353002f 	cmp	r3, #47	; 0x2f
7001a390:	9a000007 	bls	7001a3b4 <token_run+0x494>
7001a394:	e55b3005 	ldrb	r3, [fp, #-5]
7001a398:	e3530039 	cmp	r3, #57	; 0x39
7001a39c:	8a000004 	bhi	7001a3b4 <token_run+0x494>
			{
				token_prev_char(self);
7001a3a0:	e51b0010 	ldr	r0, [fp, #-16]
7001a3a4:	ebfffec7 	bl	70019ec8 <token_prev_char>
				token_proc_number(self);
7001a3a8:	e51b0010 	ldr	r0, [fp, #-16]
7001a3ac:	eb00014b 	bl	7001a8e0 <token_proc_number>
				break;
7001a3b0:	ea000005 	b	7001a3cc <token_run+0x4ac>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
7001a3b4:	e3a0000b 	mov	r0, #11
7001a3b8:	ebffec68 	bl	70015560 <finsh_error_set>
			self->current_token = finsh_token_type_bad;
7001a3bc:	e51b3010 	ldr	r3, [fp, #-16]
7001a3c0:	e3a02020 	mov	r2, #32
7001a3c4:	e5c32008 	strb	r2, [r3, #8]

			break;
7001a3c8:	e1a00000 	nop			; (mov r0, r0)
		}
	}
}
7001a3cc:	e24bd004 	sub	sp, fp, #4
7001a3d0:	e8bd8800 	pop	{fp, pc}

7001a3d4 <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
7001a3d4:	e92d4800 	push	{fp, lr}
7001a3d8:	e28db004 	add	fp, sp, #4
7001a3dc:	e24dd010 	sub	sp, sp, #16
7001a3e0:	e50b0010 	str	r0, [fp, #-16]
7001a3e4:	e50b1014 	str	r1, [fp, #-20]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
7001a3e8:	e3a03000 	mov	r3, #0
7001a3ec:	e50b3008 	str	r3, [fp, #-8]
7001a3f0:	ea000018 	b	7001a458 <token_match_name+0x84>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
7001a3f4:	e308317c 	movw	r3, #33148	; 0x817c
7001a3f8:	e3473002 	movt	r3, #28674	; 0x7002
7001a3fc:	e51b2008 	ldr	r2, [fp, #-8]
7001a400:	e7933182 	ldr	r3, [r3, r2, lsl #3]
7001a404:	e1a00003 	mov	r0, r3
7001a408:	e51b1014 	ldr	r1, [fp, #-20]
7001a40c:	fa00227c 	blx	70022e04 <strcmp>
7001a410:	e1a03000 	mov	r3, r0
7001a414:	e3530000 	cmp	r3, #0
7001a418:	1a00000b 	bne	7001a44c <token_match_name+0x78>
		{
			self->current_token = finsh_name_table[i].type;
7001a41c:	e308317c 	movw	r3, #33148	; 0x817c
7001a420:	e3473002 	movt	r3, #28674	; 0x7002
7001a424:	e51b1008 	ldr	r1, [fp, #-8]
7001a428:	e3a02004 	mov	r2, #4
7001a42c:	e1a01181 	lsl	r1, r1, #3
7001a430:	e0833001 	add	r3, r3, r1
7001a434:	e0833002 	add	r3, r3, r2
7001a438:	e5d32000 	ldrb	r2, [r3]
7001a43c:	e51b3010 	ldr	r3, [fp, #-16]
7001a440:	e5c32008 	strb	r2, [r3, #8]
			return 1;
7001a444:	e3a03001 	mov	r3, #1
7001a448:	ea000006 	b	7001a468 <token_match_name+0x94>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
7001a44c:	e51b3008 	ldr	r3, [fp, #-8]
7001a450:	e2833001 	add	r3, r3, #1
7001a454:	e50b3008 	str	r3, [fp, #-8]
7001a458:	e51b3008 	ldr	r3, [fp, #-8]
7001a45c:	e3530007 	cmp	r3, #7
7001a460:	9affffe3 	bls	7001a3f4 <token_match_name+0x20>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
7001a464:	e3a03000 	mov	r3, #0
}
7001a468:	e1a00003 	mov	r0, r3
7001a46c:	e24bd004 	sub	sp, fp, #4
7001a470:	e8bd8800 	pop	{fp, pc}

7001a474 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
7001a474:	e92d4800 	push	{fp, lr}
7001a478:	e28db004 	add	fp, sp, #4
7001a47c:	e24dd010 	sub	sp, sp, #16
7001a480:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
7001a484:	e51b0010 	ldr	r0, [fp, #-16]
7001a488:	ebfffe5f 	bl	70019e0c <token_next_char>
7001a48c:	e1a03000 	mov	r3, r0
7001a490:	e54b3005 	strb	r3, [fp, #-5]
7001a494:	e55b3005 	ldrb	r3, [fp, #-5]
7001a498:	e3530020 	cmp	r3, #32
7001a49c:	0afffff8 	beq	7001a484 <token_trim_space+0x10>
7001a4a0:	e55b3005 	ldrb	r3, [fp, #-5]
7001a4a4:	e3530009 	cmp	r3, #9
7001a4a8:	0afffff5 	beq	7001a484 <token_trim_space+0x10>
        ch == '\t' || 
7001a4ac:	e55b3005 	ldrb	r3, [fp, #-5]
7001a4b0:	e353000d 	cmp	r3, #13
7001a4b4:	0afffff2 	beq	7001a484 <token_trim_space+0x10>
        ch == '\r');

	token_prev_char(self);
7001a4b8:	e51b0010 	ldr	r0, [fp, #-16]
7001a4bc:	ebfffe81 	bl	70019ec8 <token_prev_char>
}
7001a4c0:	e24bd004 	sub	sp, fp, #4
7001a4c4:	e8bd8800 	pop	{fp, pc}

7001a4c8 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
7001a4c8:	e92d4800 	push	{fp, lr}
7001a4cc:	e28db004 	add	fp, sp, #4
7001a4d0:	e24dd018 	sub	sp, sp, #24
7001a4d4:	e50b0018 	str	r0, [fp, #-24]
	char ch;
	char buf[4], *p;

	p = buf;
7001a4d8:	e24b3010 	sub	r3, fp, #16
7001a4dc:	e50b300c 	str	r3, [fp, #-12]
	ch = token_next_char(self);
7001a4e0:	e51b0018 	ldr	r0, [fp, #-24]
7001a4e4:	ebfffe48 	bl	70019e0c <token_next_char>
7001a4e8:	e1a03000 	mov	r3, r0
7001a4ec:	e54b3005 	strb	r3, [fp, #-5]

	if ( ch == '\\' )
7001a4f0:	e55b3005 	ldrb	r3, [fp, #-5]
7001a4f4:	e353005c 	cmp	r3, #92	; 0x5c
7001a4f8:	1a000044 	bne	7001a610 <token_proc_char+0x148>
	{
		ch = token_next_char(self);
7001a4fc:	e51b0018 	ldr	r0, [fp, #-24]
7001a500:	ebfffe41 	bl	70019e0c <token_next_char>
7001a504:	e1a03000 	mov	r3, r0
7001a508:	e54b3005 	strb	r3, [fp, #-5]
		switch ( ch )
7001a50c:	e55b3005 	ldrb	r3, [fp, #-5]
7001a510:	e353006e 	cmp	r3, #110	; 0x6e
7001a514:	0a00000f 	beq	7001a558 <token_proc_char+0x90>
7001a518:	e353006e 	cmp	r3, #110	; 0x6e
7001a51c:	ca000006 	bgt	7001a53c <token_proc_char+0x74>
7001a520:	e353005c 	cmp	r3, #92	; 0x5c
7001a524:	0a00001a 	beq	7001a594 <token_proc_char+0xcc>
7001a528:	e3530062 	cmp	r3, #98	; 0x62
7001a52c:	0a000012 	beq	7001a57c <token_proc_char+0xb4>
7001a530:	e3530027 	cmp	r3, #39	; 0x27
7001a534:	0a000019 	beq	7001a5a0 <token_proc_char+0xd8>
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
7001a538:	ea000024 	b	7001a5d0 <token_proc_char+0x108>
	ch = token_next_char(self);

	if ( ch == '\\' )
	{
		ch = token_next_char(self);
		switch ( ch )
7001a53c:	e3530074 	cmp	r3, #116	; 0x74
7001a540:	0a000007 	beq	7001a564 <token_proc_char+0x9c>
7001a544:	e3530076 	cmp	r3, #118	; 0x76
7001a548:	0a000008 	beq	7001a570 <token_proc_char+0xa8>
7001a54c:	e3530072 	cmp	r3, #114	; 0x72
7001a550:	0a00000c 	beq	7001a588 <token_proc_char+0xc0>
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
7001a554:	ea00001d 	b	7001a5d0 <token_proc_char+0x108>
	if ( ch == '\\' )
	{
		ch = token_next_char(self);
		switch ( ch )
		{
		case 'n': ch = '\n'; break;
7001a558:	e3a0300a 	mov	r3, #10
7001a55c:	e54b3005 	strb	r3, [fp, #-5]
7001a560:	ea00002a 	b	7001a610 <token_proc_char+0x148>
		case 't': ch = '\t'; break;
7001a564:	e3a03009 	mov	r3, #9
7001a568:	e54b3005 	strb	r3, [fp, #-5]
7001a56c:	ea000027 	b	7001a610 <token_proc_char+0x148>
		case 'v': ch = '\v'; break;
7001a570:	e3a0300b 	mov	r3, #11
7001a574:	e54b3005 	strb	r3, [fp, #-5]
7001a578:	ea000024 	b	7001a610 <token_proc_char+0x148>
		case 'b': ch = '\b'; break;
7001a57c:	e3a03008 	mov	r3, #8
7001a580:	e54b3005 	strb	r3, [fp, #-5]
7001a584:	ea000021 	b	7001a610 <token_proc_char+0x148>
		case 'r': ch = '\r'; break;
7001a588:	e3a0300d 	mov	r3, #13
7001a58c:	e54b3005 	strb	r3, [fp, #-5]
7001a590:	ea00001e 	b	7001a610 <token_proc_char+0x148>
		case '\\': ch = '\\';  break;
7001a594:	e3a0305c 	mov	r3, #92	; 0x5c
7001a598:	e54b3005 	strb	r3, [fp, #-5]
7001a59c:	ea00001b 	b	7001a610 <token_proc_char+0x148>
		case '\'': ch = '\'';  break;
7001a5a0:	e3a03027 	mov	r3, #39	; 0x27
7001a5a4:	e54b3005 	strb	r3, [fp, #-5]
7001a5a8:	ea000018 	b	7001a610 <token_proc_char+0x148>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
			{
				ch = token_next_char(self);
7001a5ac:	e51b0018 	ldr	r0, [fp, #-24]
7001a5b0:	ebfffe15 	bl	70019e0c <token_next_char>
7001a5b4:	e1a03000 	mov	r3, r0
7001a5b8:	e54b3005 	strb	r3, [fp, #-5]
				*p++ = ch;
7001a5bc:	e51b300c 	ldr	r3, [fp, #-12]
7001a5c0:	e2832001 	add	r2, r3, #1
7001a5c4:	e50b200c 	str	r2, [fp, #-12]
7001a5c8:	e55b2005 	ldrb	r2, [fp, #-5]
7001a5cc:	e5c32000 	strb	r2, [r3]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
7001a5d0:	e55b3005 	ldrb	r3, [fp, #-5]
7001a5d4:	e353002f 	cmp	r3, #47	; 0x2f
7001a5d8:	9a000002 	bls	7001a5e8 <token_proc_char+0x120>
7001a5dc:	e55b3005 	ldrb	r3, [fp, #-5]
7001a5e0:	e3530039 	cmp	r3, #57	; 0x39
7001a5e4:	9afffff0 	bls	7001a5ac <token_proc_char+0xe4>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
7001a5e8:	e51b0018 	ldr	r0, [fp, #-24]
7001a5ec:	ebfffe35 	bl	70019ec8 <token_prev_char>
			*p = '\0';
7001a5f0:	e51b300c 	ldr	r3, [fp, #-12]
7001a5f4:	e3a02000 	mov	r2, #0
7001a5f8:	e5c32000 	strb	r2, [r3]
			ch = atoi(p);
7001a5fc:	e51b000c 	ldr	r0, [fp, #-12]
7001a600:	fa002626 	blx	70023ea0 <atoi>
7001a604:	e1a03000 	mov	r3, r0
7001a608:	e54b3005 	strb	r3, [fp, #-5]
			break;
7001a60c:	e1a00000 	nop			; (mov r0, r0)
		}
	}

	if ( token_next_char(self) != '\'' )
7001a610:	e51b0018 	ldr	r0, [fp, #-24]
7001a614:	ebfffdfc 	bl	70019e0c <token_next_char>
7001a618:	e1a03000 	mov	r3, r0
7001a61c:	e3530027 	cmp	r3, #39	; 0x27
7001a620:	0a000005 	beq	7001a63c <token_proc_char+0x174>
	{
		token_prev_char(self);
7001a624:	e51b0018 	ldr	r0, [fp, #-24]
7001a628:	ebfffe26 	bl	70019ec8 <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
7001a62c:	e3a00009 	mov	r0, #9
7001a630:	ebffebca 	bl	70015560 <finsh_error_set>
		return ch;
7001a634:	e55b3005 	ldrb	r3, [fp, #-5]
7001a638:	ea000000 	b	7001a640 <token_proc_char+0x178>
	}

	return ch;
7001a63c:	e55b3005 	ldrb	r3, [fp, #-5]
}
7001a640:	e1a00003 	mov	r0, r3
7001a644:	e24bd004 	sub	sp, fp, #4
7001a648:	e8bd8800 	pop	{fp, pc}

7001a64c <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
7001a64c:	e92d4800 	push	{fp, lr}
7001a650:	e28db004 	add	fp, sp, #4
7001a654:	e24dd010 	sub	sp, sp, #16
7001a658:	e50b0010 	str	r0, [fp, #-16]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
7001a65c:	e51b3010 	ldr	r3, [fp, #-16]
7001a660:	e2833010 	add	r3, r3, #16
7001a664:	e50b3008 	str	r3, [fp, #-8]
7001a668:	ea000021 	b	7001a6f4 <token_proc_string+0xa8>
	{
		char ch = token_next_char(self);
7001a66c:	e51b0010 	ldr	r0, [fp, #-16]
7001a670:	ebfffde5 	bl	70019e0c <token_next_char>
7001a674:	e1a03000 	mov	r3, r0
7001a678:	e54b3009 	strb	r3, [fp, #-9]

		if ( is_eof(self) )
7001a67c:	e51b3010 	ldr	r3, [fp, #-16]
7001a680:	e5d33000 	ldrb	r3, [r3]
7001a684:	e3530000 	cmp	r3, #0
7001a688:	0a000003 	beq	7001a69c <token_proc_string+0x50>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
7001a68c:	e3a0000a 	mov	r0, #10
7001a690:	ebffebb2 	bl	70015560 <finsh_error_set>
			return NULL;;
7001a694:	e3a03000 	mov	r3, #0
7001a698:	ea00001c 	b	7001a710 <token_proc_string+0xc4>
		}
		if ( ch == '\\' )
7001a69c:	e55b3009 	ldrb	r3, [fp, #-9]
7001a6a0:	e353005c 	cmp	r3, #92	; 0x5c
7001a6a4:	1a000004 	bne	7001a6bc <token_proc_string+0x70>
		{
			ch = token_proc_escape(self);
7001a6a8:	e51b0010 	ldr	r0, [fp, #-16]
7001a6ac:	eb00001a 	bl	7001a71c <token_proc_escape>
7001a6b0:	e1a03000 	mov	r3, r0
7001a6b4:	e54b3009 	strb	r3, [fp, #-9]
7001a6b8:	ea000008 	b	7001a6e0 <token_proc_string+0x94>
		}
		else if ( ch == '"' )/*end of string.*/
7001a6bc:	e55b3009 	ldrb	r3, [fp, #-9]
7001a6c0:	e3530022 	cmp	r3, #34	; 0x22
7001a6c4:	1a000005 	bne	7001a6e0 <token_proc_string+0x94>
		{
			*p = '\0';
7001a6c8:	e51b3008 	ldr	r3, [fp, #-8]
7001a6cc:	e3a02000 	mov	r2, #0
7001a6d0:	e5c32000 	strb	r2, [r3]
			return self->string;
7001a6d4:	e51b3010 	ldr	r3, [fp, #-16]
7001a6d8:	e2833010 	add	r3, r3, #16
7001a6dc:	ea00000b 	b	7001a710 <token_proc_string+0xc4>
		}

		*p++ = ch;
7001a6e0:	e51b3008 	ldr	r3, [fp, #-8]
7001a6e4:	e2832001 	add	r2, r3, #1
7001a6e8:	e50b2008 	str	r2, [fp, #-8]
7001a6ec:	e55b2009 	ldrb	r2, [fp, #-9]
7001a6f0:	e5c32000 	strb	r2, [r3]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
7001a6f4:	e51b2008 	ldr	r2, [fp, #-8]
7001a6f8:	e51b3010 	ldr	r3, [fp, #-16]
7001a6fc:	e2833010 	add	r3, r3, #16
7001a700:	e0633002 	rsb	r3, r3, r2
7001a704:	e353007f 	cmp	r3, #127	; 0x7f
7001a708:	daffffd7 	ble	7001a66c <token_proc_string+0x20>
		}

		*p++ = ch;
	}

	return NULL;
7001a70c:	e3a03000 	mov	r3, #0
}
7001a710:	e1a00003 	mov	r0, r3
7001a714:	e24bd004 	sub	sp, fp, #4
7001a718:	e8bd8800 	pop	{fp, pc}

7001a71c <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
7001a71c:	e92d4800 	push	{fp, lr}
7001a720:	e28db004 	add	fp, sp, #4
7001a724:	e24dd010 	sub	sp, sp, #16
7001a728:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	int result=0;
7001a72c:	e3a03000 	mov	r3, #0
7001a730:	e50b300c 	str	r3, [fp, #-12]

	ch = token_next_char(self);
7001a734:	e51b0010 	ldr	r0, [fp, #-16]
7001a738:	ebfffdb3 	bl	70019e0c <token_next_char>
7001a73c:	e1a03000 	mov	r3, r0
7001a740:	e54b3005 	strb	r3, [fp, #-5]
	switch (ch)
7001a744:	e55b3005 	ldrb	r3, [fp, #-5]
7001a748:	e2433061 	sub	r3, r3, #97	; 0x61
7001a74c:	e3530017 	cmp	r3, #23
7001a750:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
7001a754:	ea000044 	b	7001a86c <token_proc_escape+0x150>
7001a758:	7001a800 	.word	0x7001a800
7001a75c:	7001a7dc 	.word	0x7001a7dc
7001a760:	7001a86c 	.word	0x7001a86c
7001a764:	7001a86c 	.word	0x7001a86c
7001a768:	7001a86c 	.word	0x7001a86c
7001a76c:	7001a7f4 	.word	0x7001a7f4
7001a770:	7001a86c 	.word	0x7001a86c
7001a774:	7001a86c 	.word	0x7001a86c
7001a778:	7001a86c 	.word	0x7001a86c
7001a77c:	7001a86c 	.word	0x7001a86c
7001a780:	7001a86c 	.word	0x7001a86c
7001a784:	7001a86c 	.word	0x7001a86c
7001a788:	7001a86c 	.word	0x7001a86c
7001a78c:	7001a7b8 	.word	0x7001a7b8
7001a790:	7001a86c 	.word	0x7001a86c
7001a794:	7001a86c 	.word	0x7001a86c
7001a798:	7001a86c 	.word	0x7001a86c
7001a79c:	7001a7e8 	.word	0x7001a7e8
7001a7a0:	7001a86c 	.word	0x7001a86c
7001a7a4:	7001a7c4 	.word	0x7001a7c4
7001a7a8:	7001a86c 	.word	0x7001a86c
7001a7ac:	7001a7d0 	.word	0x7001a7d0
7001a7b0:	7001a86c 	.word	0x7001a86c
7001a7b4:	7001a80c 	.word	0x7001a80c
	{
	case 'n':
		result = '\n';
7001a7b8:	e3a0300a 	mov	r3, #10
7001a7bc:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7c0:	ea000042 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 't':
		result = '\t';
7001a7c4:	e3a03009 	mov	r3, #9
7001a7c8:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7cc:	ea00003f 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'v':
		result = '\v';
7001a7d0:	e3a0300b 	mov	r3, #11
7001a7d4:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7d8:	ea00003c 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'b':
		result = '\b';
7001a7dc:	e3a03008 	mov	r3, #8
7001a7e0:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7e4:	ea000039 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'r':
		result = '\r';
7001a7e8:	e3a0300d 	mov	r3, #13
7001a7ec:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7f0:	ea000036 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'f':
		result = '\f';
7001a7f4:	e3a0300c 	mov	r3, #12
7001a7f8:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a7fc:	ea000033 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'a':
		result = '\007';
7001a800:	e3a03007 	mov	r3, #7
7001a804:	e50b300c 	str	r3, [fp, #-12]
		break;
7001a808:	ea000030 	b	7001a8d0 <token_proc_escape+0x1b4>
	case 'x':
		result = 0;
7001a80c:	e3a03000 	mov	r3, #0
7001a810:	e50b300c 	str	r3, [fp, #-12]
		ch  = token_next_char(self);
7001a814:	e51b0010 	ldr	r0, [fp, #-16]
7001a818:	ebfffd7b 	bl	70019e0c <token_next_char>
7001a81c:	e1a03000 	mov	r3, r0
7001a820:	e54b3005 	strb	r3, [fp, #-5]
		while ( (ch - '0')<16u )
7001a824:	ea000009 	b	7001a850 <token_proc_escape+0x134>
		{
			result = result*16 + ch - '0';
7001a828:	e51b300c 	ldr	r3, [fp, #-12]
7001a82c:	e1a02203 	lsl	r2, r3, #4
7001a830:	e55b3005 	ldrb	r3, [fp, #-5]
7001a834:	e0823003 	add	r3, r2, r3
7001a838:	e2433030 	sub	r3, r3, #48	; 0x30
7001a83c:	e50b300c 	str	r3, [fp, #-12]
			ch = token_next_char(self);
7001a840:	e51b0010 	ldr	r0, [fp, #-16]
7001a844:	ebfffd70 	bl	70019e0c <token_next_char>
7001a848:	e1a03000 	mov	r3, r0
7001a84c:	e54b3005 	strb	r3, [fp, #-5]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
7001a850:	e55b3005 	ldrb	r3, [fp, #-5]
7001a854:	e2433030 	sub	r3, r3, #48	; 0x30
7001a858:	e353000f 	cmp	r3, #15
7001a85c:	9afffff1 	bls	7001a828 <token_proc_escape+0x10c>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
7001a860:	e51b0010 	ldr	r0, [fp, #-16]
7001a864:	ebfffd97 	bl	70019ec8 <token_prev_char>
		break;
7001a868:	ea000018 	b	7001a8d0 <token_proc_escape+0x1b4>
	default:
		if ( (ch - '0') < 8u)
7001a86c:	e55b3005 	ldrb	r3, [fp, #-5]
7001a870:	e2433030 	sub	r3, r3, #48	; 0x30
7001a874:	e3530007 	cmp	r3, #7
7001a878:	8a000013 	bhi	7001a8cc <token_proc_escape+0x1b0>
		{
			result = 0;
7001a87c:	e3a03000 	mov	r3, #0
7001a880:	e50b300c 	str	r3, [fp, #-12]
			while ( (ch - '0') < 8u )
7001a884:	ea000009 	b	7001a8b0 <token_proc_escape+0x194>
			{
				result = result*8 + ch - '0';
7001a888:	e51b300c 	ldr	r3, [fp, #-12]
7001a88c:	e1a02183 	lsl	r2, r3, #3
7001a890:	e55b3005 	ldrb	r3, [fp, #-5]
7001a894:	e0823003 	add	r3, r2, r3
7001a898:	e2433030 	sub	r3, r3, #48	; 0x30
7001a89c:	e50b300c 	str	r3, [fp, #-12]
				ch = token_next_char(self);
7001a8a0:	e51b0010 	ldr	r0, [fp, #-16]
7001a8a4:	ebfffd58 	bl	70019e0c <token_next_char>
7001a8a8:	e1a03000 	mov	r3, r0
7001a8ac:	e54b3005 	strb	r3, [fp, #-5]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
7001a8b0:	e55b3005 	ldrb	r3, [fp, #-5]
7001a8b4:	e2433030 	sub	r3, r3, #48	; 0x30
7001a8b8:	e3530007 	cmp	r3, #7
7001a8bc:	9afffff1 	bls	7001a888 <token_proc_escape+0x16c>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
7001a8c0:	e51b0010 	ldr	r0, [fp, #-16]
7001a8c4:	ebfffd7f 	bl	70019ec8 <token_prev_char>
		}
		break;
7001a8c8:	eaffffff 	b	7001a8cc <token_proc_escape+0x1b0>
7001a8cc:	e1a00000 	nop			; (mov r0, r0)
	}

	return result;
7001a8d0:	e51b300c 	ldr	r3, [fp, #-12]
}
7001a8d4:	e1a00003 	mov	r0, r3
7001a8d8:	e24bd004 	sub	sp, fp, #4
7001a8dc:	e8bd8800 	pop	{fp, pc}

7001a8e0 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
7001a8e0:	e92d4800 	push	{fp, lr}
7001a8e4:	e28db004 	add	fp, sp, #4
7001a8e8:	e24dd098 	sub	sp, sp, #152	; 0x98
7001a8ec:	e50b0098 	str	r0, [fp, #-152]	; 0x98
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
7001a8f0:	e3a03000 	mov	r3, #0
7001a8f4:	e50b3010 	str	r3, [fp, #-16]
	p = buf;
7001a8f8:	e24b3094 	sub	r3, fp, #148	; 0x94
7001a8fc:	e50b300c 	str	r3, [fp, #-12]

	ch  = token_next_char(self);
7001a900:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001a904:	ebfffd40 	bl	70019e0c <token_next_char>
7001a908:	e1a03000 	mov	r3, r0
7001a90c:	e54b3005 	strb	r3, [fp, #-5]
	if ( ch == '0' )
7001a910:	e55b3005 	ldrb	r3, [fp, #-5]
7001a914:	e3530030 	cmp	r3, #48	; 0x30
7001a918:	1a00007e 	bne	7001ab18 <token_proc_number+0x238>
	{
		int b;
		ch = token_next_char(self);
7001a91c:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001a920:	ebfffd39 	bl	70019e0c <token_next_char>
7001a924:	e1a03000 	mov	r3, r0
7001a928:	e54b3005 	strb	r3, [fp, #-5]
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
7001a92c:	e55b3005 	ldrb	r3, [fp, #-5]
7001a930:	e3530078 	cmp	r3, #120	; 0x78
7001a934:	0a000002 	beq	7001a944 <token_proc_number+0x64>
7001a938:	e55b3005 	ldrb	r3, [fp, #-5]
7001a93c:	e3530058 	cmp	r3, #88	; 0x58
7001a940:	1a00001f 	bne	7001a9c4 <token_proc_number+0xe4>
		{
			b = 16;
7001a944:	e3a03010 	mov	r3, #16
7001a948:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
7001a94c:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001a950:	ebfffd2d 	bl	70019e0c <token_next_char>
7001a954:	e1a03000 	mov	r3, r0
7001a958:	e54b3005 	strb	r3, [fp, #-5]
			while ( is_digit(ch) || is_alpha(ch) )
7001a95c:	ea000008 	b	7001a984 <token_proc_number+0xa4>
			{
				*p++ = ch;
7001a960:	e51b300c 	ldr	r3, [fp, #-12]
7001a964:	e2832001 	add	r2, r3, #1
7001a968:	e50b200c 	str	r2, [fp, #-12]
7001a96c:	e55b2005 	ldrb	r2, [fp, #-5]
7001a970:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
7001a974:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001a978:	ebfffd23 	bl	70019e0c <token_next_char>
7001a97c:	e1a03000 	mov	r3, r0
7001a980:	e54b3005 	strb	r3, [fp, #-5]
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
7001a984:	e55b3005 	ldrb	r3, [fp, #-5]
7001a988:	e353002f 	cmp	r3, #47	; 0x2f
7001a98c:	9a000002 	bls	7001a99c <token_proc_number+0xbc>
7001a990:	e55b3005 	ldrb	r3, [fp, #-5]
7001a994:	e3530039 	cmp	r3, #57	; 0x39
7001a998:	9afffff0 	bls	7001a960 <token_proc_number+0x80>
7001a99c:	e55b3005 	ldrb	r3, [fp, #-5]
7001a9a0:	e3833020 	orr	r3, r3, #32
7001a9a4:	e6ef3073 	uxtb	r3, r3
7001a9a8:	e2433061 	sub	r3, r3, #97	; 0x61
7001a9ac:	e3530019 	cmp	r3, #25
7001a9b0:	9affffea 	bls	7001a960 <token_proc_number+0x80>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
7001a9b4:	e51b300c 	ldr	r3, [fp, #-12]
7001a9b8:	e3a02000 	mov	r2, #0
7001a9bc:	e5c32000 	strb	r2, [r3]
7001a9c0:	ea000044 	b	7001aad8 <token_proc_number+0x1f8>
		}
		else if ( ch == 'b' || ch == 'B' )
7001a9c4:	e55b3005 	ldrb	r3, [fp, #-5]
7001a9c8:	e3530062 	cmp	r3, #98	; 0x62
7001a9cc:	0a000002 	beq	7001a9dc <token_proc_number+0xfc>
7001a9d0:	e55b3005 	ldrb	r3, [fp, #-5]
7001a9d4:	e3530042 	cmp	r3, #66	; 0x42
7001a9d8:	1a000019 	bne	7001aa44 <token_proc_number+0x164>
		{
			b = 2;
7001a9dc:	e3a03002 	mov	r3, #2
7001a9e0:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
7001a9e4:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001a9e8:	ebfffd07 	bl	70019e0c <token_next_char>
7001a9ec:	e1a03000 	mov	r3, r0
7001a9f0:	e54b3005 	strb	r3, [fp, #-5]
			while ( (ch=='0')||(ch=='1') )
7001a9f4:	ea000008 	b	7001aa1c <token_proc_number+0x13c>
			{
				*p++ = ch;
7001a9f8:	e51b300c 	ldr	r3, [fp, #-12]
7001a9fc:	e2832001 	add	r2, r3, #1
7001aa00:	e50b200c 	str	r2, [fp, #-12]
7001aa04:	e55b2005 	ldrb	r2, [fp, #-5]
7001aa08:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
7001aa0c:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001aa10:	ebfffcfd 	bl	70019e0c <token_next_char>
7001aa14:	e1a03000 	mov	r3, r0
7001aa18:	e54b3005 	strb	r3, [fp, #-5]
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
7001aa1c:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa20:	e3530030 	cmp	r3, #48	; 0x30
7001aa24:	0afffff3 	beq	7001a9f8 <token_proc_number+0x118>
7001aa28:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa2c:	e3530031 	cmp	r3, #49	; 0x31
7001aa30:	0afffff0 	beq	7001a9f8 <token_proc_number+0x118>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
7001aa34:	e51b300c 	ldr	r3, [fp, #-12]
7001aa38:	e3a02000 	mov	r2, #0
7001aa3c:	e5c32000 	strb	r2, [r3]
7001aa40:	ea000024 	b	7001aad8 <token_proc_number+0x1f8>
		}
		else if ( '0' <= ch && ch <= '7' )
7001aa44:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa48:	e353002f 	cmp	r3, #47	; 0x2f
7001aa4c:	9a000018 	bls	7001aab4 <token_proc_number+0x1d4>
7001aa50:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa54:	e3530037 	cmp	r3, #55	; 0x37
7001aa58:	8a000015 	bhi	7001aab4 <token_proc_number+0x1d4>
		{
			b = 8;
7001aa5c:	e3a03008 	mov	r3, #8
7001aa60:	e50b3014 	str	r3, [fp, #-20]
			while ( '0' <= ch && ch <= '7' )
7001aa64:	ea000008 	b	7001aa8c <token_proc_number+0x1ac>
			{
				*p++ = ch;
7001aa68:	e51b300c 	ldr	r3, [fp, #-12]
7001aa6c:	e2832001 	add	r2, r3, #1
7001aa70:	e50b200c 	str	r2, [fp, #-12]
7001aa74:	e55b2005 	ldrb	r2, [fp, #-5]
7001aa78:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
7001aa7c:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001aa80:	ebfffce1 	bl	70019e0c <token_next_char>
7001aa84:	e1a03000 	mov	r3, r0
7001aa88:	e54b3005 	strb	r3, [fp, #-5]
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
7001aa8c:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa90:	e353002f 	cmp	r3, #47	; 0x2f
7001aa94:	9a000002 	bls	7001aaa4 <token_proc_number+0x1c4>
7001aa98:	e55b3005 	ldrb	r3, [fp, #-5]
7001aa9c:	e3530037 	cmp	r3, #55	; 0x37
7001aaa0:	9afffff0 	bls	7001aa68 <token_proc_number+0x188>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
7001aaa4:	e51b300c 	ldr	r3, [fp, #-12]
7001aaa8:	e3a02000 	mov	r2, #0
7001aaac:	e5c32000 	strb	r2, [r3]
7001aab0:	ea000008 	b	7001aad8 <token_proc_number+0x1f8>
		}
		else
		{
			token_prev_char(self);
7001aab4:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001aab8:	ebfffd02 	bl	70019ec8 <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
7001aabc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001aac0:	e3a02000 	mov	r2, #0
7001aac4:	e583200c 	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
7001aac8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001aacc:	e3a0201b 	mov	r2, #27
7001aad0:	e5c32008 	strb	r2, [r3, #8]
			return;
7001aad4:	ea000036 	b	7001abb4 <token_proc_number+0x2d4>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
7001aad8:	e24b3094 	sub	r3, fp, #148	; 0x94
7001aadc:	e1a00003 	mov	r0, r3
7001aae0:	fa002613 	blx	70024334 <strlen>
7001aae4:	e1a03000 	mov	r3, r0
7001aae8:	e24b2094 	sub	r2, fp, #148	; 0x94
7001aaec:	e1a00002 	mov	r0, r2
7001aaf0:	e1a01003 	mov	r1, r3
7001aaf4:	e51b2014 	ldr	r2, [fp, #-20]
7001aaf8:	eb00002f 	bl	7001abbc <token_spec_number>
7001aafc:	e1a02000 	mov	r2, r0
7001ab00:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001ab04:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
7001ab08:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001ab0c:	e3a0201b 	mov	r2, #27
7001ab10:	e5c32008 	strb	r2, [r3, #8]
7001ab14:	ea00001a 	b	7001ab84 <token_proc_number+0x2a4>
	}
	else
	{
		while ( is_digit(ch) )
7001ab18:	ea00000d 	b	7001ab54 <token_proc_number+0x274>
		{
			value = value*10 + ( ch - '0' );
7001ab1c:	e51b2010 	ldr	r2, [fp, #-16]
7001ab20:	e1a03002 	mov	r3, r2
7001ab24:	e1a03103 	lsl	r3, r3, #2
7001ab28:	e0833002 	add	r3, r3, r2
7001ab2c:	e1a03083 	lsl	r3, r3, #1
7001ab30:	e1a02003 	mov	r2, r3
7001ab34:	e55b3005 	ldrb	r3, [fp, #-5]
7001ab38:	e2433030 	sub	r3, r3, #48	; 0x30
7001ab3c:	e0823003 	add	r3, r2, r3
7001ab40:	e50b3010 	str	r3, [fp, #-16]
			ch = token_next_char(self);
7001ab44:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001ab48:	ebfffcaf 	bl	70019e0c <token_next_char>
7001ab4c:	e1a03000 	mov	r3, r0
7001ab50:	e54b3005 	strb	r3, [fp, #-5]
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
7001ab54:	e55b3005 	ldrb	r3, [fp, #-5]
7001ab58:	e353002f 	cmp	r3, #47	; 0x2f
7001ab5c:	9a000002 	bls	7001ab6c <token_proc_number+0x28c>
7001ab60:	e55b3005 	ldrb	r3, [fp, #-5]
7001ab64:	e3530039 	cmp	r3, #57	; 0x39
7001ab68:	9affffeb 	bls	7001ab1c <token_proc_number+0x23c>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
7001ab6c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001ab70:	e51b2010 	ldr	r2, [fp, #-16]
7001ab74:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
7001ab78:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001ab7c:	e3a0201b 	mov	r2, #27
7001ab80:	e5c32008 	strb	r2, [r3, #8]
	}

	switch ( ch )
7001ab84:	e55b3005 	ldrb	r3, [fp, #-5]
7001ab88:	e353004c 	cmp	r3, #76	; 0x4c
7001ab8c:	0a000001 	beq	7001ab98 <token_proc_number+0x2b8>
7001ab90:	e353006c 	cmp	r3, #108	; 0x6c
7001ab94:	1a000003 	bne	7001aba8 <token_proc_number+0x2c8>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
7001ab98:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
7001ab9c:	e3a0201c 	mov	r2, #28
7001aba0:	e5c32008 	strb	r2, [r3, #8]
		break;
7001aba4:	ea000002 	b	7001abb4 <token_proc_number+0x2d4>

	default:
		token_prev_char(self);
7001aba8:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
7001abac:	ebfffcc5 	bl	70019ec8 <token_prev_char>
		break;
7001abb0:	e1a00000 	nop			; (mov r0, r0)
	}
}
7001abb4:	e24bd004 	sub	sp, fp, #4
7001abb8:	e8bd8800 	pop	{fp, pc}

7001abbc <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
7001abbc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001abc0:	e28db000 	add	fp, sp, #0
7001abc4:	e24dd03c 	sub	sp, sp, #60	; 0x3c
7001abc8:	e50b0030 	str	r0, [fp, #-48]	; 0x30
7001abcc:	e50b1034 	str	r1, [fp, #-52]	; 0x34
7001abd0:	e50b2038 	str	r2, [fp, #-56]	; 0x38
	char* p;
	int t;
	int i, j, shift=1;
7001abd4:	e3a03001 	mov	r3, #1
7001abd8:	e50b3018 	str	r3, [fp, #-24]
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
7001abdc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7001abe0:	e50b3008 	str	r3, [fp, #-8]
	i = 0;
7001abe4:	e3a03000 	mov	r3, #0
7001abe8:	e50b3010 	str	r3, [fp, #-16]

	switch ( b )
7001abec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
7001abf0:	e3530008 	cmp	r3, #8
7001abf4:	0a000007 	beq	7001ac18 <token_spec_number+0x5c>
7001abf8:	e3530010 	cmp	r3, #16
7001abfc:	0a000002 	beq	7001ac0c <token_spec_number+0x50>
7001ac00:	e3530002 	cmp	r3, #2
7001ac04:	0a000006 	beq	7001ac24 <token_spec_number+0x68>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
7001ac08:	ea000008 	b	7001ac30 <token_spec_number+0x74>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
7001ac0c:	e3a03004 	mov	r3, #4
7001ac10:	e50b3018 	str	r3, [fp, #-24]
		break;
7001ac14:	ea000005 	b	7001ac30 <token_spec_number+0x74>
	case 8:  shift = 3;
7001ac18:	e3a03003 	mov	r3, #3
7001ac1c:	e50b3018 	str	r3, [fp, #-24]
		break;
7001ac20:	ea000002 	b	7001ac30 <token_spec_number+0x74>
	case 2:  shift = 1;
7001ac24:	e3a03001 	mov	r3, #1
7001ac28:	e50b3018 	str	r3, [fp, #-24]
		break;
7001ac2c:	e1a00000 	nop			; (mov r0, r0)
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
7001ac30:	e3a03000 	mov	r3, #0
7001ac34:	e50b3014 	str	r3, [fp, #-20]
7001ac38:	ea00000a 	b	7001ac68 <token_spec_number+0xac>
7001ac3c:	e51b2014 	ldr	r2, [fp, #-20]
7001ac40:	e3e03023 	mvn	r3, #35	; 0x23
7001ac44:	e1a02102 	lsl	r2, r2, #2
7001ac48:	e24b0004 	sub	r0, fp, #4
7001ac4c:	e0802002 	add	r2, r0, r2
7001ac50:	e0823003 	add	r3, r2, r3
7001ac54:	e3a02000 	mov	r2, #0
7001ac58:	e5832000 	str	r2, [r3]
7001ac5c:	e51b3014 	ldr	r3, [fp, #-20]
7001ac60:	e2833001 	add	r3, r3, #1
7001ac64:	e50b3014 	str	r3, [fp, #-20]
7001ac68:	e51b3014 	ldr	r3, [fp, #-20]
7001ac6c:	e3530001 	cmp	r3, #1
7001ac70:	dafffff1 	ble	7001ac3c <token_spec_number+0x80>

	while ( i<length )
7001ac74:	ea000040 	b	7001ad7c <token_spec_number+0x1c0>
	{
		t = *p++;
7001ac78:	e51b3008 	ldr	r3, [fp, #-8]
7001ac7c:	e2832001 	add	r2, r3, #1
7001ac80:	e50b2008 	str	r2, [fp, #-8]
7001ac84:	e5d33000 	ldrb	r3, [r3]
7001ac88:	e50b300c 	str	r3, [fp, #-12]
		if ( t>='a' && t <='f' )
7001ac8c:	e51b300c 	ldr	r3, [fp, #-12]
7001ac90:	e3530060 	cmp	r3, #96	; 0x60
7001ac94:	da000006 	ble	7001acb4 <token_spec_number+0xf8>
7001ac98:	e51b300c 	ldr	r3, [fp, #-12]
7001ac9c:	e3530066 	cmp	r3, #102	; 0x66
7001aca0:	ca000003 	bgt	7001acb4 <token_spec_number+0xf8>
		{
			t = t - 'a' +10;
7001aca4:	e51b300c 	ldr	r3, [fp, #-12]
7001aca8:	e2433057 	sub	r3, r3, #87	; 0x57
7001acac:	e50b300c 	str	r3, [fp, #-12]
7001acb0:	ea00000c 	b	7001ace8 <token_spec_number+0x12c>
		}
		else if ( t >='A' && t <='F' )
7001acb4:	e51b300c 	ldr	r3, [fp, #-12]
7001acb8:	e3530040 	cmp	r3, #64	; 0x40
7001acbc:	da000006 	ble	7001acdc <token_spec_number+0x120>
7001acc0:	e51b300c 	ldr	r3, [fp, #-12]
7001acc4:	e3530046 	cmp	r3, #70	; 0x46
7001acc8:	ca000003 	bgt	7001acdc <token_spec_number+0x120>
		{
			t = t - 'A' +10;
7001accc:	e51b300c 	ldr	r3, [fp, #-12]
7001acd0:	e2433037 	sub	r3, r3, #55	; 0x37
7001acd4:	e50b300c 	str	r3, [fp, #-12]
7001acd8:	ea000002 	b	7001ace8 <token_spec_number+0x12c>
		}
		else t = t - '0';
7001acdc:	e51b300c 	ldr	r3, [fp, #-12]
7001ace0:	e2433030 	sub	r3, r3, #48	; 0x30
7001ace4:	e50b300c 	str	r3, [fp, #-12]

		for ( j=0; j<BN_SIZE ; j++)
7001ace8:	e3a03000 	mov	r3, #0
7001acec:	e50b3014 	str	r3, [fp, #-20]
7001acf0:	ea00001b 	b	7001ad64 <token_spec_number+0x1a8>
		{
			v = bn[j];
7001acf4:	e51b2014 	ldr	r2, [fp, #-20]
7001acf8:	e3e03023 	mvn	r3, #35	; 0x23
7001acfc:	e1a02102 	lsl	r2, r2, #2
7001ad00:	e24b1004 	sub	r1, fp, #4
7001ad04:	e0812002 	add	r2, r1, r2
7001ad08:	e0823003 	add	r3, r2, r3
7001ad0c:	e5933000 	ldr	r3, [r3]
7001ad10:	e50b301c 	str	r3, [fp, #-28]
			bn[j] = (v<<shift) | t;
7001ad14:	e51b201c 	ldr	r2, [fp, #-28]
7001ad18:	e51b3018 	ldr	r3, [fp, #-24]
7001ad1c:	e1a02312 	lsl	r2, r2, r3
7001ad20:	e51b300c 	ldr	r3, [fp, #-12]
7001ad24:	e1822003 	orr	r2, r2, r3
7001ad28:	e51b1014 	ldr	r1, [fp, #-20]
7001ad2c:	e3e03023 	mvn	r3, #35	; 0x23
7001ad30:	e1a01101 	lsl	r1, r1, #2
7001ad34:	e24b0004 	sub	r0, fp, #4
7001ad38:	e0801001 	add	r1, r0, r1
7001ad3c:	e0813003 	add	r3, r1, r3
7001ad40:	e5832000 	str	r2, [r3]
			t = v >> (32 - shift);
7001ad44:	e51b3018 	ldr	r3, [fp, #-24]
7001ad48:	e2633020 	rsb	r3, r3, #32
7001ad4c:	e51b201c 	ldr	r2, [fp, #-28]
7001ad50:	e1a03332 	lsr	r3, r2, r3
7001ad54:	e50b300c 	str	r3, [fp, #-12]
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
7001ad58:	e51b3014 	ldr	r3, [fp, #-20]
7001ad5c:	e2833001 	add	r3, r3, #1
7001ad60:	e50b3014 	str	r3, [fp, #-20]
7001ad64:	e51b3014 	ldr	r3, [fp, #-20]
7001ad68:	e3530001 	cmp	r3, #1
7001ad6c:	daffffe0 	ble	7001acf4 <token_spec_number+0x138>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
7001ad70:	e51b3010 	ldr	r3, [fp, #-16]
7001ad74:	e2833001 	add	r3, r3, #1
7001ad78:	e50b3010 	str	r3, [fp, #-16]
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
7001ad7c:	e51b2010 	ldr	r2, [fp, #-16]
7001ad80:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
7001ad84:	e1520003 	cmp	r2, r3
7001ad88:	baffffba 	blt	7001ac78 <token_spec_number+0xbc>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
7001ad8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001ad90:	e50b3020 	str	r3, [fp, #-32]

	return d;
7001ad94:	e51b3020 	ldr	r3, [fp, #-32]
}
7001ad98:	e1a00003 	mov	r0, r3
7001ad9c:	e24bd000 	sub	sp, fp, #0
7001ada0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ada4:	e12fff1e 	bx	lr

7001ada8 <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
7001ada8:	e92d4800 	push	{fp, lr}
7001adac:	e28db004 	add	fp, sp, #4
7001adb0:	e24dd010 	sub	sp, sp, #16
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
7001adb4:	e3a03000 	mov	r3, #0
7001adb8:	e50b3010 	str	r3, [fp, #-16]
    device = rt_device_find("rtc");
7001adbc:	e30801bc 	movw	r0, #33212	; 0x81bc
7001adc0:	e3470002 	movt	r0, #28674	; 0x7002
7001adc4:	ebff9717 	bl	70000a28 <rt_device_find>
7001adc8:	e50b0008 	str	r0, [fp, #-8]
    if (device != RT_NULL)
7001adcc:	e51b3008 	ldr	r3, [fp, #-8]
7001add0:	e3530000 	cmp	r3, #0
7001add4:	0a000004 	beq	7001adec <clock_time_system_init+0x44>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
7001add8:	e24b3010 	sub	r3, fp, #16
7001addc:	e51b0008 	ldr	r0, [fp, #-8]
7001ade0:	e3a01010 	mov	r1, #16
7001ade4:	e1a02003 	mov	r2, r3
7001ade8:	ebff98f5 	bl	700011c4 <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
7001adec:	ebff9636 	bl	700006cc <rt_tick_get>
7001adf0:	e50b000c 	str	r0, [fp, #-12]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
7001adf4:	e51b200c 	ldr	r2, [fp, #-12]
7001adf8:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001adfc:	e3413062 	movt	r3, #4194	; 0x1062
7001ae00:	e0830293 	umull	r0, r3, r3, r2
7001ae04:	e1a03323 	lsr	r3, r3, #6
7001ae08:	e3a01ffa 	mov	r1, #1000	; 0x3e8
7001ae0c:	e0030391 	mul	r3, r1, r3
7001ae10:	e0633002 	rsb	r3, r3, r2
7001ae14:	e3a02ffa 	mov	r2, #1000	; 0x3e8
7001ae18:	e0030392 	mul	r3, r2, r3
7001ae1c:	e1a02003 	mov	r2, r3
7001ae20:	e30b3834 	movw	r3, #47156	; 0xb834
7001ae24:	e3473002 	movt	r3, #28674	; 0x7002
7001ae28:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
7001ae2c:	e51b3010 	ldr	r3, [fp, #-16]
7001ae30:	e1a02003 	mov	r2, r3
7001ae34:	e51b100c 	ldr	r1, [fp, #-12]
7001ae38:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001ae3c:	e3413062 	movt	r3, #4194	; 0x1062
7001ae40:	e0830193 	umull	r0, r3, r3, r1
7001ae44:	e1a03323 	lsr	r3, r3, #6
7001ae48:	e0633002 	rsb	r3, r3, r2
7001ae4c:	e2433001 	sub	r3, r3, #1
7001ae50:	e1a02003 	mov	r2, r3
7001ae54:	e30b3834 	movw	r3, #47156	; 0xb834
7001ae58:	e3473002 	movt	r3, #28674	; 0x7002
7001ae5c:	e5832000 	str	r2, [r3]
}
7001ae60:	e24bd004 	sub	sp, fp, #4
7001ae64:	e8bd8800 	pop	{fp, pc}

7001ae68 <clock_time_to_tick>:

int clock_time_to_tick(const struct timespec *time)
{
7001ae68:	e92d4800 	push	{fp, lr}
7001ae6c:	e28db004 	add	fp, sp, #4
7001ae70:	e24dd020 	sub	sp, sp, #32
7001ae74:	e50b0020 	str	r0, [fp, #-32]
    int tick;
    int nsecond, second;
    struct timespec tp;

    RT_ASSERT(time != RT_NULL);
7001ae78:	e51b3020 	ldr	r3, [fp, #-32]
7001ae7c:	e3530000 	cmp	r3, #0
7001ae80:	1a00001d 	bne	7001aefc <clock_time_to_tick+0x94>
7001ae84:	e3a03000 	mov	r3, #0
7001ae88:	e54b3019 	strb	r3, [fp, #-25]
7001ae8c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ae90:	e3473002 	movt	r3, #28674	; 0x7002
7001ae94:	e5933000 	ldr	r3, [r3]
7001ae98:	e3530000 	cmp	r3, #0
7001ae9c:	1a00000d 	bne	7001aed8 <clock_time_to_tick+0x70>
7001aea0:	e30801c0 	movw	r0, #33216	; 0x81c0
7001aea4:	e3470002 	movt	r0, #28674	; 0x7002
7001aea8:	e30811e0 	movw	r1, #33248	; 0x81e0
7001aeac:	e3471002 	movt	r1, #28674	; 0x7002
7001aeb0:	e30821f0 	movw	r2, #33264	; 0x81f0
7001aeb4:	e3472002 	movt	r2, #28674	; 0x7002
7001aeb8:	e3a03039 	mov	r3, #57	; 0x39
7001aebc:	ebffb24c 	bl	700077f4 <rt_kprintf>
7001aec0:	e1a00000 	nop			; (mov r0, r0)
7001aec4:	e55b3019 	ldrb	r3, [fp, #-25]
7001aec8:	e6ef3073 	uxtb	r3, r3
7001aecc:	e3530000 	cmp	r3, #0
7001aed0:	0afffffb 	beq	7001aec4 <clock_time_to_tick+0x5c>
7001aed4:	ea000008 	b	7001aefc <clock_time_to_tick+0x94>
7001aed8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001aedc:	e3473002 	movt	r3, #28674	; 0x7002
7001aee0:	e5933000 	ldr	r3, [r3]
7001aee4:	e30801e0 	movw	r0, #33248	; 0x81e0
7001aee8:	e3470002 	movt	r0, #28674	; 0x7002
7001aeec:	e30811f0 	movw	r1, #33264	; 0x81f0
7001aef0:	e3471002 	movt	r1, #28674	; 0x7002
7001aef4:	e3a02039 	mov	r2, #57	; 0x39
7001aef8:	e12fff33 	blx	r3

    tick = RT_WAITING_FOREVER;
7001aefc:	e3e03000 	mvn	r3, #0
7001af00:	e50b3008 	str	r3, [fp, #-8]
    if (time != NULL)
7001af04:	e51b3020 	ldr	r3, [fp, #-32]
7001af08:	e3530000 	cmp	r3, #0
7001af0c:	0a000036 	beq	7001afec <clock_time_to_tick+0x184>
    {
        /* get current tp */
        clock_gettime(CLOCK_REALTIME, &tp);
7001af10:	e24b3018 	sub	r3, fp, #24
7001af14:	e3a00000 	mov	r0, #0
7001af18:	e1a01003 	mov	r1, r3
7001af1c:	eb000050 	bl	7001b064 <clock_gettime>

        if ((time->tv_nsec - tp.tv_nsec) < 0)
7001af20:	e51b3020 	ldr	r3, [fp, #-32]
7001af24:	e5932004 	ldr	r2, [r3, #4]
7001af28:	e51b3014 	ldr	r3, [fp, #-20]
7001af2c:	e0633002 	rsb	r3, r3, r2
7001af30:	e3530000 	cmp	r3, #0
7001af34:	aa00000f 	bge	7001af78 <clock_time_to_tick+0x110>
        {
            nsecond = NANOSECOND_PER_SECOND - (tp.tv_nsec - time->tv_nsec);
7001af38:	e51b3020 	ldr	r3, [fp, #-32]
7001af3c:	e5932004 	ldr	r2, [r3, #4]
7001af40:	e51b3014 	ldr	r3, [fp, #-20]
7001af44:	e0633002 	rsb	r3, r3, r2
7001af48:	e1a02003 	mov	r2, r3
7001af4c:	e3a03cca 	mov	r3, #51712	; 0xca00
7001af50:	e3433b9a 	movt	r3, #15258	; 0x3b9a
7001af54:	e0823003 	add	r3, r2, r3
7001af58:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec - 1;
7001af5c:	e51b3020 	ldr	r3, [fp, #-32]
7001af60:	e5932000 	ldr	r2, [r3]
7001af64:	e51b3018 	ldr	r3, [fp, #-24]
7001af68:	e0633002 	rsb	r3, r3, r2
7001af6c:	e2433001 	sub	r3, r3, #1
7001af70:	e50b3010 	str	r3, [fp, #-16]
7001af74:	ea000009 	b	7001afa0 <clock_time_to_tick+0x138>
        }
        else
        {
            nsecond = time->tv_nsec - tp.tv_nsec;
7001af78:	e51b3020 	ldr	r3, [fp, #-32]
7001af7c:	e5932004 	ldr	r2, [r3, #4]
7001af80:	e51b3014 	ldr	r3, [fp, #-20]
7001af84:	e0633002 	rsb	r3, r3, r2
7001af88:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec;
7001af8c:	e51b3020 	ldr	r3, [fp, #-32]
7001af90:	e5932000 	ldr	r2, [r3]
7001af94:	e51b3018 	ldr	r3, [fp, #-24]
7001af98:	e0633002 	rsb	r3, r3, r2
7001af9c:	e50b3010 	str	r3, [fp, #-16]
        }

        tick = second * RT_TICK_PER_SECOND + nsecond * RT_TICK_PER_SECOND / NANOSECOND_PER_SECOND;
7001afa0:	e51b3010 	ldr	r3, [fp, #-16]
7001afa4:	e3a02ffa 	mov	r2, #1000	; 0x3e8
7001afa8:	e0030392 	mul	r3, r2, r3
7001afac:	e1a02003 	mov	r2, r3
7001afb0:	e51b300c 	ldr	r3, [fp, #-12]
7001afb4:	e3a01ffa 	mov	r1, #1000	; 0x3e8
7001afb8:	e0030391 	mul	r3, r1, r3
7001afbc:	e1a014a3 	lsr	r1, r3, #9
7001afc0:	e3043b83 	movw	r3, #19331	; 0x4b83
7001afc4:	e3403004 	movt	r3, #4
7001afc8:	e0830193 	umull	r0, r3, r3, r1
7001afcc:	e1a033a3 	lsr	r3, r3, #7
7001afd0:	e0823003 	add	r3, r2, r3
7001afd4:	e50b3008 	str	r3, [fp, #-8]
        if (tick < 0) tick = 0;
7001afd8:	e51b3008 	ldr	r3, [fp, #-8]
7001afdc:	e3530000 	cmp	r3, #0
7001afe0:	aa000001 	bge	7001afec <clock_time_to_tick+0x184>
7001afe4:	e3a03000 	mov	r3, #0
7001afe8:	e50b3008 	str	r3, [fp, #-8]
    }

    return tick;
7001afec:	e51b3008 	ldr	r3, [fp, #-8]
}
7001aff0:	e1a00003 	mov	r0, r3
7001aff4:	e24bd004 	sub	sp, fp, #4
7001aff8:	e8bd8800 	pop	{fp, pc}

7001affc <clock_getres>:
RTM_EXPORT(clock_time_to_tick);

int clock_getres(clockid_t clockid, struct timespec *res)
{
7001affc:	e92d4800 	push	{fp, lr}
7001b000:	e28db004 	add	fp, sp, #4
7001b004:	e24dd008 	sub	sp, sp, #8
7001b008:	e50b0008 	str	r0, [fp, #-8]
7001b00c:	e50b100c 	str	r1, [fp, #-12]
    if ((clockid != CLOCK_REALTIME) || (res == RT_NULL))
7001b010:	e51b3008 	ldr	r3, [fp, #-8]
7001b014:	e3530000 	cmp	r3, #0
7001b018:	1a000002 	bne	7001b028 <clock_getres+0x2c>
7001b01c:	e51b300c 	ldr	r3, [fp, #-12]
7001b020:	e3530000 	cmp	r3, #0
7001b024:	1a000003 	bne	7001b038 <clock_getres+0x3c>
    {
        rt_set_errno(EINVAL);
7001b028:	e3a00016 	mov	r0, #22
7001b02c:	ebffabc3 	bl	70005f40 <rt_set_errno>

        return -1;
7001b030:	e3e03000 	mvn	r3, #0
7001b034:	ea000007 	b	7001b058 <clock_getres+0x5c>
    }

    res->tv_sec = 0;
7001b038:	e51b300c 	ldr	r3, [fp, #-12]
7001b03c:	e3a02000 	mov	r2, #0
7001b040:	e5832000 	str	r2, [r3]
    res->tv_nsec = NANOSECOND_PER_SECOND/RT_TICK_PER_SECOND;
7001b044:	e51b200c 	ldr	r2, [fp, #-12]
7001b048:	e3043240 	movw	r3, #16960	; 0x4240
7001b04c:	e340300f 	movt	r3, #15
7001b050:	e5823004 	str	r3, [r2, #4]

    return 0;
7001b054:	e3a03000 	mov	r3, #0
}
7001b058:	e1a00003 	mov	r0, r3
7001b05c:	e24bd004 	sub	sp, fp, #4
7001b060:	e8bd8800 	pop	{fp, pc}

7001b064 <clock_gettime>:
RTM_EXPORT(clock_getres);

int clock_gettime(clockid_t clockid, struct timespec *tp)
{
7001b064:	e92d4800 	push	{fp, lr}
7001b068:	e28db004 	add	fp, sp, #4
7001b06c:	e24dd010 	sub	sp, sp, #16
7001b070:	e50b0010 	str	r0, [fp, #-16]
7001b074:	e50b1014 	str	r1, [fp, #-20]
    rt_tick_t tick;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
7001b078:	e51b3010 	ldr	r3, [fp, #-16]
7001b07c:	e3530000 	cmp	r3, #0
7001b080:	1a000002 	bne	7001b090 <clock_gettime+0x2c>
7001b084:	e51b3014 	ldr	r3, [fp, #-20]
7001b088:	e3530000 	cmp	r3, #0
7001b08c:	1a000003 	bne	7001b0a0 <clock_gettime+0x3c>
    {
        rt_set_errno(EINVAL);
7001b090:	e3a00016 	mov	r0, #22
7001b094:	ebffaba9 	bl	70005f40 <rt_set_errno>

        return -1;
7001b098:	e3e03000 	mvn	r3, #0
7001b09c:	ea000024 	b	7001b134 <clock_gettime+0xd0>
    }

    /* get tick */
    tick = rt_tick_get();
7001b0a0:	ebff9589 	bl	700006cc <rt_tick_get>
7001b0a4:	e50b0008 	str	r0, [fp, #-8]

    tp->tv_sec = _timevalue.tv_sec + tick / RT_TICK_PER_SECOND;
7001b0a8:	e30b3834 	movw	r3, #47156	; 0xb834
7001b0ac:	e3473002 	movt	r3, #28674	; 0x7002
7001b0b0:	e5933000 	ldr	r3, [r3]
7001b0b4:	e1a02003 	mov	r2, r3
7001b0b8:	e51b1008 	ldr	r1, [fp, #-8]
7001b0bc:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001b0c0:	e3413062 	movt	r3, #4194	; 0x1062
7001b0c4:	e0830193 	umull	r0, r3, r3, r1
7001b0c8:	e1a03323 	lsr	r3, r3, #6
7001b0cc:	e0823003 	add	r3, r2, r3
7001b0d0:	e1a02003 	mov	r2, r3
7001b0d4:	e51b3014 	ldr	r3, [fp, #-20]
7001b0d8:	e5832000 	str	r2, [r3]
    tp->tv_nsec = (_timevalue.tv_usec + (tick % RT_TICK_PER_SECOND) * NANOSECOND_PER_TICK) * 1000;
7001b0dc:	e30b3834 	movw	r3, #47156	; 0xb834
7001b0e0:	e3473002 	movt	r3, #28674	; 0x7002
7001b0e4:	e5933004 	ldr	r3, [r3, #4]
7001b0e8:	e1a01003 	mov	r1, r3
7001b0ec:	e51b2008 	ldr	r2, [fp, #-8]
7001b0f0:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001b0f4:	e3413062 	movt	r3, #4194	; 0x1062
7001b0f8:	e0830293 	umull	r0, r3, r3, r2
7001b0fc:	e1a03323 	lsr	r3, r3, #6
7001b100:	e3a00ffa 	mov	r0, #1000	; 0x3e8
7001b104:	e0030390 	mul	r3, r0, r3
7001b108:	e0633002 	rsb	r3, r3, r2
7001b10c:	e3042240 	movw	r2, #16960	; 0x4240
7001b110:	e340200f 	movt	r2, #15
7001b114:	e0030392 	mul	r3, r2, r3
7001b118:	e0813003 	add	r3, r1, r3
7001b11c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
7001b120:	e0030392 	mul	r3, r2, r3
7001b124:	e1a02003 	mov	r2, r3
7001b128:	e51b3014 	ldr	r3, [fp, #-20]
7001b12c:	e5832004 	str	r2, [r3, #4]
    
    return 0;
7001b130:	e3a03000 	mov	r3, #0
}
7001b134:	e1a00003 	mov	r0, r3
7001b138:	e24bd004 	sub	sp, fp, #4
7001b13c:	e8bd8800 	pop	{fp, pc}

7001b140 <clock_settime>:
RTM_EXPORT(clock_gettime);

int clock_settime(clockid_t clockid, const struct timespec *tp)
{
7001b140:	e92d4800 	push	{fp, lr}
7001b144:	e28db004 	add	fp, sp, #4
7001b148:	e24dd018 	sub	sp, sp, #24
7001b14c:	e50b0018 	str	r0, [fp, #-24]
7001b150:	e50b101c 	str	r1, [fp, #-28]
    int second;
    rt_tick_t tick;
    rt_device_t device;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
7001b154:	e51b3018 	ldr	r3, [fp, #-24]
7001b158:	e3530000 	cmp	r3, #0
7001b15c:	1a000002 	bne	7001b16c <clock_settime+0x2c>
7001b160:	e51b301c 	ldr	r3, [fp, #-28]
7001b164:	e3530000 	cmp	r3, #0
7001b168:	1a000003 	bne	7001b17c <clock_settime+0x3c>
    {
        rt_set_errno(EINVAL);
7001b16c:	e3a00016 	mov	r0, #22
7001b170:	ebffab72 	bl	70005f40 <rt_set_errno>

        return -1;
7001b174:	e3e03000 	mvn	r3, #0
7001b178:	ea000030 	b	7001b240 <clock_settime+0x100>
    }

    /* get second */
    second = tp->tv_sec;
7001b17c:	e51b301c 	ldr	r3, [fp, #-28]
7001b180:	e5933000 	ldr	r3, [r3]
7001b184:	e50b3010 	str	r3, [fp, #-16]
    /* get tick */
    tick = rt_tick_get();
7001b188:	ebff954f 	bl	700006cc <rt_tick_get>
7001b18c:	e50b0008 	str	r0, [fp, #-8]

    /* update timevalue */
    _timevalue.tv_usec = MICROSECOND_PER_SECOND - (tick % RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
7001b190:	e51b2008 	ldr	r2, [fp, #-8]
7001b194:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001b198:	e3413062 	movt	r3, #4194	; 0x1062
7001b19c:	e0830293 	umull	r0, r3, r3, r2
7001b1a0:	e1a03323 	lsr	r3, r3, #6
7001b1a4:	e3a01ffa 	mov	r1, #1000	; 0x3e8
7001b1a8:	e0030391 	mul	r3, r1, r3
7001b1ac:	e0633002 	rsb	r3, r3, r2
7001b1b0:	e3a02ffa 	mov	r2, #1000	; 0x3e8
7001b1b4:	e0030392 	mul	r3, r2, r3
7001b1b8:	e263393d 	rsb	r3, r3, #999424	; 0xf4000
7001b1bc:	e2833d09 	add	r3, r3, #576	; 0x240
7001b1c0:	e1a02003 	mov	r2, r3
7001b1c4:	e30b3834 	movw	r3, #47156	; 0xb834
7001b1c8:	e3473002 	movt	r3, #28674	; 0x7002
7001b1cc:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = second - tick/RT_TICK_PER_SECOND - 1;
7001b1d0:	e51b3010 	ldr	r3, [fp, #-16]
7001b1d4:	e1a02003 	mov	r2, r3
7001b1d8:	e51b1008 	ldr	r1, [fp, #-8]
7001b1dc:	e3043dd3 	movw	r3, #19923	; 0x4dd3
7001b1e0:	e3413062 	movt	r3, #4194	; 0x1062
7001b1e4:	e0830193 	umull	r0, r3, r3, r1
7001b1e8:	e1a03323 	lsr	r3, r3, #6
7001b1ec:	e0633002 	rsb	r3, r3, r2
7001b1f0:	e2433001 	sub	r3, r3, #1
7001b1f4:	e1a02003 	mov	r2, r3
7001b1f8:	e30b3834 	movw	r3, #47156	; 0xb834
7001b1fc:	e3473002 	movt	r3, #28674	; 0x7002
7001b200:	e5832000 	str	r2, [r3]

    /* update for RTC device */
    device = rt_device_find("rtc");
7001b204:	e30801bc 	movw	r0, #33212	; 0x81bc
7001b208:	e3470002 	movt	r0, #28674	; 0x7002
7001b20c:	ebff9605 	bl	70000a28 <rt_device_find>
7001b210:	e50b000c 	str	r0, [fp, #-12]
    if (device != RT_NULL)
7001b214:	e51b300c 	ldr	r3, [fp, #-12]
7001b218:	e3530000 	cmp	r3, #0
7001b21c:	0a000006 	beq	7001b23c <clock_settime+0xfc>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
7001b220:	e24b3010 	sub	r3, fp, #16
7001b224:	e51b000c 	ldr	r0, [fp, #-12]
7001b228:	e3a01011 	mov	r1, #17
7001b22c:	e1a02003 	mov	r2, r3
7001b230:	ebff97e3 	bl	700011c4 <rt_device_control>
    }
    else
        return -1;

    return 0;
7001b234:	e3a03000 	mov	r3, #0
7001b238:	ea000000 	b	7001b240 <clock_settime+0x100>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
    }
    else
        return -1;
7001b23c:	e3e03000 	mvn	r3, #0

    return 0;
}
7001b240:	e1a00003 	mov	r0, r3
7001b244:	e24bd004 	sub	sp, fp, #4
7001b248:	e8bd8800 	pop	{fp, pc}

7001b24c <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
7001b24c:	e92d4800 	push	{fp, lr}
7001b250:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
7001b254:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b258:	e3470002 	movt	r0, #28674	; 0x7002
7001b25c:	e3081204 	movw	r1, #33284	; 0x8204
7001b260:	e3471002 	movt	r1, #28674	; 0x7002
7001b264:	e3a02001 	mov	r2, #1
7001b268:	e3a03000 	mov	r3, #0
7001b26c:	ebff99cc 	bl	700019a4 <rt_sem_init>
}
7001b270:	e8bd8800 	pop	{fp, pc}

7001b274 <posix_mq_insert>:

rt_inline void posix_mq_insert(mqd_t pmq)
{
7001b274:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001b278:	e28db000 	add	fp, sp, #0
7001b27c:	e24dd00c 	sub	sp, sp, #12
7001b280:	e50b0008 	str	r0, [fp, #-8]
    pmq->next = posix_mq_list;
7001b284:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b288:	e3473002 	movt	r3, #28674	; 0x7002
7001b28c:	e5932000 	ldr	r2, [r3]
7001b290:	e51b3008 	ldr	r3, [fp, #-8]
7001b294:	e5832008 	str	r2, [r3, #8]
    posix_mq_list = pmq;
7001b298:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b29c:	e3473002 	movt	r3, #28674	; 0x7002
7001b2a0:	e51b2008 	ldr	r2, [fp, #-8]
7001b2a4:	e5832000 	str	r2, [r3]
}
7001b2a8:	e24bd000 	sub	sp, fp, #0
7001b2ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001b2b0:	e12fff1e 	bx	lr

7001b2b4 <posix_mq_delete>:

static void posix_mq_delete(mqd_t pmq)
{
7001b2b4:	e92d4800 	push	{fp, lr}
7001b2b8:	e28db004 	add	fp, sp, #4
7001b2bc:	e24dd010 	sub	sp, sp, #16
7001b2c0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    if (posix_mq_list == pmq)
7001b2c4:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b2c8:	e3473002 	movt	r3, #28674	; 0x7002
7001b2cc:	e5932000 	ldr	r2, [r3]
7001b2d0:	e51b3010 	ldr	r3, [fp, #-16]
7001b2d4:	e1520003 	cmp	r2, r3
7001b2d8:	1a00000b 	bne	7001b30c <posix_mq_delete+0x58>
    {
        posix_mq_list = pmq->next;
7001b2dc:	e51b3010 	ldr	r3, [fp, #-16]
7001b2e0:	e5932008 	ldr	r2, [r3, #8]
7001b2e4:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b2e8:	e3473002 	movt	r3, #28674	; 0x7002
7001b2ec:	e5832000 	str	r2, [r3]

        rt_mq_delete(pmq->mq);
7001b2f0:	e51b3010 	ldr	r3, [fp, #-16]
7001b2f4:	e5933004 	ldr	r3, [r3, #4]
7001b2f8:	e1a00003 	mov	r0, r3
7001b2fc:	ebffa713 	bl	70004f50 <rt_mq_delete>
        rt_free(pmq);
7001b300:	e51b0010 	ldr	r0, [fp, #-16]
7001b304:	ebffb62f 	bl	70008bc8 <rt_free>

        return;
7001b308:	ea000023 	b	7001b39c <posix_mq_delete+0xe8>
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
7001b30c:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b310:	e3473002 	movt	r3, #28674	; 0x7002
7001b314:	e5933000 	ldr	r3, [r3]
7001b318:	e50b3008 	str	r3, [fp, #-8]
7001b31c:	ea00001a 	b	7001b38c <posix_mq_delete+0xd8>
    {
        if (iter->next == pmq)
7001b320:	e51b3008 	ldr	r3, [fp, #-8]
7001b324:	e5932008 	ldr	r2, [r3, #8]
7001b328:	e51b3010 	ldr	r3, [fp, #-16]
7001b32c:	e1520003 	cmp	r2, r3
7001b330:	1a000012 	bne	7001b380 <posix_mq_delete+0xcc>
        {
            /* delete this mq */
            if (pmq->next != RT_NULL)
7001b334:	e51b3010 	ldr	r3, [fp, #-16]
7001b338:	e5933008 	ldr	r3, [r3, #8]
7001b33c:	e3530000 	cmp	r3, #0
7001b340:	0a000004 	beq	7001b358 <posix_mq_delete+0xa4>
                iter->next = pmq->next;
7001b344:	e51b3010 	ldr	r3, [fp, #-16]
7001b348:	e5932008 	ldr	r2, [r3, #8]
7001b34c:	e51b3008 	ldr	r3, [fp, #-8]
7001b350:	e5832008 	str	r2, [r3, #8]
7001b354:	ea000002 	b	7001b364 <posix_mq_delete+0xb0>
            else
                iter->next = RT_NULL;
7001b358:	e51b3008 	ldr	r3, [fp, #-8]
7001b35c:	e3a02000 	mov	r2, #0
7001b360:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_mq_delete(pmq->mq);
7001b364:	e51b3010 	ldr	r3, [fp, #-16]
7001b368:	e5933004 	ldr	r3, [r3, #4]
7001b36c:	e1a00003 	mov	r0, r3
7001b370:	ebffa6f6 	bl	70004f50 <rt_mq_delete>
            rt_free(pmq);
7001b374:	e51b0010 	ldr	r0, [fp, #-16]
7001b378:	ebffb612 	bl	70008bc8 <rt_free>

            return ;
7001b37c:	ea000006 	b	7001b39c <posix_mq_delete+0xe8>
        rt_mq_delete(pmq->mq);
        rt_free(pmq);

        return;
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
7001b380:	e51b3008 	ldr	r3, [fp, #-8]
7001b384:	e5933008 	ldr	r3, [r3, #8]
7001b388:	e50b3008 	str	r3, [fp, #-8]
7001b38c:	e51b3008 	ldr	r3, [fp, #-8]
7001b390:	e5933008 	ldr	r3, [r3, #8]
7001b394:	e3530000 	cmp	r3, #0
7001b398:	1affffe0 	bne	7001b320 <posix_mq_delete+0x6c>
            rt_free(pmq);

            return ;
        }
    }
}
7001b39c:	e24bd004 	sub	sp, fp, #4
7001b3a0:	e8bd8800 	pop	{fp, pc}

7001b3a4 <posix_mq_find>:

static mqd_t posix_mq_find(const char* name)
{
7001b3a4:	e92d4800 	push	{fp, lr}
7001b3a8:	e28db004 	add	fp, sp, #4
7001b3ac:	e24dd010 	sub	sp, sp, #16
7001b3b0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
7001b3b4:	e30a3a2c 	movw	r3, #43564	; 0xaa2c
7001b3b8:	e3473002 	movt	r3, #28674	; 0x7002
7001b3bc:	e5933000 	ldr	r3, [r3]
7001b3c0:	e50b3008 	str	r3, [fp, #-8]
7001b3c4:	ea00000f 	b	7001b408 <posix_mq_find+0x64>
    {
        object = (rt_object_t)(iter->mq);
7001b3c8:	e51b3008 	ldr	r3, [fp, #-8]
7001b3cc:	e5933004 	ldr	r3, [r3, #4]
7001b3d0:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
7001b3d4:	e51b300c 	ldr	r3, [fp, #-12]
7001b3d8:	e1a00003 	mov	r0, r3
7001b3dc:	e51b1010 	ldr	r1, [fp, #-16]
7001b3e0:	e3a02006 	mov	r2, #6
7001b3e4:	fa0023ea 	blx	70024394 <strncmp>
7001b3e8:	e1a03000 	mov	r3, r0
7001b3ec:	e3530000 	cmp	r3, #0
7001b3f0:	1a000001 	bne	7001b3fc <posix_mq_find+0x58>
        {
            return iter;
7001b3f4:	e51b3008 	ldr	r3, [fp, #-8]
7001b3f8:	ea000006 	b	7001b418 <posix_mq_find+0x74>
static mqd_t posix_mq_find(const char* name)
{
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
7001b3fc:	e51b3008 	ldr	r3, [fp, #-8]
7001b400:	e5933008 	ldr	r3, [r3, #8]
7001b404:	e50b3008 	str	r3, [fp, #-8]
7001b408:	e51b3008 	ldr	r3, [fp, #-8]
7001b40c:	e3530000 	cmp	r3, #0
7001b410:	1affffec 	bne	7001b3c8 <posix_mq_find+0x24>
        {
            return iter;
        }
    }

    return RT_NULL;
7001b414:	e3a03000 	mov	r3, #0
}
7001b418:	e1a00003 	mov	r0, r3
7001b41c:	e24bd004 	sub	sp, fp, #4
7001b420:	e8bd8800 	pop	{fp, pc}

7001b424 <mq_setattr>:

int mq_setattr(mqd_t                 mqdes,
               const struct mq_attr *mqstat,
               struct mq_attr       *omqstat)
{
7001b424:	e92d4800 	push	{fp, lr}
7001b428:	e28db004 	add	fp, sp, #4
7001b42c:	e24dd010 	sub	sp, sp, #16
7001b430:	e50b0008 	str	r0, [fp, #-8]
7001b434:	e50b100c 	str	r1, [fp, #-12]
7001b438:	e50b2010 	str	r2, [fp, #-16]
    rt_set_errno(-RT_ERROR);
7001b43c:	e3e00000 	mvn	r0, #0
7001b440:	ebffaabe 	bl	70005f40 <rt_set_errno>

    return -1;
7001b444:	e3e03000 	mvn	r3, #0
}
7001b448:	e1a00003 	mov	r0, r3
7001b44c:	e24bd004 	sub	sp, fp, #4
7001b450:	e8bd8800 	pop	{fp, pc}

7001b454 <mq_getattr>:
RTM_EXPORT(mq_setattr);

int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat)
{
7001b454:	e92d4800 	push	{fp, lr}
7001b458:	e28db004 	add	fp, sp, #4
7001b45c:	e24dd008 	sub	sp, sp, #8
7001b460:	e50b0008 	str	r0, [fp, #-8]
7001b464:	e50b100c 	str	r1, [fp, #-12]
    if ((mqdes == RT_NULL) || mqstat == RT_NULL)
7001b468:	e51b3008 	ldr	r3, [fp, #-8]
7001b46c:	e3530000 	cmp	r3, #0
7001b470:	0a000002 	beq	7001b480 <mq_getattr+0x2c>
7001b474:	e51b300c 	ldr	r3, [fp, #-12]
7001b478:	e3530000 	cmp	r3, #0
7001b47c:	1a000003 	bne	7001b490 <mq_getattr+0x3c>
    {
        rt_set_errno(EBADF);
7001b480:	e3a00009 	mov	r0, #9
7001b484:	ebffaaad 	bl	70005f40 <rt_set_errno>

        return -1;
7001b488:	e3e03000 	mvn	r3, #0
7001b48c:	ea000012 	b	7001b4dc <mq_getattr+0x88>
    }

    mqstat->mq_maxmsg = mqdes->mq->max_msgs;
7001b490:	e51b3008 	ldr	r3, [fp, #-8]
7001b494:	e5933004 	ldr	r3, [r3, #4]
7001b498:	e1d331be 	ldrh	r3, [r3, #30]
7001b49c:	e1a02003 	mov	r2, r3
7001b4a0:	e51b300c 	ldr	r3, [fp, #-12]
7001b4a4:	e5832004 	str	r2, [r3, #4]
    mqstat->mq_msgsize = mqdes->mq->msg_size;
7001b4a8:	e51b3008 	ldr	r3, [fp, #-8]
7001b4ac:	e5933004 	ldr	r3, [r3, #4]
7001b4b0:	e1d331bc 	ldrh	r3, [r3, #28]
7001b4b4:	e1a02003 	mov	r2, r3
7001b4b8:	e51b300c 	ldr	r3, [fp, #-12]
7001b4bc:	e5832008 	str	r2, [r3, #8]
    mqstat->mq_curmsgs = 0;
7001b4c0:	e51b300c 	ldr	r3, [fp, #-12]
7001b4c4:	e3a02000 	mov	r2, #0
7001b4c8:	e583200c 	str	r2, [r3, #12]
    mqstat->mq_flags = 0;
7001b4cc:	e51b300c 	ldr	r3, [fp, #-12]
7001b4d0:	e3a02000 	mov	r2, #0
7001b4d4:	e5832000 	str	r2, [r3]

    return 0;
7001b4d8:	e3a03000 	mov	r3, #0
}
7001b4dc:	e1a00003 	mov	r0, r3
7001b4e0:	e24bd004 	sub	sp, fp, #4
7001b4e4:	e8bd8800 	pop	{fp, pc}

7001b4e8 <mq_open>:
RTM_EXPORT(mq_getattr);

mqd_t mq_open(const char *name, int oflag, ...)
{
7001b4e8:	e92d000e 	push	{r1, r2, r3}
7001b4ec:	e92d4800 	push	{fp, lr}
7001b4f0:	e28db004 	add	fp, sp, #4
7001b4f4:	e24dd01c 	sub	sp, sp, #28
7001b4f8:	e50b001c 	str	r0, [fp, #-28]
    mqd_t mqdes;
    va_list arg;
    mode_t mode;
    struct mq_attr *attr = RT_NULL;
7001b4fc:	e3a03000 	mov	r3, #0
7001b500:	e50b3010 	str	r3, [fp, #-16]

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
7001b504:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b508:	e3470002 	movt	r0, #28674	; 0x7002
7001b50c:	e3e01000 	mvn	r1, #0
7001b510:	ebff9a32 	bl	70001de0 <rt_sem_take>

    mqdes = RT_NULL;
7001b514:	e3a03000 	mov	r3, #0
7001b518:	e50b300c 	str	r3, [fp, #-12]
    if (oflag & O_CREAT)
7001b51c:	e59b3004 	ldr	r3, [fp, #4]
7001b520:	e2033c01 	and	r3, r3, #256	; 0x100
7001b524:	e3530000 	cmp	r3, #0
7001b528:	0a00003d 	beq	7001b624 <mq_open+0x13c>
    {
        va_start(arg, oflag);
7001b52c:	e28b3008 	add	r3, fp, #8
7001b530:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t)va_arg(arg, unsigned int);
7001b534:	e51b3018 	ldr	r3, [fp, #-24]
7001b538:	e2832004 	add	r2, r3, #4
7001b53c:	e50b2018 	str	r2, [fp, #-24]
7001b540:	e5933000 	ldr	r3, [r3]
7001b544:	e50b3014 	str	r3, [fp, #-20]
        mode = mode;
        attr = (struct mq_attr *)va_arg(arg, struct mq_attr *);
7001b548:	e51b3018 	ldr	r3, [fp, #-24]
7001b54c:	e2832004 	add	r2, r3, #4
7001b550:	e50b2018 	str	r2, [fp, #-24]
7001b554:	e5933000 	ldr	r3, [r3]
7001b558:	e50b3010 	str	r3, [fp, #-16]
        va_end(arg);

        if (oflag & O_EXCL)
7001b55c:	e59b3004 	ldr	r3, [fp, #4]
7001b560:	e2033c02 	and	r3, r3, #512	; 0x200
7001b564:	e3530000 	cmp	r3, #0
7001b568:	0a000007 	beq	7001b58c <mq_open+0xa4>
        {
            if (posix_mq_find(name) != RT_NULL)
7001b56c:	e51b001c 	ldr	r0, [fp, #-28]
7001b570:	ebffff8b 	bl	7001b3a4 <posix_mq_find>
7001b574:	e1a03000 	mov	r3, r0
7001b578:	e3530000 	cmp	r3, #0
7001b57c:	0a000002 	beq	7001b58c <mq_open+0xa4>
            {
                rt_set_errno(EEXIST);
7001b580:	e3a00011 	mov	r0, #17
7001b584:	ebffaa6d 	bl	70005f40 <rt_set_errno>
                goto __return;
7001b588:	ea00003a 	b	7001b678 <mq_open+0x190>
            }
        }
        mqdes = (mqd_t) rt_malloc (sizeof(struct mqdes));
7001b58c:	e3a0000c 	mov	r0, #12
7001b590:	ebffb2c9 	bl	700080bc <rt_malloc>
7001b594:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes == RT_NULL)
7001b598:	e51b300c 	ldr	r3, [fp, #-12]
7001b59c:	e3530000 	cmp	r3, #0
7001b5a0:	1a000002 	bne	7001b5b0 <mq_open+0xc8>
        {
            rt_set_errno(ENFILE);
7001b5a4:	e3a00017 	mov	r0, #23
7001b5a8:	ebffaa64 	bl	70005f40 <rt_set_errno>
            goto __return;
7001b5ac:	ea000031 	b	7001b678 <mq_open+0x190>
        }

        /* create RT-Thread message queue */
        mqdes->mq = rt_mq_create(name, attr->mq_msgsize, attr->mq_maxmsg, RT_IPC_FLAG_FIFO);
7001b5b0:	e51b3010 	ldr	r3, [fp, #-16]
7001b5b4:	e5933008 	ldr	r3, [r3, #8]
7001b5b8:	e1a02003 	mov	r2, r3
7001b5bc:	e51b3010 	ldr	r3, [fp, #-16]
7001b5c0:	e5933004 	ldr	r3, [r3, #4]
7001b5c4:	e51b001c 	ldr	r0, [fp, #-28]
7001b5c8:	e1a01002 	mov	r1, r2
7001b5cc:	e1a02003 	mov	r2, r3
7001b5d0:	e3a03000 	mov	r3, #0
7001b5d4:	ebffa5d6 	bl	70004d34 <rt_mq_create>
7001b5d8:	e1a02000 	mov	r2, r0
7001b5dc:	e51b300c 	ldr	r3, [fp, #-12]
7001b5e0:	e5832004 	str	r2, [r3, #4]
        if (mqdes->mq == RT_NULL) /* create failed */
7001b5e4:	e51b300c 	ldr	r3, [fp, #-12]
7001b5e8:	e5933004 	ldr	r3, [r3, #4]
7001b5ec:	e3530000 	cmp	r3, #0
7001b5f0:	1a000002 	bne	7001b600 <mq_open+0x118>
        {
            rt_set_errno(ENFILE);
7001b5f4:	e3a00017 	mov	r0, #23
7001b5f8:	ebffaa50 	bl	70005f40 <rt_set_errno>
            goto __return;
7001b5fc:	ea00001d 	b	7001b678 <mq_open+0x190>
        }
        /* initialize reference count */
        mqdes->refcount = 1;
7001b600:	e51b300c 	ldr	r3, [fp, #-12]
7001b604:	e3a02001 	mov	r2, #1
7001b608:	e1c320b0 	strh	r2, [r3]
        mqdes->unlinked = 0;
7001b60c:	e51b300c 	ldr	r3, [fp, #-12]
7001b610:	e3a02000 	mov	r2, #0
7001b614:	e1c320b2 	strh	r2, [r3, #2]

        /* insert mq to posix mq list */
        posix_mq_insert(mqdes);
7001b618:	e51b000c 	ldr	r0, [fp, #-12]
7001b61c:	ebffff14 	bl	7001b274 <posix_mq_insert>
7001b620:	ea00000f 	b	7001b664 <mq_open+0x17c>
    }
    else
    {
        /* find mqueue */
        mqdes = posix_mq_find(name);
7001b624:	e51b001c 	ldr	r0, [fp, #-28]
7001b628:	ebffff5d 	bl	7001b3a4 <posix_mq_find>
7001b62c:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes != RT_NULL)
7001b630:	e51b300c 	ldr	r3, [fp, #-12]
7001b634:	e3530000 	cmp	r3, #0
7001b638:	0a000006 	beq	7001b658 <mq_open+0x170>
        {
            mqdes->refcount ++; /* increase reference count */
7001b63c:	e51b300c 	ldr	r3, [fp, #-12]
7001b640:	e1d330b0 	ldrh	r3, [r3]
7001b644:	e2833001 	add	r3, r3, #1
7001b648:	e6ff2073 	uxth	r2, r3
7001b64c:	e51b300c 	ldr	r3, [fp, #-12]
7001b650:	e1c320b0 	strh	r2, [r3]
7001b654:	ea000002 	b	7001b664 <mq_open+0x17c>
        }
        else
        {
            rt_set_errno(ENOENT);
7001b658:	e3a00002 	mov	r0, #2
7001b65c:	ebffaa37 	bl	70005f40 <rt_set_errno>
            goto __return;
7001b660:	ea000004 	b	7001b678 <mq_open+0x190>
        }
    }
    rt_sem_release(&posix_mq_lock);
7001b664:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b668:	e3470002 	movt	r0, #28674	; 0x7002
7001b66c:	ebff9ab7 	bl	70002150 <rt_sem_release>

    return mqdes;
7001b670:	e51b300c 	ldr	r3, [fp, #-12]
7001b674:	ea000010 	b	7001b6bc <mq_open+0x1d4>

__return:
    /* release lock */
    rt_sem_release(&posix_mq_lock);
7001b678:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b67c:	e3470002 	movt	r0, #28674	; 0x7002
7001b680:	ebff9ab2 	bl	70002150 <rt_sem_release>

    /* release allocated memory */
    if (mqdes != RT_NULL)
7001b684:	e51b300c 	ldr	r3, [fp, #-12]
7001b688:	e3530000 	cmp	r3, #0
7001b68c:	0a000009 	beq	7001b6b8 <mq_open+0x1d0>
    {
        if (mqdes->mq != RT_NULL)
7001b690:	e51b300c 	ldr	r3, [fp, #-12]
7001b694:	e5933004 	ldr	r3, [r3, #4]
7001b698:	e3530000 	cmp	r3, #0
7001b69c:	0a000003 	beq	7001b6b0 <mq_open+0x1c8>
        {
            /* delete RT-Thread message queue */
            rt_mq_delete(mqdes->mq);
7001b6a0:	e51b300c 	ldr	r3, [fp, #-12]
7001b6a4:	e5933004 	ldr	r3, [r3, #4]
7001b6a8:	e1a00003 	mov	r0, r3
7001b6ac:	ebffa627 	bl	70004f50 <rt_mq_delete>
        }
        rt_free(mqdes);
7001b6b0:	e51b000c 	ldr	r0, [fp, #-12]
7001b6b4:	ebffb543 	bl	70008bc8 <rt_free>
    }
    return RT_NULL;
7001b6b8:	e3a03000 	mov	r3, #0
}
7001b6bc:	e1a00003 	mov	r0, r3
7001b6c0:	e24bd004 	sub	sp, fp, #4
7001b6c4:	e8bd4800 	pop	{fp, lr}
7001b6c8:	e28dd00c 	add	sp, sp, #12
7001b6cc:	e12fff1e 	bx	lr

7001b6d0 <mq_receive>:
RTM_EXPORT(mq_open);

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio)
{
7001b6d0:	e92d4800 	push	{fp, lr}
7001b6d4:	e28db004 	add	fp, sp, #4
7001b6d8:	e24dd018 	sub	sp, sp, #24
7001b6dc:	e50b0010 	str	r0, [fp, #-16]
7001b6e0:	e50b1014 	str	r1, [fp, #-20]
7001b6e4:	e50b2018 	str	r2, [fp, #-24]
7001b6e8:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
7001b6ec:	e51b3010 	ldr	r3, [fp, #-16]
7001b6f0:	e3530000 	cmp	r3, #0
7001b6f4:	0a000002 	beq	7001b704 <mq_receive+0x34>
7001b6f8:	e51b3014 	ldr	r3, [fp, #-20]
7001b6fc:	e3530000 	cmp	r3, #0
7001b700:	1a000003 	bne	7001b714 <mq_receive+0x44>
    {
        rt_set_errno(EINVAL);
7001b704:	e3a00016 	mov	r0, #22
7001b708:	ebffaa0c 	bl	70005f40 <rt_set_errno>

        return -1;
7001b70c:	e3e03000 	mvn	r3, #0
7001b710:	ea00000f 	b	7001b754 <mq_receive+0x84>
    }

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, RT_WAITING_FOREVER);
7001b714:	e51b3010 	ldr	r3, [fp, #-16]
7001b718:	e5933004 	ldr	r3, [r3, #4]
7001b71c:	e1a00003 	mov	r0, r3
7001b720:	e51b1014 	ldr	r1, [fp, #-20]
7001b724:	e51b2018 	ldr	r2, [fp, #-24]
7001b728:	e3e03000 	mvn	r3, #0
7001b72c:	ebffa7f9 	bl	70005718 <rt_mq_recv>
7001b730:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
7001b734:	e51b3008 	ldr	r3, [fp, #-8]
7001b738:	e3530000 	cmp	r3, #0
7001b73c:	1a000001 	bne	7001b748 <mq_receive+0x78>
        return msg_len;
7001b740:	e51b3018 	ldr	r3, [fp, #-24]
7001b744:	ea000002 	b	7001b754 <mq_receive+0x84>

    rt_set_errno(EBADF);
7001b748:	e3a00009 	mov	r0, #9
7001b74c:	ebffa9fb 	bl	70005f40 <rt_set_errno>
    return -1;
7001b750:	e3e03000 	mvn	r3, #0
}
7001b754:	e1a00003 	mov	r0, r3
7001b758:	e24bd004 	sub	sp, fp, #4
7001b75c:	e8bd8800 	pop	{fp, pc}

7001b760 <mq_send>:
RTM_EXPORT(mq_receive);

int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)
{
7001b760:	e92d4800 	push	{fp, lr}
7001b764:	e28db004 	add	fp, sp, #4
7001b768:	e24dd018 	sub	sp, sp, #24
7001b76c:	e50b0010 	str	r0, [fp, #-16]
7001b770:	e50b1014 	str	r1, [fp, #-20]
7001b774:	e50b2018 	str	r2, [fp, #-24]
7001b778:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
7001b77c:	e51b3010 	ldr	r3, [fp, #-16]
7001b780:	e3530000 	cmp	r3, #0
7001b784:	0a000002 	beq	7001b794 <mq_send+0x34>
7001b788:	e51b3014 	ldr	r3, [fp, #-20]
7001b78c:	e3530000 	cmp	r3, #0
7001b790:	1a000003 	bne	7001b7a4 <mq_send+0x44>
    {
        rt_set_errno(EINVAL);
7001b794:	e3a00016 	mov	r0, #22
7001b798:	ebffa9e8 	bl	70005f40 <rt_set_errno>

        return -1;
7001b79c:	e3e03000 	mvn	r3, #0
7001b7a0:	ea00000e 	b	7001b7e0 <mq_send+0x80>
    }

    result = rt_mq_send(mqdes->mq, (void*)msg_ptr, msg_len);
7001b7a4:	e51b3010 	ldr	r3, [fp, #-16]
7001b7a8:	e5933004 	ldr	r3, [r3, #4]
7001b7ac:	e1a00003 	mov	r0, r3
7001b7b0:	e51b1014 	ldr	r1, [fp, #-20]
7001b7b4:	e51b2018 	ldr	r2, [fp, #-24]
7001b7b8:	ebffa643 	bl	700050cc <rt_mq_send>
7001b7bc:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
7001b7c0:	e51b3008 	ldr	r3, [fp, #-8]
7001b7c4:	e3530000 	cmp	r3, #0
7001b7c8:	1a000001 	bne	7001b7d4 <mq_send+0x74>
        return 0;
7001b7cc:	e3a03000 	mov	r3, #0
7001b7d0:	ea000002 	b	7001b7e0 <mq_send+0x80>

    rt_set_errno(EBADF);
7001b7d4:	e3a00009 	mov	r0, #9
7001b7d8:	ebffa9d8 	bl	70005f40 <rt_set_errno>

    return -1;
7001b7dc:	e3e03000 	mvn	r3, #0
}
7001b7e0:	e1a00003 	mov	r0, r3
7001b7e4:	e24bd004 	sub	sp, fp, #4
7001b7e8:	e8bd8800 	pop	{fp, pc}

7001b7ec <mq_timedreceive>:
ssize_t mq_timedreceive(mqd_t                  mqdes,
                        char                  *msg_ptr,
                        size_t                 msg_len,
                        unsigned              *msg_prio,
                        const struct timespec *abs_timeout)
{
7001b7ec:	e92d4800 	push	{fp, lr}
7001b7f0:	e28db004 	add	fp, sp, #4
7001b7f4:	e24dd018 	sub	sp, sp, #24
7001b7f8:	e50b0010 	str	r0, [fp, #-16]
7001b7fc:	e50b1014 	str	r1, [fp, #-20]
7001b800:	e50b2018 	str	r2, [fp, #-24]
7001b804:	e50b301c 	str	r3, [fp, #-28]
    int tick;
    rt_err_t result;

    /* parameters check */
    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
7001b808:	e51b3010 	ldr	r3, [fp, #-16]
7001b80c:	e3530000 	cmp	r3, #0
7001b810:	0a000002 	beq	7001b820 <mq_timedreceive+0x34>
7001b814:	e51b3014 	ldr	r3, [fp, #-20]
7001b818:	e3530000 	cmp	r3, #0
7001b81c:	1a000003 	bne	7001b830 <mq_timedreceive+0x44>
    {
        rt_set_errno(EINVAL);
7001b820:	e3a00016 	mov	r0, #22
7001b824:	ebffa9c5 	bl	70005f40 <rt_set_errno>

        return -1;
7001b828:	e3e03000 	mvn	r3, #0
7001b82c:	ea000018 	b	7001b894 <mq_timedreceive+0xa8>
    }

    tick = clock_time_to_tick(abs_timeout);
7001b830:	e59b0004 	ldr	r0, [fp, #4]
7001b834:	ebfffd8b 	bl	7001ae68 <clock_time_to_tick>
7001b838:	e50b0008 	str	r0, [fp, #-8]

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, tick);
7001b83c:	e51b3010 	ldr	r3, [fp, #-16]
7001b840:	e5933004 	ldr	r3, [r3, #4]
7001b844:	e1a00003 	mov	r0, r3
7001b848:	e51b1014 	ldr	r1, [fp, #-20]
7001b84c:	e51b2018 	ldr	r2, [fp, #-24]
7001b850:	e51b3008 	ldr	r3, [fp, #-8]
7001b854:	ebffa7af 	bl	70005718 <rt_mq_recv>
7001b858:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
7001b85c:	e51b300c 	ldr	r3, [fp, #-12]
7001b860:	e3530000 	cmp	r3, #0
7001b864:	1a000001 	bne	7001b870 <mq_timedreceive+0x84>
        return msg_len;
7001b868:	e51b3018 	ldr	r3, [fp, #-24]
7001b86c:	ea000008 	b	7001b894 <mq_timedreceive+0xa8>

    if (result == -RT_ETIMEOUT)
7001b870:	e51b300c 	ldr	r3, [fp, #-12]
7001b874:	e3730002 	cmn	r3, #2
7001b878:	1a000002 	bne	7001b888 <mq_timedreceive+0x9c>
        rt_set_errno(ETIMEDOUT);
7001b87c:	e3a00074 	mov	r0, #116	; 0x74
7001b880:	ebffa9ae 	bl	70005f40 <rt_set_errno>
7001b884:	ea000001 	b	7001b890 <mq_timedreceive+0xa4>
    else
        rt_set_errno(EBADMSG);
7001b888:	e3a0004d 	mov	r0, #77	; 0x4d
7001b88c:	ebffa9ab 	bl	70005f40 <rt_set_errno>

    return -1;
7001b890:	e3e03000 	mvn	r3, #0
}
7001b894:	e1a00003 	mov	r0, r3
7001b898:	e24bd004 	sub	sp, fp, #4
7001b89c:	e8bd8800 	pop	{fp, pc}

7001b8a0 <mq_timedsend>:
int mq_timedsend(mqd_t                  mqdes,
                 const char            *msg_ptr,
                 size_t                 msg_len,
                 unsigned               msg_prio,
                 const struct timespec *abs_timeout)
{
7001b8a0:	e92d4800 	push	{fp, lr}
7001b8a4:	e28db004 	add	fp, sp, #4
7001b8a8:	e24dd010 	sub	sp, sp, #16
7001b8ac:	e50b0008 	str	r0, [fp, #-8]
7001b8b0:	e50b100c 	str	r1, [fp, #-12]
7001b8b4:	e50b2010 	str	r2, [fp, #-16]
7001b8b8:	e50b3014 	str	r3, [fp, #-20]
    /* RT-Thread does not support timed send */
    return mq_send(mqdes, msg_ptr, msg_len, msg_prio);
7001b8bc:	e51b0008 	ldr	r0, [fp, #-8]
7001b8c0:	e51b100c 	ldr	r1, [fp, #-12]
7001b8c4:	e51b2010 	ldr	r2, [fp, #-16]
7001b8c8:	e51b3014 	ldr	r3, [fp, #-20]
7001b8cc:	ebffffa3 	bl	7001b760 <mq_send>
7001b8d0:	e1a03000 	mov	r3, r0
}
7001b8d4:	e1a00003 	mov	r0, r3
7001b8d8:	e24bd004 	sub	sp, fp, #4
7001b8dc:	e8bd8800 	pop	{fp, pc}

7001b8e0 <mq_notify>:
RTM_EXPORT(mq_timedsend);

int mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
7001b8e0:	e92d4800 	push	{fp, lr}
7001b8e4:	e28db004 	add	fp, sp, #4
7001b8e8:	e24dd008 	sub	sp, sp, #8
7001b8ec:	e50b0008 	str	r0, [fp, #-8]
7001b8f0:	e50b100c 	str	r1, [fp, #-12]
    rt_set_errno(-RT_ERROR);
7001b8f4:	e3e00000 	mvn	r0, #0
7001b8f8:	ebffa990 	bl	70005f40 <rt_set_errno>

    return -1;
7001b8fc:	e3e03000 	mvn	r3, #0
}
7001b900:	e1a00003 	mov	r0, r3
7001b904:	e24bd004 	sub	sp, fp, #4
7001b908:	e8bd8800 	pop	{fp, pc}

7001b90c <mq_close>:
RTM_EXPORT(mq_notify);

int mq_close(mqd_t mqdes)
{
7001b90c:	e92d4800 	push	{fp, lr}
7001b910:	e28db004 	add	fp, sp, #4
7001b914:	e24dd008 	sub	sp, sp, #8
7001b918:	e50b0008 	str	r0, [fp, #-8]
    if (mqdes == RT_NULL)
7001b91c:	e51b3008 	ldr	r3, [fp, #-8]
7001b920:	e3530000 	cmp	r3, #0
7001b924:	1a000003 	bne	7001b938 <mq_close+0x2c>
    {
        rt_set_errno(EINVAL);
7001b928:	e3a00016 	mov	r0, #22
7001b92c:	ebffa983 	bl	70005f40 <rt_set_errno>

        return -1;
7001b930:	e3e03000 	mvn	r3, #0
7001b934:	ea000017 	b	7001b998 <mq_close+0x8c>
    }

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
7001b938:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b93c:	e3470002 	movt	r0, #28674	; 0x7002
7001b940:	e3e01000 	mvn	r1, #0
7001b944:	ebff9925 	bl	70001de0 <rt_sem_take>
    mqdes->refcount --;
7001b948:	e51b3008 	ldr	r3, [fp, #-8]
7001b94c:	e1d330b0 	ldrh	r3, [r3]
7001b950:	e2433001 	sub	r3, r3, #1
7001b954:	e6ff2073 	uxth	r2, r3
7001b958:	e51b3008 	ldr	r3, [fp, #-8]
7001b95c:	e1c320b0 	strh	r2, [r3]
    if (mqdes->refcount == 0)
7001b960:	e51b3008 	ldr	r3, [fp, #-8]
7001b964:	e1d330b0 	ldrh	r3, [r3]
7001b968:	e3530000 	cmp	r3, #0
7001b96c:	1a000005 	bne	7001b988 <mq_close+0x7c>
    {
        /* delete from posix mqueue list */
        if (mqdes->unlinked)
7001b970:	e51b3008 	ldr	r3, [fp, #-8]
7001b974:	e1d330b2 	ldrh	r3, [r3, #2]
7001b978:	e3530000 	cmp	r3, #0
7001b97c:	0a000001 	beq	7001b988 <mq_close+0x7c>
            posix_mq_delete(mqdes);
7001b980:	e51b0008 	ldr	r0, [fp, #-8]
7001b984:	ebfffe4a 	bl	7001b2b4 <posix_mq_delete>
    }
    rt_sem_release(&posix_mq_lock);
7001b988:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b98c:	e3470002 	movt	r0, #28674	; 0x7002
7001b990:	ebff99ee 	bl	70002150 <rt_sem_release>

    return 0;
7001b994:	e3a03000 	mov	r3, #0
}
7001b998:	e1a00003 	mov	r0, r3
7001b99c:	e24bd004 	sub	sp, fp, #4
7001b9a0:	e8bd8800 	pop	{fp, pc}

7001b9a4 <mq_unlink>:
RTM_EXPORT(mq_close);

int mq_unlink(const char *name)
{
7001b9a4:	e92d4800 	push	{fp, lr}
7001b9a8:	e28db004 	add	fp, sp, #4
7001b9ac:	e24dd010 	sub	sp, sp, #16
7001b9b0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t pmq;

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
7001b9b4:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001b9b8:	e3470002 	movt	r0, #28674	; 0x7002
7001b9bc:	e3e01000 	mvn	r1, #0
7001b9c0:	ebff9906 	bl	70001de0 <rt_sem_take>
    pmq = posix_mq_find(name);
7001b9c4:	e51b0010 	ldr	r0, [fp, #-16]
7001b9c8:	ebfffe75 	bl	7001b3a4 <posix_mq_find>
7001b9cc:	e50b0008 	str	r0, [fp, #-8]
    if (pmq != RT_NULL)
7001b9d0:	e51b3008 	ldr	r3, [fp, #-8]
7001b9d4:	e3530000 	cmp	r3, #0
7001b9d8:	0a00000d 	beq	7001ba14 <mq_unlink+0x70>
    {
        pmq->unlinked = 1;
7001b9dc:	e51b3008 	ldr	r3, [fp, #-8]
7001b9e0:	e3a02001 	mov	r2, #1
7001b9e4:	e1c320b2 	strh	r2, [r3, #2]
        if (pmq->refcount == 0)
7001b9e8:	e51b3008 	ldr	r3, [fp, #-8]
7001b9ec:	e1d330b0 	ldrh	r3, [r3]
7001b9f0:	e3530000 	cmp	r3, #0
7001b9f4:	1a000001 	bne	7001ba00 <mq_unlink+0x5c>
        {
            /* remove this mqueue */
            posix_mq_delete(pmq);
7001b9f8:	e51b0008 	ldr	r0, [fp, #-8]
7001b9fc:	ebfffe2c 	bl	7001b2b4 <posix_mq_delete>
        }
        rt_sem_release(&posix_mq_lock);
7001ba00:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001ba04:	e3470002 	movt	r0, #28674	; 0x7002
7001ba08:	ebff99d0 	bl	70002150 <rt_sem_release>

        return 0;
7001ba0c:	e3a03000 	mov	r3, #0
7001ba10:	ea000005 	b	7001ba2c <mq_unlink+0x88>
    }
    rt_sem_release(&posix_mq_lock);
7001ba14:	e30a0a30 	movw	r0, #43568	; 0xaa30
7001ba18:	e3470002 	movt	r0, #28674	; 0x7002
7001ba1c:	ebff99cb 	bl	70002150 <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
7001ba20:	e3a00002 	mov	r0, #2
7001ba24:	ebffa945 	bl	70005f40 <rt_set_errno>

    return -1;
7001ba28:	e3e03000 	mvn	r3, #0
}
7001ba2c:	e1a00003 	mov	r0, r3
7001ba30:	e24bd004 	sub	sp, fp, #4
7001ba34:	e8bd8800 	pop	{fp, pc}

7001ba38 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
7001ba38:	e92d4800 	push	{fp, lr}
7001ba3c:	e28db004 	add	fp, sp, #4
7001ba40:	e24dd010 	sub	sp, sp, #16
7001ba44:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
7001ba48:	e51b3010 	ldr	r3, [fp, #-16]
7001ba4c:	e3530000 	cmp	r3, #0
7001ba50:	1a00001d 	bne	7001bacc <_pthread_get_data+0x94>
7001ba54:	e3a03000 	mov	r3, #0
7001ba58:	e54b3009 	strb	r3, [fp, #-9]
7001ba5c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ba60:	e3473002 	movt	r3, #28674	; 0x7002
7001ba64:	e5933000 	ldr	r3, [r3]
7001ba68:	e3530000 	cmp	r3, #0
7001ba6c:	1a00000d 	bne	7001baa8 <_pthread_get_data+0x70>
7001ba70:	e3080208 	movw	r0, #33288	; 0x8208
7001ba74:	e3470002 	movt	r0, #28674	; 0x7002
7001ba78:	e3081228 	movw	r1, #33320	; 0x8228
7001ba7c:	e3471002 	movt	r1, #28674	; 0x7002
7001ba80:	e30822b0 	movw	r2, #33456	; 0x82b0
7001ba84:	e3472002 	movt	r2, #28674	; 0x7002
7001ba88:	e3a0304c 	mov	r3, #76	; 0x4c
7001ba8c:	ebffaf58 	bl	700077f4 <rt_kprintf>
7001ba90:	e1a00000 	nop			; (mov r0, r0)
7001ba94:	e55b3009 	ldrb	r3, [fp, #-9]
7001ba98:	e6ef3073 	uxtb	r3, r3
7001ba9c:	e3530000 	cmp	r3, #0
7001baa0:	0afffffb 	beq	7001ba94 <_pthread_get_data+0x5c>
7001baa4:	ea000008 	b	7001bacc <_pthread_get_data+0x94>
7001baa8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001baac:	e3473002 	movt	r3, #28674	; 0x7002
7001bab0:	e5933000 	ldr	r3, [r3]
7001bab4:	e3080228 	movw	r0, #33320	; 0x8228
7001bab8:	e3470002 	movt	r0, #28674	; 0x7002
7001babc:	e30812b0 	movw	r1, #33456	; 0x82b0
7001bac0:	e3471002 	movt	r1, #28674	; 0x7002
7001bac4:	e3a0204c 	mov	r2, #76	; 0x4c
7001bac8:	e12fff33 	blx	r3

    ptd = (_pthread_data_t *)thread->user_data;
7001bacc:	e51b3010 	ldr	r3, [fp, #-16]
7001bad0:	e5933074 	ldr	r3, [r3, #116]	; 0x74
7001bad4:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001bad8:	e51b3008 	ldr	r3, [fp, #-8]
7001badc:	e3530000 	cmp	r3, #0
7001bae0:	1a00001d 	bne	7001bb5c <_pthread_get_data+0x124>
7001bae4:	e3a03000 	mov	r3, #0
7001bae8:	e54b300a 	strb	r3, [fp, #-10]
7001baec:	e30a3b74 	movw	r3, #43892	; 0xab74
7001baf0:	e3473002 	movt	r3, #28674	; 0x7002
7001baf4:	e5933000 	ldr	r3, [r3]
7001baf8:	e3530000 	cmp	r3, #0
7001bafc:	1a00000d 	bne	7001bb38 <_pthread_get_data+0x100>
7001bb00:	e3080208 	movw	r0, #33288	; 0x8208
7001bb04:	e3470002 	movt	r0, #28674	; 0x7002
7001bb08:	e308123c 	movw	r1, #33340	; 0x823c
7001bb0c:	e3471002 	movt	r1, #28674	; 0x7002
7001bb10:	e30822b0 	movw	r2, #33456	; 0x82b0
7001bb14:	e3472002 	movt	r2, #28674	; 0x7002
7001bb18:	e3a0304f 	mov	r3, #79	; 0x4f
7001bb1c:	ebffaf34 	bl	700077f4 <rt_kprintf>
7001bb20:	e1a00000 	nop			; (mov r0, r0)
7001bb24:	e55b300a 	ldrb	r3, [fp, #-10]
7001bb28:	e6ef3073 	uxtb	r3, r3
7001bb2c:	e3530000 	cmp	r3, #0
7001bb30:	0afffffb 	beq	7001bb24 <_pthread_get_data+0xec>
7001bb34:	ea000008 	b	7001bb5c <_pthread_get_data+0x124>
7001bb38:	e30a3b74 	movw	r3, #43892	; 0xab74
7001bb3c:	e3473002 	movt	r3, #28674	; 0x7002
7001bb40:	e5933000 	ldr	r3, [r3]
7001bb44:	e308023c 	movw	r0, #33340	; 0x823c
7001bb48:	e3470002 	movt	r0, #28674	; 0x7002
7001bb4c:	e30812b0 	movw	r1, #33456	; 0x82b0
7001bb50:	e3471002 	movt	r1, #28674	; 0x7002
7001bb54:	e3a0204f 	mov	r2, #79	; 0x4f
7001bb58:	e12fff33 	blx	r3
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
7001bb5c:	e51b3008 	ldr	r3, [fp, #-8]
7001bb60:	e5932000 	ldr	r2, [r3]
7001bb64:	e3063873 	movw	r3, #26739	; 0x6873
7001bb68:	e3473074 	movt	r3, #28788	; 0x7074
7001bb6c:	e1520003 	cmp	r2, r3
7001bb70:	0a00001d 	beq	7001bbec <_pthread_get_data+0x1b4>
7001bb74:	e3a03000 	mov	r3, #0
7001bb78:	e54b300b 	strb	r3, [fp, #-11]
7001bb7c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001bb80:	e3473002 	movt	r3, #28674	; 0x7002
7001bb84:	e5933000 	ldr	r3, [r3]
7001bb88:	e3530000 	cmp	r3, #0
7001bb8c:	1a00000d 	bne	7001bbc8 <_pthread_get_data+0x190>
7001bb90:	e3080208 	movw	r0, #33288	; 0x8208
7001bb94:	e3470002 	movt	r0, #28674	; 0x7002
7001bb98:	e308124c 	movw	r1, #33356	; 0x824c
7001bb9c:	e3471002 	movt	r1, #28674	; 0x7002
7001bba0:	e30822b0 	movw	r2, #33456	; 0x82b0
7001bba4:	e3472002 	movt	r2, #28674	; 0x7002
7001bba8:	e3a03050 	mov	r3, #80	; 0x50
7001bbac:	ebffaf10 	bl	700077f4 <rt_kprintf>
7001bbb0:	e1a00000 	nop			; (mov r0, r0)
7001bbb4:	e55b300b 	ldrb	r3, [fp, #-11]
7001bbb8:	e6ef3073 	uxtb	r3, r3
7001bbbc:	e3530000 	cmp	r3, #0
7001bbc0:	0afffffb 	beq	7001bbb4 <_pthread_get_data+0x17c>
7001bbc4:	ea000008 	b	7001bbec <_pthread_get_data+0x1b4>
7001bbc8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001bbcc:	e3473002 	movt	r3, #28674	; 0x7002
7001bbd0:	e5933000 	ldr	r3, [r3]
7001bbd4:	e308024c 	movw	r0, #33356	; 0x824c
7001bbd8:	e3470002 	movt	r0, #28674	; 0x7002
7001bbdc:	e30812b0 	movw	r1, #33456	; 0x82b0
7001bbe0:	e3471002 	movt	r1, #28674	; 0x7002
7001bbe4:	e3a02050 	mov	r2, #80	; 0x50
7001bbe8:	e12fff33 	blx	r3

    return ptd;
7001bbec:	e51b3008 	ldr	r3, [fp, #-8]
}
7001bbf0:	e1a00003 	mov	r0, r3
7001bbf4:	e24bd004 	sub	sp, fp, #4
7001bbf8:	e8bd8800 	pop	{fp, pc}

7001bbfc <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
7001bbfc:	e92d4800 	push	{fp, lr}
7001bc00:	e28db004 	add	fp, sp, #4
    /* initialize clock and time */
    clock_time_system_init();
7001bc04:	ebfffc67 	bl	7001ada8 <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
7001bc08:	eb00076a 	bl	7001d9b8 <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
7001bc0c:	ebfffd8e 	bl	7001b24c <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
7001bc10:	eb000849 	bl	7001dd3c <posix_sem_system_init>

    return 0;
7001bc14:	e3a03000 	mov	r3, #0
}
7001bc18:	e1a00003 	mov	r0, r3
7001bc1c:	e8bd8800 	pop	{fp, pc}

7001bc20 <_pthread_cleanup>:

static void _pthread_cleanup(rt_thread_t tid)
{
7001bc20:	e92d4800 	push	{fp, lr}
7001bc24:	e28db004 	add	fp, sp, #4
7001bc28:	e24dd010 	sub	sp, sp, #16
7001bc2c:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    ptd = _pthread_get_data(tid);
7001bc30:	e51b0010 	ldr	r0, [fp, #-16]
7001bc34:	ebffff7f 	bl	7001ba38 <_pthread_get_data>
7001bc38:	e50b0008 	str	r0, [fp, #-8]

    /* clear cleanup function */
    tid->cleanup = RT_NULL;
7001bc3c:	e51b3010 	ldr	r3, [fp, #-16]
7001bc40:	e3a02000 	mov	r2, #0
7001bc44:	e5832070 	str	r2, [r3, #112]	; 0x70
    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
7001bc48:	e51b3008 	ldr	r3, [fp, #-8]
7001bc4c:	e5d3300b 	ldrb	r3, [r3, #11]
7001bc50:	e3530000 	cmp	r3, #0
7001bc54:	1a000004 	bne	7001bc6c <_pthread_cleanup+0x4c>
    {
        rt_sem_release(ptd->joinable_sem);
7001bc58:	e51b3008 	ldr	r3, [fp, #-8]
7001bc5c:	e5933020 	ldr	r3, [r3, #32]
7001bc60:	e1a00003 	mov	r0, r3
7001bc64:	ebff9939 	bl	70002150 <rt_sem_release>
7001bc68:	ea000001 	b	7001bc74 <_pthread_cleanup+0x54>
    }
    else
    {
        /* release pthread resource */
        pthread_detach(tid);
7001bc6c:	e51b0010 	ldr	r0, [fp, #-16]
7001bc70:	eb000113 	bl	7001c0c4 <pthread_detach>
    }
}
7001bc74:	e24bd004 	sub	sp, fp, #4
7001bc78:	e8bd8800 	pop	{fp, pc}

7001bc7c <pthread_entry_stub>:

static void pthread_entry_stub(void *parameter)
{
7001bc7c:	e92d4800 	push	{fp, lr}
7001bc80:	e28db004 	add	fp, sp, #4
7001bc84:	e24dd010 	sub	sp, sp, #16
7001bc88:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    void *value;

    ptd = (_pthread_data_t*)parameter;
7001bc8c:	e51b3010 	ldr	r3, [fp, #-16]
7001bc90:	e50b3008 	str	r3, [fp, #-8]

    /* execute pthread entry */
    value = ptd->thread_entry(ptd->thread_parameter);
7001bc94:	e51b3008 	ldr	r3, [fp, #-8]
7001bc98:	e5933014 	ldr	r3, [r3, #20]
7001bc9c:	e51b2008 	ldr	r2, [fp, #-8]
7001bca0:	e5922018 	ldr	r2, [r2, #24]
7001bca4:	e1a00002 	mov	r0, r2
7001bca8:	e12fff33 	blx	r3
7001bcac:	e50b000c 	str	r0, [fp, #-12]
    /* set value */
    ptd->return_value = value;
7001bcb0:	e51b3008 	ldr	r3, [fp, #-8]
7001bcb4:	e51b200c 	ldr	r2, [fp, #-12]
7001bcb8:	e583201c 	str	r2, [r3, #28]
}
7001bcbc:	e24bd004 	sub	sp, fp, #4
7001bcc0:	e8bd8800 	pop	{fp, pc}

7001bcc4 <pthread_create>:

int pthread_create(pthread_t            *tid,
                   const pthread_attr_t *attr, 
                   void *(*start) (void *), void *parameter)
{
7001bcc4:	e92d4800 	push	{fp, lr}
7001bcc8:	e28db004 	add	fp, sp, #4
7001bccc:	e24dd038 	sub	sp, sp, #56	; 0x38
7001bcd0:	e50b0020 	str	r0, [fp, #-32]
7001bcd4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
7001bcd8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
7001bcdc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    char name[RT_NAME_MAX];
    static rt_uint16_t pthread_number = 0;
    _pthread_data_t *ptd;

    /* tid shall be provided */
    RT_ASSERT(tid != RT_NULL);
7001bce0:	e51b3020 	ldr	r3, [fp, #-32]
7001bce4:	e3530000 	cmp	r3, #0
7001bce8:	1a00001d 	bne	7001bd64 <pthread_create+0xa0>
7001bcec:	e3a03000 	mov	r3, #0
7001bcf0:	e54b3019 	strb	r3, [fp, #-25]
7001bcf4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001bcf8:	e3473002 	movt	r3, #28674	; 0x7002
7001bcfc:	e5933000 	ldr	r3, [r3]
7001bd00:	e3530000 	cmp	r3, #0
7001bd04:	1a00000d 	bne	7001bd40 <pthread_create+0x7c>
7001bd08:	e3080208 	movw	r0, #33288	; 0x8208
7001bd0c:	e3470002 	movt	r0, #28674	; 0x7002
7001bd10:	e3081268 	movw	r1, #33384	; 0x8268
7001bd14:	e3471002 	movt	r1, #28674	; 0x7002
7001bd18:	e30822c4 	movw	r2, #33476	; 0x82c4
7001bd1c:	e3472002 	movt	r2, #28674	; 0x7002
7001bd20:	e3a03055 	mov	r3, #85	; 0x55
7001bd24:	ebffaeb2 	bl	700077f4 <rt_kprintf>
7001bd28:	e1a00000 	nop			; (mov r0, r0)
7001bd2c:	e55b3019 	ldrb	r3, [fp, #-25]
7001bd30:	e6ef3073 	uxtb	r3, r3
7001bd34:	e3530000 	cmp	r3, #0
7001bd38:	0afffffb 	beq	7001bd2c <pthread_create+0x68>
7001bd3c:	ea000008 	b	7001bd64 <pthread_create+0xa0>
7001bd40:	e30a3b74 	movw	r3, #43892	; 0xab74
7001bd44:	e3473002 	movt	r3, #28674	; 0x7002
7001bd48:	e5933000 	ldr	r3, [r3]
7001bd4c:	e3080268 	movw	r0, #33384	; 0x8268
7001bd50:	e3470002 	movt	r0, #28674	; 0x7002
7001bd54:	e30812c4 	movw	r1, #33476	; 0x82c4
7001bd58:	e3471002 	movt	r1, #28674	; 0x7002
7001bd5c:	e3a02055 	mov	r2, #85	; 0x55
7001bd60:	e12fff33 	blx	r3

    /* allocate posix thread data */
    ptd = (_pthread_data_t*)rt_malloc(sizeof(_pthread_data_t));
7001bd64:	e3a00030 	mov	r0, #48	; 0x30
7001bd68:	ebffb0d3 	bl	700080bc <rt_malloc>
7001bd6c:	e50b000c 	str	r0, [fp, #-12]
    if (ptd == RT_NULL)
7001bd70:	e51b300c 	ldr	r3, [fp, #-12]
7001bd74:	e3530000 	cmp	r3, #0
7001bd78:	1a000001 	bne	7001bd84 <pthread_create+0xc0>
        return ENOMEM;
7001bd7c:	e3a0300c 	mov	r3, #12
7001bd80:	ea0000cc 	b	7001c0b8 <pthread_create+0x3f4>
    /* clean posix thread data memory */
    rt_memset(ptd, 0, sizeof(_pthread_data_t));
7001bd84:	e51b000c 	ldr	r0, [fp, #-12]
7001bd88:	e3a01000 	mov	r1, #0
7001bd8c:	e3a02030 	mov	r2, #48	; 0x30
7001bd90:	ebffa89d 	bl	7000600c <rt_memset>
    ptd->canceled = 0;
7001bd94:	e51b300c 	ldr	r3, [fp, #-12]
7001bd98:	e3a02000 	mov	r2, #0
7001bd9c:	e5c32026 	strb	r2, [r3, #38]	; 0x26
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
7001bda0:	e51b300c 	ldr	r3, [fp, #-12]
7001bda4:	e3a02003 	mov	r2, #3
7001bda8:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    ptd->canceltype = PTHREAD_CANCEL_DEFERRED;
7001bdac:	e51b300c 	ldr	r3, [fp, #-12]
7001bdb0:	e3a02002 	mov	r2, #2
7001bdb4:	e5c32025 	strb	r2, [r3, #37]	; 0x25
    ptd->magic = PTHREAD_MAGIC;
7001bdb8:	e51b200c 	ldr	r2, [fp, #-12]
7001bdbc:	e3063873 	movw	r3, #26739	; 0x6873
7001bdc0:	e3473074 	movt	r3, #28788	; 0x7074
7001bdc4:	e5823000 	str	r3, [r2]

    if (attr != RT_NULL)
7001bdc8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7001bdcc:	e3530000 	cmp	r3, #0
7001bdd0:	0a000005 	beq	7001bdec <pthread_create+0x128>
        ptd->attr = *attr;
7001bdd4:	e51b300c 	ldr	r3, [fp, #-12]
7001bdd8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
7001bddc:	e2833004 	add	r3, r3, #4
7001bde0:	e8920007 	ldm	r2, {r0, r1, r2}
7001bde4:	e8830007 	stm	r3, {r0, r1, r2}
7001bde8:	ea000003 	b	7001bdfc <pthread_create+0x138>
    else 
    {
        /* use default attribute */
        pthread_attr_init(&ptd->attr);
7001bdec:	e51b300c 	ldr	r3, [fp, #-12]
7001bdf0:	e2833004 	add	r3, r3, #4
7001bdf4:	e1a00003 	mov	r0, r3
7001bdf8:	eb000375 	bl	7001cbd4 <pthread_attr_init>
    }

    rt_snprintf(name, sizeof(name), "pth%02d", pthread_number ++);
7001bdfc:	e30a3a4c 	movw	r3, #43596	; 0xaa4c
7001be00:	e3473002 	movt	r3, #28674	; 0x7002
7001be04:	e1d330b0 	ldrh	r3, [r3]
7001be08:	e1a02003 	mov	r2, r3
7001be0c:	e2823001 	add	r3, r2, #1
7001be10:	e6ff1073 	uxth	r1, r3
7001be14:	e30a3a4c 	movw	r3, #43596	; 0xaa4c
7001be18:	e3473002 	movt	r3, #28674	; 0x7002
7001be1c:	e1c310b0 	strh	r1, [r3]
7001be20:	e1a03002 	mov	r3, r2
7001be24:	e24b2018 	sub	r2, fp, #24
7001be28:	e1a00002 	mov	r0, r2
7001be2c:	e3a01006 	mov	r1, #6
7001be30:	e3082278 	movw	r2, #33400	; 0x8278
7001be34:	e3472002 	movt	r2, #28674	; 0x7002
7001be38:	ebffae02 	bl	70007648 <rt_snprintf>
    if (ptd->attr.stack_base == 0)
7001be3c:	e51b300c 	ldr	r3, [fp, #-12]
7001be40:	e5933004 	ldr	r3, [r3, #4]
7001be44:	e3530000 	cmp	r3, #0
7001be48:	1a000005 	bne	7001be64 <pthread_create+0x1a0>
    {
        stack = (void*)rt_malloc(ptd->attr.stack_size);
7001be4c:	e51b300c 	ldr	r3, [fp, #-12]
7001be50:	e1d330b8 	ldrh	r3, [r3, #8]
7001be54:	e1a00003 	mov	r0, r3
7001be58:	ebffb097 	bl	700080bc <rt_malloc>
7001be5c:	e50b0008 	str	r0, [fp, #-8]
7001be60:	ea000002 	b	7001be70 <pthread_create+0x1ac>
    }
    else
        stack = (void*)(ptd->attr.stack_base);
7001be64:	e51b300c 	ldr	r3, [fp, #-12]
7001be68:	e5933004 	ldr	r3, [r3, #4]
7001be6c:	e50b3008 	str	r3, [fp, #-8]

    if (stack == RT_NULL) 
7001be70:	e51b3008 	ldr	r3, [fp, #-8]
7001be74:	e3530000 	cmp	r3, #0
7001be78:	1a000003 	bne	7001be8c <pthread_create+0x1c8>
    {
        rt_free(ptd);
7001be7c:	e51b000c 	ldr	r0, [fp, #-12]
7001be80:	ebffb350 	bl	70008bc8 <rt_free>

        return ENOMEM;
7001be84:	e3a0300c 	mov	r3, #12
7001be88:	ea00008a 	b	7001c0b8 <pthread_create+0x3f4>
    }

    /* pthread is a static thread object */
    ptd->tid = (rt_thread_t) rt_malloc(sizeof(struct rt_thread));
7001be8c:	e3a00078 	mov	r0, #120	; 0x78
7001be90:	ebffb089 	bl	700080bc <rt_malloc>
7001be94:	e1a02000 	mov	r2, r0
7001be98:	e51b300c 	ldr	r3, [fp, #-12]
7001be9c:	e5832010 	str	r2, [r3, #16]
    if (ptd->tid == RT_NULL)
7001bea0:	e51b300c 	ldr	r3, [fp, #-12]
7001bea4:	e5933010 	ldr	r3, [r3, #16]
7001bea8:	e3530000 	cmp	r3, #0
7001beac:	1a000009 	bne	7001bed8 <pthread_create+0x214>
    {
        if (ptd->attr.stack_base == 0)
7001beb0:	e51b300c 	ldr	r3, [fp, #-12]
7001beb4:	e5933004 	ldr	r3, [r3, #4]
7001beb8:	e3530000 	cmp	r3, #0
7001bebc:	1a000001 	bne	7001bec8 <pthread_create+0x204>
            rt_free(stack);
7001bec0:	e51b0008 	ldr	r0, [fp, #-8]
7001bec4:	ebffb33f 	bl	70008bc8 <rt_free>
        rt_free(ptd);
7001bec8:	e51b000c 	ldr	r0, [fp, #-12]
7001becc:	ebffb33d 	bl	70008bc8 <rt_free>

        return ENOMEM;
7001bed0:	e3a0300c 	mov	r3, #12
7001bed4:	ea000077 	b	7001c0b8 <pthread_create+0x3f4>
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
7001bed8:	e51b300c 	ldr	r3, [fp, #-12]
7001bedc:	e5d3300b 	ldrb	r3, [r3, #11]
7001bee0:	e3530000 	cmp	r3, #0
7001bee4:	1a000015 	bne	7001bf40 <pthread_create+0x27c>
    {
        ptd->joinable_sem = rt_sem_create(name, 0, RT_IPC_FLAG_FIFO);
7001bee8:	e24b3018 	sub	r3, fp, #24
7001beec:	e1a00003 	mov	r0, r3
7001bef0:	e3a01000 	mov	r1, #0
7001bef4:	e3a02000 	mov	r2, #0
7001bef8:	ebff9714 	bl	70001b50 <rt_sem_create>
7001befc:	e1a02000 	mov	r2, r0
7001bf00:	e51b300c 	ldr	r3, [fp, #-12]
7001bf04:	e5832020 	str	r2, [r3, #32]
        if (ptd->joinable_sem == RT_NULL)
7001bf08:	e51b300c 	ldr	r3, [fp, #-12]
7001bf0c:	e5933020 	ldr	r3, [r3, #32]
7001bf10:	e3530000 	cmp	r3, #0
7001bf14:	1a00000c 	bne	7001bf4c <pthread_create+0x288>
        {
            if (ptd->attr.stack_base != 0)
7001bf18:	e51b300c 	ldr	r3, [fp, #-12]
7001bf1c:	e5933004 	ldr	r3, [r3, #4]
7001bf20:	e3530000 	cmp	r3, #0
7001bf24:	0a000001 	beq	7001bf30 <pthread_create+0x26c>
                rt_free(stack);
7001bf28:	e51b0008 	ldr	r0, [fp, #-8]
7001bf2c:	ebffb325 	bl	70008bc8 <rt_free>
            rt_free(ptd);
7001bf30:	e51b000c 	ldr	r0, [fp, #-12]
7001bf34:	ebffb323 	bl	70008bc8 <rt_free>

            return ENOMEM;
7001bf38:	e3a0300c 	mov	r3, #12
7001bf3c:	ea00005d 	b	7001c0b8 <pthread_create+0x3f4>
        }
    }
    else
        ptd->joinable_sem = RT_NULL;
7001bf40:	e51b300c 	ldr	r3, [fp, #-12]
7001bf44:	e3a02000 	mov	r2, #0
7001bf48:	e5832020 	str	r2, [r3, #32]

    /* set parameter */
    ptd->thread_entry = start;
7001bf4c:	e51b300c 	ldr	r3, [fp, #-12]
7001bf50:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
7001bf54:	e5832014 	str	r2, [r3, #20]
    ptd->thread_parameter = parameter;
7001bf58:	e51b300c 	ldr	r3, [fp, #-12]
7001bf5c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
7001bf60:	e5832018 	str	r2, [r3, #24]

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
7001bf64:	e51b300c 	ldr	r3, [fp, #-12]
7001bf68:	e5932010 	ldr	r2, [r3, #16]
        stack, ptd->attr.stack_size, 
7001bf6c:	e51b300c 	ldr	r3, [fp, #-12]
7001bf70:	e1d330b8 	ldrh	r3, [r3, #8]
    /* set parameter */
    ptd->thread_entry = start;
    ptd->thread_parameter = parameter;

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
7001bf74:	e1a00003 	mov	r0, r3
7001bf78:	e51b300c 	ldr	r3, [fp, #-12]
7001bf7c:	e5d3100a 	ldrb	r1, [r3, #10]
7001bf80:	e24b3018 	sub	r3, fp, #24
7001bf84:	e51bc008 	ldr	ip, [fp, #-8]
7001bf88:	e58dc000 	str	ip, [sp]
7001bf8c:	e58d0004 	str	r0, [sp, #4]
7001bf90:	e58d1008 	str	r1, [sp, #8]
7001bf94:	e3a01005 	mov	r1, #5
7001bf98:	e58d100c 	str	r1, [sp, #12]
7001bf9c:	e1a00002 	mov	r0, r2
7001bfa0:	e1a01003 	mov	r1, r3
7001bfa4:	e30b2c7c 	movw	r2, #48252	; 0xbc7c
7001bfa8:	e3472001 	movt	r2, #28673	; 0x7001
7001bfac:	e51b300c 	ldr	r3, [fp, #-12]
7001bfb0:	ebffb910 	bl	7000a3f8 <rt_thread_init>
7001bfb4:	e1a03000 	mov	r3, r0
7001bfb8:	e3530000 	cmp	r3, #0
7001bfbc:	0a000011 	beq	7001c008 <pthread_create+0x344>
        stack, ptd->attr.stack_size, 
        ptd->attr.priority, 5) != RT_EOK)
    {
        if (ptd->attr.stack_base == 0)
7001bfc0:	e51b300c 	ldr	r3, [fp, #-12]
7001bfc4:	e5933004 	ldr	r3, [r3, #4]
7001bfc8:	e3530000 	cmp	r3, #0
7001bfcc:	1a000001 	bne	7001bfd8 <pthread_create+0x314>
            rt_free(stack);
7001bfd0:	e51b0008 	ldr	r0, [fp, #-8]
7001bfd4:	ebffb2fb 	bl	70008bc8 <rt_free>
        if (ptd->joinable_sem != RT_NULL)
7001bfd8:	e51b300c 	ldr	r3, [fp, #-12]
7001bfdc:	e5933020 	ldr	r3, [r3, #32]
7001bfe0:	e3530000 	cmp	r3, #0
7001bfe4:	0a000003 	beq	7001bff8 <pthread_create+0x334>
            rt_sem_delete(ptd->joinable_sem);
7001bfe8:	e51b300c 	ldr	r3, [fp, #-12]
7001bfec:	e5933020 	ldr	r3, [r3, #32]
7001bff0:	e1a00003 	mov	r0, r3
7001bff4:	ebff971e 	bl	70001c74 <rt_sem_delete>
        rt_free(ptd);
7001bff8:	e51b000c 	ldr	r0, [fp, #-12]
7001bffc:	ebffb2f1 	bl	70008bc8 <rt_free>

        return EINVAL;
7001c000:	e3a03016 	mov	r3, #22
7001c004:	ea00002b 	b	7001c0b8 <pthread_create+0x3f4>
    }

    /* set pthread id */
    *tid = ptd->tid;
7001c008:	e51b300c 	ldr	r3, [fp, #-12]
7001c00c:	e5932010 	ldr	r2, [r3, #16]
7001c010:	e51b3020 	ldr	r3, [fp, #-32]
7001c014:	e5832000 	str	r2, [r3]

    /* set pthread cleanup function and ptd data */
    (*tid)->cleanup = _pthread_cleanup;
7001c018:	e51b3020 	ldr	r3, [fp, #-32]
7001c01c:	e5932000 	ldr	r2, [r3]
7001c020:	e30b3c20 	movw	r3, #48160	; 0xbc20
7001c024:	e3473001 	movt	r3, #28673	; 0x7001
7001c028:	e5823070 	str	r3, [r2, #112]	; 0x70
    (*tid)->user_data = (rt_uint32_t)ptd;
7001c02c:	e51b3020 	ldr	r3, [fp, #-32]
7001c030:	e5933000 	ldr	r3, [r3]
7001c034:	e51b200c 	ldr	r2, [fp, #-12]
7001c038:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* start thread */
    result = rt_thread_startup(*tid);
7001c03c:	e51b3020 	ldr	r3, [fp, #-32]
7001c040:	e5933000 	ldr	r3, [r3]
7001c044:	e1a00003 	mov	r0, r3
7001c048:	ebffb951 	bl	7000a594 <rt_thread_startup>
7001c04c:	e50b0010 	str	r0, [fp, #-16]
    if (result == RT_EOK)
7001c050:	e51b3010 	ldr	r3, [fp, #-16]
7001c054:	e3530000 	cmp	r3, #0
7001c058:	1a000001 	bne	7001c064 <pthread_create+0x3a0>
        return 0;
7001c05c:	e3a03000 	mov	r3, #0
7001c060:	ea000014 	b	7001c0b8 <pthread_create+0x3f4>

    /* start thread failed */
    rt_thread_detach(ptd->tid);
7001c064:	e51b300c 	ldr	r3, [fp, #-12]
7001c068:	e5933010 	ldr	r3, [r3, #16]
7001c06c:	e1a00003 	mov	r0, r3
7001c070:	ebffb9a7 	bl	7000a714 <rt_thread_detach>
    if (ptd->attr.stack_base == 0)
7001c074:	e51b300c 	ldr	r3, [fp, #-12]
7001c078:	e5933004 	ldr	r3, [r3, #4]
7001c07c:	e3530000 	cmp	r3, #0
7001c080:	1a000001 	bne	7001c08c <pthread_create+0x3c8>
        rt_free(stack);
7001c084:	e51b0008 	ldr	r0, [fp, #-8]
7001c088:	ebffb2ce 	bl	70008bc8 <rt_free>
    if (ptd->joinable_sem != RT_NULL)
7001c08c:	e51b300c 	ldr	r3, [fp, #-12]
7001c090:	e5933020 	ldr	r3, [r3, #32]
7001c094:	e3530000 	cmp	r3, #0
7001c098:	0a000003 	beq	7001c0ac <pthread_create+0x3e8>
        rt_sem_delete(ptd->joinable_sem);
7001c09c:	e51b300c 	ldr	r3, [fp, #-12]
7001c0a0:	e5933020 	ldr	r3, [r3, #32]
7001c0a4:	e1a00003 	mov	r0, r3
7001c0a8:	ebff96f1 	bl	70001c74 <rt_sem_delete>

    rt_free(ptd);
7001c0ac:	e51b000c 	ldr	r0, [fp, #-12]
7001c0b0:	ebffb2c4 	bl	70008bc8 <rt_free>

    return EINVAL;
7001c0b4:	e3a03016 	mov	r3, #22
}
7001c0b8:	e1a00003 	mov	r0, r3
7001c0bc:	e24bd004 	sub	sp, fp, #4
7001c0c0:	e8bd8800 	pop	{fp, pc}

7001c0c4 <pthread_detach>:
RTM_EXPORT(pthread_create);

int pthread_detach(pthread_t thread)
{
7001c0c4:	e92d4800 	push	{fp, lr}
7001c0c8:	e28db004 	add	fp, sp, #4
7001c0cc:	e24dd010 	sub	sp, sp, #16
7001c0d0:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t* ptd;

    ptd = _pthread_get_data(thread);
7001c0d4:	e51b0010 	ldr	r0, [fp, #-16]
7001c0d8:	ebfffe56 	bl	7001ba38 <_pthread_get_data>
7001c0dc:	e50b0008 	str	r0, [fp, #-8]

    if (thread->stat == RT_THREAD_CLOSE)
7001c0e0:	e51b3010 	ldr	r3, [fp, #-16]
7001c0e4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
7001c0e8:	e3530004 	cmp	r3, #4
7001c0ec:	1a000023 	bne	7001c180 <pthread_detach+0xbc>
    {
        /* delete joinable semaphore */
        if (ptd->joinable_sem != RT_NULL)
7001c0f0:	e51b3008 	ldr	r3, [fp, #-8]
7001c0f4:	e5933020 	ldr	r3, [r3, #32]
7001c0f8:	e3530000 	cmp	r3, #0
7001c0fc:	0a000003 	beq	7001c110 <pthread_detach+0x4c>
            rt_sem_delete(ptd->joinable_sem);
7001c100:	e51b3008 	ldr	r3, [fp, #-8]
7001c104:	e5933020 	ldr	r3, [r3, #32]
7001c108:	e1a00003 	mov	r0, r3
7001c10c:	ebff96d8 	bl	70001c74 <rt_sem_delete>
        /* detach thread object */
        rt_thread_detach(ptd->tid);
7001c110:	e51b3008 	ldr	r3, [fp, #-8]
7001c114:	e5933010 	ldr	r3, [r3, #16]
7001c118:	e1a00003 	mov	r0, r3
7001c11c:	ebffb97c 	bl	7000a714 <rt_thread_detach>

        /* release thread resource */
        if (ptd->attr.stack_base == RT_NULL)
7001c120:	e51b3008 	ldr	r3, [fp, #-8]
7001c124:	e5933004 	ldr	r3, [r3, #4]
7001c128:	e3530000 	cmp	r3, #0
7001c12c:	1a000004 	bne	7001c144 <pthread_detach+0x80>
        {
            /* release thread allocated stack */
            rt_free(ptd->tid->stack_addr);
7001c130:	e51b3008 	ldr	r3, [fp, #-8]
7001c134:	e5933010 	ldr	r3, [r3, #16]
7001c138:	e5933024 	ldr	r3, [r3, #36]	; 0x24
7001c13c:	e1a00003 	mov	r0, r3
7001c140:	ebffb2a0 	bl	70008bc8 <rt_free>

        /*
         * if this thread create the local thread data,
         * delete it
         */
        if (ptd->tls != RT_NULL)
7001c144:	e51b3008 	ldr	r3, [fp, #-8]
7001c148:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001c14c:	e3530000 	cmp	r3, #0
7001c150:	0a000003 	beq	7001c164 <pthread_detach+0xa0>
            rt_free(ptd->tls);
7001c154:	e51b3008 	ldr	r3, [fp, #-8]
7001c158:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001c15c:	e1a00003 	mov	r0, r3
7001c160:	ebffb298 	bl	70008bc8 <rt_free>
        rt_free(ptd->tid);
7001c164:	e51b3008 	ldr	r3, [fp, #-8]
7001c168:	e5933010 	ldr	r3, [r3, #16]
7001c16c:	e1a00003 	mov	r0, r3
7001c170:	ebffb294 	bl	70008bc8 <rt_free>
        rt_free(ptd);
7001c174:	e51b0008 	ldr	r0, [fp, #-8]
7001c178:	ebffb292 	bl	70008bc8 <rt_free>
7001c17c:	ea00000b 	b	7001c1b0 <pthread_detach+0xec>
    }
    else
    {
        rt_enter_critical();
7001c180:	ebffb76c 	bl	70009f38 <rt_enter_critical>
        /* change to detach state */
        ptd->attr.detachstate = PTHREAD_CREATE_DETACHED;
7001c184:	e51b3008 	ldr	r3, [fp, #-8]
7001c188:	e3a02001 	mov	r2, #1
7001c18c:	e5c3200b 	strb	r2, [r3, #11]

        /* detach joinable semaphore */
        rt_sem_delete(ptd->joinable_sem);
7001c190:	e51b3008 	ldr	r3, [fp, #-8]
7001c194:	e5933020 	ldr	r3, [r3, #32]
7001c198:	e1a00003 	mov	r0, r3
7001c19c:	ebff96b4 	bl	70001c74 <rt_sem_delete>
        ptd->joinable_sem = RT_NULL;
7001c1a0:	e51b3008 	ldr	r3, [fp, #-8]
7001c1a4:	e3a02000 	mov	r2, #0
7001c1a8:	e5832020 	str	r2, [r3, #32]
        rt_exit_critical();
7001c1ac:	ebffb771 	bl	70009f78 <rt_exit_critical>
    }

    return 0;
7001c1b0:	e3a03000 	mov	r3, #0
}
7001c1b4:	e1a00003 	mov	r0, r3
7001c1b8:	e24bd004 	sub	sp, fp, #4
7001c1bc:	e8bd8800 	pop	{fp, pc}

7001c1c0 <pthread_join>:
RTM_EXPORT(pthread_detach);

int pthread_join (pthread_t thread, void **value_ptr)
{
7001c1c0:	e92d4800 	push	{fp, lr}
7001c1c4:	e28db004 	add	fp, sp, #4
7001c1c8:	e24dd010 	sub	sp, sp, #16
7001c1cc:	e50b0010 	str	r0, [fp, #-16]
7001c1d0:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t* ptd;
    rt_err_t result;

    if (thread == rt_thread_self())
7001c1d4:	ebffb8e5 	bl	7000a570 <rt_thread_self>
7001c1d8:	e1a02000 	mov	r2, r0
7001c1dc:	e51b3010 	ldr	r3, [fp, #-16]
7001c1e0:	e1520003 	cmp	r2, r3
7001c1e4:	1a000001 	bne	7001c1f0 <pthread_join+0x30>
    {
        /* join self */
        return EDEADLK;
7001c1e8:	e3a0302d 	mov	r3, #45	; 0x2d
7001c1ec:	ea00001d 	b	7001c268 <pthread_join+0xa8>
    }

    ptd = _pthread_get_data(thread);
7001c1f0:	e51b0010 	ldr	r0, [fp, #-16]
7001c1f4:	ebfffe0f 	bl	7001ba38 <_pthread_get_data>
7001c1f8:	e50b0008 	str	r0, [fp, #-8]
    if (ptd->attr.detachstate == PTHREAD_CREATE_DETACHED)
7001c1fc:	e51b3008 	ldr	r3, [fp, #-8]
7001c200:	e5d3300b 	ldrb	r3, [r3, #11]
7001c204:	e3530001 	cmp	r3, #1
7001c208:	1a000001 	bne	7001c214 <pthread_join+0x54>
        return EINVAL; /* join on a detached pthread */
7001c20c:	e3a03016 	mov	r3, #22
7001c210:	ea000014 	b	7001c268 <pthread_join+0xa8>

    result = rt_sem_take(ptd->joinable_sem, RT_WAITING_FOREVER);
7001c214:	e51b3008 	ldr	r3, [fp, #-8]
7001c218:	e5933020 	ldr	r3, [r3, #32]
7001c21c:	e1a00003 	mov	r0, r3
7001c220:	e3e01000 	mvn	r1, #0
7001c224:	ebff96ed 	bl	70001de0 <rt_sem_take>
7001c228:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
7001c22c:	e51b300c 	ldr	r3, [fp, #-12]
7001c230:	e3530000 	cmp	r3, #0
7001c234:	1a00000a 	bne	7001c264 <pthread_join+0xa4>
    {
        /* get return value */
        if (value_ptr != RT_NULL)
7001c238:	e51b3014 	ldr	r3, [fp, #-20]
7001c23c:	e3530000 	cmp	r3, #0
7001c240:	0a000003 	beq	7001c254 <pthread_join+0x94>
            *value_ptr = ptd->return_value;
7001c244:	e51b3008 	ldr	r3, [fp, #-8]
7001c248:	e593201c 	ldr	r2, [r3, #28]
7001c24c:	e51b3014 	ldr	r3, [fp, #-20]
7001c250:	e5832000 	str	r2, [r3]

        /* release resource */
        pthread_detach(thread);
7001c254:	e51b0010 	ldr	r0, [fp, #-16]
7001c258:	ebffff99 	bl	7001c0c4 <pthread_detach>
    }
    else
        return ESRCH;
    
    return 0;
7001c25c:	e3a03000 	mov	r3, #0
7001c260:	ea000000 	b	7001c268 <pthread_join+0xa8>

        /* release resource */
        pthread_detach(thread);
    }
    else
        return ESRCH;
7001c264:	e3a03003 	mov	r3, #3
    
    return 0;
}
7001c268:	e1a00003 	mov	r0, r3
7001c26c:	e24bd004 	sub	sp, fp, #4
7001c270:	e8bd8800 	pop	{fp, pc}

7001c274 <pthread_exit>:
RTM_EXPORT(pthread_join);

void pthread_exit (void *value)
{
7001c274:	e92d4800 	push	{fp, lr}
7001c278:	e28db004 	add	fp, sp, #4
7001c27c:	e24dd018 	sub	sp, sp, #24
7001c280:	e50b0018 	str	r0, [fp, #-24]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;
    extern _pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

    ptd = _pthread_get_data(rt_thread_self());
7001c284:	ebffb8b9 	bl	7000a570 <rt_thread_self>
7001c288:	e1a03000 	mov	r3, r0
7001c28c:	e1a00003 	mov	r0, r3
7001c290:	ebfffde8 	bl	7001ba38 <_pthread_get_data>
7001c294:	e50b000c 	str	r0, [fp, #-12]

    rt_enter_critical();
7001c298:	ebffb726 	bl	70009f38 <rt_enter_critical>
    /* disable cancel */
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
7001c29c:	e51b300c 	ldr	r3, [fp, #-12]
7001c2a0:	e3a02003 	mov	r2, #3
7001c2a4:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    /* set return value */
    ptd->return_value = value;
7001c2a8:	e51b300c 	ldr	r3, [fp, #-12]
7001c2ac:	e51b2018 	ldr	r2, [fp, #-24]
7001c2b0:	e583201c 	str	r2, [r3, #28]
    rt_exit_critical();
7001c2b4:	ebffb72f 	bl	70009f78 <rt_exit_critical>

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
7001c2b8:	ea00000e 	b	7001c2f8 <pthread_exit+0x84>
    {
        cleanup = ptd->cleanup;
7001c2bc:	e51b300c 	ldr	r3, [fp, #-12]
7001c2c0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
7001c2c4:	e50b3010 	str	r3, [fp, #-16]
        ptd->cleanup = cleanup->next;
7001c2c8:	e51b3010 	ldr	r3, [fp, #-16]
7001c2cc:	e5932008 	ldr	r2, [r3, #8]
7001c2d0:	e51b300c 	ldr	r3, [fp, #-12]
7001c2d4:	e5832028 	str	r2, [r3, #40]	; 0x28

        cleanup->cleanup_func(cleanup->parameter);
7001c2d8:	e51b3010 	ldr	r3, [fp, #-16]
7001c2dc:	e5933000 	ldr	r3, [r3]
7001c2e0:	e51b2010 	ldr	r2, [fp, #-16]
7001c2e4:	e5922004 	ldr	r2, [r2, #4]
7001c2e8:	e1a00002 	mov	r0, r2
7001c2ec:	e12fff33 	blx	r3
        /* release this cleanup function */
        rt_free(cleanup);
7001c2f0:	e51b0010 	ldr	r0, [fp, #-16]
7001c2f4:	ebffb233 	bl	70008bc8 <rt_free>
    /* set return value */
    ptd->return_value = value;
    rt_exit_critical();

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
7001c2f8:	e51b300c 	ldr	r3, [fp, #-12]
7001c2fc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
7001c300:	e3530000 	cmp	r3, #0
7001c304:	1affffec 	bne	7001c2bc <pthread_exit+0x48>
        /* release this cleanup function */
        rt_free(cleanup);
    }

    /* destruct thread local key */
    if (ptd->tls != RT_NULL)
7001c308:	e51b300c 	ldr	r3, [fp, #-12]
7001c30c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001c310:	e3530000 	cmp	r3, #0
7001c314:	0a000029 	beq	7001c3c0 <pthread_exit+0x14c>
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
7001c318:	e3a03000 	mov	r3, #0
7001c31c:	e50b3008 	str	r3, [fp, #-8]
7001c320:	ea00001c 	b	7001c398 <pthread_exit+0x124>
        {
            if (_thread_keys[index].is_used)
7001c324:	e30b383c 	movw	r3, #47164	; 0xb83c
7001c328:	e3473002 	movt	r3, #28674	; 0x7002
7001c32c:	e51b2008 	ldr	r2, [fp, #-8]
7001c330:	e7933182 	ldr	r3, [r3, r2, lsl #3]
7001c334:	e3530000 	cmp	r3, #0
7001c338:	0a000013 	beq	7001c38c <pthread_exit+0x118>
            {
                data = ptd->tls[index];
7001c33c:	e51b300c 	ldr	r3, [fp, #-12]
7001c340:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
7001c344:	e51b3008 	ldr	r3, [fp, #-8]
7001c348:	e1a03103 	lsl	r3, r3, #2
7001c34c:	e0823003 	add	r3, r2, r3
7001c350:	e5933000 	ldr	r3, [r3]
7001c354:	e50b3014 	str	r3, [fp, #-20]
                if (data)
7001c358:	e51b3014 	ldr	r3, [fp, #-20]
7001c35c:	e3530000 	cmp	r3, #0
7001c360:	0a000009 	beq	7001c38c <pthread_exit+0x118>
                    _thread_keys[index].destructor(data);
7001c364:	e30b383c 	movw	r3, #47164	; 0xb83c
7001c368:	e3473002 	movt	r3, #28674	; 0x7002
7001c36c:	e51b1008 	ldr	r1, [fp, #-8]
7001c370:	e3a02004 	mov	r2, #4
7001c374:	e1a01181 	lsl	r1, r1, #3
7001c378:	e0833001 	add	r3, r3, r1
7001c37c:	e0833002 	add	r3, r3, r2
7001c380:	e5933000 	ldr	r3, [r3]
7001c384:	e51b0014 	ldr	r0, [fp, #-20]
7001c388:	e12fff33 	blx	r3
    if (ptd->tls != RT_NULL)
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
7001c38c:	e51b3008 	ldr	r3, [fp, #-8]
7001c390:	e2833001 	add	r3, r3, #1
7001c394:	e50b3008 	str	r3, [fp, #-8]
7001c398:	e51b3008 	ldr	r3, [fp, #-8]
7001c39c:	e3530007 	cmp	r3, #7
7001c3a0:	9affffdf 	bls	7001c324 <pthread_exit+0xb0>
                    _thread_keys[index].destructor(data);
            }
        }

        /* release tls area */
        rt_free(ptd->tls);
7001c3a4:	e51b300c 	ldr	r3, [fp, #-12]
7001c3a8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001c3ac:	e1a00003 	mov	r0, r3
7001c3b0:	ebffb204 	bl	70008bc8 <rt_free>
        ptd->tls = RT_NULL;
7001c3b4:	e51b300c 	ldr	r3, [fp, #-12]
7001c3b8:	e3a02000 	mov	r2, #0
7001c3bc:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
7001c3c0:	e51b300c 	ldr	r3, [fp, #-12]
7001c3c4:	e5d3300b 	ldrb	r3, [r3, #11]
7001c3c8:	e3530000 	cmp	r3, #0
7001c3cc:	1a000003 	bne	7001c3e0 <pthread_exit+0x16c>
    {
        /* release the joinable pthread */
        rt_sem_release(ptd->joinable_sem);
7001c3d0:	e51b300c 	ldr	r3, [fp, #-12]
7001c3d4:	e5933020 	ldr	r3, [r3, #32]
7001c3d8:	e1a00003 	mov	r0, r3
7001c3dc:	ebff975b 	bl	70002150 <rt_sem_release>
    }

    /* detach thread */
    rt_thread_detach(ptd->tid);
7001c3e0:	e51b300c 	ldr	r3, [fp, #-12]
7001c3e4:	e5933010 	ldr	r3, [r3, #16]
7001c3e8:	e1a00003 	mov	r0, r3
7001c3ec:	ebffb8c8 	bl	7000a714 <rt_thread_detach>
    /* reschedule thread */
    rt_schedule();
7001c3f0:	ebffb5fb 	bl	70009be4 <rt_schedule>
}
7001c3f4:	e24bd004 	sub	sp, fp, #4
7001c3f8:	e8bd8800 	pop	{fp, pc}

7001c3fc <pthread_once>:
RTM_EXPORT(pthread_exit);

int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))
{
7001c3fc:	e92d4800 	push	{fp, lr}
7001c400:	e28db004 	add	fp, sp, #4
7001c404:	e24dd010 	sub	sp, sp, #16
7001c408:	e50b0010 	str	r0, [fp, #-16]
7001c40c:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(once_control != RT_NULL);
7001c410:	e51b3010 	ldr	r3, [fp, #-16]
7001c414:	e3530000 	cmp	r3, #0
7001c418:	1a00001d 	bne	7001c494 <pthread_once+0x98>
7001c41c:	e3a03000 	mov	r3, #0
7001c420:	e54b3005 	strb	r3, [fp, #-5]
7001c424:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c428:	e3473002 	movt	r3, #28674	; 0x7002
7001c42c:	e5933000 	ldr	r3, [r3]
7001c430:	e3530000 	cmp	r3, #0
7001c434:	1a00000d 	bne	7001c470 <pthread_once+0x74>
7001c438:	e3080208 	movw	r0, #33288	; 0x8208
7001c43c:	e3470002 	movt	r0, #28674	; 0x7002
7001c440:	e3081280 	movw	r1, #33408	; 0x8280
7001c444:	e3471002 	movt	r1, #28674	; 0x7002
7001c448:	e30822d4 	movw	r2, #33492	; 0x82d4
7001c44c:	e3472002 	movt	r2, #28674	; 0x7002
7001c450:	e300314a 	movw	r3, #330	; 0x14a
7001c454:	ebfface6 	bl	700077f4 <rt_kprintf>
7001c458:	e1a00000 	nop			; (mov r0, r0)
7001c45c:	e55b3005 	ldrb	r3, [fp, #-5]
7001c460:	e6ef3073 	uxtb	r3, r3
7001c464:	e3530000 	cmp	r3, #0
7001c468:	0afffffb 	beq	7001c45c <pthread_once+0x60>
7001c46c:	ea000008 	b	7001c494 <pthread_once+0x98>
7001c470:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c474:	e3473002 	movt	r3, #28674	; 0x7002
7001c478:	e5933000 	ldr	r3, [r3]
7001c47c:	e3080280 	movw	r0, #33408	; 0x8280
7001c480:	e3470002 	movt	r0, #28674	; 0x7002
7001c484:	e30812d4 	movw	r1, #33492	; 0x82d4
7001c488:	e3471002 	movt	r1, #28674	; 0x7002
7001c48c:	e300214a 	movw	r2, #330	; 0x14a
7001c490:	e12fff33 	blx	r3
    RT_ASSERT(init_routine != RT_NULL);
7001c494:	e51b3014 	ldr	r3, [fp, #-20]
7001c498:	e3530000 	cmp	r3, #0
7001c49c:	1a00001d 	bne	7001c518 <pthread_once+0x11c>
7001c4a0:	e3a03000 	mov	r3, #0
7001c4a4:	e54b3006 	strb	r3, [fp, #-6]
7001c4a8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c4ac:	e3473002 	movt	r3, #28674	; 0x7002
7001c4b0:	e5933000 	ldr	r3, [r3]
7001c4b4:	e3530000 	cmp	r3, #0
7001c4b8:	1a00000d 	bne	7001c4f4 <pthread_once+0xf8>
7001c4bc:	e3080208 	movw	r0, #33288	; 0x8208
7001c4c0:	e3470002 	movt	r0, #28674	; 0x7002
7001c4c4:	e3081298 	movw	r1, #33432	; 0x8298
7001c4c8:	e3471002 	movt	r1, #28674	; 0x7002
7001c4cc:	e30822d4 	movw	r2, #33492	; 0x82d4
7001c4d0:	e3472002 	movt	r2, #28674	; 0x7002
7001c4d4:	e300314b 	movw	r3, #331	; 0x14b
7001c4d8:	ebffacc5 	bl	700077f4 <rt_kprintf>
7001c4dc:	e1a00000 	nop			; (mov r0, r0)
7001c4e0:	e55b3006 	ldrb	r3, [fp, #-6]
7001c4e4:	e6ef3073 	uxtb	r3, r3
7001c4e8:	e3530000 	cmp	r3, #0
7001c4ec:	0afffffb 	beq	7001c4e0 <pthread_once+0xe4>
7001c4f0:	ea000008 	b	7001c518 <pthread_once+0x11c>
7001c4f4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c4f8:	e3473002 	movt	r3, #28674	; 0x7002
7001c4fc:	e5933000 	ldr	r3, [r3]
7001c500:	e3080298 	movw	r0, #33432	; 0x8298
7001c504:	e3470002 	movt	r0, #28674	; 0x7002
7001c508:	e30812d4 	movw	r1, #33492	; 0x82d4
7001c50c:	e3471002 	movt	r1, #28674	; 0x7002
7001c510:	e300214b 	movw	r2, #331	; 0x14b
7001c514:	e12fff33 	blx	r3

    rt_enter_critical();
7001c518:	ebffb686 	bl	70009f38 <rt_enter_critical>
    if (!(*once_control))
7001c51c:	e51b3010 	ldr	r3, [fp, #-16]
7001c520:	e5933000 	ldr	r3, [r3]
7001c524:	e3530000 	cmp	r3, #0
7001c528:	1a000005 	bne	7001c544 <pthread_once+0x148>
    {
        /* call routine once */
        *once_control = 1;
7001c52c:	e51b3010 	ldr	r3, [fp, #-16]
7001c530:	e3a02001 	mov	r2, #1
7001c534:	e5832000 	str	r2, [r3]
        rt_exit_critical();
7001c538:	ebffb68e 	bl	70009f78 <rt_exit_critical>

        init_routine();
7001c53c:	e51b3014 	ldr	r3, [fp, #-20]
7001c540:	e12fff33 	blx	r3
    }
    rt_exit_critical();
7001c544:	ebffb68b 	bl	70009f78 <rt_exit_critical>

    return 0;
7001c548:	e3a03000 	mov	r3, #0
}
7001c54c:	e1a00003 	mov	r0, r3
7001c550:	e24bd004 	sub	sp, fp, #4
7001c554:	e8bd8800 	pop	{fp, pc}

7001c558 <pthread_atfork>:
RTM_EXPORT(pthread_once);

int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
{
7001c558:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001c55c:	e28db000 	add	fp, sp, #0
7001c560:	e24dd014 	sub	sp, sp, #20
7001c564:	e50b0008 	str	r0, [fp, #-8]
7001c568:	e50b100c 	str	r1, [fp, #-12]
7001c56c:	e50b2010 	str	r2, [fp, #-16]
    return EOPNOTSUPP;
7001c570:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001c574:	e1a00003 	mov	r0, r3
7001c578:	e24bd000 	sub	sp, fp, #0
7001c57c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001c580:	e12fff1e 	bx	lr

7001c584 <pthread_kill>:
RTM_EXPORT(pthread_atfork);

int pthread_kill(pthread_t thread, int sig)
{
7001c584:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001c588:	e28db000 	add	fp, sp, #0
7001c58c:	e24dd00c 	sub	sp, sp, #12
7001c590:	e50b0008 	str	r0, [fp, #-8]
7001c594:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
7001c598:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001c59c:	e1a00003 	mov	r0, r3
7001c5a0:	e24bd000 	sub	sp, fp, #0
7001c5a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001c5a8:	e12fff1e 	bx	lr

7001c5ac <pthread_cleanup_pop>:
RTM_EXPORT(pthread_kill);

void pthread_cleanup_pop(int execute)
{
7001c5ac:	e92d4800 	push	{fp, lr}
7001c5b0:	e28db004 	add	fp, sp, #4
7001c5b4:	e24dd018 	sub	sp, sp, #24
7001c5b8:	e50b0018 	str	r0, [fp, #-24]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
7001c5bc:	ebffb7eb 	bl	7000a570 <rt_thread_self>
7001c5c0:	e1a03000 	mov	r3, r0
7001c5c4:	e1a00003 	mov	r0, r3
7001c5c8:	ebfffd1a 	bl	7001ba38 <_pthread_get_data>
7001c5cc:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001c5d0:	e51b3008 	ldr	r3, [fp, #-8]
7001c5d4:	e3530000 	cmp	r3, #0
7001c5d8:	1a00001d 	bne	7001c654 <pthread_cleanup_pop+0xa8>
7001c5dc:	e3a03000 	mov	r3, #0
7001c5e0:	e54b300d 	strb	r3, [fp, #-13]
7001c5e4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c5e8:	e3473002 	movt	r3, #28674	; 0x7002
7001c5ec:	e5933000 	ldr	r3, [r3]
7001c5f0:	e3530000 	cmp	r3, #0
7001c5f4:	1a00000d 	bne	7001c630 <pthread_cleanup_pop+0x84>
7001c5f8:	e3080208 	movw	r0, #33288	; 0x8208
7001c5fc:	e3470002 	movt	r0, #28674	; 0x7002
7001c600:	e308123c 	movw	r1, #33340	; 0x823c
7001c604:	e3471002 	movt	r1, #28674	; 0x7002
7001c608:	e30822e4 	movw	r2, #33508	; 0x82e4
7001c60c:	e3472002 	movt	r2, #28674	; 0x7002
7001c610:	e300316f 	movw	r3, #367	; 0x16f
7001c614:	ebffac76 	bl	700077f4 <rt_kprintf>
7001c618:	e1a00000 	nop			; (mov r0, r0)
7001c61c:	e55b300d 	ldrb	r3, [fp, #-13]
7001c620:	e6ef3073 	uxtb	r3, r3
7001c624:	e3530000 	cmp	r3, #0
7001c628:	0afffffb 	beq	7001c61c <pthread_cleanup_pop+0x70>
7001c62c:	ea000008 	b	7001c654 <pthread_cleanup_pop+0xa8>
7001c630:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c634:	e3473002 	movt	r3, #28674	; 0x7002
7001c638:	e5933000 	ldr	r3, [r3]
7001c63c:	e308023c 	movw	r0, #33340	; 0x823c
7001c640:	e3470002 	movt	r0, #28674	; 0x7002
7001c644:	e30812e4 	movw	r1, #33508	; 0x82e4
7001c648:	e3471002 	movt	r1, #28674	; 0x7002
7001c64c:	e300216f 	movw	r2, #367	; 0x16f
7001c650:	e12fff33 	blx	r3

    if (execute)
7001c654:	e51b3018 	ldr	r3, [fp, #-24]
7001c658:	e3530000 	cmp	r3, #0
7001c65c:	0a000016 	beq	7001c6bc <pthread_cleanup_pop+0x110>
    {
        rt_enter_critical();
7001c660:	ebffb634 	bl	70009f38 <rt_enter_critical>
        cleanup = ptd->cleanup;
7001c664:	e51b3008 	ldr	r3, [fp, #-8]
7001c668:	e5933028 	ldr	r3, [r3, #40]	; 0x28
7001c66c:	e50b300c 	str	r3, [fp, #-12]
        if (cleanup)
7001c670:	e51b300c 	ldr	r3, [fp, #-12]
7001c674:	e3530000 	cmp	r3, #0
7001c678:	0a000003 	beq	7001c68c <pthread_cleanup_pop+0xe0>
            ptd->cleanup = cleanup->next;
7001c67c:	e51b300c 	ldr	r3, [fp, #-12]
7001c680:	e5932008 	ldr	r2, [r3, #8]
7001c684:	e51b3008 	ldr	r3, [fp, #-8]
7001c688:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
7001c68c:	ebffb639 	bl	70009f78 <rt_exit_critical>

        if (cleanup)
7001c690:	e51b300c 	ldr	r3, [fp, #-12]
7001c694:	e3530000 	cmp	r3, #0
7001c698:	0a000007 	beq	7001c6bc <pthread_cleanup_pop+0x110>
        {
            cleanup->cleanup_func(cleanup->parameter);
7001c69c:	e51b300c 	ldr	r3, [fp, #-12]
7001c6a0:	e5933000 	ldr	r3, [r3]
7001c6a4:	e51b200c 	ldr	r2, [fp, #-12]
7001c6a8:	e5922004 	ldr	r2, [r2, #4]
7001c6ac:	e1a00002 	mov	r0, r2
7001c6b0:	e12fff33 	blx	r3

            rt_free(cleanup);
7001c6b4:	e51b000c 	ldr	r0, [fp, #-12]
7001c6b8:	ebffb142 	bl	70008bc8 <rt_free>
        }
    }
}
7001c6bc:	e24bd004 	sub	sp, fp, #4
7001c6c0:	e8bd8800 	pop	{fp, pc}

7001c6c4 <pthread_cleanup_push>:
RTM_EXPORT(pthread_cleanup_pop);

void pthread_cleanup_push(void (*routine)(void*), void *arg)
{
7001c6c4:	e92d4800 	push	{fp, lr}
7001c6c8:	e28db004 	add	fp, sp, #4
7001c6cc:	e24dd018 	sub	sp, sp, #24
7001c6d0:	e50b0018 	str	r0, [fp, #-24]
7001c6d4:	e50b101c 	str	r1, [fp, #-28]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
7001c6d8:	ebffb7a4 	bl	7000a570 <rt_thread_self>
7001c6dc:	e1a03000 	mov	r3, r0
7001c6e0:	e1a00003 	mov	r0, r3
7001c6e4:	ebfffcd3 	bl	7001ba38 <_pthread_get_data>
7001c6e8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001c6ec:	e51b3008 	ldr	r3, [fp, #-8]
7001c6f0:	e3530000 	cmp	r3, #0
7001c6f4:	1a00001d 	bne	7001c770 <pthread_cleanup_push+0xac>
7001c6f8:	e3a03000 	mov	r3, #0
7001c6fc:	e54b300d 	strb	r3, [fp, #-13]
7001c700:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c704:	e3473002 	movt	r3, #28674	; 0x7002
7001c708:	e5933000 	ldr	r3, [r3]
7001c70c:	e3530000 	cmp	r3, #0
7001c710:	1a00000d 	bne	7001c74c <pthread_cleanup_push+0x88>
7001c714:	e3080208 	movw	r0, #33288	; 0x8208
7001c718:	e3470002 	movt	r0, #28674	; 0x7002
7001c71c:	e308123c 	movw	r1, #33340	; 0x823c
7001c720:	e3471002 	movt	r1, #28674	; 0x7002
7001c724:	e30822f8 	movw	r2, #33528	; 0x82f8
7001c728:	e3472002 	movt	r2, #28674	; 0x7002
7001c72c:	e300318a 	movw	r3, #394	; 0x18a
7001c730:	ebffac2f 	bl	700077f4 <rt_kprintf>
7001c734:	e1a00000 	nop			; (mov r0, r0)
7001c738:	e55b300d 	ldrb	r3, [fp, #-13]
7001c73c:	e6ef3073 	uxtb	r3, r3
7001c740:	e3530000 	cmp	r3, #0
7001c744:	0afffffb 	beq	7001c738 <pthread_cleanup_push+0x74>
7001c748:	ea000008 	b	7001c770 <pthread_cleanup_push+0xac>
7001c74c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c750:	e3473002 	movt	r3, #28674	; 0x7002
7001c754:	e5933000 	ldr	r3, [r3]
7001c758:	e308023c 	movw	r0, #33340	; 0x823c
7001c75c:	e3470002 	movt	r0, #28674	; 0x7002
7001c760:	e30812f8 	movw	r1, #33528	; 0x82f8
7001c764:	e3471002 	movt	r1, #28674	; 0x7002
7001c768:	e300218a 	movw	r2, #394	; 0x18a
7001c76c:	e12fff33 	blx	r3

    cleanup = (_pthread_cleanup_t *)rt_malloc(sizeof(_pthread_cleanup_t));
7001c770:	e3a0000c 	mov	r0, #12
7001c774:	ebffae50 	bl	700080bc <rt_malloc>
7001c778:	e50b000c 	str	r0, [fp, #-12]
    if (cleanup != RT_NULL)
7001c77c:	e51b300c 	ldr	r3, [fp, #-12]
7001c780:	e3530000 	cmp	r3, #0
7001c784:	0a00000e 	beq	7001c7c4 <pthread_cleanup_push+0x100>
    {
        cleanup->cleanup_func = routine;
7001c788:	e51b300c 	ldr	r3, [fp, #-12]
7001c78c:	e51b2018 	ldr	r2, [fp, #-24]
7001c790:	e5832000 	str	r2, [r3]
        cleanup->parameter = arg;
7001c794:	e51b300c 	ldr	r3, [fp, #-12]
7001c798:	e51b201c 	ldr	r2, [fp, #-28]
7001c79c:	e5832004 	str	r2, [r3, #4]

        rt_enter_critical();
7001c7a0:	ebffb5e4 	bl	70009f38 <rt_enter_critical>
        cleanup->next = ptd->cleanup;
7001c7a4:	e51b3008 	ldr	r3, [fp, #-8]
7001c7a8:	e5932028 	ldr	r2, [r3, #40]	; 0x28
7001c7ac:	e51b300c 	ldr	r3, [fp, #-12]
7001c7b0:	e5832008 	str	r2, [r3, #8]
        ptd->cleanup = cleanup;
7001c7b4:	e51b3008 	ldr	r3, [fp, #-8]
7001c7b8:	e51b200c 	ldr	r2, [fp, #-12]
7001c7bc:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
7001c7c0:	ebffb5ec 	bl	70009f78 <rt_exit_critical>
    }
}
7001c7c4:	e24bd004 	sub	sp, fp, #4
7001c7c8:	e8bd8800 	pop	{fp, pc}

7001c7cc <pthread_setcancelstate>:
 * The pthread_cancel(), pthread_setcancelstate(), and pthread_setcanceltype()
 * functions are defined to be async-cancel safe.
 */

int pthread_setcancelstate(int state, int *oldstate)
{
7001c7cc:	e92d4800 	push	{fp, lr}
7001c7d0:	e28db004 	add	fp, sp, #4
7001c7d4:	e24dd010 	sub	sp, sp, #16
7001c7d8:	e50b0010 	str	r0, [fp, #-16]
7001c7dc:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
7001c7e0:	ebffb762 	bl	7000a570 <rt_thread_self>
7001c7e4:	e1a03000 	mov	r3, r0
7001c7e8:	e1a00003 	mov	r0, r3
7001c7ec:	ebfffc91 	bl	7001ba38 <_pthread_get_data>
7001c7f0:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001c7f4:	e51b3008 	ldr	r3, [fp, #-8]
7001c7f8:	e3530000 	cmp	r3, #0
7001c7fc:	1a00001d 	bne	7001c878 <pthread_setcancelstate+0xac>
7001c800:	e3a03000 	mov	r3, #0
7001c804:	e54b3009 	strb	r3, [fp, #-9]
7001c808:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c80c:	e3473002 	movt	r3, #28674	; 0x7002
7001c810:	e5933000 	ldr	r3, [r3]
7001c814:	e3530000 	cmp	r3, #0
7001c818:	1a00000d 	bne	7001c854 <pthread_setcancelstate+0x88>
7001c81c:	e3080208 	movw	r0, #33288	; 0x8208
7001c820:	e3470002 	movt	r0, #28674	; 0x7002
7001c824:	e308123c 	movw	r1, #33340	; 0x823c
7001c828:	e3471002 	movt	r1, #28674	; 0x7002
7001c82c:	e3082310 	movw	r2, #33552	; 0x8310
7001c830:	e3472002 	movt	r2, #28674	; 0x7002
7001c834:	e3a03f6f 	mov	r3, #444	; 0x1bc
7001c838:	ebffabed 	bl	700077f4 <rt_kprintf>
7001c83c:	e1a00000 	nop			; (mov r0, r0)
7001c840:	e55b3009 	ldrb	r3, [fp, #-9]
7001c844:	e6ef3073 	uxtb	r3, r3
7001c848:	e3530000 	cmp	r3, #0
7001c84c:	0afffffb 	beq	7001c840 <pthread_setcancelstate+0x74>
7001c850:	ea000008 	b	7001c878 <pthread_setcancelstate+0xac>
7001c854:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c858:	e3473002 	movt	r3, #28674	; 0x7002
7001c85c:	e5933000 	ldr	r3, [r3]
7001c860:	e308023c 	movw	r0, #33340	; 0x823c
7001c864:	e3470002 	movt	r0, #28674	; 0x7002
7001c868:	e3081310 	movw	r1, #33552	; 0x8310
7001c86c:	e3471002 	movt	r1, #28674	; 0x7002
7001c870:	e3a02f6f 	mov	r2, #444	; 0x1bc
7001c874:	e12fff33 	blx	r3

    if ((state == PTHREAD_CANCEL_ENABLE) || (state == PTHREAD_CANCEL_DISABLE))
7001c878:	e51b3010 	ldr	r3, [fp, #-16]
7001c87c:	e3530001 	cmp	r3, #1
7001c880:	0a000002 	beq	7001c890 <pthread_setcancelstate+0xc4>
7001c884:	e51b3010 	ldr	r3, [fp, #-16]
7001c888:	e3530003 	cmp	r3, #3
7001c88c:	1a00000d 	bne	7001c8c8 <pthread_setcancelstate+0xfc>
    {
        if (oldstate)
7001c890:	e51b3014 	ldr	r3, [fp, #-20]
7001c894:	e3530000 	cmp	r3, #0
7001c898:	0a000004 	beq	7001c8b0 <pthread_setcancelstate+0xe4>
            *oldstate = ptd->cancelstate;
7001c89c:	e51b3008 	ldr	r3, [fp, #-8]
7001c8a0:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
7001c8a4:	e1a02003 	mov	r2, r3
7001c8a8:	e51b3014 	ldr	r3, [fp, #-20]
7001c8ac:	e5832000 	str	r2, [r3]
        ptd->cancelstate = state;
7001c8b0:	e51b3010 	ldr	r3, [fp, #-16]
7001c8b4:	e6ef2073 	uxtb	r2, r3
7001c8b8:	e51b3008 	ldr	r3, [fp, #-8]
7001c8bc:	e5c32024 	strb	r2, [r3, #36]	; 0x24

        return 0;
7001c8c0:	e3a03000 	mov	r3, #0
7001c8c4:	ea000000 	b	7001c8cc <pthread_setcancelstate+0x100>
    }

    return EINVAL;
7001c8c8:	e3a03016 	mov	r3, #22
}
7001c8cc:	e1a00003 	mov	r0, r3
7001c8d0:	e24bd004 	sub	sp, fp, #4
7001c8d4:	e8bd8800 	pop	{fp, pc}

7001c8d8 <pthread_setcanceltype>:
RTM_EXPORT(pthread_setcancelstate);

int pthread_setcanceltype(int type, int *oldtype)
{
7001c8d8:	e92d4800 	push	{fp, lr}
7001c8dc:	e28db004 	add	fp, sp, #4
7001c8e0:	e24dd010 	sub	sp, sp, #16
7001c8e4:	e50b0010 	str	r0, [fp, #-16]
7001c8e8:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
7001c8ec:	ebffb71f 	bl	7000a570 <rt_thread_self>
7001c8f0:	e1a03000 	mov	r3, r0
7001c8f4:	e1a00003 	mov	r0, r3
7001c8f8:	ebfffc4e 	bl	7001ba38 <_pthread_get_data>
7001c8fc:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001c900:	e51b3008 	ldr	r3, [fp, #-8]
7001c904:	e3530000 	cmp	r3, #0
7001c908:	1a00001d 	bne	7001c984 <pthread_setcanceltype+0xac>
7001c90c:	e3a03000 	mov	r3, #0
7001c910:	e54b3009 	strb	r3, [fp, #-9]
7001c914:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c918:	e3473002 	movt	r3, #28674	; 0x7002
7001c91c:	e5933000 	ldr	r3, [r3]
7001c920:	e3530000 	cmp	r3, #0
7001c924:	1a00000d 	bne	7001c960 <pthread_setcanceltype+0x88>
7001c928:	e3080208 	movw	r0, #33288	; 0x8208
7001c92c:	e3470002 	movt	r0, #28674	; 0x7002
7001c930:	e308123c 	movw	r1, #33340	; 0x823c
7001c934:	e3471002 	movt	r1, #28674	; 0x7002
7001c938:	e3082328 	movw	r2, #33576	; 0x8328
7001c93c:	e3472002 	movt	r2, #28674	; 0x7002
7001c940:	e30031d1 	movw	r3, #465	; 0x1d1
7001c944:	ebffabaa 	bl	700077f4 <rt_kprintf>
7001c948:	e1a00000 	nop			; (mov r0, r0)
7001c94c:	e55b3009 	ldrb	r3, [fp, #-9]
7001c950:	e6ef3073 	uxtb	r3, r3
7001c954:	e3530000 	cmp	r3, #0
7001c958:	0afffffb 	beq	7001c94c <pthread_setcanceltype+0x74>
7001c95c:	ea000008 	b	7001c984 <pthread_setcanceltype+0xac>
7001c960:	e30a3b74 	movw	r3, #43892	; 0xab74
7001c964:	e3473002 	movt	r3, #28674	; 0x7002
7001c968:	e5933000 	ldr	r3, [r3]
7001c96c:	e308023c 	movw	r0, #33340	; 0x823c
7001c970:	e3470002 	movt	r0, #28674	; 0x7002
7001c974:	e3081328 	movw	r1, #33576	; 0x8328
7001c978:	e3471002 	movt	r1, #28674	; 0x7002
7001c97c:	e30021d1 	movw	r2, #465	; 0x1d1
7001c980:	e12fff33 	blx	r3

    if ((type != PTHREAD_CANCEL_DEFERRED) && (type != PTHREAD_CANCEL_ASYNCHRONOUS)) 
7001c984:	e51b3010 	ldr	r3, [fp, #-16]
7001c988:	e3530002 	cmp	r3, #2
7001c98c:	0a000004 	beq	7001c9a4 <pthread_setcanceltype+0xcc>
7001c990:	e51b3010 	ldr	r3, [fp, #-16]
7001c994:	e3530000 	cmp	r3, #0
7001c998:	0a000001 	beq	7001c9a4 <pthread_setcanceltype+0xcc>
        return EINVAL;
7001c99c:	e3a03016 	mov	r3, #22
7001c9a0:	ea00000d 	b	7001c9dc <pthread_setcanceltype+0x104>

    if (oldtype)
7001c9a4:	e51b3014 	ldr	r3, [fp, #-20]
7001c9a8:	e3530000 	cmp	r3, #0
7001c9ac:	0a000005 	beq	7001c9c8 <pthread_setcanceltype+0xf0>
        *oldtype = ptd->canceltype;
7001c9b0:	e51b3008 	ldr	r3, [fp, #-8]
7001c9b4:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
7001c9b8:	e6ef3073 	uxtb	r3, r3
7001c9bc:	e1a02003 	mov	r2, r3
7001c9c0:	e51b3014 	ldr	r3, [fp, #-20]
7001c9c4:	e5832000 	str	r2, [r3]
    ptd->canceltype = type;
7001c9c8:	e51b3010 	ldr	r3, [fp, #-16]
7001c9cc:	e6ef2073 	uxtb	r2, r3
7001c9d0:	e51b3008 	ldr	r3, [fp, #-8]
7001c9d4:	e5c32025 	strb	r2, [r3, #37]	; 0x25

    return 0;
7001c9d8:	e3a03000 	mov	r3, #0
}
7001c9dc:	e1a00003 	mov	r0, r3
7001c9e0:	e24bd004 	sub	sp, fp, #4
7001c9e4:	e8bd8800 	pop	{fp, pc}

7001c9e8 <pthread_testcancel>:
RTM_EXPORT(pthread_setcanceltype);

void pthread_testcancel(void)
{
7001c9e8:	e92d4800 	push	{fp, lr}
7001c9ec:	e28db004 	add	fp, sp, #4
7001c9f0:	e24dd010 	sub	sp, sp, #16
    int cancel=0;
7001c9f4:	e3a03000 	mov	r3, #0
7001c9f8:	e50b3008 	str	r3, [fp, #-8]
    _pthread_data_t* ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
7001c9fc:	ebffb6db 	bl	7000a570 <rt_thread_self>
7001ca00:	e1a03000 	mov	r3, r0
7001ca04:	e1a00003 	mov	r0, r3
7001ca08:	ebfffc0a 	bl	7001ba38 <_pthread_get_data>
7001ca0c:	e50b000c 	str	r0, [fp, #-12]
    RT_ASSERT(ptd != RT_NULL);
7001ca10:	e51b300c 	ldr	r3, [fp, #-12]
7001ca14:	e3530000 	cmp	r3, #0
7001ca18:	1a00001d 	bne	7001ca94 <pthread_testcancel+0xac>
7001ca1c:	e3a03000 	mov	r3, #0
7001ca20:	e54b300d 	strb	r3, [fp, #-13]
7001ca24:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ca28:	e3473002 	movt	r3, #28674	; 0x7002
7001ca2c:	e5933000 	ldr	r3, [r3]
7001ca30:	e3530000 	cmp	r3, #0
7001ca34:	1a00000d 	bne	7001ca70 <pthread_testcancel+0x88>
7001ca38:	e3080208 	movw	r0, #33288	; 0x8208
7001ca3c:	e3470002 	movt	r0, #28674	; 0x7002
7001ca40:	e308123c 	movw	r1, #33340	; 0x823c
7001ca44:	e3471002 	movt	r1, #28674	; 0x7002
7001ca48:	e3082340 	movw	r2, #33600	; 0x8340
7001ca4c:	e3472002 	movt	r2, #28674	; 0x7002
7001ca50:	e30031e5 	movw	r3, #485	; 0x1e5
7001ca54:	ebffab66 	bl	700077f4 <rt_kprintf>
7001ca58:	e1a00000 	nop			; (mov r0, r0)
7001ca5c:	e55b300d 	ldrb	r3, [fp, #-13]
7001ca60:	e6ef3073 	uxtb	r3, r3
7001ca64:	e3530000 	cmp	r3, #0
7001ca68:	0afffffb 	beq	7001ca5c <pthread_testcancel+0x74>
7001ca6c:	ea000008 	b	7001ca94 <pthread_testcancel+0xac>
7001ca70:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ca74:	e3473002 	movt	r3, #28674	; 0x7002
7001ca78:	e5933000 	ldr	r3, [r3]
7001ca7c:	e308023c 	movw	r0, #33340	; 0x823c
7001ca80:	e3470002 	movt	r0, #28674	; 0x7002
7001ca84:	e3081340 	movw	r1, #33600	; 0x8340
7001ca88:	e3471002 	movt	r1, #28674	; 0x7002
7001ca8c:	e30021e5 	movw	r2, #485	; 0x1e5
7001ca90:	e12fff33 	blx	r3

    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
7001ca94:	e51b300c 	ldr	r3, [fp, #-12]
7001ca98:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
7001ca9c:	e3530001 	cmp	r3, #1
7001caa0:	1a000003 	bne	7001cab4 <pthread_testcancel+0xcc>
        cancel = ptd->canceled;
7001caa4:	e51b300c 	ldr	r3, [fp, #-12]
7001caa8:	e5d33026 	ldrb	r3, [r3, #38]	; 0x26
7001caac:	e6ef3073 	uxtb	r3, r3
7001cab0:	e50b3008 	str	r3, [fp, #-8]
    if (cancel)
7001cab4:	e51b3008 	ldr	r3, [fp, #-8]
7001cab8:	e3530000 	cmp	r3, #0
7001cabc:	0a000001 	beq	7001cac8 <pthread_testcancel+0xe0>
        pthread_exit((void*)PTHREAD_CANCELED);
7001cac0:	e3a00004 	mov	r0, #4
7001cac4:	ebfffdea 	bl	7001c274 <pthread_exit>
}
7001cac8:	e24bd004 	sub	sp, fp, #4
7001cacc:	e8bd8800 	pop	{fp, pc}

7001cad0 <pthread_cancel>:
RTM_EXPORT(pthread_testcancel);

int pthread_cancel(pthread_t thread)
{
7001cad0:	e92d4800 	push	{fp, lr}
7001cad4:	e28db004 	add	fp, sp, #4
7001cad8:	e24dd010 	sub	sp, sp, #16
7001cadc:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;

    /* cancel self */
    if (thread == rt_thread_self())
7001cae0:	ebffb6a2 	bl	7000a570 <rt_thread_self>
7001cae4:	e1a02000 	mov	r2, r0
7001cae8:	e51b3010 	ldr	r3, [fp, #-16]
7001caec:	e1520003 	cmp	r2, r3
7001caf0:	1a000001 	bne	7001cafc <pthread_cancel+0x2c>
        return 0;
7001caf4:	e3a03000 	mov	r3, #0
7001caf8:	ea000032 	b	7001cbc8 <pthread_cancel+0xf8>

    /* get posix thread data */
    ptd = _pthread_get_data(thread);
7001cafc:	e51b0010 	ldr	r0, [fp, #-16]
7001cb00:	ebfffbcc 	bl	7001ba38 <_pthread_get_data>
7001cb04:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001cb08:	e51b3008 	ldr	r3, [fp, #-8]
7001cb0c:	e3530000 	cmp	r3, #0
7001cb10:	1a00001d 	bne	7001cb8c <pthread_cancel+0xbc>
7001cb14:	e3a03000 	mov	r3, #0
7001cb18:	e54b3009 	strb	r3, [fp, #-9]
7001cb1c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cb20:	e3473002 	movt	r3, #28674	; 0x7002
7001cb24:	e5933000 	ldr	r3, [r3]
7001cb28:	e3530000 	cmp	r3, #0
7001cb2c:	1a00000d 	bne	7001cb68 <pthread_cancel+0x98>
7001cb30:	e3080208 	movw	r0, #33288	; 0x8208
7001cb34:	e3470002 	movt	r0, #28674	; 0x7002
7001cb38:	e308123c 	movw	r1, #33340	; 0x823c
7001cb3c:	e3471002 	movt	r1, #28674	; 0x7002
7001cb40:	e3082354 	movw	r2, #33620	; 0x8354
7001cb44:	e3472002 	movt	r2, #28674	; 0x7002
7001cb48:	e3a03f7e 	mov	r3, #504	; 0x1f8
7001cb4c:	ebffab28 	bl	700077f4 <rt_kprintf>
7001cb50:	e1a00000 	nop			; (mov r0, r0)
7001cb54:	e55b3009 	ldrb	r3, [fp, #-9]
7001cb58:	e6ef3073 	uxtb	r3, r3
7001cb5c:	e3530000 	cmp	r3, #0
7001cb60:	0afffffb 	beq	7001cb54 <pthread_cancel+0x84>
7001cb64:	ea000008 	b	7001cb8c <pthread_cancel+0xbc>
7001cb68:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cb6c:	e3473002 	movt	r3, #28674	; 0x7002
7001cb70:	e5933000 	ldr	r3, [r3]
7001cb74:	e308023c 	movw	r0, #33340	; 0x823c
7001cb78:	e3470002 	movt	r0, #28674	; 0x7002
7001cb7c:	e3081354 	movw	r1, #33620	; 0x8354
7001cb80:	e3471002 	movt	r1, #28674	; 0x7002
7001cb84:	e3a02f7e 	mov	r2, #504	; 0x1f8
7001cb88:	e12fff33 	blx	r3

    /* set canceled */
    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
7001cb8c:	e51b3008 	ldr	r3, [fp, #-8]
7001cb90:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
7001cb94:	e3530001 	cmp	r3, #1
7001cb98:	1a000009 	bne	7001cbc4 <pthread_cancel+0xf4>
    {
        ptd->canceled = 1;
7001cb9c:	e51b3008 	ldr	r3, [fp, #-8]
7001cba0:	e3a02001 	mov	r2, #1
7001cba4:	e5c32026 	strb	r2, [r3, #38]	; 0x26
        if (ptd->canceltype == PTHREAD_CANCEL_ASYNCHRONOUS)
7001cba8:	e51b3008 	ldr	r3, [fp, #-8]
7001cbac:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
7001cbb0:	e6ef3073 	uxtb	r3, r3
7001cbb4:	e3530000 	cmp	r3, #0
7001cbb8:	1a000001 	bne	7001cbc4 <pthread_cancel+0xf4>
             * this thread will be removed from scheduler list
             * and because there is a cleanup function in the
             * thread (pthread_cleanup), it will move to defunct
             * thread list and wait for handling in idle thread.
             */
            rt_thread_detach(thread);
7001cbbc:	e51b0010 	ldr	r0, [fp, #-16]
7001cbc0:	ebffb6d3 	bl	7000a714 <rt_thread_detach>
        }
    }

    return 0;
7001cbc4:	e3a03000 	mov	r3, #0
}
7001cbc8:	e1a00003 	mov	r0, r3
7001cbcc:	e24bd004 	sub	sp, fp, #4
7001cbd0:	e8bd8800 	pop	{fp, pc}

7001cbd4 <pthread_attr_init>:
    SCHED_FIFO,                 /* scheduler policy */
    PTHREAD_INHERIT_SCHED       /* Inherit parent prio/policy */
};

int pthread_attr_init(pthread_attr_t *attr)
{
7001cbd4:	e92d4800 	push	{fp, lr}
7001cbd8:	e28db004 	add	fp, sp, #4
7001cbdc:	e24dd010 	sub	sp, sp, #16
7001cbe0:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
7001cbe4:	e51b3010 	ldr	r3, [fp, #-16]
7001cbe8:	e3530000 	cmp	r3, #0
7001cbec:	1a00001d 	bne	7001cc68 <pthread_attr_init+0x94>
7001cbf0:	e3a03000 	mov	r3, #0
7001cbf4:	e54b3005 	strb	r3, [fp, #-5]
7001cbf8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cbfc:	e3473002 	movt	r3, #28674	; 0x7002
7001cc00:	e5933000 	ldr	r3, [r3]
7001cc04:	e3530000 	cmp	r3, #0
7001cc08:	1a00000d 	bne	7001cc44 <pthread_attr_init+0x70>
7001cc0c:	e3080370 	movw	r0, #33648	; 0x8370
7001cc10:	e3470002 	movt	r0, #28674	; 0x7002
7001cc14:	e3081390 	movw	r1, #33680	; 0x8390
7001cc18:	e3471002 	movt	r1, #28674	; 0x7002
7001cc1c:	e30823b4 	movw	r2, #33716	; 0x83b4
7001cc20:	e3472002 	movt	r2, #28674	; 0x7002
7001cc24:	e3a0302d 	mov	r3, #45	; 0x2d
7001cc28:	ebffaaf1 	bl	700077f4 <rt_kprintf>
7001cc2c:	e1a00000 	nop			; (mov r0, r0)
7001cc30:	e55b3005 	ldrb	r3, [fp, #-5]
7001cc34:	e6ef3073 	uxtb	r3, r3
7001cc38:	e3530000 	cmp	r3, #0
7001cc3c:	0afffffb 	beq	7001cc30 <pthread_attr_init+0x5c>
7001cc40:	ea000008 	b	7001cc68 <pthread_attr_init+0x94>
7001cc44:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cc48:	e3473002 	movt	r3, #28674	; 0x7002
7001cc4c:	e5933000 	ldr	r3, [r3]
7001cc50:	e3080390 	movw	r0, #33680	; 0x8390
7001cc54:	e3470002 	movt	r0, #28674	; 0x7002
7001cc58:	e30813b4 	movw	r1, #33716	; 0x83b4
7001cc5c:	e3471002 	movt	r1, #28674	; 0x7002
7001cc60:	e3a0202d 	mov	r2, #45	; 0x2d
7001cc64:	e12fff33 	blx	r3

    *attr = pthread_default_attr;
7001cc68:	e51b2010 	ldr	r2, [fp, #-16]
7001cc6c:	e3083364 	movw	r3, #33636	; 0x8364
7001cc70:	e3473002 	movt	r3, #28674	; 0x7002
7001cc74:	e1a0c002 	mov	ip, r2
7001cc78:	e8930007 	ldm	r3, {r0, r1, r2}
7001cc7c:	e88c0007 	stm	ip, {r0, r1, r2}

    return 0;
7001cc80:	e3a03000 	mov	r3, #0
}
7001cc84:	e1a00003 	mov	r0, r3
7001cc88:	e24bd004 	sub	sp, fp, #4
7001cc8c:	e8bd8800 	pop	{fp, pc}

7001cc90 <pthread_attr_destroy>:
RTM_EXPORT(pthread_attr_init);

int pthread_attr_destroy(pthread_attr_t *attr)
{
7001cc90:	e92d4800 	push	{fp, lr}
7001cc94:	e28db004 	add	fp, sp, #4
7001cc98:	e24dd010 	sub	sp, sp, #16
7001cc9c:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
7001cca0:	e51b3010 	ldr	r3, [fp, #-16]
7001cca4:	e3530000 	cmp	r3, #0
7001cca8:	1a00001d 	bne	7001cd24 <pthread_attr_destroy+0x94>
7001ccac:	e3a03000 	mov	r3, #0
7001ccb0:	e54b3005 	strb	r3, [fp, #-5]
7001ccb4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ccb8:	e3473002 	movt	r3, #28674	; 0x7002
7001ccbc:	e5933000 	ldr	r3, [r3]
7001ccc0:	e3530000 	cmp	r3, #0
7001ccc4:	1a00000d 	bne	7001cd00 <pthread_attr_destroy+0x70>
7001ccc8:	e3080370 	movw	r0, #33648	; 0x8370
7001cccc:	e3470002 	movt	r0, #28674	; 0x7002
7001ccd0:	e3081390 	movw	r1, #33680	; 0x8390
7001ccd4:	e3471002 	movt	r1, #28674	; 0x7002
7001ccd8:	e30823c8 	movw	r2, #33736	; 0x83c8
7001ccdc:	e3472002 	movt	r2, #28674	; 0x7002
7001cce0:	e3a03037 	mov	r3, #55	; 0x37
7001cce4:	ebffaac2 	bl	700077f4 <rt_kprintf>
7001cce8:	e1a00000 	nop			; (mov r0, r0)
7001ccec:	e55b3005 	ldrb	r3, [fp, #-5]
7001ccf0:	e6ef3073 	uxtb	r3, r3
7001ccf4:	e3530000 	cmp	r3, #0
7001ccf8:	0afffffb 	beq	7001ccec <pthread_attr_destroy+0x5c>
7001ccfc:	ea000008 	b	7001cd24 <pthread_attr_destroy+0x94>
7001cd00:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cd04:	e3473002 	movt	r3, #28674	; 0x7002
7001cd08:	e5933000 	ldr	r3, [r3]
7001cd0c:	e3080390 	movw	r0, #33680	; 0x8390
7001cd10:	e3470002 	movt	r0, #28674	; 0x7002
7001cd14:	e30813c8 	movw	r1, #33736	; 0x83c8
7001cd18:	e3471002 	movt	r1, #28674	; 0x7002
7001cd1c:	e3a02037 	mov	r2, #55	; 0x37
7001cd20:	e12fff33 	blx	r3

    memset(attr, 0, sizeof(pthread_attr_t));
7001cd24:	e51b0010 	ldr	r0, [fp, #-16]
7001cd28:	e3a01000 	mov	r1, #0
7001cd2c:	e3a0200c 	mov	r2, #12
7001cd30:	fa001c86 	blx	70023f50 <memset>

    return 0;
7001cd34:	e3a03000 	mov	r3, #0
}
7001cd38:	e1a00003 	mov	r0, r3
7001cd3c:	e24bd004 	sub	sp, fp, #4
7001cd40:	e8bd8800 	pop	{fp, pc}

7001cd44 <pthread_attr_setdetachstate>:
RTM_EXPORT(pthread_attr_destroy);

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
7001cd44:	e92d4800 	push	{fp, lr}
7001cd48:	e28db004 	add	fp, sp, #4
7001cd4c:	e24dd010 	sub	sp, sp, #16
7001cd50:	e50b0010 	str	r0, [fp, #-16]
7001cd54:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001cd58:	e51b3010 	ldr	r3, [fp, #-16]
7001cd5c:	e3530000 	cmp	r3, #0
7001cd60:	1a00001d 	bne	7001cddc <pthread_attr_setdetachstate+0x98>
7001cd64:	e3a03000 	mov	r3, #0
7001cd68:	e54b3005 	strb	r3, [fp, #-5]
7001cd6c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cd70:	e3473002 	movt	r3, #28674	; 0x7002
7001cd74:	e5933000 	ldr	r3, [r3]
7001cd78:	e3530000 	cmp	r3, #0
7001cd7c:	1a00000d 	bne	7001cdb8 <pthread_attr_setdetachstate+0x74>
7001cd80:	e3080370 	movw	r0, #33648	; 0x8370
7001cd84:	e3470002 	movt	r0, #28674	; 0x7002
7001cd88:	e3081390 	movw	r1, #33680	; 0x8390
7001cd8c:	e3471002 	movt	r1, #28674	; 0x7002
7001cd90:	e30823e0 	movw	r2, #33760	; 0x83e0
7001cd94:	e3472002 	movt	r2, #28674	; 0x7002
7001cd98:	e3a03041 	mov	r3, #65	; 0x41
7001cd9c:	ebffaa94 	bl	700077f4 <rt_kprintf>
7001cda0:	e1a00000 	nop			; (mov r0, r0)
7001cda4:	e55b3005 	ldrb	r3, [fp, #-5]
7001cda8:	e6ef3073 	uxtb	r3, r3
7001cdac:	e3530000 	cmp	r3, #0
7001cdb0:	0afffffb 	beq	7001cda4 <pthread_attr_setdetachstate+0x60>
7001cdb4:	ea000008 	b	7001cddc <pthread_attr_setdetachstate+0x98>
7001cdb8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cdbc:	e3473002 	movt	r3, #28674	; 0x7002
7001cdc0:	e5933000 	ldr	r3, [r3]
7001cdc4:	e3080390 	movw	r0, #33680	; 0x8390
7001cdc8:	e3470002 	movt	r0, #28674	; 0x7002
7001cdcc:	e30813e0 	movw	r1, #33760	; 0x83e0
7001cdd0:	e3471002 	movt	r1, #28674	; 0x7002
7001cdd4:	e3a02041 	mov	r2, #65	; 0x41
7001cdd8:	e12fff33 	blx	r3

    if (state != PTHREAD_CREATE_JOINABLE && state != PTHREAD_CREATE_DETACHED)
7001cddc:	e51b3014 	ldr	r3, [fp, #-20]
7001cde0:	e3530000 	cmp	r3, #0
7001cde4:	0a000004 	beq	7001cdfc <pthread_attr_setdetachstate+0xb8>
7001cde8:	e51b3014 	ldr	r3, [fp, #-20]
7001cdec:	e3530001 	cmp	r3, #1
7001cdf0:	0a000001 	beq	7001cdfc <pthread_attr_setdetachstate+0xb8>
        return EINVAL;
7001cdf4:	e3a03016 	mov	r3, #22
7001cdf8:	ea000004 	b	7001ce10 <pthread_attr_setdetachstate+0xcc>

    attr->detachstate = state;
7001cdfc:	e51b3014 	ldr	r3, [fp, #-20]
7001ce00:	e6ef2073 	uxtb	r2, r3
7001ce04:	e51b3010 	ldr	r3, [fp, #-16]
7001ce08:	e5c32007 	strb	r2, [r3, #7]

    return 0;
7001ce0c:	e3a03000 	mov	r3, #0
}
7001ce10:	e1a00003 	mov	r0, r3
7001ce14:	e24bd004 	sub	sp, fp, #4
7001ce18:	e8bd8800 	pop	{fp, pc}

7001ce1c <pthread_attr_getdetachstate>:
RTM_EXPORT(pthread_attr_setdetachstate);

int pthread_attr_getdetachstate(pthread_attr_t const *attr, int *state)
{
7001ce1c:	e92d4800 	push	{fp, lr}
7001ce20:	e28db004 	add	fp, sp, #4
7001ce24:	e24dd010 	sub	sp, sp, #16
7001ce28:	e50b0010 	str	r0, [fp, #-16]
7001ce2c:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001ce30:	e51b3010 	ldr	r3, [fp, #-16]
7001ce34:	e3530000 	cmp	r3, #0
7001ce38:	1a00001d 	bne	7001ceb4 <pthread_attr_getdetachstate+0x98>
7001ce3c:	e3a03000 	mov	r3, #0
7001ce40:	e54b3005 	strb	r3, [fp, #-5]
7001ce44:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ce48:	e3473002 	movt	r3, #28674	; 0x7002
7001ce4c:	e5933000 	ldr	r3, [r3]
7001ce50:	e3530000 	cmp	r3, #0
7001ce54:	1a00000d 	bne	7001ce90 <pthread_attr_getdetachstate+0x74>
7001ce58:	e3080370 	movw	r0, #33648	; 0x8370
7001ce5c:	e3470002 	movt	r0, #28674	; 0x7002
7001ce60:	e3081390 	movw	r1, #33680	; 0x8390
7001ce64:	e3471002 	movt	r1, #28674	; 0x7002
7001ce68:	e30823fc 	movw	r2, #33788	; 0x83fc
7001ce6c:	e3472002 	movt	r2, #28674	; 0x7002
7001ce70:	e3a0304e 	mov	r3, #78	; 0x4e
7001ce74:	ebffaa5e 	bl	700077f4 <rt_kprintf>
7001ce78:	e1a00000 	nop			; (mov r0, r0)
7001ce7c:	e55b3005 	ldrb	r3, [fp, #-5]
7001ce80:	e6ef3073 	uxtb	r3, r3
7001ce84:	e3530000 	cmp	r3, #0
7001ce88:	0afffffb 	beq	7001ce7c <pthread_attr_getdetachstate+0x60>
7001ce8c:	ea000008 	b	7001ceb4 <pthread_attr_getdetachstate+0x98>
7001ce90:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ce94:	e3473002 	movt	r3, #28674	; 0x7002
7001ce98:	e5933000 	ldr	r3, [r3]
7001ce9c:	e3080390 	movw	r0, #33680	; 0x8390
7001cea0:	e3470002 	movt	r0, #28674	; 0x7002
7001cea4:	e30813fc 	movw	r1, #33788	; 0x83fc
7001cea8:	e3471002 	movt	r1, #28674	; 0x7002
7001ceac:	e3a0204e 	mov	r2, #78	; 0x4e
7001ceb0:	e12fff33 	blx	r3

    *state = (int)attr->detachstate;
7001ceb4:	e51b3010 	ldr	r3, [fp, #-16]
7001ceb8:	e5d33007 	ldrb	r3, [r3, #7]
7001cebc:	e1a02003 	mov	r2, r3
7001cec0:	e51b3014 	ldr	r3, [fp, #-20]
7001cec4:	e5832000 	str	r2, [r3]

    return 0;
7001cec8:	e3a03000 	mov	r3, #0
}
7001cecc:	e1a00003 	mov	r0, r3
7001ced0:	e24bd004 	sub	sp, fp, #4
7001ced4:	e8bd8800 	pop	{fp, pc}

7001ced8 <pthread_attr_setschedpolicy>:
RTM_EXPORT(pthread_attr_getdetachstate);

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
7001ced8:	e92d4800 	push	{fp, lr}
7001cedc:	e28db004 	add	fp, sp, #4
7001cee0:	e24dd010 	sub	sp, sp, #16
7001cee4:	e50b0010 	str	r0, [fp, #-16]
7001cee8:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001ceec:	e51b3010 	ldr	r3, [fp, #-16]
7001cef0:	e3530000 	cmp	r3, #0
7001cef4:	1a00001d 	bne	7001cf70 <pthread_attr_setschedpolicy+0x98>
7001cef8:	e3a03000 	mov	r3, #0
7001cefc:	e54b3005 	strb	r3, [fp, #-5]
7001cf00:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cf04:	e3473002 	movt	r3, #28674	; 0x7002
7001cf08:	e5933000 	ldr	r3, [r3]
7001cf0c:	e3530000 	cmp	r3, #0
7001cf10:	1a00000d 	bne	7001cf4c <pthread_attr_setschedpolicy+0x74>
7001cf14:	e3080370 	movw	r0, #33648	; 0x8370
7001cf18:	e3470002 	movt	r0, #28674	; 0x7002
7001cf1c:	e3081390 	movw	r1, #33680	; 0x8390
7001cf20:	e3471002 	movt	r1, #28674	; 0x7002
7001cf24:	e3082418 	movw	r2, #33816	; 0x8418
7001cf28:	e3472002 	movt	r2, #28674	; 0x7002
7001cf2c:	e3a03058 	mov	r3, #88	; 0x58
7001cf30:	ebffaa2f 	bl	700077f4 <rt_kprintf>
7001cf34:	e1a00000 	nop			; (mov r0, r0)
7001cf38:	e55b3005 	ldrb	r3, [fp, #-5]
7001cf3c:	e6ef3073 	uxtb	r3, r3
7001cf40:	e3530000 	cmp	r3, #0
7001cf44:	0afffffb 	beq	7001cf38 <pthread_attr_setschedpolicy+0x60>
7001cf48:	ea000008 	b	7001cf70 <pthread_attr_setschedpolicy+0x98>
7001cf4c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cf50:	e3473002 	movt	r3, #28674	; 0x7002
7001cf54:	e5933000 	ldr	r3, [r3]
7001cf58:	e3080390 	movw	r0, #33680	; 0x8390
7001cf5c:	e3470002 	movt	r0, #28674	; 0x7002
7001cf60:	e3081418 	movw	r1, #33816	; 0x8418
7001cf64:	e3471002 	movt	r1, #28674	; 0x7002
7001cf68:	e3a02058 	mov	r2, #88	; 0x58
7001cf6c:	e12fff33 	blx	r3

    attr->policy = policy;
7001cf70:	e51b3014 	ldr	r3, [fp, #-20]
7001cf74:	e6ef2073 	uxtb	r2, r3
7001cf78:	e51b3010 	ldr	r3, [fp, #-16]
7001cf7c:	e5c32008 	strb	r2, [r3, #8]

    return 0;
7001cf80:	e3a03000 	mov	r3, #0
}
7001cf84:	e1a00003 	mov	r0, r3
7001cf88:	e24bd004 	sub	sp, fp, #4
7001cf8c:	e8bd8800 	pop	{fp, pc}

7001cf90 <pthread_attr_getschedpolicy>:
RTM_EXPORT(pthread_attr_setschedpolicy);

int pthread_attr_getschedpolicy(pthread_attr_t const *attr, int *policy)
{
7001cf90:	e92d4800 	push	{fp, lr}
7001cf94:	e28db004 	add	fp, sp, #4
7001cf98:	e24dd010 	sub	sp, sp, #16
7001cf9c:	e50b0010 	str	r0, [fp, #-16]
7001cfa0:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001cfa4:	e51b3010 	ldr	r3, [fp, #-16]
7001cfa8:	e3530000 	cmp	r3, #0
7001cfac:	1a00001d 	bne	7001d028 <pthread_attr_getschedpolicy+0x98>
7001cfb0:	e3a03000 	mov	r3, #0
7001cfb4:	e54b3005 	strb	r3, [fp, #-5]
7001cfb8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001cfbc:	e3473002 	movt	r3, #28674	; 0x7002
7001cfc0:	e5933000 	ldr	r3, [r3]
7001cfc4:	e3530000 	cmp	r3, #0
7001cfc8:	1a00000d 	bne	7001d004 <pthread_attr_getschedpolicy+0x74>
7001cfcc:	e3080370 	movw	r0, #33648	; 0x8370
7001cfd0:	e3470002 	movt	r0, #28674	; 0x7002
7001cfd4:	e3081390 	movw	r1, #33680	; 0x8390
7001cfd8:	e3471002 	movt	r1, #28674	; 0x7002
7001cfdc:	e3082434 	movw	r2, #33844	; 0x8434
7001cfe0:	e3472002 	movt	r2, #28674	; 0x7002
7001cfe4:	e3a03062 	mov	r3, #98	; 0x62
7001cfe8:	ebffaa01 	bl	700077f4 <rt_kprintf>
7001cfec:	e1a00000 	nop			; (mov r0, r0)
7001cff0:	e55b3005 	ldrb	r3, [fp, #-5]
7001cff4:	e6ef3073 	uxtb	r3, r3
7001cff8:	e3530000 	cmp	r3, #0
7001cffc:	0afffffb 	beq	7001cff0 <pthread_attr_getschedpolicy+0x60>
7001d000:	ea000008 	b	7001d028 <pthread_attr_getschedpolicy+0x98>
7001d004:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d008:	e3473002 	movt	r3, #28674	; 0x7002
7001d00c:	e5933000 	ldr	r3, [r3]
7001d010:	e3080390 	movw	r0, #33680	; 0x8390
7001d014:	e3470002 	movt	r0, #28674	; 0x7002
7001d018:	e3081434 	movw	r1, #33844	; 0x8434
7001d01c:	e3471002 	movt	r1, #28674	; 0x7002
7001d020:	e3a02062 	mov	r2, #98	; 0x62
7001d024:	e12fff33 	blx	r3

    *policy = (int)attr->policy;
7001d028:	e51b3010 	ldr	r3, [fp, #-16]
7001d02c:	e5d33008 	ldrb	r3, [r3, #8]
7001d030:	e1a02003 	mov	r2, r3
7001d034:	e51b3014 	ldr	r3, [fp, #-20]
7001d038:	e5832000 	str	r2, [r3]

    return 0;
7001d03c:	e3a03000 	mov	r3, #0
}
7001d040:	e1a00003 	mov	r0, r3
7001d044:	e24bd004 	sub	sp, fp, #4
7001d048:	e8bd8800 	pop	{fp, pc}

7001d04c <pthread_attr_setschedparam>:
RTM_EXPORT(pthread_attr_getschedpolicy);

int pthread_attr_setschedparam(pthread_attr_t           *attr,
                               struct sched_param const *param)
{
7001d04c:	e92d4800 	push	{fp, lr}
7001d050:	e28db004 	add	fp, sp, #4
7001d054:	e24dd010 	sub	sp, sp, #16
7001d058:	e50b0010 	str	r0, [fp, #-16]
7001d05c:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d060:	e51b3010 	ldr	r3, [fp, #-16]
7001d064:	e3530000 	cmp	r3, #0
7001d068:	1a00001d 	bne	7001d0e4 <pthread_attr_setschedparam+0x98>
7001d06c:	e3a03000 	mov	r3, #0
7001d070:	e54b3005 	strb	r3, [fp, #-5]
7001d074:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d078:	e3473002 	movt	r3, #28674	; 0x7002
7001d07c:	e5933000 	ldr	r3, [r3]
7001d080:	e3530000 	cmp	r3, #0
7001d084:	1a00000d 	bne	7001d0c0 <pthread_attr_setschedparam+0x74>
7001d088:	e3080370 	movw	r0, #33648	; 0x8370
7001d08c:	e3470002 	movt	r0, #28674	; 0x7002
7001d090:	e3081390 	movw	r1, #33680	; 0x8390
7001d094:	e3471002 	movt	r1, #28674	; 0x7002
7001d098:	e3082450 	movw	r2, #33872	; 0x8450
7001d09c:	e3472002 	movt	r2, #28674	; 0x7002
7001d0a0:	e3a0306d 	mov	r3, #109	; 0x6d
7001d0a4:	ebffa9d2 	bl	700077f4 <rt_kprintf>
7001d0a8:	e1a00000 	nop			; (mov r0, r0)
7001d0ac:	e55b3005 	ldrb	r3, [fp, #-5]
7001d0b0:	e6ef3073 	uxtb	r3, r3
7001d0b4:	e3530000 	cmp	r3, #0
7001d0b8:	0afffffb 	beq	7001d0ac <pthread_attr_setschedparam+0x60>
7001d0bc:	ea000008 	b	7001d0e4 <pthread_attr_setschedparam+0x98>
7001d0c0:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d0c4:	e3473002 	movt	r3, #28674	; 0x7002
7001d0c8:	e5933000 	ldr	r3, [r3]
7001d0cc:	e3080390 	movw	r0, #33680	; 0x8390
7001d0d0:	e3470002 	movt	r0, #28674	; 0x7002
7001d0d4:	e3081450 	movw	r1, #33872	; 0x8450
7001d0d8:	e3471002 	movt	r1, #28674	; 0x7002
7001d0dc:	e3a0206d 	mov	r2, #109	; 0x6d
7001d0e0:	e12fff33 	blx	r3
    RT_ASSERT(param != RT_NULL);
7001d0e4:	e51b3014 	ldr	r3, [fp, #-20]
7001d0e8:	e3530000 	cmp	r3, #0
7001d0ec:	1a00001d 	bne	7001d168 <pthread_attr_setschedparam+0x11c>
7001d0f0:	e3a03000 	mov	r3, #0
7001d0f4:	e54b3006 	strb	r3, [fp, #-6]
7001d0f8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d0fc:	e3473002 	movt	r3, #28674	; 0x7002
7001d100:	e5933000 	ldr	r3, [r3]
7001d104:	e3530000 	cmp	r3, #0
7001d108:	1a00000d 	bne	7001d144 <pthread_attr_setschedparam+0xf8>
7001d10c:	e3080370 	movw	r0, #33648	; 0x8370
7001d110:	e3470002 	movt	r0, #28674	; 0x7002
7001d114:	e30813a0 	movw	r1, #33696	; 0x83a0
7001d118:	e3471002 	movt	r1, #28674	; 0x7002
7001d11c:	e3082450 	movw	r2, #33872	; 0x8450
7001d120:	e3472002 	movt	r2, #28674	; 0x7002
7001d124:	e3a0306e 	mov	r3, #110	; 0x6e
7001d128:	ebffa9b1 	bl	700077f4 <rt_kprintf>
7001d12c:	e1a00000 	nop			; (mov r0, r0)
7001d130:	e55b3006 	ldrb	r3, [fp, #-6]
7001d134:	e6ef3073 	uxtb	r3, r3
7001d138:	e3530000 	cmp	r3, #0
7001d13c:	0afffffb 	beq	7001d130 <pthread_attr_setschedparam+0xe4>
7001d140:	ea000008 	b	7001d168 <pthread_attr_setschedparam+0x11c>
7001d144:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d148:	e3473002 	movt	r3, #28674	; 0x7002
7001d14c:	e5933000 	ldr	r3, [r3]
7001d150:	e30803a0 	movw	r0, #33696	; 0x83a0
7001d154:	e3470002 	movt	r0, #28674	; 0x7002
7001d158:	e3081450 	movw	r1, #33872	; 0x8450
7001d15c:	e3471002 	movt	r1, #28674	; 0x7002
7001d160:	e3a0206e 	mov	r2, #110	; 0x6e
7001d164:	e12fff33 	blx	r3

    attr->priority = param->sched_priority;
7001d168:	e51b3014 	ldr	r3, [fp, #-20]
7001d16c:	e5933000 	ldr	r3, [r3]
7001d170:	e6ef2073 	uxtb	r2, r3
7001d174:	e51b3010 	ldr	r3, [fp, #-16]
7001d178:	e5c32006 	strb	r2, [r3, #6]

    return 0;
7001d17c:	e3a03000 	mov	r3, #0
}
7001d180:	e1a00003 	mov	r0, r3
7001d184:	e24bd004 	sub	sp, fp, #4
7001d188:	e8bd8800 	pop	{fp, pc}

7001d18c <pthread_attr_getschedparam>:
RTM_EXPORT(pthread_attr_setschedparam);

int pthread_attr_getschedparam(pthread_attr_t const *attr,
                               struct sched_param   *param)
{
7001d18c:	e92d4800 	push	{fp, lr}
7001d190:	e28db004 	add	fp, sp, #4
7001d194:	e24dd010 	sub	sp, sp, #16
7001d198:	e50b0010 	str	r0, [fp, #-16]
7001d19c:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d1a0:	e51b3010 	ldr	r3, [fp, #-16]
7001d1a4:	e3530000 	cmp	r3, #0
7001d1a8:	1a00001d 	bne	7001d224 <pthread_attr_getschedparam+0x98>
7001d1ac:	e3a03000 	mov	r3, #0
7001d1b0:	e54b3005 	strb	r3, [fp, #-5]
7001d1b4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d1b8:	e3473002 	movt	r3, #28674	; 0x7002
7001d1bc:	e5933000 	ldr	r3, [r3]
7001d1c0:	e3530000 	cmp	r3, #0
7001d1c4:	1a00000d 	bne	7001d200 <pthread_attr_getschedparam+0x74>
7001d1c8:	e3080370 	movw	r0, #33648	; 0x8370
7001d1cc:	e3470002 	movt	r0, #28674	; 0x7002
7001d1d0:	e3081390 	movw	r1, #33680	; 0x8390
7001d1d4:	e3471002 	movt	r1, #28674	; 0x7002
7001d1d8:	e308246c 	movw	r2, #33900	; 0x846c
7001d1dc:	e3472002 	movt	r2, #28674	; 0x7002
7001d1e0:	e3a03079 	mov	r3, #121	; 0x79
7001d1e4:	ebffa982 	bl	700077f4 <rt_kprintf>
7001d1e8:	e1a00000 	nop			; (mov r0, r0)
7001d1ec:	e55b3005 	ldrb	r3, [fp, #-5]
7001d1f0:	e6ef3073 	uxtb	r3, r3
7001d1f4:	e3530000 	cmp	r3, #0
7001d1f8:	0afffffb 	beq	7001d1ec <pthread_attr_getschedparam+0x60>
7001d1fc:	ea000008 	b	7001d224 <pthread_attr_getschedparam+0x98>
7001d200:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d204:	e3473002 	movt	r3, #28674	; 0x7002
7001d208:	e5933000 	ldr	r3, [r3]
7001d20c:	e3080390 	movw	r0, #33680	; 0x8390
7001d210:	e3470002 	movt	r0, #28674	; 0x7002
7001d214:	e308146c 	movw	r1, #33900	; 0x846c
7001d218:	e3471002 	movt	r1, #28674	; 0x7002
7001d21c:	e3a02079 	mov	r2, #121	; 0x79
7001d220:	e12fff33 	blx	r3
    RT_ASSERT(param != RT_NULL);
7001d224:	e51b3014 	ldr	r3, [fp, #-20]
7001d228:	e3530000 	cmp	r3, #0
7001d22c:	1a00001d 	bne	7001d2a8 <pthread_attr_getschedparam+0x11c>
7001d230:	e3a03000 	mov	r3, #0
7001d234:	e54b3006 	strb	r3, [fp, #-6]
7001d238:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d23c:	e3473002 	movt	r3, #28674	; 0x7002
7001d240:	e5933000 	ldr	r3, [r3]
7001d244:	e3530000 	cmp	r3, #0
7001d248:	1a00000d 	bne	7001d284 <pthread_attr_getschedparam+0xf8>
7001d24c:	e3080370 	movw	r0, #33648	; 0x8370
7001d250:	e3470002 	movt	r0, #28674	; 0x7002
7001d254:	e30813a0 	movw	r1, #33696	; 0x83a0
7001d258:	e3471002 	movt	r1, #28674	; 0x7002
7001d25c:	e308246c 	movw	r2, #33900	; 0x846c
7001d260:	e3472002 	movt	r2, #28674	; 0x7002
7001d264:	e3a0307a 	mov	r3, #122	; 0x7a
7001d268:	ebffa961 	bl	700077f4 <rt_kprintf>
7001d26c:	e1a00000 	nop			; (mov r0, r0)
7001d270:	e55b3006 	ldrb	r3, [fp, #-6]
7001d274:	e6ef3073 	uxtb	r3, r3
7001d278:	e3530000 	cmp	r3, #0
7001d27c:	0afffffb 	beq	7001d270 <pthread_attr_getschedparam+0xe4>
7001d280:	ea000008 	b	7001d2a8 <pthread_attr_getschedparam+0x11c>
7001d284:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d288:	e3473002 	movt	r3, #28674	; 0x7002
7001d28c:	e5933000 	ldr	r3, [r3]
7001d290:	e30803a0 	movw	r0, #33696	; 0x83a0
7001d294:	e3470002 	movt	r0, #28674	; 0x7002
7001d298:	e308146c 	movw	r1, #33900	; 0x846c
7001d29c:	e3471002 	movt	r1, #28674	; 0x7002
7001d2a0:	e3a0207a 	mov	r2, #122	; 0x7a
7001d2a4:	e12fff33 	blx	r3

    param->sched_priority = attr->priority;
7001d2a8:	e51b3010 	ldr	r3, [fp, #-16]
7001d2ac:	e5d33006 	ldrb	r3, [r3, #6]
7001d2b0:	e1a02003 	mov	r2, r3
7001d2b4:	e51b3014 	ldr	r3, [fp, #-20]
7001d2b8:	e5832000 	str	r2, [r3]

    return 0;
7001d2bc:	e3a03000 	mov	r3, #0
}
7001d2c0:	e1a00003 	mov	r0, r3
7001d2c4:	e24bd004 	sub	sp, fp, #4
7001d2c8:	e8bd8800 	pop	{fp, pc}

7001d2cc <pthread_attr_setstacksize>:
RTM_EXPORT(pthread_attr_getschedparam);

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stack_size)
{
7001d2cc:	e92d4800 	push	{fp, lr}
7001d2d0:	e28db004 	add	fp, sp, #4
7001d2d4:	e24dd010 	sub	sp, sp, #16
7001d2d8:	e50b0010 	str	r0, [fp, #-16]
7001d2dc:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d2e0:	e51b3010 	ldr	r3, [fp, #-16]
7001d2e4:	e3530000 	cmp	r3, #0
7001d2e8:	1a00001d 	bne	7001d364 <pthread_attr_setstacksize+0x98>
7001d2ec:	e3a03000 	mov	r3, #0
7001d2f0:	e54b3005 	strb	r3, [fp, #-5]
7001d2f4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d2f8:	e3473002 	movt	r3, #28674	; 0x7002
7001d2fc:	e5933000 	ldr	r3, [r3]
7001d300:	e3530000 	cmp	r3, #0
7001d304:	1a00000d 	bne	7001d340 <pthread_attr_setstacksize+0x74>
7001d308:	e3080370 	movw	r0, #33648	; 0x8370
7001d30c:	e3470002 	movt	r0, #28674	; 0x7002
7001d310:	e3081390 	movw	r1, #33680	; 0x8390
7001d314:	e3471002 	movt	r1, #28674	; 0x7002
7001d318:	e3082488 	movw	r2, #33928	; 0x8488
7001d31c:	e3472002 	movt	r2, #28674	; 0x7002
7001d320:	e3a03084 	mov	r3, #132	; 0x84
7001d324:	ebffa932 	bl	700077f4 <rt_kprintf>
7001d328:	e1a00000 	nop			; (mov r0, r0)
7001d32c:	e55b3005 	ldrb	r3, [fp, #-5]
7001d330:	e6ef3073 	uxtb	r3, r3
7001d334:	e3530000 	cmp	r3, #0
7001d338:	0afffffb 	beq	7001d32c <pthread_attr_setstacksize+0x60>
7001d33c:	ea000008 	b	7001d364 <pthread_attr_setstacksize+0x98>
7001d340:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d344:	e3473002 	movt	r3, #28674	; 0x7002
7001d348:	e5933000 	ldr	r3, [r3]
7001d34c:	e3080390 	movw	r0, #33680	; 0x8390
7001d350:	e3470002 	movt	r0, #28674	; 0x7002
7001d354:	e3081488 	movw	r1, #33928	; 0x8488
7001d358:	e3471002 	movt	r1, #28674	; 0x7002
7001d35c:	e3a02084 	mov	r2, #132	; 0x84
7001d360:	e12fff33 	blx	r3

    attr->stack_size = stack_size;
7001d364:	e51b3014 	ldr	r3, [fp, #-20]
7001d368:	e6ff2073 	uxth	r2, r3
7001d36c:	e51b3010 	ldr	r3, [fp, #-16]
7001d370:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
7001d374:	e3a03000 	mov	r3, #0
}
7001d378:	e1a00003 	mov	r0, r3
7001d37c:	e24bd004 	sub	sp, fp, #4
7001d380:	e8bd8800 	pop	{fp, pc}

7001d384 <pthread_attr_getstacksize>:
RTM_EXPORT(pthread_attr_setstacksize);

int pthread_attr_getstacksize(pthread_attr_t const *attr, size_t *stack_size)
{
7001d384:	e92d4800 	push	{fp, lr}
7001d388:	e28db004 	add	fp, sp, #4
7001d38c:	e24dd010 	sub	sp, sp, #16
7001d390:	e50b0010 	str	r0, [fp, #-16]
7001d394:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d398:	e51b3010 	ldr	r3, [fp, #-16]
7001d39c:	e3530000 	cmp	r3, #0
7001d3a0:	1a00001d 	bne	7001d41c <pthread_attr_getstacksize+0x98>
7001d3a4:	e3a03000 	mov	r3, #0
7001d3a8:	e54b3005 	strb	r3, [fp, #-5]
7001d3ac:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d3b0:	e3473002 	movt	r3, #28674	; 0x7002
7001d3b4:	e5933000 	ldr	r3, [r3]
7001d3b8:	e3530000 	cmp	r3, #0
7001d3bc:	1a00000d 	bne	7001d3f8 <pthread_attr_getstacksize+0x74>
7001d3c0:	e3080370 	movw	r0, #33648	; 0x8370
7001d3c4:	e3470002 	movt	r0, #28674	; 0x7002
7001d3c8:	e3081390 	movw	r1, #33680	; 0x8390
7001d3cc:	e3471002 	movt	r1, #28674	; 0x7002
7001d3d0:	e30824a4 	movw	r2, #33956	; 0x84a4
7001d3d4:	e3472002 	movt	r2, #28674	; 0x7002
7001d3d8:	e3a0308e 	mov	r3, #142	; 0x8e
7001d3dc:	ebffa904 	bl	700077f4 <rt_kprintf>
7001d3e0:	e1a00000 	nop			; (mov r0, r0)
7001d3e4:	e55b3005 	ldrb	r3, [fp, #-5]
7001d3e8:	e6ef3073 	uxtb	r3, r3
7001d3ec:	e3530000 	cmp	r3, #0
7001d3f0:	0afffffb 	beq	7001d3e4 <pthread_attr_getstacksize+0x60>
7001d3f4:	ea000008 	b	7001d41c <pthread_attr_getstacksize+0x98>
7001d3f8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d3fc:	e3473002 	movt	r3, #28674	; 0x7002
7001d400:	e5933000 	ldr	r3, [r3]
7001d404:	e3080390 	movw	r0, #33680	; 0x8390
7001d408:	e3470002 	movt	r0, #28674	; 0x7002
7001d40c:	e30814a4 	movw	r1, #33956	; 0x84a4
7001d410:	e3471002 	movt	r1, #28674	; 0x7002
7001d414:	e3a0208e 	mov	r2, #142	; 0x8e
7001d418:	e12fff33 	blx	r3

    *stack_size = attr->stack_size;
7001d41c:	e51b3010 	ldr	r3, [fp, #-16]
7001d420:	e1d330b4 	ldrh	r3, [r3, #4]
7001d424:	e1a02003 	mov	r2, r3
7001d428:	e51b3014 	ldr	r3, [fp, #-20]
7001d42c:	e5832000 	str	r2, [r3]

    return 0;
7001d430:	e3a03000 	mov	r3, #0
}
7001d434:	e1a00003 	mov	r0, r3
7001d438:	e24bd004 	sub	sp, fp, #4
7001d43c:	e8bd8800 	pop	{fp, pc}

7001d440 <pthread_attr_setstackaddr>:
RTM_EXPORT(pthread_attr_getstacksize);

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack_addr)
{
7001d440:	e92d4800 	push	{fp, lr}
7001d444:	e28db004 	add	fp, sp, #4
7001d448:	e24dd010 	sub	sp, sp, #16
7001d44c:	e50b0010 	str	r0, [fp, #-16]
7001d450:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d454:	e51b3010 	ldr	r3, [fp, #-16]
7001d458:	e3530000 	cmp	r3, #0
7001d45c:	1a00001d 	bne	7001d4d8 <pthread_attr_setstackaddr+0x98>
7001d460:	e3a03000 	mov	r3, #0
7001d464:	e54b3005 	strb	r3, [fp, #-5]
7001d468:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d46c:	e3473002 	movt	r3, #28674	; 0x7002
7001d470:	e5933000 	ldr	r3, [r3]
7001d474:	e3530000 	cmp	r3, #0
7001d478:	1a00000d 	bne	7001d4b4 <pthread_attr_setstackaddr+0x74>
7001d47c:	e3080370 	movw	r0, #33648	; 0x8370
7001d480:	e3470002 	movt	r0, #28674	; 0x7002
7001d484:	e3081390 	movw	r1, #33680	; 0x8390
7001d488:	e3471002 	movt	r1, #28674	; 0x7002
7001d48c:	e30824c0 	movw	r2, #33984	; 0x84c0
7001d490:	e3472002 	movt	r2, #28674	; 0x7002
7001d494:	e3a03098 	mov	r3, #152	; 0x98
7001d498:	ebffa8d5 	bl	700077f4 <rt_kprintf>
7001d49c:	e1a00000 	nop			; (mov r0, r0)
7001d4a0:	e55b3005 	ldrb	r3, [fp, #-5]
7001d4a4:	e6ef3073 	uxtb	r3, r3
7001d4a8:	e3530000 	cmp	r3, #0
7001d4ac:	0afffffb 	beq	7001d4a0 <pthread_attr_setstackaddr+0x60>
7001d4b0:	ea000008 	b	7001d4d8 <pthread_attr_setstackaddr+0x98>
7001d4b4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d4b8:	e3473002 	movt	r3, #28674	; 0x7002
7001d4bc:	e5933000 	ldr	r3, [r3]
7001d4c0:	e3080390 	movw	r0, #33680	; 0x8390
7001d4c4:	e3470002 	movt	r0, #28674	; 0x7002
7001d4c8:	e30814c0 	movw	r1, #33984	; 0x84c0
7001d4cc:	e3471002 	movt	r1, #28674	; 0x7002
7001d4d0:	e3a02098 	mov	r2, #152	; 0x98
7001d4d4:	e12fff33 	blx	r3

    return EOPNOTSUPP;
7001d4d8:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001d4dc:	e1a00003 	mov	r0, r3
7001d4e0:	e24bd004 	sub	sp, fp, #4
7001d4e4:	e8bd8800 	pop	{fp, pc}

7001d4e8 <pthread_attr_getstackaddr>:
RTM_EXPORT(pthread_attr_setstackaddr);

int pthread_attr_getstackaddr(pthread_attr_t const *attr, void **stack_addr)
{
7001d4e8:	e92d4800 	push	{fp, lr}
7001d4ec:	e28db004 	add	fp, sp, #4
7001d4f0:	e24dd010 	sub	sp, sp, #16
7001d4f4:	e50b0010 	str	r0, [fp, #-16]
7001d4f8:	e50b1014 	str	r1, [fp, #-20]
    RT_ASSERT(attr != RT_NULL);
7001d4fc:	e51b3010 	ldr	r3, [fp, #-16]
7001d500:	e3530000 	cmp	r3, #0
7001d504:	1a00001d 	bne	7001d580 <pthread_attr_getstackaddr+0x98>
7001d508:	e3a03000 	mov	r3, #0
7001d50c:	e54b3005 	strb	r3, [fp, #-5]
7001d510:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d514:	e3473002 	movt	r3, #28674	; 0x7002
7001d518:	e5933000 	ldr	r3, [r3]
7001d51c:	e3530000 	cmp	r3, #0
7001d520:	1a00000d 	bne	7001d55c <pthread_attr_getstackaddr+0x74>
7001d524:	e3080370 	movw	r0, #33648	; 0x8370
7001d528:	e3470002 	movt	r0, #28674	; 0x7002
7001d52c:	e3081390 	movw	r1, #33680	; 0x8390
7001d530:	e3471002 	movt	r1, #28674	; 0x7002
7001d534:	e30824dc 	movw	r2, #34012	; 0x84dc
7001d538:	e3472002 	movt	r2, #28674	; 0x7002
7001d53c:	e3a030a0 	mov	r3, #160	; 0xa0
7001d540:	ebffa8ab 	bl	700077f4 <rt_kprintf>
7001d544:	e1a00000 	nop			; (mov r0, r0)
7001d548:	e55b3005 	ldrb	r3, [fp, #-5]
7001d54c:	e6ef3073 	uxtb	r3, r3
7001d550:	e3530000 	cmp	r3, #0
7001d554:	0afffffb 	beq	7001d548 <pthread_attr_getstackaddr+0x60>
7001d558:	ea000008 	b	7001d580 <pthread_attr_getstackaddr+0x98>
7001d55c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d560:	e3473002 	movt	r3, #28674	; 0x7002
7001d564:	e5933000 	ldr	r3, [r3]
7001d568:	e3080390 	movw	r0, #33680	; 0x8390
7001d56c:	e3470002 	movt	r0, #28674	; 0x7002
7001d570:	e30814dc 	movw	r1, #34012	; 0x84dc
7001d574:	e3471002 	movt	r1, #28674	; 0x7002
7001d578:	e3a020a0 	mov	r2, #160	; 0xa0
7001d57c:	e12fff33 	blx	r3

    return EOPNOTSUPP;
7001d580:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001d584:	e1a00003 	mov	r0, r3
7001d588:	e24bd004 	sub	sp, fp, #4
7001d58c:	e8bd8800 	pop	{fp, pc}

7001d590 <pthread_attr_setstack>:
RTM_EXPORT(pthread_attr_getstackaddr);

int pthread_attr_setstack(pthread_attr_t *attr,
                          void           *stack_base,
                          size_t          stack_size)
{
7001d590:	e92d4800 	push	{fp, lr}
7001d594:	e28db004 	add	fp, sp, #4
7001d598:	e24dd018 	sub	sp, sp, #24
7001d59c:	e50b0010 	str	r0, [fp, #-16]
7001d5a0:	e50b1014 	str	r1, [fp, #-20]
7001d5a4:	e50b2018 	str	r2, [fp, #-24]
    RT_ASSERT(attr != RT_NULL);
7001d5a8:	e51b3010 	ldr	r3, [fp, #-16]
7001d5ac:	e3530000 	cmp	r3, #0
7001d5b0:	1a00001d 	bne	7001d62c <pthread_attr_setstack+0x9c>
7001d5b4:	e3a03000 	mov	r3, #0
7001d5b8:	e54b3005 	strb	r3, [fp, #-5]
7001d5bc:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d5c0:	e3473002 	movt	r3, #28674	; 0x7002
7001d5c4:	e5933000 	ldr	r3, [r3]
7001d5c8:	e3530000 	cmp	r3, #0
7001d5cc:	1a00000d 	bne	7001d608 <pthread_attr_setstack+0x78>
7001d5d0:	e3080370 	movw	r0, #33648	; 0x8370
7001d5d4:	e3470002 	movt	r0, #28674	; 0x7002
7001d5d8:	e3081390 	movw	r1, #33680	; 0x8390
7001d5dc:	e3471002 	movt	r1, #28674	; 0x7002
7001d5e0:	e30824f8 	movw	r2, #34040	; 0x84f8
7001d5e4:	e3472002 	movt	r2, #28674	; 0x7002
7001d5e8:	e3a030aa 	mov	r3, #170	; 0xaa
7001d5ec:	ebffa880 	bl	700077f4 <rt_kprintf>
7001d5f0:	e1a00000 	nop			; (mov r0, r0)
7001d5f4:	e55b3005 	ldrb	r3, [fp, #-5]
7001d5f8:	e6ef3073 	uxtb	r3, r3
7001d5fc:	e3530000 	cmp	r3, #0
7001d600:	0afffffb 	beq	7001d5f4 <pthread_attr_setstack+0x64>
7001d604:	ea000008 	b	7001d62c <pthread_attr_setstack+0x9c>
7001d608:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d60c:	e3473002 	movt	r3, #28674	; 0x7002
7001d610:	e5933000 	ldr	r3, [r3]
7001d614:	e3080390 	movw	r0, #33680	; 0x8390
7001d618:	e3470002 	movt	r0, #28674	; 0x7002
7001d61c:	e30814f8 	movw	r1, #34040	; 0x84f8
7001d620:	e3471002 	movt	r1, #28674	; 0x7002
7001d624:	e3a020aa 	mov	r2, #170	; 0xaa
7001d628:	e12fff33 	blx	r3

    attr->stack_base = stack_base;
7001d62c:	e51b3010 	ldr	r3, [fp, #-16]
7001d630:	e51b2014 	ldr	r2, [fp, #-20]
7001d634:	e5832000 	str	r2, [r3]
    attr->stack_size = RT_ALIGN_DOWN(stack_size, RT_ALIGN_SIZE);
7001d638:	e51b3018 	ldr	r3, [fp, #-24]
7001d63c:	e6ff3073 	uxth	r3, r3
7001d640:	e3c33003 	bic	r3, r3, #3
7001d644:	e6ff2073 	uxth	r2, r3
7001d648:	e51b3010 	ldr	r3, [fp, #-16]
7001d64c:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
7001d650:	e3a03000 	mov	r3, #0
}
7001d654:	e1a00003 	mov	r0, r3
7001d658:	e24bd004 	sub	sp, fp, #4
7001d65c:	e8bd8800 	pop	{fp, pc}

7001d660 <pthread_attr_getstack>:
RTM_EXPORT(pthread_attr_setstack);

int pthread_attr_getstack(pthread_attr_t const *attr,
                          void                **stack_base,
                          size_t               *stack_size)
{
7001d660:	e92d4800 	push	{fp, lr}
7001d664:	e28db004 	add	fp, sp, #4
7001d668:	e24dd018 	sub	sp, sp, #24
7001d66c:	e50b0010 	str	r0, [fp, #-16]
7001d670:	e50b1014 	str	r1, [fp, #-20]
7001d674:	e50b2018 	str	r2, [fp, #-24]
    RT_ASSERT(attr != RT_NULL);
7001d678:	e51b3010 	ldr	r3, [fp, #-16]
7001d67c:	e3530000 	cmp	r3, #0
7001d680:	1a00001d 	bne	7001d6fc <pthread_attr_getstack+0x9c>
7001d684:	e3a03000 	mov	r3, #0
7001d688:	e54b3005 	strb	r3, [fp, #-5]
7001d68c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d690:	e3473002 	movt	r3, #28674	; 0x7002
7001d694:	e5933000 	ldr	r3, [r3]
7001d698:	e3530000 	cmp	r3, #0
7001d69c:	1a00000d 	bne	7001d6d8 <pthread_attr_getstack+0x78>
7001d6a0:	e3080370 	movw	r0, #33648	; 0x8370
7001d6a4:	e3470002 	movt	r0, #28674	; 0x7002
7001d6a8:	e3081390 	movw	r1, #33680	; 0x8390
7001d6ac:	e3471002 	movt	r1, #28674	; 0x7002
7001d6b0:	e3082510 	movw	r2, #34064	; 0x8510
7001d6b4:	e3472002 	movt	r2, #28674	; 0x7002
7001d6b8:	e3a030b7 	mov	r3, #183	; 0xb7
7001d6bc:	ebffa84c 	bl	700077f4 <rt_kprintf>
7001d6c0:	e1a00000 	nop			; (mov r0, r0)
7001d6c4:	e55b3005 	ldrb	r3, [fp, #-5]
7001d6c8:	e6ef3073 	uxtb	r3, r3
7001d6cc:	e3530000 	cmp	r3, #0
7001d6d0:	0afffffb 	beq	7001d6c4 <pthread_attr_getstack+0x64>
7001d6d4:	ea000008 	b	7001d6fc <pthread_attr_getstack+0x9c>
7001d6d8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d6dc:	e3473002 	movt	r3, #28674	; 0x7002
7001d6e0:	e5933000 	ldr	r3, [r3]
7001d6e4:	e3080390 	movw	r0, #33680	; 0x8390
7001d6e8:	e3470002 	movt	r0, #28674	; 0x7002
7001d6ec:	e3081510 	movw	r1, #34064	; 0x8510
7001d6f0:	e3471002 	movt	r1, #28674	; 0x7002
7001d6f4:	e3a020b7 	mov	r2, #183	; 0xb7
7001d6f8:	e12fff33 	blx	r3

    *stack_base = attr->stack_base;
7001d6fc:	e51b3010 	ldr	r3, [fp, #-16]
7001d700:	e5932000 	ldr	r2, [r3]
7001d704:	e51b3014 	ldr	r3, [fp, #-20]
7001d708:	e5832000 	str	r2, [r3]
    *stack_size = attr->stack_size;
7001d70c:	e51b3010 	ldr	r3, [fp, #-16]
7001d710:	e1d330b4 	ldrh	r3, [r3, #4]
7001d714:	e1a02003 	mov	r2, r3
7001d718:	e51b3018 	ldr	r3, [fp, #-24]
7001d71c:	e5832000 	str	r2, [r3]

    return 0;
7001d720:	e3a03000 	mov	r3, #0
}
7001d724:	e1a00003 	mov	r0, r3
7001d728:	e24bd004 	sub	sp, fp, #4
7001d72c:	e8bd8800 	pop	{fp, pc}

7001d730 <pthread_attr_setguardsize>:
RTM_EXPORT(pthread_attr_getstack);

int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guard_size)
{
7001d730:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001d734:	e28db000 	add	fp, sp, #0
7001d738:	e24dd00c 	sub	sp, sp, #12
7001d73c:	e50b0008 	str	r0, [fp, #-8]
7001d740:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
7001d744:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001d748:	e1a00003 	mov	r0, r3
7001d74c:	e24bd000 	sub	sp, fp, #0
7001d750:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001d754:	e12fff1e 	bx	lr

7001d758 <pthread_attr_getguardsize>:

int pthread_attr_getguardsize(pthread_attr_t const *attr, size_t *guard_size)
{
7001d758:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001d75c:	e28db000 	add	fp, sp, #0
7001d760:	e24dd00c 	sub	sp, sp, #12
7001d764:	e50b0008 	str	r0, [fp, #-8]
7001d768:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
7001d76c:	e3a0305f 	mov	r3, #95	; 0x5f
}
7001d770:	e1a00003 	mov	r0, r3
7001d774:	e24bd000 	sub	sp, fp, #0
7001d778:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001d77c:	e12fff1e 	bx	lr

7001d780 <pthread_attr_setscope>:
RTM_EXPORT(pthread_attr_getguardsize);

int pthread_attr_setscope(pthread_attr_t *attr, int scope)
{
7001d780:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001d784:	e28db000 	add	fp, sp, #0
7001d788:	e24dd00c 	sub	sp, sp, #12
7001d78c:	e50b0008 	str	r0, [fp, #-8]
7001d790:	e50b100c 	str	r1, [fp, #-12]
    if (scope == PTHREAD_SCOPE_SYSTEM)
7001d794:	e51b300c 	ldr	r3, [fp, #-12]
7001d798:	e3530001 	cmp	r3, #1
7001d79c:	1a000001 	bne	7001d7a8 <pthread_attr_setscope+0x28>
        return 0;
7001d7a0:	e3a03000 	mov	r3, #0
7001d7a4:	ea000005 	b	7001d7c0 <pthread_attr_setscope+0x40>
    if (scope == PTHREAD_SCOPE_PROCESS)
7001d7a8:	e51b300c 	ldr	r3, [fp, #-12]
7001d7ac:	e3530000 	cmp	r3, #0
7001d7b0:	1a000001 	bne	7001d7bc <pthread_attr_setscope+0x3c>
        return EOPNOTSUPP;
7001d7b4:	e3a0305f 	mov	r3, #95	; 0x5f
7001d7b8:	ea000000 	b	7001d7c0 <pthread_attr_setscope+0x40>

    return EINVAL;
7001d7bc:	e3a03016 	mov	r3, #22
}
7001d7c0:	e1a00003 	mov	r0, r3
7001d7c4:	e24bd000 	sub	sp, fp, #0
7001d7c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001d7cc:	e12fff1e 	bx	lr

7001d7d0 <pthread_attr_getscope>:
RTM_EXPORT(pthread_attr_setscope);

int pthread_attr_getscope(pthread_attr_t const *attr)
{
7001d7d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001d7d4:	e28db000 	add	fp, sp, #0
7001d7d8:	e24dd00c 	sub	sp, sp, #12
7001d7dc:	e50b0008 	str	r0, [fp, #-8]
    return PTHREAD_SCOPE_SYSTEM;
7001d7e0:	e3a03001 	mov	r3, #1
}
7001d7e4:	e1a00003 	mov	r0, r3
7001d7e8:	e24bd000 	sub	sp, fp, #0
7001d7ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001d7f0:	e12fff1e 	bx	lr

7001d7f4 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
7001d7f4:	e92d4800 	push	{fp, lr}
7001d7f8:	e28db004 	add	fp, sp, #4
7001d7fc:	e24dd010 	sub	sp, sp, #16
7001d800:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
7001d804:	e51b3010 	ldr	r3, [fp, #-16]
7001d808:	e3530000 	cmp	r3, #0
7001d80c:	1a00001d 	bne	7001d888 <_pthread_get_data+0x94>
7001d810:	e3a03000 	mov	r3, #0
7001d814:	e54b3009 	strb	r3, [fp, #-9]
7001d818:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d81c:	e3473002 	movt	r3, #28674	; 0x7002
7001d820:	e5933000 	ldr	r3, [r3]
7001d824:	e3530000 	cmp	r3, #0
7001d828:	1a00000d 	bne	7001d864 <_pthread_get_data+0x70>
7001d82c:	e3080528 	movw	r0, #34088	; 0x8528
7001d830:	e3470002 	movt	r0, #28674	; 0x7002
7001d834:	e3081548 	movw	r1, #34120	; 0x8548
7001d838:	e3471002 	movt	r1, #28674	; 0x7002
7001d83c:	e30825a8 	movw	r2, #34216	; 0x85a8
7001d840:	e3472002 	movt	r2, #28674	; 0x7002
7001d844:	e3a0304c 	mov	r3, #76	; 0x4c
7001d848:	ebffa7e9 	bl	700077f4 <rt_kprintf>
7001d84c:	e1a00000 	nop			; (mov r0, r0)
7001d850:	e55b3009 	ldrb	r3, [fp, #-9]
7001d854:	e6ef3073 	uxtb	r3, r3
7001d858:	e3530000 	cmp	r3, #0
7001d85c:	0afffffb 	beq	7001d850 <_pthread_get_data+0x5c>
7001d860:	ea000008 	b	7001d888 <_pthread_get_data+0x94>
7001d864:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d868:	e3473002 	movt	r3, #28674	; 0x7002
7001d86c:	e5933000 	ldr	r3, [r3]
7001d870:	e3080548 	movw	r0, #34120	; 0x8548
7001d874:	e3470002 	movt	r0, #28674	; 0x7002
7001d878:	e30815a8 	movw	r1, #34216	; 0x85a8
7001d87c:	e3471002 	movt	r1, #28674	; 0x7002
7001d880:	e3a0204c 	mov	r2, #76	; 0x4c
7001d884:	e12fff33 	blx	r3

    ptd = (_pthread_data_t *)thread->user_data;
7001d888:	e51b3010 	ldr	r3, [fp, #-16]
7001d88c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
7001d890:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
7001d894:	e51b3008 	ldr	r3, [fp, #-8]
7001d898:	e3530000 	cmp	r3, #0
7001d89c:	1a00001d 	bne	7001d918 <_pthread_get_data+0x124>
7001d8a0:	e3a03000 	mov	r3, #0
7001d8a4:	e54b300a 	strb	r3, [fp, #-10]
7001d8a8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d8ac:	e3473002 	movt	r3, #28674	; 0x7002
7001d8b0:	e5933000 	ldr	r3, [r3]
7001d8b4:	e3530000 	cmp	r3, #0
7001d8b8:	1a00000d 	bne	7001d8f4 <_pthread_get_data+0x100>
7001d8bc:	e3080528 	movw	r0, #34088	; 0x8528
7001d8c0:	e3470002 	movt	r0, #28674	; 0x7002
7001d8c4:	e308155c 	movw	r1, #34140	; 0x855c
7001d8c8:	e3471002 	movt	r1, #28674	; 0x7002
7001d8cc:	e30825a8 	movw	r2, #34216	; 0x85a8
7001d8d0:	e3472002 	movt	r2, #28674	; 0x7002
7001d8d4:	e3a0304f 	mov	r3, #79	; 0x4f
7001d8d8:	ebffa7c5 	bl	700077f4 <rt_kprintf>
7001d8dc:	e1a00000 	nop			; (mov r0, r0)
7001d8e0:	e55b300a 	ldrb	r3, [fp, #-10]
7001d8e4:	e6ef3073 	uxtb	r3, r3
7001d8e8:	e3530000 	cmp	r3, #0
7001d8ec:	0afffffb 	beq	7001d8e0 <_pthread_get_data+0xec>
7001d8f0:	ea000008 	b	7001d918 <_pthread_get_data+0x124>
7001d8f4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d8f8:	e3473002 	movt	r3, #28674	; 0x7002
7001d8fc:	e5933000 	ldr	r3, [r3]
7001d900:	e308055c 	movw	r0, #34140	; 0x855c
7001d904:	e3470002 	movt	r0, #28674	; 0x7002
7001d908:	e30815a8 	movw	r1, #34216	; 0x85a8
7001d90c:	e3471002 	movt	r1, #28674	; 0x7002
7001d910:	e3a0204f 	mov	r2, #79	; 0x4f
7001d914:	e12fff33 	blx	r3
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
7001d918:	e51b3008 	ldr	r3, [fp, #-8]
7001d91c:	e5932000 	ldr	r2, [r3]
7001d920:	e3063873 	movw	r3, #26739	; 0x6873
7001d924:	e3473074 	movt	r3, #28788	; 0x7074
7001d928:	e1520003 	cmp	r2, r3
7001d92c:	0a00001d 	beq	7001d9a8 <_pthread_get_data+0x1b4>
7001d930:	e3a03000 	mov	r3, #0
7001d934:	e54b300b 	strb	r3, [fp, #-11]
7001d938:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d93c:	e3473002 	movt	r3, #28674	; 0x7002
7001d940:	e5933000 	ldr	r3, [r3]
7001d944:	e3530000 	cmp	r3, #0
7001d948:	1a00000d 	bne	7001d984 <_pthread_get_data+0x190>
7001d94c:	e3080528 	movw	r0, #34088	; 0x8528
7001d950:	e3470002 	movt	r0, #28674	; 0x7002
7001d954:	e308156c 	movw	r1, #34156	; 0x856c
7001d958:	e3471002 	movt	r1, #28674	; 0x7002
7001d95c:	e30825a8 	movw	r2, #34216	; 0x85a8
7001d960:	e3472002 	movt	r2, #28674	; 0x7002
7001d964:	e3a03050 	mov	r3, #80	; 0x50
7001d968:	ebffa7a1 	bl	700077f4 <rt_kprintf>
7001d96c:	e1a00000 	nop			; (mov r0, r0)
7001d970:	e55b300b 	ldrb	r3, [fp, #-11]
7001d974:	e6ef3073 	uxtb	r3, r3
7001d978:	e3530000 	cmp	r3, #0
7001d97c:	0afffffb 	beq	7001d970 <_pthread_get_data+0x17c>
7001d980:	ea000008 	b	7001d9a8 <_pthread_get_data+0x1b4>
7001d984:	e30a3b74 	movw	r3, #43892	; 0xab74
7001d988:	e3473002 	movt	r3, #28674	; 0x7002
7001d98c:	e5933000 	ldr	r3, [r3]
7001d990:	e308056c 	movw	r0, #34156	; 0x856c
7001d994:	e3470002 	movt	r0, #28674	; 0x7002
7001d998:	e30815a8 	movw	r1, #34216	; 0x85a8
7001d99c:	e3471002 	movt	r1, #28674	; 0x7002
7001d9a0:	e3a02050 	mov	r2, #80	; 0x50
7001d9a4:	e12fff33 	blx	r3

    return ptd;
7001d9a8:	e51b3008 	ldr	r3, [fp, #-8]
}
7001d9ac:	e1a00003 	mov	r0, r3
7001d9b0:	e24bd004 	sub	sp, fp, #4
7001d9b4:	e8bd8800 	pop	{fp, pc}

7001d9b8 <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
7001d9b8:	e92d4800 	push	{fp, lr}
7001d9bc:	e28db004 	add	fp, sp, #4
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
7001d9c0:	e30b083c 	movw	r0, #47164	; 0xb83c
7001d9c4:	e3470002 	movt	r0, #28674	; 0x7002
7001d9c8:	e3a01000 	mov	r1, #0
7001d9cc:	e3a02040 	mov	r2, #64	; 0x40
7001d9d0:	ebffa18d 	bl	7000600c <rt_memset>
}
7001d9d4:	e8bd8800 	pop	{fp, pc}

7001d9d8 <pthread_getspecific>:

void *pthread_getspecific(pthread_key_t key)
{
7001d9d8:	e92d4800 	push	{fp, lr}
7001d9dc:	e28db004 	add	fp, sp, #4
7001d9e0:	e24dd010 	sub	sp, sp, #16
7001d9e4:	e50b0010 	str	r0, [fp, #-16]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
7001d9e8:	ebffb2e0 	bl	7000a570 <rt_thread_self>
7001d9ec:	e1a03000 	mov	r3, r0
7001d9f0:	e1a00003 	mov	r0, r3
7001d9f4:	ebffff7e 	bl	7001d7f4 <_pthread_get_data>
7001d9f8:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
7001d9fc:	e51b3008 	ldr	r3, [fp, #-8]
7001da00:	e3530000 	cmp	r3, #0
7001da04:	1a00001d 	bne	7001da80 <pthread_getspecific+0xa8>
7001da08:	e3a03000 	mov	r3, #0
7001da0c:	e54b3009 	strb	r3, [fp, #-9]
7001da10:	e30a3b74 	movw	r3, #43892	; 0xab74
7001da14:	e3473002 	movt	r3, #28674	; 0x7002
7001da18:	e5933000 	ldr	r3, [r3]
7001da1c:	e3530000 	cmp	r3, #0
7001da20:	1a00000d 	bne	7001da5c <pthread_getspecific+0x84>
7001da24:	e3080528 	movw	r0, #34088	; 0x8528
7001da28:	e3470002 	movt	r0, #28674	; 0x7002
7001da2c:	e3081588 	movw	r1, #34184	; 0x8588
7001da30:	e3471002 	movt	r1, #28674	; 0x7002
7001da34:	e3082594 	movw	r2, #34196	; 0x8594
7001da38:	e3472002 	movt	r2, #28674	; 0x7002
7001da3c:	e3a03028 	mov	r3, #40	; 0x28
7001da40:	ebffa76b 	bl	700077f4 <rt_kprintf>
7001da44:	e1a00000 	nop			; (mov r0, r0)
7001da48:	e55b3009 	ldrb	r3, [fp, #-9]
7001da4c:	e6ef3073 	uxtb	r3, r3
7001da50:	e3530000 	cmp	r3, #0
7001da54:	0afffffb 	beq	7001da48 <pthread_getspecific+0x70>
7001da58:	ea000008 	b	7001da80 <pthread_getspecific+0xa8>
7001da5c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001da60:	e3473002 	movt	r3, #28674	; 0x7002
7001da64:	e5933000 	ldr	r3, [r3]
7001da68:	e3080588 	movw	r0, #34184	; 0x8588
7001da6c:	e3470002 	movt	r0, #28674	; 0x7002
7001da70:	e3081594 	movw	r1, #34196	; 0x8594
7001da74:	e3471002 	movt	r1, #28674	; 0x7002
7001da78:	e3a02028 	mov	r2, #40	; 0x28
7001da7c:	e12fff33 	blx	r3

    if (ptd->tls == NULL)
7001da80:	e51b3008 	ldr	r3, [fp, #-8]
7001da84:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001da88:	e3530000 	cmp	r3, #0
7001da8c:	1a000001 	bne	7001da98 <pthread_getspecific+0xc0>
        return NULL;
7001da90:	e3a03000 	mov	r3, #0
7001da94:	ea000010 	b	7001dadc <pthread_getspecific+0x104>

    if ((key < PTHREAD_KEY_MAX) && (_thread_keys[key].is_used))
7001da98:	e51b3010 	ldr	r3, [fp, #-16]
7001da9c:	e3530007 	cmp	r3, #7
7001daa0:	ca00000c 	bgt	7001dad8 <pthread_getspecific+0x100>
7001daa4:	e30b383c 	movw	r3, #47164	; 0xb83c
7001daa8:	e3473002 	movt	r3, #28674	; 0x7002
7001daac:	e51b2010 	ldr	r2, [fp, #-16]
7001dab0:	e7933182 	ldr	r3, [r3, r2, lsl #3]
7001dab4:	e3530000 	cmp	r3, #0
7001dab8:	0a000006 	beq	7001dad8 <pthread_getspecific+0x100>
        return ptd->tls[key];
7001dabc:	e51b3008 	ldr	r3, [fp, #-8]
7001dac0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
7001dac4:	e51b3010 	ldr	r3, [fp, #-16]
7001dac8:	e1a03103 	lsl	r3, r3, #2
7001dacc:	e0823003 	add	r3, r2, r3
7001dad0:	e5933000 	ldr	r3, [r3]
7001dad4:	ea000000 	b	7001dadc <pthread_getspecific+0x104>

    return NULL;
7001dad8:	e3a03000 	mov	r3, #0
}
7001dadc:	e1a00003 	mov	r0, r3
7001dae0:	e24bd004 	sub	sp, fp, #4
7001dae4:	e8bd8800 	pop	{fp, pc}

7001dae8 <pthread_setspecific>:
RTM_EXPORT(pthread_getspecific);

int pthread_setspecific(pthread_key_t key, const void *value)
{
7001dae8:	e92d4800 	push	{fp, lr}
7001daec:	e28db004 	add	fp, sp, #4
7001daf0:	e24dd010 	sub	sp, sp, #16
7001daf4:	e50b0010 	str	r0, [fp, #-16]
7001daf8:	e50b1014 	str	r1, [fp, #-20]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
7001dafc:	ebffb29b 	bl	7000a570 <rt_thread_self>
7001db00:	e1a03000 	mov	r3, r0
7001db04:	e1a00003 	mov	r0, r3
7001db08:	ebffff39 	bl	7001d7f4 <_pthread_get_data>
7001db0c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
7001db10:	e51b3008 	ldr	r3, [fp, #-8]
7001db14:	e3530000 	cmp	r3, #0
7001db18:	1a00001d 	bne	7001db94 <pthread_setspecific+0xac>
7001db1c:	e3a03000 	mov	r3, #0
7001db20:	e54b3009 	strb	r3, [fp, #-9]
7001db24:	e30a3b74 	movw	r3, #43892	; 0xab74
7001db28:	e3473002 	movt	r3, #28674	; 0x7002
7001db2c:	e5933000 	ldr	r3, [r3]
7001db30:	e3530000 	cmp	r3, #0
7001db34:	1a00000d 	bne	7001db70 <pthread_setspecific+0x88>
7001db38:	e3080528 	movw	r0, #34088	; 0x8528
7001db3c:	e3470002 	movt	r0, #28674	; 0x7002
7001db40:	e3081588 	movw	r1, #34184	; 0x8588
7001db44:	e3471002 	movt	r1, #28674	; 0x7002
7001db48:	e30825bc 	movw	r2, #34236	; 0x85bc
7001db4c:	e3472002 	movt	r2, #28674	; 0x7002
7001db50:	e3a03039 	mov	r3, #57	; 0x39
7001db54:	ebffa726 	bl	700077f4 <rt_kprintf>
7001db58:	e1a00000 	nop			; (mov r0, r0)
7001db5c:	e55b3009 	ldrb	r3, [fp, #-9]
7001db60:	e6ef3073 	uxtb	r3, r3
7001db64:	e3530000 	cmp	r3, #0
7001db68:	0afffffb 	beq	7001db5c <pthread_setspecific+0x74>
7001db6c:	ea000008 	b	7001db94 <pthread_setspecific+0xac>
7001db70:	e30a3b74 	movw	r3, #43892	; 0xab74
7001db74:	e3473002 	movt	r3, #28674	; 0x7002
7001db78:	e5933000 	ldr	r3, [r3]
7001db7c:	e3080588 	movw	r0, #34184	; 0x8588
7001db80:	e3470002 	movt	r0, #28674	; 0x7002
7001db84:	e30815bc 	movw	r1, #34236	; 0x85bc
7001db88:	e3471002 	movt	r1, #28674	; 0x7002
7001db8c:	e3a02039 	mov	r2, #57	; 0x39
7001db90:	e12fff33 	blx	r3

    /* check tls area */
    if (ptd->tls == NULL)
7001db94:	e51b3008 	ldr	r3, [fp, #-8]
7001db98:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7001db9c:	e3530000 	cmp	r3, #0
7001dba0:	1a000004 	bne	7001dbb8 <pthread_setspecific+0xd0>
    {
        ptd->tls = (void**)rt_malloc(sizeof(void*) * PTHREAD_KEY_MAX);
7001dba4:	e3a00020 	mov	r0, #32
7001dba8:	ebffa943 	bl	700080bc <rt_malloc>
7001dbac:	e1a02000 	mov	r2, r0
7001dbb0:	e51b3008 	ldr	r3, [fp, #-8]
7001dbb4:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if ((key < PTHREAD_KEY_MAX) && _thread_keys[key].is_used)
7001dbb8:	e51b3010 	ldr	r3, [fp, #-16]
7001dbbc:	e3530007 	cmp	r3, #7
7001dbc0:	ca00000e 	bgt	7001dc00 <pthread_setspecific+0x118>
7001dbc4:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dbc8:	e3473002 	movt	r3, #28674	; 0x7002
7001dbcc:	e51b2010 	ldr	r2, [fp, #-16]
7001dbd0:	e7933182 	ldr	r3, [r3, r2, lsl #3]
7001dbd4:	e3530000 	cmp	r3, #0
7001dbd8:	0a000008 	beq	7001dc00 <pthread_setspecific+0x118>
    {
        ptd->tls[key] = (void *)value;
7001dbdc:	e51b3008 	ldr	r3, [fp, #-8]
7001dbe0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
7001dbe4:	e51b3010 	ldr	r3, [fp, #-16]
7001dbe8:	e1a03103 	lsl	r3, r3, #2
7001dbec:	e0823003 	add	r3, r2, r3
7001dbf0:	e51b2014 	ldr	r2, [fp, #-20]
7001dbf4:	e5832000 	str	r2, [r3]

        return 0;
7001dbf8:	e3a03000 	mov	r3, #0
7001dbfc:	ea000000 	b	7001dc04 <pthread_setspecific+0x11c>
    }

    return EINVAL;
7001dc00:	e3a03016 	mov	r3, #22
}
7001dc04:	e1a00003 	mov	r0, r3
7001dc08:	e24bd004 	sub	sp, fp, #4
7001dc0c:	e8bd8800 	pop	{fp, pc}

7001dc10 <pthread_key_create>:
RTM_EXPORT(pthread_setspecific);

int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
7001dc10:	e92d4800 	push	{fp, lr}
7001dc14:	e28db004 	add	fp, sp, #4
7001dc18:	e24dd010 	sub	sp, sp, #16
7001dc1c:	e50b0010 	str	r0, [fp, #-16]
7001dc20:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t index;

    rt_enter_critical();
7001dc24:	ebffb0c3 	bl	70009f38 <rt_enter_critical>
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
7001dc28:	e3a03000 	mov	r3, #0
7001dc2c:	e50b3008 	str	r3, [fp, #-8]
7001dc30:	ea00001c 	b	7001dca8 <pthread_key_create+0x98>
    {
        if (_thread_keys[index].is_used == 0)
7001dc34:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dc38:	e3473002 	movt	r3, #28674	; 0x7002
7001dc3c:	e51b2008 	ldr	r2, [fp, #-8]
7001dc40:	e7933182 	ldr	r3, [r3, r2, lsl #3]
7001dc44:	e3530000 	cmp	r3, #0
7001dc48:	1a000013 	bne	7001dc9c <pthread_key_create+0x8c>
        {
            _thread_keys[index].is_used = 1;
7001dc4c:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dc50:	e3473002 	movt	r3, #28674	; 0x7002
7001dc54:	e51b2008 	ldr	r2, [fp, #-8]
7001dc58:	e3a01001 	mov	r1, #1
7001dc5c:	e7831182 	str	r1, [r3, r2, lsl #3]
            _thread_keys[index].destructor = destructor;
7001dc60:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dc64:	e3473002 	movt	r3, #28674	; 0x7002
7001dc68:	e51b1008 	ldr	r1, [fp, #-8]
7001dc6c:	e3a02004 	mov	r2, #4
7001dc70:	e1a01181 	lsl	r1, r1, #3
7001dc74:	e0833001 	add	r3, r3, r1
7001dc78:	e0833002 	add	r3, r3, r2
7001dc7c:	e51b2014 	ldr	r2, [fp, #-20]
7001dc80:	e5832000 	str	r2, [r3]

            *key = index;
7001dc84:	e51b2008 	ldr	r2, [fp, #-8]
7001dc88:	e51b3010 	ldr	r3, [fp, #-16]
7001dc8c:	e5832000 	str	r2, [r3]

            rt_exit_critical();
7001dc90:	ebffb0b8 	bl	70009f78 <rt_exit_critical>

            return 0;
7001dc94:	e3a03000 	mov	r3, #0
7001dc98:	ea000007 	b	7001dcbc <pthread_key_create+0xac>
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
    rt_uint32_t index;

    rt_enter_critical();
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
7001dc9c:	e51b3008 	ldr	r3, [fp, #-8]
7001dca0:	e2833001 	add	r3, r3, #1
7001dca4:	e50b3008 	str	r3, [fp, #-8]
7001dca8:	e51b3008 	ldr	r3, [fp, #-8]
7001dcac:	e3530007 	cmp	r3, #7
7001dcb0:	9affffdf 	bls	7001dc34 <pthread_key_create+0x24>

            return 0;
        }
    }

    rt_exit_critical();
7001dcb4:	ebffb0af 	bl	70009f78 <rt_exit_critical>

    return EAGAIN;
7001dcb8:	e3a0300b 	mov	r3, #11
}
7001dcbc:	e1a00003 	mov	r0, r3
7001dcc0:	e24bd004 	sub	sp, fp, #4
7001dcc4:	e8bd8800 	pop	{fp, pc}

7001dcc8 <pthread_key_delete>:
RTM_EXPORT(pthread_key_create);

int pthread_key_delete(pthread_key_t key)
{
7001dcc8:	e92d4800 	push	{fp, lr}
7001dccc:	e28db004 	add	fp, sp, #4
7001dcd0:	e24dd008 	sub	sp, sp, #8
7001dcd4:	e50b0008 	str	r0, [fp, #-8]
    if (key >= PTHREAD_KEY_MAX)
7001dcd8:	e51b3008 	ldr	r3, [fp, #-8]
7001dcdc:	e3530007 	cmp	r3, #7
7001dce0:	da000001 	ble	7001dcec <pthread_key_delete+0x24>
        return EINVAL;
7001dce4:	e3a03016 	mov	r3, #22
7001dce8:	ea000010 	b	7001dd30 <pthread_key_delete+0x68>

    rt_enter_critical();
7001dcec:	ebffb091 	bl	70009f38 <rt_enter_critical>
    _thread_keys[key].is_used = 0;
7001dcf0:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dcf4:	e3473002 	movt	r3, #28674	; 0x7002
7001dcf8:	e51b2008 	ldr	r2, [fp, #-8]
7001dcfc:	e3a01000 	mov	r1, #0
7001dd00:	e7831182 	str	r1, [r3, r2, lsl #3]
    _thread_keys[key].destructor = 0;
7001dd04:	e30b383c 	movw	r3, #47164	; 0xb83c
7001dd08:	e3473002 	movt	r3, #28674	; 0x7002
7001dd0c:	e51b1008 	ldr	r1, [fp, #-8]
7001dd10:	e3a02004 	mov	r2, #4
7001dd14:	e1a01181 	lsl	r1, r1, #3
7001dd18:	e0833001 	add	r3, r3, r1
7001dd1c:	e0833002 	add	r3, r3, r2
7001dd20:	e3a02000 	mov	r2, #0
7001dd24:	e5832000 	str	r2, [r3]
    rt_exit_critical();
7001dd28:	ebffb092 	bl	70009f78 <rt_exit_critical>

    return 0;
7001dd2c:	e3a03000 	mov	r3, #0
}
7001dd30:	e1a00003 	mov	r0, r3
7001dd34:	e24bd004 	sub	sp, fp, #4
7001dd38:	e8bd8800 	pop	{fp, pc}

7001dd3c <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
7001dd3c:	e92d4800 	push	{fp, lr}
7001dd40:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
7001dd44:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001dd48:	e3470002 	movt	r0, #28674	; 0x7002
7001dd4c:	e30815d0 	movw	r1, #34256	; 0x85d0
7001dd50:	e3471002 	movt	r1, #28674	; 0x7002
7001dd54:	e3a02001 	mov	r2, #1
7001dd58:	e3a03000 	mov	r3, #0
7001dd5c:	ebff8f10 	bl	700019a4 <rt_sem_init>
}
7001dd60:	e8bd8800 	pop	{fp, pc}

7001dd64 <posix_sem_insert>:

rt_inline void posix_sem_insert(sem_t *psem)
{
7001dd64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001dd68:	e28db000 	add	fp, sp, #0
7001dd6c:	e24dd00c 	sub	sp, sp, #12
7001dd70:	e50b0008 	str	r0, [fp, #-8]
    psem->next = posix_sem_list;
7001dd74:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001dd78:	e3473002 	movt	r3, #28674	; 0x7002
7001dd7c:	e5932000 	ldr	r2, [r3]
7001dd80:	e51b3008 	ldr	r3, [fp, #-8]
7001dd84:	e5832008 	str	r2, [r3, #8]
    posix_sem_list = psem;
7001dd88:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001dd8c:	e3473002 	movt	r3, #28674	; 0x7002
7001dd90:	e51b2008 	ldr	r2, [fp, #-8]
7001dd94:	e5832000 	str	r2, [r3]
}
7001dd98:	e24bd000 	sub	sp, fp, #0
7001dd9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001dda0:	e12fff1e 	bx	lr

7001dda4 <posix_sem_delete>:

static void posix_sem_delete(sem_t *psem)
{
7001dda4:	e92d4800 	push	{fp, lr}
7001dda8:	e28db004 	add	fp, sp, #4
7001ddac:	e24dd010 	sub	sp, sp, #16
7001ddb0:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    if (posix_sem_list == psem)
7001ddb4:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001ddb8:	e3473002 	movt	r3, #28674	; 0x7002
7001ddbc:	e5932000 	ldr	r2, [r3]
7001ddc0:	e51b3010 	ldr	r3, [fp, #-16]
7001ddc4:	e1520003 	cmp	r2, r3
7001ddc8:	1a00000b 	bne	7001ddfc <posix_sem_delete+0x58>
    {
        posix_sem_list = psem->next;
7001ddcc:	e51b3010 	ldr	r3, [fp, #-16]
7001ddd0:	e5932008 	ldr	r2, [r3, #8]
7001ddd4:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001ddd8:	e3473002 	movt	r3, #28674	; 0x7002
7001dddc:	e5832000 	str	r2, [r3]

        rt_sem_delete(psem->sem);
7001dde0:	e51b3010 	ldr	r3, [fp, #-16]
7001dde4:	e5933004 	ldr	r3, [r3, #4]
7001dde8:	e1a00003 	mov	r0, r3
7001ddec:	ebff8fa0 	bl	70001c74 <rt_sem_delete>
        rt_free(psem);
7001ddf0:	e51b0010 	ldr	r0, [fp, #-16]
7001ddf4:	ebffab73 	bl	70008bc8 <rt_free>

        return;
7001ddf8:	ea000023 	b	7001de8c <posix_sem_delete+0xe8>
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
7001ddfc:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001de00:	e3473002 	movt	r3, #28674	; 0x7002
7001de04:	e5933000 	ldr	r3, [r3]
7001de08:	e50b3008 	str	r3, [fp, #-8]
7001de0c:	ea00001a 	b	7001de7c <posix_sem_delete+0xd8>
    {
        if (iter->next == psem)
7001de10:	e51b3008 	ldr	r3, [fp, #-8]
7001de14:	e5932008 	ldr	r2, [r3, #8]
7001de18:	e51b3010 	ldr	r3, [fp, #-16]
7001de1c:	e1520003 	cmp	r2, r3
7001de20:	1a000012 	bne	7001de70 <posix_sem_delete+0xcc>
        {
            /* delete this mq */
            if (psem->next != RT_NULL)
7001de24:	e51b3010 	ldr	r3, [fp, #-16]
7001de28:	e5933008 	ldr	r3, [r3, #8]
7001de2c:	e3530000 	cmp	r3, #0
7001de30:	0a000004 	beq	7001de48 <posix_sem_delete+0xa4>
                iter->next = psem->next;
7001de34:	e51b3010 	ldr	r3, [fp, #-16]
7001de38:	e5932008 	ldr	r2, [r3, #8]
7001de3c:	e51b3008 	ldr	r3, [fp, #-8]
7001de40:	e5832008 	str	r2, [r3, #8]
7001de44:	ea000002 	b	7001de54 <posix_sem_delete+0xb0>
            else
                iter->next = RT_NULL;
7001de48:	e51b3008 	ldr	r3, [fp, #-8]
7001de4c:	e3a02000 	mov	r2, #0
7001de50:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_sem_delete(psem->sem);
7001de54:	e51b3010 	ldr	r3, [fp, #-16]
7001de58:	e5933004 	ldr	r3, [r3, #4]
7001de5c:	e1a00003 	mov	r0, r3
7001de60:	ebff8f83 	bl	70001c74 <rt_sem_delete>
            rt_free(psem);
7001de64:	e51b0010 	ldr	r0, [fp, #-16]
7001de68:	ebffab56 	bl	70008bc8 <rt_free>

            return ;
7001de6c:	ea000006 	b	7001de8c <posix_sem_delete+0xe8>
        rt_sem_delete(psem->sem);
        rt_free(psem);

        return;
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
7001de70:	e51b3008 	ldr	r3, [fp, #-8]
7001de74:	e5933008 	ldr	r3, [r3, #8]
7001de78:	e50b3008 	str	r3, [fp, #-8]
7001de7c:	e51b3008 	ldr	r3, [fp, #-8]
7001de80:	e5933008 	ldr	r3, [r3, #8]
7001de84:	e3530000 	cmp	r3, #0
7001de88:	1affffe0 	bne	7001de10 <posix_sem_delete+0x6c>
            rt_free(psem);

            return ;
        }
    }
}
7001de8c:	e24bd004 	sub	sp, fp, #4
7001de90:	e8bd8800 	pop	{fp, pc}

7001de94 <posix_sem_find>:

static sem_t *posix_sem_find(const char* name)
{
7001de94:	e92d4800 	push	{fp, lr}
7001de98:	e28db004 	add	fp, sp, #4
7001de9c:	e24dd010 	sub	sp, sp, #16
7001dea0:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
7001dea4:	e30a3a50 	movw	r3, #43600	; 0xaa50
7001dea8:	e3473002 	movt	r3, #28674	; 0x7002
7001deac:	e5933000 	ldr	r3, [r3]
7001deb0:	e50b3008 	str	r3, [fp, #-8]
7001deb4:	ea00000f 	b	7001def8 <posix_sem_find+0x64>
    {
        object = (rt_object_t)&(iter->sem);
7001deb8:	e51b3008 	ldr	r3, [fp, #-8]
7001debc:	e2833004 	add	r3, r3, #4
7001dec0:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
7001dec4:	e51b300c 	ldr	r3, [fp, #-12]
7001dec8:	e1a00003 	mov	r0, r3
7001decc:	e51b1010 	ldr	r1, [fp, #-16]
7001ded0:	e3a02006 	mov	r2, #6
7001ded4:	fa00192e 	blx	70024394 <strncmp>
7001ded8:	e1a03000 	mov	r3, r0
7001dedc:	e3530000 	cmp	r3, #0
7001dee0:	1a000001 	bne	7001deec <posix_sem_find+0x58>
        {
            return iter;
7001dee4:	e51b3008 	ldr	r3, [fp, #-8]
7001dee8:	ea000006 	b	7001df08 <posix_sem_find+0x74>
static sem_t *posix_sem_find(const char* name)
{
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
7001deec:	e51b3008 	ldr	r3, [fp, #-8]
7001def0:	e5933008 	ldr	r3, [r3, #8]
7001def4:	e50b3008 	str	r3, [fp, #-8]
7001def8:	e51b3008 	ldr	r3, [fp, #-8]
7001defc:	e3530000 	cmp	r3, #0
7001df00:	1affffec 	bne	7001deb8 <posix_sem_find+0x24>
        {
            return iter;
        }
    }
    
    return RT_NULL;
7001df04:	e3a03000 	mov	r3, #0
}
7001df08:	e1a00003 	mov	r0, r3
7001df0c:	e24bd004 	sub	sp, fp, #4
7001df10:	e8bd8800 	pop	{fp, pc}

7001df14 <sem_close>:

int sem_close(sem_t *sem)
{
7001df14:	e92d4800 	push	{fp, lr}
7001df18:	e28db004 	add	fp, sp, #4
7001df1c:	e24dd008 	sub	sp, sp, #8
7001df20:	e50b0008 	str	r0, [fp, #-8]
    if (sem == RT_NULL)
7001df24:	e51b3008 	ldr	r3, [fp, #-8]
7001df28:	e3530000 	cmp	r3, #0
7001df2c:	1a000003 	bne	7001df40 <sem_close+0x2c>
    {
        rt_set_errno(EINVAL);
7001df30:	e3a00016 	mov	r0, #22
7001df34:	ebffa001 	bl	70005f40 <rt_set_errno>

        return -1;
7001df38:	e3e03000 	mvn	r3, #0
7001df3c:	ea000019 	b	7001dfa8 <sem_close+0x94>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
7001df40:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001df44:	e3470002 	movt	r0, #28674	; 0x7002
7001df48:	e3e01000 	mvn	r1, #0
7001df4c:	ebff8fa3 	bl	70001de0 <rt_sem_take>
    sem->refcount --;
7001df50:	e51b3008 	ldr	r3, [fp, #-8]
7001df54:	e1d330b0 	ldrh	r3, [r3]
7001df58:	e2433001 	sub	r3, r3, #1
7001df5c:	e6ff2073 	uxth	r2, r3
7001df60:	e51b3008 	ldr	r3, [fp, #-8]
7001df64:	e1c320b0 	strh	r2, [r3]
    if (sem->refcount == 0)
7001df68:	e51b3008 	ldr	r3, [fp, #-8]
7001df6c:	e1d330b0 	ldrh	r3, [r3]
7001df70:	e3530000 	cmp	r3, #0
7001df74:	1a000007 	bne	7001df98 <sem_close+0x84>
    {
        /* delete from posix semaphore list */
        if (sem->unlinked)
7001df78:	e51b3008 	ldr	r3, [fp, #-8]
7001df7c:	e5d33002 	ldrb	r3, [r3, #2]
7001df80:	e3530000 	cmp	r3, #0
7001df84:	0a000001 	beq	7001df90 <sem_close+0x7c>
            posix_sem_delete(sem);
7001df88:	e51b0008 	ldr	r0, [fp, #-8]
7001df8c:	ebffff84 	bl	7001dda4 <posix_sem_delete>
        sem = RT_NULL;
7001df90:	e3a03000 	mov	r3, #0
7001df94:	e50b3008 	str	r3, [fp, #-8]
    }
    rt_sem_release(&posix_sem_lock);
7001df98:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001df9c:	e3470002 	movt	r0, #28674	; 0x7002
7001dfa0:	ebff906a 	bl	70002150 <rt_sem_release>

    return 0;
7001dfa4:	e3a03000 	mov	r3, #0
}
7001dfa8:	e1a00003 	mov	r0, r3
7001dfac:	e24bd004 	sub	sp, fp, #4
7001dfb0:	e8bd8800 	pop	{fp, pc}

7001dfb4 <sem_destroy>:
RTM_EXPORT(sem_close);

int sem_destroy(sem_t *sem)
{
7001dfb4:	e92d4800 	push	{fp, lr}
7001dfb8:	e28db004 	add	fp, sp, #4
7001dfbc:	e24dd010 	sub	sp, sp, #16
7001dfc0:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if ((!sem) || !(sem->unamed))
7001dfc4:	e51b3010 	ldr	r3, [fp, #-16]
7001dfc8:	e3530000 	cmp	r3, #0
7001dfcc:	0a000003 	beq	7001dfe0 <sem_destroy+0x2c>
7001dfd0:	e51b3010 	ldr	r3, [fp, #-16]
7001dfd4:	e5d33003 	ldrb	r3, [r3, #3]
7001dfd8:	e3530000 	cmp	r3, #0
7001dfdc:	1a000003 	bne	7001dff0 <sem_destroy+0x3c>
    {
        rt_set_errno(EINVAL);
7001dfe0:	e3a00016 	mov	r0, #22
7001dfe4:	ebff9fd5 	bl	70005f40 <rt_set_errno>

        return -1;
7001dfe8:	e3e03000 	mvn	r3, #0
7001dfec:	ea000018 	b	7001e054 <sem_destroy+0xa0>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
7001dff0:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001dff4:	e3470002 	movt	r0, #28674	; 0x7002
7001dff8:	e3e01000 	mvn	r1, #0
7001dffc:	ebff8f77 	bl	70001de0 <rt_sem_take>
    result = rt_sem_trytake(sem->sem);
7001e000:	e51b3010 	ldr	r3, [fp, #-16]
7001e004:	e5933004 	ldr	r3, [r3, #4]
7001e008:	e1a00003 	mov	r0, r3
7001e00c:	ebff9044 	bl	70002124 <rt_sem_trytake>
7001e010:	e50b0008 	str	r0, [fp, #-8]
    if (result != RT_EOK)
7001e014:	e51b3008 	ldr	r3, [fp, #-8]
7001e018:	e3530000 	cmp	r3, #0
7001e01c:	0a000006 	beq	7001e03c <sem_destroy+0x88>
    {
        rt_sem_release(&posix_sem_lock);
7001e020:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e024:	e3470002 	movt	r0, #28674	; 0x7002
7001e028:	ebff9048 	bl	70002150 <rt_sem_release>
        rt_set_errno(EBUSY);
7001e02c:	e3a00010 	mov	r0, #16
7001e030:	ebff9fc2 	bl	70005f40 <rt_set_errno>

        return -1;
7001e034:	e3e03000 	mvn	r3, #0
7001e038:	ea000005 	b	7001e054 <sem_destroy+0xa0>
    }

    /* destroy an unamed posix semaphore */
    posix_sem_delete(sem);
7001e03c:	e51b0010 	ldr	r0, [fp, #-16]
7001e040:	ebffff57 	bl	7001dda4 <posix_sem_delete>
    rt_sem_release(&posix_sem_lock);
7001e044:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e048:	e3470002 	movt	r0, #28674	; 0x7002
7001e04c:	ebff903f 	bl	70002150 <rt_sem_release>

    return 0;
7001e050:	e3a03000 	mov	r3, #0
}
7001e054:	e1a00003 	mov	r0, r3
7001e058:	e24bd004 	sub	sp, fp, #4
7001e05c:	e8bd8800 	pop	{fp, pc}

7001e060 <sem_unlink>:
RTM_EXPORT(sem_destroy);

int sem_unlink(const char *name)
{
7001e060:	e92d4800 	push	{fp, lr}
7001e064:	e28db004 	add	fp, sp, #4
7001e068:	e24dd010 	sub	sp, sp, #16
7001e06c:	e50b0010 	str	r0, [fp, #-16]
    sem_t *psem;

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
7001e070:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e074:	e3470002 	movt	r0, #28674	; 0x7002
7001e078:	e3e01000 	mvn	r1, #0
7001e07c:	ebff8f57 	bl	70001de0 <rt_sem_take>
    psem = posix_sem_find(name);
7001e080:	e51b0010 	ldr	r0, [fp, #-16]
7001e084:	ebffff82 	bl	7001de94 <posix_sem_find>
7001e088:	e50b0008 	str	r0, [fp, #-8]
    if (psem != RT_NULL)
7001e08c:	e51b3008 	ldr	r3, [fp, #-8]
7001e090:	e3530000 	cmp	r3, #0
7001e094:	0a00000d 	beq	7001e0d0 <sem_unlink+0x70>
    {
        psem->unlinked = 1;
7001e098:	e51b3008 	ldr	r3, [fp, #-8]
7001e09c:	e3a02001 	mov	r2, #1
7001e0a0:	e5c32002 	strb	r2, [r3, #2]
        if (psem->refcount == 0)
7001e0a4:	e51b3008 	ldr	r3, [fp, #-8]
7001e0a8:	e1d330b0 	ldrh	r3, [r3]
7001e0ac:	e3530000 	cmp	r3, #0
7001e0b0:	1a000001 	bne	7001e0bc <sem_unlink+0x5c>
        {
            /* remove this semaphore */
            posix_sem_delete(psem);
7001e0b4:	e51b0008 	ldr	r0, [fp, #-8]
7001e0b8:	ebffff39 	bl	7001dda4 <posix_sem_delete>
        }
        rt_sem_release(&posix_sem_lock);
7001e0bc:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e0c0:	e3470002 	movt	r0, #28674	; 0x7002
7001e0c4:	ebff9021 	bl	70002150 <rt_sem_release>

        return 0;
7001e0c8:	e3a03000 	mov	r3, #0
7001e0cc:	ea000005 	b	7001e0e8 <sem_unlink+0x88>
    }
    rt_sem_release(&posix_sem_lock);
7001e0d0:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e0d4:	e3470002 	movt	r0, #28674	; 0x7002
7001e0d8:	ebff901c 	bl	70002150 <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
7001e0dc:	e3a00002 	mov	r0, #2
7001e0e0:	ebff9f96 	bl	70005f40 <rt_set_errno>

    return -1;
7001e0e4:	e3e03000 	mvn	r3, #0
}
7001e0e8:	e1a00003 	mov	r0, r3
7001e0ec:	e24bd004 	sub	sp, fp, #4
7001e0f0:	e8bd8800 	pop	{fp, pc}

7001e0f4 <sem_getvalue>:
RTM_EXPORT(sem_unlink);

int sem_getvalue(sem_t *sem, int *sval)
{
7001e0f4:	e92d4800 	push	{fp, lr}
7001e0f8:	e28db004 	add	fp, sp, #4
7001e0fc:	e24dd008 	sub	sp, sp, #8
7001e100:	e50b0008 	str	r0, [fp, #-8]
7001e104:	e50b100c 	str	r1, [fp, #-12]
    if (!sem || !sval)
7001e108:	e51b3008 	ldr	r3, [fp, #-8]
7001e10c:	e3530000 	cmp	r3, #0
7001e110:	0a000002 	beq	7001e120 <sem_getvalue+0x2c>
7001e114:	e51b300c 	ldr	r3, [fp, #-12]
7001e118:	e3530000 	cmp	r3, #0
7001e11c:	1a000003 	bne	7001e130 <sem_getvalue+0x3c>
    {
        rt_set_errno(EINVAL);
7001e120:	e3a00016 	mov	r0, #22
7001e124:	ebff9f85 	bl	70005f40 <rt_set_errno>

        return -1;
7001e128:	e3e03000 	mvn	r3, #0
7001e12c:	ea000006 	b	7001e14c <sem_getvalue+0x58>
    }
    *sval = sem->sem->value;
7001e130:	e51b3008 	ldr	r3, [fp, #-8]
7001e134:	e5933004 	ldr	r3, [r3, #4]
7001e138:	e1d331b8 	ldrh	r3, [r3, #24]
7001e13c:	e1a02003 	mov	r2, r3
7001e140:	e51b300c 	ldr	r3, [fp, #-12]
7001e144:	e5832000 	str	r2, [r3]

    return 0;
7001e148:	e3a03000 	mov	r3, #0
}
7001e14c:	e1a00003 	mov	r0, r3
7001e150:	e24bd004 	sub	sp, fp, #4
7001e154:	e8bd8800 	pop	{fp, pc}

7001e158 <sem_init>:
RTM_EXPORT(sem_getvalue);

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
7001e158:	e92d4800 	push	{fp, lr}
7001e15c:	e28db004 	add	fp, sp, #4
7001e160:	e24dd018 	sub	sp, sp, #24
7001e164:	e50b0010 	str	r0, [fp, #-16]
7001e168:	e50b1014 	str	r1, [fp, #-20]
7001e16c:	e50b2018 	str	r2, [fp, #-24]
    char name[RT_NAME_MAX];
    static rt_uint16_t psem_number = 0;

    if (sem == RT_NULL)
7001e170:	e51b3010 	ldr	r3, [fp, #-16]
7001e174:	e3530000 	cmp	r3, #0
7001e178:	1a000003 	bne	7001e18c <sem_init+0x34>
    {
        rt_set_errno(EINVAL);
7001e17c:	e3a00016 	mov	r0, #22
7001e180:	ebff9f6e 	bl	70005f40 <rt_set_errno>

        return -1;
7001e184:	e3e03000 	mvn	r3, #0
7001e188:	ea000031 	b	7001e254 <sem_init+0xfc>
    }

    rt_snprintf(name, sizeof(name), "psem%02d", psem_number++);
7001e18c:	e30a3a70 	movw	r3, #43632	; 0xaa70
7001e190:	e3473002 	movt	r3, #28674	; 0x7002
7001e194:	e1d330b0 	ldrh	r3, [r3]
7001e198:	e1a02003 	mov	r2, r3
7001e19c:	e2823001 	add	r3, r2, #1
7001e1a0:	e6ff1073 	uxth	r1, r3
7001e1a4:	e30a3a70 	movw	r3, #43632	; 0xaa70
7001e1a8:	e3473002 	movt	r3, #28674	; 0x7002
7001e1ac:	e1c310b0 	strh	r1, [r3]
7001e1b0:	e1a03002 	mov	r3, r2
7001e1b4:	e24b200c 	sub	r2, fp, #12
7001e1b8:	e1a00002 	mov	r0, r2
7001e1bc:	e3a01006 	mov	r1, #6
7001e1c0:	e30825d8 	movw	r2, #34264	; 0x85d8
7001e1c4:	e3472002 	movt	r2, #28674	; 0x7002
7001e1c8:	ebffa51e 	bl	70007648 <rt_snprintf>
    sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
7001e1cc:	e24b300c 	sub	r3, fp, #12
7001e1d0:	e1a00003 	mov	r0, r3
7001e1d4:	e51b1018 	ldr	r1, [fp, #-24]
7001e1d8:	e3a02000 	mov	r2, #0
7001e1dc:	ebff8e5b 	bl	70001b50 <rt_sem_create>
7001e1e0:	e1a02000 	mov	r2, r0
7001e1e4:	e51b3010 	ldr	r3, [fp, #-16]
7001e1e8:	e5832004 	str	r2, [r3, #4]
    if (sem == RT_NULL)
7001e1ec:	e51b3010 	ldr	r3, [fp, #-16]
7001e1f0:	e3530000 	cmp	r3, #0
7001e1f4:	1a000003 	bne	7001e208 <sem_init+0xb0>
    {
        rt_set_errno(ENOMEM);
7001e1f8:	e3a0000c 	mov	r0, #12
7001e1fc:	ebff9f4f 	bl	70005f40 <rt_set_errno>

        return -1;
7001e200:	e3e03000 	mvn	r3, #0
7001e204:	ea000012 	b	7001e254 <sem_init+0xfc>
    }

    /* initialize posix semaphore */
    sem->refcount = 1;
7001e208:	e51b3010 	ldr	r3, [fp, #-16]
7001e20c:	e3a02001 	mov	r2, #1
7001e210:	e1c320b0 	strh	r2, [r3]
    sem->unlinked = 0;
7001e214:	e51b3010 	ldr	r3, [fp, #-16]
7001e218:	e3a02000 	mov	r2, #0
7001e21c:	e5c32002 	strb	r2, [r3, #2]
    sem->unamed = 1;
7001e220:	e51b3010 	ldr	r3, [fp, #-16]
7001e224:	e3a02001 	mov	r2, #1
7001e228:	e5c32003 	strb	r2, [r3, #3]
    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
7001e22c:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e230:	e3470002 	movt	r0, #28674	; 0x7002
7001e234:	e3e01000 	mvn	r1, #0
7001e238:	ebff8ee8 	bl	70001de0 <rt_sem_take>
    posix_sem_insert(sem);
7001e23c:	e51b0010 	ldr	r0, [fp, #-16]
7001e240:	ebfffec7 	bl	7001dd64 <posix_sem_insert>
    rt_sem_release(&posix_sem_lock);
7001e244:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e248:	e3470002 	movt	r0, #28674	; 0x7002
7001e24c:	ebff8fbf 	bl	70002150 <rt_sem_release>

    return 0;
7001e250:	e3a03000 	mov	r3, #0
}
7001e254:	e1a00003 	mov	r0, r3
7001e258:	e24bd004 	sub	sp, fp, #4
7001e25c:	e8bd8800 	pop	{fp, pc}

7001e260 <sem_open>:
RTM_EXPORT(sem_init);

sem_t *sem_open(const char *name, int oflag, ...)
{
7001e260:	e92d000e 	push	{r1, r2, r3}
7001e264:	e92d4800 	push	{fp, lr}
7001e268:	e28db004 	add	fp, sp, #4
7001e26c:	e24dd01c 	sub	sp, sp, #28
7001e270:	e50b001c 	str	r0, [fp, #-28]
    sem_t* sem;
    va_list arg;
    mode_t mode;
    unsigned int value;

    sem = RT_NULL;
7001e274:	e3a03000 	mov	r3, #0
7001e278:	e50b300c 	str	r3, [fp, #-12]

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
7001e27c:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e280:	e3470002 	movt	r0, #28674	; 0x7002
7001e284:	e3e01000 	mvn	r1, #0
7001e288:	ebff8ed4 	bl	70001de0 <rt_sem_take>
    if (oflag & O_CREAT)
7001e28c:	e59b3004 	ldr	r3, [fp, #4]
7001e290:	e2033c01 	and	r3, r3, #256	; 0x100
7001e294:	e3530000 	cmp	r3, #0
7001e298:	0a00003a 	beq	7001e388 <sem_open+0x128>
    {
        va_start(arg, oflag);
7001e29c:	e28b3008 	add	r3, fp, #8
7001e2a0:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t) va_arg( arg, unsigned int); mode = mode;
7001e2a4:	e51b3018 	ldr	r3, [fp, #-24]
7001e2a8:	e2832004 	add	r2, r3, #4
7001e2ac:	e50b2018 	str	r2, [fp, #-24]
7001e2b0:	e5933000 	ldr	r3, [r3]
7001e2b4:	e50b3010 	str	r3, [fp, #-16]
        value = va_arg( arg, unsigned int);
7001e2b8:	e51b3018 	ldr	r3, [fp, #-24]
7001e2bc:	e2832004 	add	r2, r3, #4
7001e2c0:	e50b2018 	str	r2, [fp, #-24]
7001e2c4:	e5933000 	ldr	r3, [r3]
7001e2c8:	e50b3014 	str	r3, [fp, #-20]
        va_end(arg);

        if (oflag & O_EXCL)
7001e2cc:	e59b3004 	ldr	r3, [fp, #4]
7001e2d0:	e2033c02 	and	r3, r3, #512	; 0x200
7001e2d4:	e3530000 	cmp	r3, #0
7001e2d8:	0a000007 	beq	7001e2fc <sem_open+0x9c>
        {
            if (posix_sem_find(name) != RT_NULL)
7001e2dc:	e51b001c 	ldr	r0, [fp, #-28]
7001e2e0:	ebfffeeb 	bl	7001de94 <posix_sem_find>
7001e2e4:	e1a03000 	mov	r3, r0
7001e2e8:	e3530000 	cmp	r3, #0
7001e2ec:	0a000002 	beq	7001e2fc <sem_open+0x9c>
            {
                rt_set_errno(EEXIST);
7001e2f0:	e3a00011 	mov	r0, #17
7001e2f4:	ebff9f11 	bl	70005f40 <rt_set_errno>
                goto __return;
7001e2f8:	ea000037 	b	7001e3dc <sem_open+0x17c>
            }
        }
        sem = (sem_t*) rt_malloc (sizeof(struct posix_sem));
7001e2fc:	e3a0000c 	mov	r0, #12
7001e300:	ebffa76d 	bl	700080bc <rt_malloc>
7001e304:	e50b000c 	str	r0, [fp, #-12]
        if (sem == RT_NULL)
7001e308:	e51b300c 	ldr	r3, [fp, #-12]
7001e30c:	e3530000 	cmp	r3, #0
7001e310:	1a000002 	bne	7001e320 <sem_open+0xc0>
        {
            rt_set_errno(ENFILE);
7001e314:	e3a00017 	mov	r0, #23
7001e318:	ebff9f08 	bl	70005f40 <rt_set_errno>
            goto __return;
7001e31c:	ea00002e 	b	7001e3dc <sem_open+0x17c>
        }

        /* create RT-Thread semaphore */
        sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
7001e320:	e51b001c 	ldr	r0, [fp, #-28]
7001e324:	e51b1014 	ldr	r1, [fp, #-20]
7001e328:	e3a02000 	mov	r2, #0
7001e32c:	ebff8e07 	bl	70001b50 <rt_sem_create>
7001e330:	e1a02000 	mov	r2, r0
7001e334:	e51b300c 	ldr	r3, [fp, #-12]
7001e338:	e5832004 	str	r2, [r3, #4]
        if (sem->sem == RT_NULL) /* create failed */
7001e33c:	e51b300c 	ldr	r3, [fp, #-12]
7001e340:	e5933004 	ldr	r3, [r3, #4]
7001e344:	e3530000 	cmp	r3, #0
7001e348:	1a000002 	bne	7001e358 <sem_open+0xf8>
        {
            rt_set_errno(ENFILE);
7001e34c:	e3a00017 	mov	r0, #23
7001e350:	ebff9efa 	bl	70005f40 <rt_set_errno>
            goto __return;
7001e354:	ea000020 	b	7001e3dc <sem_open+0x17c>
        }
        /* initialize reference count */
        sem->refcount = 1;
7001e358:	e51b300c 	ldr	r3, [fp, #-12]
7001e35c:	e3a02001 	mov	r2, #1
7001e360:	e1c320b0 	strh	r2, [r3]
        sem->unlinked = 0;
7001e364:	e51b300c 	ldr	r3, [fp, #-12]
7001e368:	e3a02000 	mov	r2, #0
7001e36c:	e5c32002 	strb	r2, [r3, #2]
        sem->unamed = 0;
7001e370:	e51b300c 	ldr	r3, [fp, #-12]
7001e374:	e3a02000 	mov	r2, #0
7001e378:	e5c32003 	strb	r2, [r3, #3]

        /* insert semaphore to posix semaphore list */
        posix_sem_insert(sem);
7001e37c:	e51b000c 	ldr	r0, [fp, #-12]
7001e380:	ebfffe77 	bl	7001dd64 <posix_sem_insert>
7001e384:	ea00000f 	b	7001e3c8 <sem_open+0x168>
    }
    else
    {
        /* find semaphore */
        sem = posix_sem_find(name);
7001e388:	e51b001c 	ldr	r0, [fp, #-28]
7001e38c:	ebfffec0 	bl	7001de94 <posix_sem_find>
7001e390:	e50b000c 	str	r0, [fp, #-12]
        if (sem != RT_NULL)
7001e394:	e51b300c 	ldr	r3, [fp, #-12]
7001e398:	e3530000 	cmp	r3, #0
7001e39c:	0a000006 	beq	7001e3bc <sem_open+0x15c>
        {
            sem->refcount ++; /* increase reference count */
7001e3a0:	e51b300c 	ldr	r3, [fp, #-12]
7001e3a4:	e1d330b0 	ldrh	r3, [r3]
7001e3a8:	e2833001 	add	r3, r3, #1
7001e3ac:	e6ff2073 	uxth	r2, r3
7001e3b0:	e51b300c 	ldr	r3, [fp, #-12]
7001e3b4:	e1c320b0 	strh	r2, [r3]
7001e3b8:	ea000002 	b	7001e3c8 <sem_open+0x168>
        }
        else
        {
            rt_set_errno(ENOENT);
7001e3bc:	e3a00002 	mov	r0, #2
7001e3c0:	ebff9ede 	bl	70005f40 <rt_set_errno>
            goto __return;
7001e3c4:	ea000004 	b	7001e3dc <sem_open+0x17c>
        }
    }
    rt_sem_release(&posix_sem_lock);
7001e3c8:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e3cc:	e3470002 	movt	r0, #28674	; 0x7002
7001e3d0:	ebff8f5e 	bl	70002150 <rt_sem_release>

    return sem;
7001e3d4:	e51b300c 	ldr	r3, [fp, #-12]
7001e3d8:	ea000010 	b	7001e420 <sem_open+0x1c0>

__return:
    /* release lock */
    rt_sem_release(&posix_sem_lock);
7001e3dc:	e30a0a54 	movw	r0, #43604	; 0xaa54
7001e3e0:	e3470002 	movt	r0, #28674	; 0x7002
7001e3e4:	ebff8f59 	bl	70002150 <rt_sem_release>

    /* release allocated memory */
    if (sem != RT_NULL)
7001e3e8:	e51b300c 	ldr	r3, [fp, #-12]
7001e3ec:	e3530000 	cmp	r3, #0
7001e3f0:	0a000009 	beq	7001e41c <sem_open+0x1bc>
    {
        /* delete RT-Thread semaphore */
        if (sem->sem != RT_NULL)
7001e3f4:	e51b300c 	ldr	r3, [fp, #-12]
7001e3f8:	e5933004 	ldr	r3, [r3, #4]
7001e3fc:	e3530000 	cmp	r3, #0
7001e400:	0a000003 	beq	7001e414 <sem_open+0x1b4>
            rt_sem_delete(sem->sem);
7001e404:	e51b300c 	ldr	r3, [fp, #-12]
7001e408:	e5933004 	ldr	r3, [r3, #4]
7001e40c:	e1a00003 	mov	r0, r3
7001e410:	ebff8e17 	bl	70001c74 <rt_sem_delete>
        rt_free(sem);
7001e414:	e51b000c 	ldr	r0, [fp, #-12]
7001e418:	ebffa9ea 	bl	70008bc8 <rt_free>
    }

    return RT_NULL;
7001e41c:	e3a03000 	mov	r3, #0
}
7001e420:	e1a00003 	mov	r0, r3
7001e424:	e24bd004 	sub	sp, fp, #4
7001e428:	e8bd4800 	pop	{fp, lr}
7001e42c:	e28dd00c 	add	sp, sp, #12
7001e430:	e12fff1e 	bx	lr

7001e434 <sem_post>:
RTM_EXPORT(sem_open);

int sem_post(sem_t *sem)
{
7001e434:	e92d4800 	push	{fp, lr}
7001e438:	e28db004 	add	fp, sp, #4
7001e43c:	e24dd010 	sub	sp, sp, #16
7001e440:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
7001e444:	e51b3010 	ldr	r3, [fp, #-16]
7001e448:	e3530000 	cmp	r3, #0
7001e44c:	1a000003 	bne	7001e460 <sem_post+0x2c>
    {
        rt_set_errno(EINVAL);
7001e450:	e3a00016 	mov	r0, #22
7001e454:	ebff9eb9 	bl	70005f40 <rt_set_errno>

        return -1;
7001e458:	e3e03000 	mvn	r3, #0
7001e45c:	ea00000c 	b	7001e494 <sem_post+0x60>
    }

    result = rt_sem_release(sem->sem);
7001e460:	e51b3010 	ldr	r3, [fp, #-16]
7001e464:	e5933004 	ldr	r3, [r3, #4]
7001e468:	e1a00003 	mov	r0, r3
7001e46c:	ebff8f37 	bl	70002150 <rt_sem_release>
7001e470:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
7001e474:	e51b3008 	ldr	r3, [fp, #-8]
7001e478:	e3530000 	cmp	r3, #0
7001e47c:	1a000001 	bne	7001e488 <sem_post+0x54>
        return 0;
7001e480:	e3a03000 	mov	r3, #0
7001e484:	ea000002 	b	7001e494 <sem_post+0x60>

    rt_set_errno(EINVAL);
7001e488:	e3a00016 	mov	r0, #22
7001e48c:	ebff9eab 	bl	70005f40 <rt_set_errno>

    return -1;
7001e490:	e3e03000 	mvn	r3, #0
}
7001e494:	e1a00003 	mov	r0, r3
7001e498:	e24bd004 	sub	sp, fp, #4
7001e49c:	e8bd8800 	pop	{fp, pc}

7001e4a0 <sem_timedwait>:
RTM_EXPORT(sem_post);

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout)
{
7001e4a0:	e92d4800 	push	{fp, lr}
7001e4a4:	e28db004 	add	fp, sp, #4
7001e4a8:	e24dd010 	sub	sp, sp, #16
7001e4ac:	e50b0010 	str	r0, [fp, #-16]
7001e4b0:	e50b1014 	str	r1, [fp, #-20]
    rt_err_t result;
    rt_int32_t tick;

    if (!sem || !abs_timeout)
7001e4b4:	e51b3010 	ldr	r3, [fp, #-16]
7001e4b8:	e3530000 	cmp	r3, #0
7001e4bc:	0a000002 	beq	7001e4cc <sem_timedwait+0x2c>
7001e4c0:	e51b3014 	ldr	r3, [fp, #-20]
7001e4c4:	e3530000 	cmp	r3, #0
7001e4c8:	1a000001 	bne	7001e4d4 <sem_timedwait+0x34>
        return EINVAL;
7001e4cc:	e3a03016 	mov	r3, #22
7001e4d0:	ea000017 	b	7001e534 <sem_timedwait+0x94>

    /* calculate os tick */
    tick = clock_time_to_tick(abs_timeout);
7001e4d4:	e51b0014 	ldr	r0, [fp, #-20]
7001e4d8:	ebfff262 	bl	7001ae68 <clock_time_to_tick>
7001e4dc:	e50b0008 	str	r0, [fp, #-8]
    
    result = rt_sem_take(sem->sem, tick);
7001e4e0:	e51b3010 	ldr	r3, [fp, #-16]
7001e4e4:	e5933004 	ldr	r3, [r3, #4]
7001e4e8:	e1a00003 	mov	r0, r3
7001e4ec:	e51b1008 	ldr	r1, [fp, #-8]
7001e4f0:	ebff8e3a 	bl	70001de0 <rt_sem_take>
7001e4f4:	e50b000c 	str	r0, [fp, #-12]
    if (result == -RT_ETIMEOUT)
7001e4f8:	e51b300c 	ldr	r3, [fp, #-12]
7001e4fc:	e3730002 	cmn	r3, #2
7001e500:	1a000003 	bne	7001e514 <sem_timedwait+0x74>
    {
        rt_set_errno(ETIMEDOUT);
7001e504:	e3a00074 	mov	r0, #116	; 0x74
7001e508:	ebff9e8c 	bl	70005f40 <rt_set_errno>

        return -1;
7001e50c:	e3e03000 	mvn	r3, #0
7001e510:	ea000007 	b	7001e534 <sem_timedwait+0x94>
    }
    if (result == RT_EOK)
7001e514:	e51b300c 	ldr	r3, [fp, #-12]
7001e518:	e3530000 	cmp	r3, #0
7001e51c:	1a000001 	bne	7001e528 <sem_timedwait+0x88>
        return 0;
7001e520:	e3a03000 	mov	r3, #0
7001e524:	ea000002 	b	7001e534 <sem_timedwait+0x94>

    rt_set_errno(EINTR);
7001e528:	e3a00004 	mov	r0, #4
7001e52c:	ebff9e83 	bl	70005f40 <rt_set_errno>

    return -1;
7001e530:	e3e03000 	mvn	r3, #0
}
7001e534:	e1a00003 	mov	r0, r3
7001e538:	e24bd004 	sub	sp, fp, #4
7001e53c:	e8bd8800 	pop	{fp, pc}

7001e540 <sem_trywait>:
RTM_EXPORT(sem_timedwait);

int sem_trywait(sem_t *sem)
{
7001e540:	e92d4800 	push	{fp, lr}
7001e544:	e28db004 	add	fp, sp, #4
7001e548:	e24dd010 	sub	sp, sp, #16
7001e54c:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
7001e550:	e51b3010 	ldr	r3, [fp, #-16]
7001e554:	e3530000 	cmp	r3, #0
7001e558:	1a000003 	bne	7001e56c <sem_trywait+0x2c>
    {
        rt_set_errno(EINVAL);
7001e55c:	e3a00016 	mov	r0, #22
7001e560:	ebff9e76 	bl	70005f40 <rt_set_errno>

        return -1;
7001e564:	e3e03000 	mvn	r3, #0
7001e568:	ea000014 	b	7001e5c0 <sem_trywait+0x80>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
7001e56c:	e51b3010 	ldr	r3, [fp, #-16]
7001e570:	e5933004 	ldr	r3, [r3, #4]
7001e574:	e1a00003 	mov	r0, r3
7001e578:	e3e01000 	mvn	r1, #0
7001e57c:	ebff8e17 	bl	70001de0 <rt_sem_take>
7001e580:	e50b0008 	str	r0, [fp, #-8]
    if (result == -RT_ETIMEOUT)
7001e584:	e51b3008 	ldr	r3, [fp, #-8]
7001e588:	e3730002 	cmn	r3, #2
7001e58c:	1a000003 	bne	7001e5a0 <sem_trywait+0x60>
    {
        rt_set_errno(EAGAIN);
7001e590:	e3a0000b 	mov	r0, #11
7001e594:	ebff9e69 	bl	70005f40 <rt_set_errno>

        return -1;
7001e598:	e3e03000 	mvn	r3, #0
7001e59c:	ea000007 	b	7001e5c0 <sem_trywait+0x80>
    }
    if (result == RT_EOK)
7001e5a0:	e51b3008 	ldr	r3, [fp, #-8]
7001e5a4:	e3530000 	cmp	r3, #0
7001e5a8:	1a000001 	bne	7001e5b4 <sem_trywait+0x74>
        return 0;
7001e5ac:	e3a03000 	mov	r3, #0
7001e5b0:	ea000002 	b	7001e5c0 <sem_trywait+0x80>

    rt_set_errno(EINTR);
7001e5b4:	e3a00004 	mov	r0, #4
7001e5b8:	ebff9e60 	bl	70005f40 <rt_set_errno>

    return -1;
7001e5bc:	e3e03000 	mvn	r3, #0
}
7001e5c0:	e1a00003 	mov	r0, r3
7001e5c4:	e24bd004 	sub	sp, fp, #4
7001e5c8:	e8bd8800 	pop	{fp, pc}

7001e5cc <sem_wait>:
RTM_EXPORT(sem_trywait);

int sem_wait(sem_t *sem)
{
7001e5cc:	e92d4800 	push	{fp, lr}
7001e5d0:	e28db004 	add	fp, sp, #4
7001e5d4:	e24dd010 	sub	sp, sp, #16
7001e5d8:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
7001e5dc:	e51b3010 	ldr	r3, [fp, #-16]
7001e5e0:	e3530000 	cmp	r3, #0
7001e5e4:	1a000003 	bne	7001e5f8 <sem_wait+0x2c>
    {
        rt_set_errno(EINVAL);
7001e5e8:	e3a00016 	mov	r0, #22
7001e5ec:	ebff9e53 	bl	70005f40 <rt_set_errno>

        return -1;
7001e5f0:	e3e03000 	mvn	r3, #0
7001e5f4:	ea00000d 	b	7001e630 <sem_wait+0x64>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
7001e5f8:	e51b3010 	ldr	r3, [fp, #-16]
7001e5fc:	e5933004 	ldr	r3, [r3, #4]
7001e600:	e1a00003 	mov	r0, r3
7001e604:	e3e01000 	mvn	r1, #0
7001e608:	ebff8df4 	bl	70001de0 <rt_sem_take>
7001e60c:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
7001e610:	e51b3008 	ldr	r3, [fp, #-8]
7001e614:	e3530000 	cmp	r3, #0
7001e618:	1a000001 	bne	7001e624 <sem_wait+0x58>
        return 0;
7001e61c:	e3a03000 	mov	r3, #0
7001e620:	ea000002 	b	7001e630 <sem_wait+0x64>

    rt_set_errno(EINTR);
7001e624:	e3a00004 	mov	r0, #4
7001e628:	ebff9e44 	bl	70005f40 <rt_set_errno>

    return -1;
7001e62c:	e3e03000 	mvn	r3, #0
}
7001e630:	e1a00003 	mov	r0, r3
7001e634:	e24bd004 	sub	sp, fp, #4
7001e638:	e8bd8800 	pop	{fp, pc}

7001e63c <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
7001e63c:	e92d4800 	push	{fp, lr}
7001e640:	e28db004 	add	fp, sp, #4
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
7001e644:	e30805e4 	movw	r0, #34276	; 0x85e4
7001e648:	e3470002 	movt	r0, #28674	; 0x7002
7001e64c:	fa001667 	blx	70023ff0 <putenv>
    putenv("HOME=/home");
7001e650:	e30805f0 	movw	r0, #34288	; 0x85f0
7001e654:	e3470002 	movt	r0, #28674	; 0x7002
7001e658:	fa001664 	blx	70023ff0 <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
7001e65c:	ebfff566 	bl	7001bbfc <pthread_system_init>
#endif

    return 0;
7001e660:	e3a03000 	mov	r3, #0
}
7001e664:	e1a00003 	mov	r0, r3
7001e668:	e8bd8800 	pop	{fp, pc}

7001e66c <_close_r>:

/* Reentrant versions of system calls.  */

int
_close_r(struct _reent *ptr, int fd)
{
7001e66c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e670:	e28db000 	add	fp, sp, #0
7001e674:	e24dd00c 	sub	sp, sp, #12
7001e678:	e50b0008 	str	r0, [fp, #-8]
7001e67c:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
7001e680:	e3a03000 	mov	r3, #0
#else
	return close(fd);
#endif
}
7001e684:	e1a00003 	mov	r0, r3
7001e688:	e24bd000 	sub	sp, fp, #0
7001e68c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e690:	e12fff1e 	bx	lr

7001e694 <_execve_r>:

int
_execve_r(struct _reent *ptr, const char * name, char *const *argv, char *const *env)
{
7001e694:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e698:	e28db000 	add	fp, sp, #0
7001e69c:	e24dd014 	sub	sp, sp, #20
7001e6a0:	e50b0008 	str	r0, [fp, #-8]
7001e6a4:	e50b100c 	str	r1, [fp, #-12]
7001e6a8:	e50b2010 	str	r2, [fp, #-16]
7001e6ac:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e6b0:	e51b3008 	ldr	r3, [fp, #-8]
7001e6b4:	e3a02086 	mov	r2, #134	; 0x86
7001e6b8:	e5832000 	str	r2, [r3]
	return -1;
7001e6bc:	e3e03000 	mvn	r3, #0
}
7001e6c0:	e1a00003 	mov	r0, r3
7001e6c4:	e24bd000 	sub	sp, fp, #0
7001e6c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e6cc:	e12fff1e 	bx	lr

7001e6d0 <_fcntl_r>:

int
_fcntl_r(struct _reent *ptr, int fd, int cmd, int arg)
{
7001e6d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e6d4:	e28db000 	add	fp, sp, #0
7001e6d8:	e24dd014 	sub	sp, sp, #20
7001e6dc:	e50b0008 	str	r0, [fp, #-8]
7001e6e0:	e50b100c 	str	r1, [fp, #-12]
7001e6e4:	e50b2010 	str	r2, [fp, #-16]
7001e6e8:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e6ec:	e51b3008 	ldr	r3, [fp, #-8]
7001e6f0:	e3a02086 	mov	r2, #134	; 0x86
7001e6f4:	e5832000 	str	r2, [r3]
	return -1;
7001e6f8:	e3e03000 	mvn	r3, #0
}
7001e6fc:	e1a00003 	mov	r0, r3
7001e700:	e24bd000 	sub	sp, fp, #0
7001e704:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e708:	e12fff1e 	bx	lr

7001e70c <_fork_r>:

int
_fork_r(struct _reent *ptr)
{
7001e70c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e710:	e28db000 	add	fp, sp, #0
7001e714:	e24dd00c 	sub	sp, sp, #12
7001e718:	e50b0008 	str	r0, [fp, #-8]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e71c:	e51b3008 	ldr	r3, [fp, #-8]
7001e720:	e3a02086 	mov	r2, #134	; 0x86
7001e724:	e5832000 	str	r2, [r3]
	return -1;
7001e728:	e3e03000 	mvn	r3, #0
}
7001e72c:	e1a00003 	mov	r0, r3
7001e730:	e24bd000 	sub	sp, fp, #0
7001e734:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e738:	e12fff1e 	bx	lr

7001e73c <_fstat_r>:

int
_fstat_r(struct _reent *ptr, int fd, struct stat *pstat)
{
7001e73c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e740:	e28db000 	add	fp, sp, #0
7001e744:	e24dd014 	sub	sp, sp, #20
7001e748:	e50b0008 	str	r0, [fp, #-8]
7001e74c:	e50b100c 	str	r1, [fp, #-12]
7001e750:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e754:	e51b3008 	ldr	r3, [fp, #-8]
7001e758:	e3a02086 	mov	r2, #134	; 0x86
7001e75c:	e5832000 	str	r2, [r3]
	return -1;
7001e760:	e3e03000 	mvn	r3, #0
}
7001e764:	e1a00003 	mov	r0, r3
7001e768:	e24bd000 	sub	sp, fp, #0
7001e76c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e770:	e12fff1e 	bx	lr

7001e774 <_getpid_r>:

int
_getpid_r(struct _reent *ptr)
{
7001e774:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e778:	e28db000 	add	fp, sp, #0
7001e77c:	e24dd00c 	sub	sp, sp, #12
7001e780:	e50b0008 	str	r0, [fp, #-8]
	return 0;
7001e784:	e3a03000 	mov	r3, #0
}
7001e788:	e1a00003 	mov	r0, r3
7001e78c:	e24bd000 	sub	sp, fp, #0
7001e790:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e794:	e12fff1e 	bx	lr

7001e798 <_isatty_r>:

int
_isatty_r(struct _reent *ptr, int fd)
{
7001e798:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e79c:	e28db000 	add	fp, sp, #0
7001e7a0:	e24dd00c 	sub	sp, sp, #12
7001e7a4:	e50b0008 	str	r0, [fp, #-8]
7001e7a8:	e50b100c 	str	r1, [fp, #-12]
	if (fd >=0 && fd < 3) return 1;
7001e7ac:	e51b300c 	ldr	r3, [fp, #-12]
7001e7b0:	e3530000 	cmp	r3, #0
7001e7b4:	ba000004 	blt	7001e7cc <_isatty_r+0x34>
7001e7b8:	e51b300c 	ldr	r3, [fp, #-12]
7001e7bc:	e3530002 	cmp	r3, #2
7001e7c0:	ca000001 	bgt	7001e7cc <_isatty_r+0x34>
7001e7c4:	e3a03001 	mov	r3, #1
7001e7c8:	ea000003 	b	7001e7dc <_isatty_r+0x44>

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e7cc:	e51b3008 	ldr	r3, [fp, #-8]
7001e7d0:	e3a02086 	mov	r2, #134	; 0x86
7001e7d4:	e5832000 	str	r2, [r3]
	return -1;
7001e7d8:	e3e03000 	mvn	r3, #0
}
7001e7dc:	e1a00003 	mov	r0, r3
7001e7e0:	e24bd000 	sub	sp, fp, #0
7001e7e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e7e8:	e12fff1e 	bx	lr

7001e7ec <_kill_r>:

int
_kill_r(struct _reent *ptr, int pid, int sig)
{
7001e7ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e7f0:	e28db000 	add	fp, sp, #0
7001e7f4:	e24dd014 	sub	sp, sp, #20
7001e7f8:	e50b0008 	str	r0, [fp, #-8]
7001e7fc:	e50b100c 	str	r1, [fp, #-12]
7001e800:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e804:	e51b3008 	ldr	r3, [fp, #-8]
7001e808:	e3a02086 	mov	r2, #134	; 0x86
7001e80c:	e5832000 	str	r2, [r3]
	return -1;
7001e810:	e3e03000 	mvn	r3, #0
}
7001e814:	e1a00003 	mov	r0, r3
7001e818:	e24bd000 	sub	sp, fp, #0
7001e81c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e820:	e12fff1e 	bx	lr

7001e824 <_link_r>:

int
_link_r(struct _reent *ptr, const char *old, const char *new)
{
7001e824:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e828:	e28db000 	add	fp, sp, #0
7001e82c:	e24dd014 	sub	sp, sp, #20
7001e830:	e50b0008 	str	r0, [fp, #-8]
7001e834:	e50b100c 	str	r1, [fp, #-12]
7001e838:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e83c:	e51b3008 	ldr	r3, [fp, #-8]
7001e840:	e3a02086 	mov	r2, #134	; 0x86
7001e844:	e5832000 	str	r2, [r3]
	return -1;
7001e848:	e3e03000 	mvn	r3, #0
}
7001e84c:	e1a00003 	mov	r0, r3
7001e850:	e24bd000 	sub	sp, fp, #0
7001e854:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e858:	e12fff1e 	bx	lr

7001e85c <_lseek_r>:

_off_t
_lseek_r(struct _reent *ptr, int fd, _off_t pos, int whence)
{
7001e85c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e860:	e28db000 	add	fp, sp, #0
7001e864:	e24dd014 	sub	sp, sp, #20
7001e868:	e50b0008 	str	r0, [fp, #-8]
7001e86c:	e50b100c 	str	r1, [fp, #-12]
7001e870:	e50b2010 	str	r2, [fp, #-16]
7001e874:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
7001e878:	e3a03000 	mov	r3, #0
	_off_t rc;

	rc = lseek(fd, pos, whence);
	return rc;
#endif
}
7001e87c:	e1a00003 	mov	r0, r3
7001e880:	e24bd000 	sub	sp, fp, #0
7001e884:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e888:	e12fff1e 	bx	lr

7001e88c <_mkdir_r>:

int
_mkdir_r(struct _reent *ptr, const char *name, int mode)
{
7001e88c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e890:	e28db000 	add	fp, sp, #0
7001e894:	e24dd014 	sub	sp, sp, #20
7001e898:	e50b0008 	str	r0, [fp, #-8]
7001e89c:	e50b100c 	str	r1, [fp, #-12]
7001e8a0:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
7001e8a4:	e3a03000 	mov	r3, #0
	int rc;

	rc = mkdir(name, mode);
	return rc;
#endif
}
7001e8a8:	e1a00003 	mov	r0, r3
7001e8ac:	e24bd000 	sub	sp, fp, #0
7001e8b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e8b4:	e12fff1e 	bx	lr

7001e8b8 <_open_r>:

int
_open_r(struct _reent *ptr, const char *file, int flags, int mode)
{
7001e8b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e8bc:	e28db000 	add	fp, sp, #0
7001e8c0:	e24dd014 	sub	sp, sp, #20
7001e8c4:	e50b0008 	str	r0, [fp, #-8]
7001e8c8:	e50b100c 	str	r1, [fp, #-12]
7001e8cc:	e50b2010 	str	r2, [fp, #-16]
7001e8d0:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
7001e8d4:	e3a03000 	mov	r3, #0
	int rc;

	rc = open(file, flags, mode);
	return rc;
#endif
}
7001e8d8:	e1a00003 	mov	r0, r3
7001e8dc:	e24bd000 	sub	sp, fp, #0
7001e8e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e8e4:	e12fff1e 	bx	lr

7001e8e8 <_read_r>:

_ssize_t 
_read_r(struct _reent *ptr, int fd, void *buf, size_t nbytes)
{
7001e8e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e8ec:	e28db000 	add	fp, sp, #0
7001e8f0:	e24dd014 	sub	sp, sp, #20
7001e8f4:	e50b0008 	str	r0, [fp, #-8]
7001e8f8:	e50b100c 	str	r1, [fp, #-12]
7001e8fc:	e50b2010 	str	r2, [fp, #-16]
7001e900:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
7001e904:	e3a03000 	mov	r3, #0
	_ssize_t rc;

	rc = read(fd, buf, nbytes);
	return rc;
#endif
}
7001e908:	e1a00003 	mov	r0, r3
7001e90c:	e24bd000 	sub	sp, fp, #0
7001e910:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e914:	e12fff1e 	bx	lr

7001e918 <_rename_r>:

int
_rename_r(struct _reent *ptr, const char *old, const char *new)
{
7001e918:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e91c:	e28db000 	add	fp, sp, #0
7001e920:	e24dd014 	sub	sp, sp, #20
7001e924:	e50b0008 	str	r0, [fp, #-8]
7001e928:	e50b100c 	str	r1, [fp, #-12]
7001e92c:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
7001e930:	e3a03000 	mov	r3, #0
	int rc;

	rc = rename(old, new);
	return rc;
#endif
}
7001e934:	e1a00003 	mov	r0, r3
7001e938:	e24bd000 	sub	sp, fp, #0
7001e93c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e940:	e12fff1e 	bx	lr

7001e944 <_sbrk_r>:

void *
_sbrk_r(struct _reent *ptr, ptrdiff_t incr)
{
7001e944:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e948:	e28db000 	add	fp, sp, #0
7001e94c:	e24dd00c 	sub	sp, sp, #12
7001e950:	e50b0008 	str	r0, [fp, #-8]
7001e954:	e50b100c 	str	r1, [fp, #-12]
	/* no use this routine to get memory */
	return RT_NULL;
7001e958:	e3a03000 	mov	r3, #0
}
7001e95c:	e1a00003 	mov	r0, r3
7001e960:	e24bd000 	sub	sp, fp, #0
7001e964:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e968:	e12fff1e 	bx	lr

7001e96c <_stat_r>:

int
_stat_r(struct _reent *ptr, const char *file, struct stat *pstat)
{
7001e96c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e970:	e28db000 	add	fp, sp, #0
7001e974:	e24dd014 	sub	sp, sp, #20
7001e978:	e50b0008 	str	r0, [fp, #-8]
7001e97c:	e50b100c 	str	r1, [fp, #-12]
7001e980:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
7001e984:	e3a03000 	mov	r3, #0
	int rc;

	rc = stat(file, pstat);
	return rc;
#endif
}
7001e988:	e1a00003 	mov	r0, r3
7001e98c:	e24bd000 	sub	sp, fp, #0
7001e990:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e994:	e12fff1e 	bx	lr

7001e998 <_times_r>:

_CLOCK_T_
_times_r(struct _reent *ptr, struct tms *ptms)
{
7001e998:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e99c:	e28db000 	add	fp, sp, #0
7001e9a0:	e24dd00c 	sub	sp, sp, #12
7001e9a4:	e50b0008 	str	r0, [fp, #-8]
7001e9a8:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001e9ac:	e51b3008 	ldr	r3, [fp, #-8]
7001e9b0:	e3a02086 	mov	r2, #134	; 0x86
7001e9b4:	e5832000 	str	r2, [r3]
	return -1;
7001e9b8:	e3e03000 	mvn	r3, #0
}
7001e9bc:	e1a00003 	mov	r0, r3
7001e9c0:	e24bd000 	sub	sp, fp, #0
7001e9c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e9c8:	e12fff1e 	bx	lr

7001e9cc <_unlink_r>:

int
_unlink_r(struct _reent *ptr, const char *file)
{
7001e9cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e9d0:	e28db000 	add	fp, sp, #0
7001e9d4:	e24dd00c 	sub	sp, sp, #12
7001e9d8:	e50b0008 	str	r0, [fp, #-8]
7001e9dc:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
7001e9e0:	e3a03000 	mov	r3, #0
	int rc;

	rc = unlink(file);
	return rc;
#endif
}
7001e9e4:	e1a00003 	mov	r0, r3
7001e9e8:	e24bd000 	sub	sp, fp, #0
7001e9ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001e9f0:	e12fff1e 	bx	lr

7001e9f4 <_wait_r>:

int
_wait_r(struct _reent *ptr, int *status)
{
7001e9f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001e9f8:	e28db000 	add	fp, sp, #0
7001e9fc:	e24dd00c 	sub	sp, sp, #12
7001ea00:	e50b0008 	str	r0, [fp, #-8]
7001ea04:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001ea08:	e51b3008 	ldr	r3, [fp, #-8]
7001ea0c:	e3a02086 	mov	r2, #134	; 0x86
7001ea10:	e5832000 	str	r2, [r3]
	return -1;
7001ea14:	e3e03000 	mvn	r3, #0
}
7001ea18:	e1a00003 	mov	r0, r3
7001ea1c:	e24bd000 	sub	sp, fp, #0
7001ea20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ea24:	e12fff1e 	bx	lr

7001ea28 <_write_r>:

#ifdef RT_USING_DEVICE
_ssize_t
_write_r(struct _reent *ptr, int fd, const void *buf, size_t nbytes)
{
7001ea28:	e92d4800 	push	{fp, lr}
7001ea2c:	e28db004 	add	fp, sp, #4
7001ea30:	e24dd018 	sub	sp, sp, #24
7001ea34:	e50b0010 	str	r0, [fp, #-16]
7001ea38:	e50b1014 	str	r1, [fp, #-20]
7001ea3c:	e50b2018 	str	r2, [fp, #-24]
7001ea40:	e50b301c 	str	r3, [fp, #-28]
	if (fd < 3)
7001ea44:	e51b3014 	ldr	r3, [fp, #-20]
7001ea48:	e3530002 	cmp	r3, #2
7001ea4c:	ca00000b 	bgt	7001ea80 <_write_r+0x58>
	{
#ifdef RT_USING_CONSOLE
		rt_device_t console_device;
		extern rt_device_t rt_console_get_device(void);

		console_device = rt_console_get_device();
7001ea50:	ebffa331 	bl	7000771c <rt_console_get_device>
7001ea54:	e50b0008 	str	r0, [fp, #-8]
		if (console_device != 0) rt_device_write(console_device, 0, buf, nbytes);
7001ea58:	e51b3008 	ldr	r3, [fp, #-8]
7001ea5c:	e3530000 	cmp	r3, #0
7001ea60:	0a000004 	beq	7001ea78 <_write_r+0x50>
7001ea64:	e51b0008 	ldr	r0, [fp, #-8]
7001ea68:	e3a01000 	mov	r1, #0
7001ea6c:	e51b2018 	ldr	r2, [fp, #-24]
7001ea70:	e51b301c 	ldr	r3, [fp, #-28]
7001ea74:	ebff898f 	bl	700010b8 <rt_device_write>
		return nbytes;
7001ea78:	e51b301c 	ldr	r3, [fp, #-28]
7001ea7c:	ea000000 	b	7001ea84 <_write_r+0x5c>
	    _ssize_t rc;

	    rc = write(fd, buf, nbytes);
	    return rc;
#else
        return 0;
7001ea80:	e3a03000 	mov	r3, #0
#endif
	}
}
7001ea84:	e1a00003 	mov	r0, r3
7001ea88:	e24bd004 	sub	sp, fp, #4
7001ea8c:	e8bd8800 	pop	{fp, pc}

7001ea90 <_gettimeofday_r>:
#else
/* POSIX thread provides clock_gettime function */
#include <time.h>
int
_gettimeofday_r(struct _reent *ptr, struct timeval *__tp, void *__tzp)
{
7001ea90:	e92d4800 	push	{fp, lr}
7001ea94:	e28db004 	add	fp, sp, #4
7001ea98:	e24dd018 	sub	sp, sp, #24
7001ea9c:	e50b0010 	str	r0, [fp, #-16]
7001eaa0:	e50b1014 	str	r1, [fp, #-20]
7001eaa4:	e50b2018 	str	r2, [fp, #-24]
	struct timespec tp;

	if (clock_gettime(CLOCK_REALTIME, &tp) == 0)
7001eaa8:	e24b300c 	sub	r3, fp, #12
7001eaac:	e3a00001 	mov	r0, #1
7001eab0:	e1a01003 	mov	r1, r3
7001eab4:	ebfff16a 	bl	7001b064 <clock_gettime>
7001eab8:	e1a03000 	mov	r3, r0
7001eabc:	e3530000 	cmp	r3, #0
7001eac0:	1a00000d 	bne	7001eafc <_gettimeofday_r+0x6c>
	{
		if (__tp != RT_NULL)
7001eac4:	e51b3014 	ldr	r3, [fp, #-20]
7001eac8:	e3530000 	cmp	r3, #0
7001eacc:	0a000008 	beq	7001eaf4 <_gettimeofday_r+0x64>
		{
			__tp->tv_sec  = tp.tv_sec;
7001ead0:	e51b200c 	ldr	r2, [fp, #-12]
7001ead4:	e51b3014 	ldr	r3, [fp, #-20]
7001ead8:	e5832000 	str	r2, [r3]
			__tp->tv_usec = tp.tv_nsec * 1000UL;
7001eadc:	e51b3008 	ldr	r3, [fp, #-8]
7001eae0:	e3a02ffa 	mov	r2, #1000	; 0x3e8
7001eae4:	e0030392 	mul	r3, r2, r3
7001eae8:	e1a02003 	mov	r2, r3
7001eaec:	e51b3014 	ldr	r3, [fp, #-20]
7001eaf0:	e5832004 	str	r2, [r3, #4]
		}

		return tp.tv_sec;
7001eaf4:	e51b300c 	ldr	r3, [fp, #-12]
7001eaf8:	ea000003 	b	7001eb0c <_gettimeofday_r+0x7c>
	}

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
7001eafc:	e51b3010 	ldr	r3, [fp, #-16]
7001eb00:	e3a02086 	mov	r2, #134	; 0x86
7001eb04:	e5832000 	str	r2, [r3]
	return -1;
7001eb08:	e3e03000 	mvn	r3, #0
}
7001eb0c:	e1a00003 	mov	r0, r3
7001eb10:	e24bd004 	sub	sp, fp, #4
7001eb14:	e8bd8800 	pop	{fp, pc}

7001eb18 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
7001eb18:	e92d4800 	push	{fp, lr}
7001eb1c:	e28db004 	add	fp, sp, #4
7001eb20:	e24dd010 	sub	sp, sp, #16
7001eb24:	e50b0010 	str	r0, [fp, #-16]
7001eb28:	e50b1014 	str	r1, [fp, #-20]
	void* result;

	result = (void*)rt_malloc (size);
7001eb2c:	e51b0014 	ldr	r0, [fp, #-20]
7001eb30:	ebffa561 	bl	700080bc <rt_malloc>
7001eb34:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
7001eb38:	e51b3008 	ldr	r3, [fp, #-8]
7001eb3c:	e3530000 	cmp	r3, #0
7001eb40:	1a000002 	bne	7001eb50 <_malloc_r+0x38>
	{
		ptr->_errno = ENOMEM;
7001eb44:	e51b3010 	ldr	r3, [fp, #-16]
7001eb48:	e3a0200c 	mov	r2, #12
7001eb4c:	e5832000 	str	r2, [r3]
	}

	return result;
7001eb50:	e51b3008 	ldr	r3, [fp, #-8]
}
7001eb54:	e1a00003 	mov	r0, r3
7001eb58:	e24bd004 	sub	sp, fp, #4
7001eb5c:	e8bd8800 	pop	{fp, pc}

7001eb60 <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
7001eb60:	e92d4800 	push	{fp, lr}
7001eb64:	e28db004 	add	fp, sp, #4
7001eb68:	e24dd018 	sub	sp, sp, #24
7001eb6c:	e50b0010 	str	r0, [fp, #-16]
7001eb70:	e50b1014 	str	r1, [fp, #-20]
7001eb74:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_realloc (old, newlen);
7001eb78:	e51b0014 	ldr	r0, [fp, #-20]
7001eb7c:	e51b1018 	ldr	r1, [fp, #-24]
7001eb80:	ebffa704 	bl	70008798 <rt_realloc>
7001eb84:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
7001eb88:	e51b3008 	ldr	r3, [fp, #-8]
7001eb8c:	e3530000 	cmp	r3, #0
7001eb90:	1a000002 	bne	7001eba0 <_realloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
7001eb94:	e51b3010 	ldr	r3, [fp, #-16]
7001eb98:	e3a0200c 	mov	r2, #12
7001eb9c:	e5832000 	str	r2, [r3]
	}

	return result;
7001eba0:	e51b3008 	ldr	r3, [fp, #-8]
}
7001eba4:	e1a00003 	mov	r0, r3
7001eba8:	e24bd004 	sub	sp, fp, #4
7001ebac:	e8bd8800 	pop	{fp, pc}

7001ebb0 <_calloc_r>:

void *_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
7001ebb0:	e92d4800 	push	{fp, lr}
7001ebb4:	e28db004 	add	fp, sp, #4
7001ebb8:	e24dd018 	sub	sp, sp, #24
7001ebbc:	e50b0010 	str	r0, [fp, #-16]
7001ebc0:	e50b1014 	str	r1, [fp, #-20]
7001ebc4:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_calloc (size, len);
7001ebc8:	e51b0014 	ldr	r0, [fp, #-20]
7001ebcc:	e51b1018 	ldr	r1, [fp, #-24]
7001ebd0:	ebffa7b8 	bl	70008ab8 <rt_calloc>
7001ebd4:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
7001ebd8:	e51b3008 	ldr	r3, [fp, #-8]
7001ebdc:	e3530000 	cmp	r3, #0
7001ebe0:	1a000002 	bne	7001ebf0 <_calloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
7001ebe4:	e51b3010 	ldr	r3, [fp, #-16]
7001ebe8:	e3a0200c 	mov	r2, #12
7001ebec:	e5832000 	str	r2, [r3]
	}

	return result;
7001ebf0:	e51b3008 	ldr	r3, [fp, #-8]
}
7001ebf4:	e1a00003 	mov	r0, r3
7001ebf8:	e24bd004 	sub	sp, fp, #4
7001ebfc:	e8bd8800 	pop	{fp, pc}

7001ec00 <_free_r>:

void 
_free_r (struct _reent *ptr, void *addr)
{
7001ec00:	e92d4800 	push	{fp, lr}
7001ec04:	e28db004 	add	fp, sp, #4
7001ec08:	e24dd008 	sub	sp, sp, #8
7001ec0c:	e50b0008 	str	r0, [fp, #-8]
7001ec10:	e50b100c 	str	r1, [fp, #-12]
	rt_free (addr);
7001ec14:	e51b000c 	ldr	r0, [fp, #-12]
7001ec18:	ebffa7ea 	bl	70008bc8 <rt_free>
}
7001ec1c:	e24bd004 	sub	sp, fp, #4
7001ec20:	e8bd8800 	pop	{fp, pc}

7001ec24 <_exit>:

void
_exit (int status)
{
7001ec24:	e92d4800 	push	{fp, lr}
7001ec28:	e28db004 	add	fp, sp, #4
7001ec2c:	e24dd010 	sub	sp, sp, #16
7001ec30:	e50b0010 	str	r0, [fp, #-16]
		/* re-schedule */
		rt_schedule();
	}
#endif
	
	rt_kprintf("thread:%s exit with %d\n", rt_thread_self()->name, status);
7001ec34:	ebffae4d 	bl	7000a570 <rt_thread_self>
7001ec38:	e1a03000 	mov	r3, r0
7001ec3c:	e30805fc 	movw	r0, #34300	; 0x85fc
7001ec40:	e3470002 	movt	r0, #28674	; 0x7002
7001ec44:	e1a01003 	mov	r1, r3
7001ec48:	e51b2010 	ldr	r2, [fp, #-16]
7001ec4c:	ebffa2e8 	bl	700077f4 <rt_kprintf>
	RT_ASSERT(0);
7001ec50:	e3a03000 	mov	r3, #0
7001ec54:	e54b3005 	strb	r3, [fp, #-5]
7001ec58:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ec5c:	e3473002 	movt	r3, #28674	; 0x7002
7001ec60:	e5933000 	ldr	r3, [r3]
7001ec64:	e3530000 	cmp	r3, #0
7001ec68:	1a00000d 	bne	7001eca4 <_exit+0x80>
7001ec6c:	e3080614 	movw	r0, #34324	; 0x8614
7001ec70:	e3470002 	movt	r0, #28674	; 0x7002
7001ec74:	e3081634 	movw	r1, #34356	; 0x8634
7001ec78:	e3471002 	movt	r1, #28674	; 0x7002
7001ec7c:	e3082638 	movw	r2, #34360	; 0x8638
7001ec80:	e3472002 	movt	r2, #28674	; 0x7002
7001ec84:	e30031b2 	movw	r3, #434	; 0x1b2
7001ec88:	ebffa2d9 	bl	700077f4 <rt_kprintf>
7001ec8c:	e1a00000 	nop			; (mov r0, r0)
7001ec90:	e55b3005 	ldrb	r3, [fp, #-5]
7001ec94:	e6ef3073 	uxtb	r3, r3
7001ec98:	e3530000 	cmp	r3, #0
7001ec9c:	0afffffb 	beq	7001ec90 <_exit+0x6c>
7001eca0:	ea000008 	b	7001ecc8 <_exit+0xa4>
7001eca4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001eca8:	e3473002 	movt	r3, #28674	; 0x7002
7001ecac:	e5933000 	ldr	r3, [r3]
7001ecb0:	e3080634 	movw	r0, #34356	; 0x8634
7001ecb4:	e3470002 	movt	r0, #28674	; 0x7002
7001ecb8:	e3081638 	movw	r1, #34360	; 0x8638
7001ecbc:	e3471002 	movt	r1, #28674	; 0x7002
7001ecc0:	e30021b2 	movw	r2, #434	; 0x1b2
7001ecc4:	e12fff33 	blx	r3

	while (1);
7001ecc8:	eafffffe 	b	7001ecc8 <_exit+0xa4>

7001eccc <_system>:
}

void 
_system(const char *s)
{
7001eccc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001ecd0:	e28db000 	add	fp, sp, #0
7001ecd4:	e24dd00c 	sub	sp, sp, #12
7001ecd8:	e50b0008 	str	r0, [fp, #-8]
    /* not support this call */
    return;
7001ecdc:	e1a00000 	nop			; (mov r0, r0)
}
7001ece0:	e24bd000 	sub	sp, fp, #0
7001ece4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ece8:	e12fff1e 	bx	lr

7001ecec <_idname_len>:
static const struct log_trace_session *_the_sessions[LOG_TRACE_MAX_SESSION] = {&_def_session};
/* there is a default session at least */
static rt_uint16_t _the_sess_nr = 1;

rt_inline int _idname_len(log_trace_idnum_t id)
{
7001ecec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001ecf0:	e28db000 	add	fp, sp, #0
7001ecf4:	e24dd00c 	sub	sp, sp, #12
7001ecf8:	e50b0008 	str	r0, [fp, #-8]
    /* little endian */
    if ((id & 0x000000FF) == 0)
7001ecfc:	e51b3008 	ldr	r3, [fp, #-8]
7001ed00:	e6ef3073 	uxtb	r3, r3
7001ed04:	e3530000 	cmp	r3, #0
7001ed08:	1a000001 	bne	7001ed14 <_idname_len+0x28>
        return 0;
7001ed0c:	e3a03000 	mov	r3, #0
7001ed10:	ea000012 	b	7001ed60 <_idname_len+0x74>
    if ((id & 0x0000FF00) == 0)
7001ed14:	e51b3008 	ldr	r3, [fp, #-8]
7001ed18:	e2033cff 	and	r3, r3, #65280	; 0xff00
7001ed1c:	e3530000 	cmp	r3, #0
7001ed20:	1a000001 	bne	7001ed2c <_idname_len+0x40>
        return 1;
7001ed24:	e3a03001 	mov	r3, #1
7001ed28:	ea00000c 	b	7001ed60 <_idname_len+0x74>
    if ((id & 0x00FF0000) == 0)
7001ed2c:	e51b3008 	ldr	r3, [fp, #-8]
7001ed30:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
7001ed34:	e3530000 	cmp	r3, #0
7001ed38:	1a000001 	bne	7001ed44 <_idname_len+0x58>
        return 2;
7001ed3c:	e3a03002 	mov	r3, #2
7001ed40:	ea000006 	b	7001ed60 <_idname_len+0x74>
    if ((id & 0xFF000000) == 0)
7001ed44:	e51b3008 	ldr	r3, [fp, #-8]
7001ed48:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
7001ed4c:	e3530000 	cmp	r3, #0
7001ed50:	1a000001 	bne	7001ed5c <_idname_len+0x70>
        return 3;
7001ed54:	e3a03003 	mov	r3, #3
7001ed58:	ea000000 	b	7001ed60 <_idname_len+0x74>
#ifndef LOG_TRACE_USE_LONGNAME
    return 4;
7001ed5c:	e3a03004 	mov	r3, #4
        if ((id2 & 0xFF000000) == 0)
            return 7;
        return 8;
    }
#endif
}
7001ed60:	e1a00003 	mov	r0, r3
7001ed64:	e24bd000 	sub	sp, fp, #0
7001ed68:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ed6c:	e12fff1e 	bx	lr

7001ed70 <_lg_lookup_session>:
 * @param len is the length of the name
 * @return the pointer to the named session. RT_NULL when there is no such a
 * session.
 */
static struct log_trace_session* _lg_lookup_session(log_trace_idnum_t num)
{
7001ed70:	e92d4800 	push	{fp, lr}
7001ed74:	e28db004 	add	fp, sp, #4
7001ed78:	e24dd018 	sub	sp, sp, #24
7001ed7c:	e50b0018 	str	r0, [fp, #-24]
    static const struct log_trace_session *_cache = &_def_session;
    rt_uint16_t first, last;

    if (_cache->id.num == num)
7001ed80:	e3083ea4 	movw	r3, #36516	; 0x8ea4
7001ed84:	e3473002 	movt	r3, #28674	; 0x7002
7001ed88:	e5933000 	ldr	r3, [r3]
7001ed8c:	e5932000 	ldr	r2, [r3]
7001ed90:	e51b3018 	ldr	r3, [fp, #-24]
7001ed94:	e1520003 	cmp	r2, r3
7001ed98:	1a000003 	bne	7001edac <_lg_lookup_session+0x3c>
        return (struct log_trace_session *)_cache;
7001ed9c:	e3083ea4 	movw	r3, #36516	; 0x8ea4
7001eda0:	e3473002 	movt	r3, #28674	; 0x7002
7001eda4:	e5933000 	ldr	r3, [r3]
7001eda8:	ea000057 	b	7001ef0c <_lg_lookup_session+0x19c>

    first = 0;
7001edac:	e3a03000 	mov	r3, #0
7001edb0:	e14b30b6 	strh	r3, [fp, #-6]
    last  = _the_sess_nr;
7001edb4:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001edb8:	e3473002 	movt	r3, #28674	; 0x7002
7001edbc:	e1d330b0 	ldrh	r3, [r3]
7001edc0:	e14b30b8 	strh	r3, [fp, #-8]
    do {
        unsigned int i = (first + last)/2;
7001edc4:	e15b20b6 	ldrh	r2, [fp, #-6]
7001edc8:	e15b30b8 	ldrh	r3, [fp, #-8]
7001edcc:	e0823003 	add	r3, r2, r3
7001edd0:	e1a02fa3 	lsr	r2, r3, #31
7001edd4:	e0823003 	add	r3, r2, r3
7001edd8:	e1a030c3 	asr	r3, r3, #1
7001eddc:	e50b300c 	str	r3, [fp, #-12]

        RT_ASSERT(_the_sessions[i]);
7001ede0:	e3083e60 	movw	r3, #36448	; 0x8e60
7001ede4:	e3473002 	movt	r3, #28674	; 0x7002
7001ede8:	e51b200c 	ldr	r2, [fp, #-12]
7001edec:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001edf0:	e3530000 	cmp	r3, #0
7001edf4:	1a00001d 	bne	7001ee70 <_lg_lookup_session+0x100>
7001edf8:	e3a03000 	mov	r3, #0
7001edfc:	e54b300d 	strb	r3, [fp, #-13]
7001ee00:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ee04:	e3473002 	movt	r3, #28674	; 0x7002
7001ee08:	e5933000 	ldr	r3, [r3]
7001ee0c:	e3530000 	cmp	r3, #0
7001ee10:	1a00000d 	bne	7001ee4c <_lg_lookup_session+0xdc>
7001ee14:	e3080640 	movw	r0, #34368	; 0x8640
7001ee18:	e3470002 	movt	r0, #28674	; 0x7002
7001ee1c:	e3081660 	movw	r1, #34400	; 0x8660
7001ee20:	e3471002 	movt	r1, #28674	; 0x7002
7001ee24:	e3082778 	movw	r2, #34680	; 0x8778
7001ee28:	e3472002 	movt	r2, #28674	; 0x7002
7001ee2c:	e3a03061 	mov	r3, #97	; 0x61
7001ee30:	ebffa26f 	bl	700077f4 <rt_kprintf>
7001ee34:	e1a00000 	nop			; (mov r0, r0)
7001ee38:	e55b300d 	ldrb	r3, [fp, #-13]
7001ee3c:	e6ef3073 	uxtb	r3, r3
7001ee40:	e3530000 	cmp	r3, #0
7001ee44:	0afffffb 	beq	7001ee38 <_lg_lookup_session+0xc8>
7001ee48:	ea000008 	b	7001ee70 <_lg_lookup_session+0x100>
7001ee4c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ee50:	e3473002 	movt	r3, #28674	; 0x7002
7001ee54:	e5933000 	ldr	r3, [r3]
7001ee58:	e3080660 	movw	r0, #34400	; 0x8660
7001ee5c:	e3470002 	movt	r0, #28674	; 0x7002
7001ee60:	e3081778 	movw	r1, #34680	; 0x8778
7001ee64:	e3471002 	movt	r1, #28674	; 0x7002
7001ee68:	e3a02061 	mov	r2, #97	; 0x61
7001ee6c:	e12fff33 	blx	r3

        if (_the_sessions[i]->id.num == num)
7001ee70:	e3083e60 	movw	r3, #36448	; 0x8e60
7001ee74:	e3473002 	movt	r3, #28674	; 0x7002
7001ee78:	e51b200c 	ldr	r2, [fp, #-12]
7001ee7c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001ee80:	e5932000 	ldr	r2, [r3]
7001ee84:	e51b3018 	ldr	r3, [fp, #-24]
7001ee88:	e1520003 	cmp	r2, r3
7001ee8c:	1a00000b 	bne	7001eec0 <_lg_lookup_session+0x150>
            /* there is no need to protect the _cache because write a pointer
             * is atomic. So we cannot get a invalid pointer. The worst thing
             * could happen is there is an interrupt in the read/modify/write
             * process and we wrote the old one to _cache. But it doesn't harm
             * a lot because it will be flushed in the next time. */
            _cache = _the_sessions[i];
7001ee90:	e3083e60 	movw	r3, #36448	; 0x8e60
7001ee94:	e3473002 	movt	r3, #28674	; 0x7002
7001ee98:	e51b200c 	ldr	r2, [fp, #-12]
7001ee9c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
7001eea0:	e3083ea4 	movw	r3, #36516	; 0x8ea4
7001eea4:	e3473002 	movt	r3, #28674	; 0x7002
7001eea8:	e5832000 	str	r2, [r3]
            return (struct log_trace_session *)_the_sessions[i];
7001eeac:	e3083e60 	movw	r3, #36448	; 0x8e60
7001eeb0:	e3473002 	movt	r3, #28674	; 0x7002
7001eeb4:	e51b200c 	ldr	r2, [fp, #-12]
7001eeb8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001eebc:	ea000012 	b	7001ef0c <_lg_lookup_session+0x19c>
        }
        else if (_the_sessions[i]->id.num > num)
7001eec0:	e3083e60 	movw	r3, #36448	; 0x8e60
7001eec4:	e3473002 	movt	r3, #28674	; 0x7002
7001eec8:	e51b200c 	ldr	r2, [fp, #-12]
7001eecc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001eed0:	e5932000 	ldr	r2, [r3]
7001eed4:	e51b3018 	ldr	r3, [fp, #-24]
7001eed8:	e1520003 	cmp	r2, r3
7001eedc:	9a000002 	bls	7001eeec <_lg_lookup_session+0x17c>
        {
            last = i;
7001eee0:	e51b300c 	ldr	r3, [fp, #-12]
7001eee4:	e14b30b8 	strh	r3, [fp, #-8]
7001eee8:	ea000001 	b	7001eef4 <_lg_lookup_session+0x184>
        }
        else // _the_sessions[i]->id.num < num
        {
            first = i;
7001eeec:	e51b300c 	ldr	r3, [fp, #-12]
7001eef0:	e14b30b6 	strh	r3, [fp, #-6]
        }
    } while (first != last-1);
7001eef4:	e15b20b6 	ldrh	r2, [fp, #-6]
7001eef8:	e15b30b8 	ldrh	r3, [fp, #-8]
7001eefc:	e2433001 	sub	r3, r3, #1
7001ef00:	e1520003 	cmp	r2, r3
7001ef04:	1affffae 	bne	7001edc4 <_lg_lookup_session+0x54>

    return RT_NULL;
7001ef08:	e3a03000 	mov	r3, #0
}
7001ef0c:	e1a00003 	mov	r0, r3
7001ef10:	e24bd004 	sub	sp, fp, #4
7001ef14:	e8bd8800 	pop	{fp, pc}

7001ef18 <log_trace_register_session>:

rt_err_t log_trace_register_session(const struct log_trace_session *session)
{
7001ef18:	e92d4800 	push	{fp, lr}
7001ef1c:	e28db004 	add	fp, sp, #4
7001ef20:	e24dd010 	sub	sp, sp, #16
7001ef24:	e50b0010 	str	r0, [fp, #-16]
    unsigned int lvl, i;

    if (_the_sess_nr == LOG_TRACE_MAX_SESSION)
7001ef28:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001ef2c:	e3473002 	movt	r3, #28674	; 0x7002
7001ef30:	e1d330b0 	ldrh	r3, [r3]
7001ef34:	e3530010 	cmp	r3, #16
7001ef38:	1a000001 	bne	7001ef44 <log_trace_register_session+0x2c>
        return -RT_EFULL;
7001ef3c:	e3e03002 	mvn	r3, #2
7001ef40:	ea000063 	b	7001f0d4 <log_trace_register_session+0x1bc>

    if (session == RT_NULL)
7001ef44:	e51b3010 	ldr	r3, [fp, #-16]
7001ef48:	e3530000 	cmp	r3, #0
7001ef4c:	1a000001 	bne	7001ef58 <log_trace_register_session+0x40>
        return RT_EOK;
7001ef50:	e3a03000 	mov	r3, #0
7001ef54:	ea00005e 	b	7001f0d4 <log_trace_register_session+0x1bc>

    lvl = rt_hw_interrupt_disable();
7001ef58:	ebffbcba 	bl	7000e248 <rt_hw_interrupt_disable>
7001ef5c:	e1a03000 	mov	r3, r0
7001ef60:	e50b300c 	str	r3, [fp, #-12]
    /* inserting the sessions in ascending order.
     *
     * this might take relatively long time. But since the register should only
     * happen when initialize the whole system, this should not be a matter. */
    for (i = 0; i < _the_sess_nr; i++)
7001ef64:	e3a03000 	mov	r3, #0
7001ef68:	e50b3008 	str	r3, [fp, #-8]
7001ef6c:	ea000039 	b	7001f058 <log_trace_register_session+0x140>
    {
        if (_the_sessions[i]->id.num > session->id.num)
7001ef70:	e3083e60 	movw	r3, #36448	; 0x8e60
7001ef74:	e3473002 	movt	r3, #28674	; 0x7002
7001ef78:	e51b2008 	ldr	r2, [fp, #-8]
7001ef7c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001ef80:	e5932000 	ldr	r2, [r3]
7001ef84:	e51b3010 	ldr	r3, [fp, #-16]
7001ef88:	e5933000 	ldr	r3, [r3]
7001ef8c:	e1520003 	cmp	r2, r3
7001ef90:	9a00001b 	bls	7001f004 <log_trace_register_session+0xec>
        {
            rt_memmove(_the_sessions+i+1, _the_sessions+i,
7001ef94:	e51b3008 	ldr	r3, [fp, #-8]
7001ef98:	e2833001 	add	r3, r3, #1
7001ef9c:	e1a02103 	lsl	r2, r3, #2
7001efa0:	e3083e60 	movw	r3, #36448	; 0x8e60
7001efa4:	e3473002 	movt	r3, #28674	; 0x7002
7001efa8:	e0821003 	add	r1, r2, r3
7001efac:	e51b3008 	ldr	r3, [fp, #-8]
7001efb0:	e1a02103 	lsl	r2, r3, #2
7001efb4:	e3083e60 	movw	r3, #36448	; 0x8e60
7001efb8:	e3473002 	movt	r3, #28674	; 0x7002
7001efbc:	e0822003 	add	r2, r2, r3
                       (_the_sess_nr-i)*sizeof(&_the_sessions[0]));
7001efc0:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001efc4:	e3473002 	movt	r3, #28674	; 0x7002
7001efc8:	e1d330b0 	ldrh	r3, [r3]
7001efcc:	e1a00003 	mov	r0, r3
7001efd0:	e51b3008 	ldr	r3, [fp, #-8]
7001efd4:	e0633000 	rsb	r3, r3, r0
7001efd8:	e1a03103 	lsl	r3, r3, #2
     * happen when initialize the whole system, this should not be a matter. */
    for (i = 0; i < _the_sess_nr; i++)
    {
        if (_the_sessions[i]->id.num > session->id.num)
        {
            rt_memmove(_the_sessions+i+1, _the_sessions+i,
7001efdc:	e1a00001 	mov	r0, r1
7001efe0:	e1a01002 	mov	r1, r2
7001efe4:	e1a02003 	mov	r2, r3
7001efe8:	ebff9cc7 	bl	7000630c <rt_memmove>
                       (_the_sess_nr-i)*sizeof(&_the_sessions[0]));
            _the_sessions[i] = session;
7001efec:	e3083e60 	movw	r3, #36448	; 0x8e60
7001eff0:	e3473002 	movt	r3, #28674	; 0x7002
7001eff4:	e51b2008 	ldr	r2, [fp, #-8]
7001eff8:	e51b1010 	ldr	r1, [fp, #-16]
7001effc:	e7831102 	str	r1, [r3, r2, lsl #2]
            break;
7001f000:	ea00001b 	b	7001f074 <log_trace_register_session+0x15c>
        }
        else if (_the_sessions[i]->id.num == session->id.num)
7001f004:	e3083e60 	movw	r3, #36448	; 0x8e60
7001f008:	e3473002 	movt	r3, #28674	; 0x7002
7001f00c:	e51b2008 	ldr	r2, [fp, #-8]
7001f010:	e7933102 	ldr	r3, [r3, r2, lsl #2]
7001f014:	e5932000 	ldr	r2, [r3]
7001f018:	e51b3010 	ldr	r3, [fp, #-16]
7001f01c:	e5933000 	ldr	r3, [r3]
7001f020:	e1520003 	cmp	r2, r3
7001f024:	1a000008 	bne	7001f04c <log_trace_register_session+0x134>
        {
            rt_kprintf("registering session 0x%p twice\n", session);
7001f028:	e3080674 	movw	r0, #34420	; 0x8674
7001f02c:	e3470002 	movt	r0, #28674	; 0x7002
7001f030:	e51b1010 	ldr	r1, [fp, #-16]
7001f034:	ebffa1ee 	bl	700077f4 <rt_kprintf>
            rt_hw_interrupt_enable(lvl);
7001f038:	e51b300c 	ldr	r3, [fp, #-12]
7001f03c:	e1a00003 	mov	r0, r3
7001f040:	ebffbc83 	bl	7000e254 <rt_hw_interrupt_enable>
            return -RT_ERROR;
7001f044:	e3e03000 	mvn	r3, #0
7001f048:	ea000021 	b	7001f0d4 <log_trace_register_session+0x1bc>
    lvl = rt_hw_interrupt_disable();
    /* inserting the sessions in ascending order.
     *
     * this might take relatively long time. But since the register should only
     * happen when initialize the whole system, this should not be a matter. */
    for (i = 0; i < _the_sess_nr; i++)
7001f04c:	e51b3008 	ldr	r3, [fp, #-8]
7001f050:	e2833001 	add	r3, r3, #1
7001f054:	e50b3008 	str	r3, [fp, #-8]
7001f058:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001f05c:	e3473002 	movt	r3, #28674	; 0x7002
7001f060:	e1d330b0 	ldrh	r3, [r3]
7001f064:	e1a02003 	mov	r2, r3
7001f068:	e51b3008 	ldr	r3, [fp, #-8]
7001f06c:	e1520003 	cmp	r2, r3
7001f070:	8affffbe 	bhi	7001ef70 <log_trace_register_session+0x58>
            rt_kprintf("registering session 0x%p twice\n", session);
            rt_hw_interrupt_enable(lvl);
            return -RT_ERROR;
        }
    }
    if (i == _the_sess_nr)
7001f074:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001f078:	e3473002 	movt	r3, #28674	; 0x7002
7001f07c:	e1d330b0 	ldrh	r3, [r3]
7001f080:	e1a02003 	mov	r2, r3
7001f084:	e51b3008 	ldr	r3, [fp, #-8]
7001f088:	e1520003 	cmp	r2, r3
7001f08c:	1a000004 	bne	7001f0a4 <log_trace_register_session+0x18c>
        _the_sessions[i] = session;
7001f090:	e3083e60 	movw	r3, #36448	; 0x8e60
7001f094:	e3473002 	movt	r3, #28674	; 0x7002
7001f098:	e51b2008 	ldr	r2, [fp, #-8]
7001f09c:	e51b1010 	ldr	r1, [fp, #-16]
7001f0a0:	e7831102 	str	r1, [r3, r2, lsl #2]
    _the_sess_nr++;
7001f0a4:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001f0a8:	e3473002 	movt	r3, #28674	; 0x7002
7001f0ac:	e1d330b0 	ldrh	r3, [r3]
7001f0b0:	e2833001 	add	r3, r3, #1
7001f0b4:	e6ff2073 	uxth	r2, r3
7001f0b8:	e3083ea0 	movw	r3, #36512	; 0x8ea0
7001f0bc:	e3473002 	movt	r3, #28674	; 0x7002
7001f0c0:	e1c320b0 	strh	r2, [r3]
    rt_hw_interrupt_enable(lvl);
7001f0c4:	e51b300c 	ldr	r3, [fp, #-12]
7001f0c8:	e1a00003 	mov	r0, r3
7001f0cc:	ebffbc60 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
7001f0d0:	e3a03000 	mov	r3, #0
}
7001f0d4:	e1a00003 	mov	r0, r3
7001f0d8:	e24bd004 	sub	sp, fp, #4
7001f0dc:	e8bd8800 	pop	{fp, pc}

7001f0e0 <log_trace_session_find>:

struct log_trace_session* log_trace_session_find(const char *name)
{
7001f0e0:	e92d4800 	push	{fp, lr}
7001f0e4:	e28db004 	add	fp, sp, #4
7001f0e8:	e24dd010 	sub	sp, sp, #16
7001f0ec:	e50b0010 	str	r0, [fp, #-16]
    union log_trace_id *idp;

    RT_ASSERT(name);
7001f0f0:	e51b3010 	ldr	r3, [fp, #-16]
7001f0f4:	e3530000 	cmp	r3, #0
7001f0f8:	1a00001d 	bne	7001f174 <log_trace_session_find+0x94>
7001f0fc:	e3a03000 	mov	r3, #0
7001f100:	e54b3009 	strb	r3, [fp, #-9]
7001f104:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f108:	e3473002 	movt	r3, #28674	; 0x7002
7001f10c:	e5933000 	ldr	r3, [r3]
7001f110:	e3530000 	cmp	r3, #0
7001f114:	1a00000d 	bne	7001f150 <log_trace_session_find+0x70>
7001f118:	e3080640 	movw	r0, #34368	; 0x8640
7001f11c:	e3470002 	movt	r0, #28674	; 0x7002
7001f120:	e3081694 	movw	r1, #34452	; 0x8694
7001f124:	e3471002 	movt	r1, #28674	; 0x7002
7001f128:	e308278c 	movw	r2, #34700	; 0x878c
7001f12c:	e3472002 	movt	r2, #28674	; 0x7002
7001f130:	e3a030a5 	mov	r3, #165	; 0xa5
7001f134:	ebffa1ae 	bl	700077f4 <rt_kprintf>
7001f138:	e1a00000 	nop			; (mov r0, r0)
7001f13c:	e55b3009 	ldrb	r3, [fp, #-9]
7001f140:	e6ef3073 	uxtb	r3, r3
7001f144:	e3530000 	cmp	r3, #0
7001f148:	0afffffb 	beq	7001f13c <log_trace_session_find+0x5c>
7001f14c:	ea000008 	b	7001f174 <log_trace_session_find+0x94>
7001f150:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f154:	e3473002 	movt	r3, #28674	; 0x7002
7001f158:	e5933000 	ldr	r3, [r3]
7001f15c:	e3080694 	movw	r0, #34452	; 0x8694
7001f160:	e3470002 	movt	r0, #28674	; 0x7002
7001f164:	e308178c 	movw	r1, #34700	; 0x878c
7001f168:	e3471002 	movt	r1, #28674	; 0x7002
7001f16c:	e3a020a5 	mov	r2, #165	; 0xa5
7001f170:	e12fff33 	blx	r3
    idp = (union log_trace_id*)name;
7001f174:	e51b3010 	ldr	r3, [fp, #-16]
7001f178:	e50b3008 	str	r3, [fp, #-8]
    return _lg_lookup_session(idp->num);
7001f17c:	e51b3008 	ldr	r3, [fp, #-8]
7001f180:	e5933000 	ldr	r3, [r3]
7001f184:	e1a00003 	mov	r0, r3
7001f188:	ebfffef8 	bl	7001ed70 <_lg_lookup_session>
7001f18c:	e1a03000 	mov	r3, r0
}
7001f190:	e1a00003 	mov	r0, r3
7001f194:	e24bd004 	sub	sp, fp, #4
7001f198:	e8bd8800 	pop	{fp, pc}

7001f19c <log_trace_set_level>:

void log_trace_set_level(rt_uint8_t level)
{
7001f19c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001f1a0:	e28db000 	add	fp, sp, #0
7001f1a4:	e24dd00c 	sub	sp, sp, #12
7001f1a8:	e1a03000 	mov	r3, r0
7001f1ac:	e54b3005 	strb	r3, [fp, #-5]
    _def_session.lvl = level;
7001f1b0:	e3083e58 	movw	r3, #36440	; 0x8e58
7001f1b4:	e3473002 	movt	r3, #28674	; 0x7002
7001f1b8:	e55b2005 	ldrb	r2, [fp, #-5]
7001f1bc:	e5c32004 	strb	r2, [r3, #4]
}
7001f1c0:	e24bd000 	sub	sp, fp, #0
7001f1c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001f1c8:	e12fff1e 	bx	lr

7001f1cc <log_trace_session_set_level>:
FINSH_FUNCTION_EXPORT_ALIAS(log_trace_set_level, log_level, set the filter level of log trace);

void log_trace_session_set_level(struct log_trace_session *sess, rt_uint8_t level)
{
7001f1cc:	e92d4800 	push	{fp, lr}
7001f1d0:	e28db004 	add	fp, sp, #4
7001f1d4:	e24dd010 	sub	sp, sp, #16
7001f1d8:	e50b0010 	str	r0, [fp, #-16]
7001f1dc:	e1a03001 	mov	r3, r1
7001f1e0:	e54b3011 	strb	r3, [fp, #-17]
    RT_ASSERT(sess);
7001f1e4:	e51b3010 	ldr	r3, [fp, #-16]
7001f1e8:	e3530000 	cmp	r3, #0
7001f1ec:	1a00001d 	bne	7001f268 <log_trace_session_set_level+0x9c>
7001f1f0:	e3a03000 	mov	r3, #0
7001f1f4:	e54b3005 	strb	r3, [fp, #-5]
7001f1f8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f1fc:	e3473002 	movt	r3, #28674	; 0x7002
7001f200:	e5933000 	ldr	r3, [r3]
7001f204:	e3530000 	cmp	r3, #0
7001f208:	1a00000d 	bne	7001f244 <log_trace_session_set_level+0x78>
7001f20c:	e3080640 	movw	r0, #34368	; 0x8640
7001f210:	e3470002 	movt	r0, #28674	; 0x7002
7001f214:	e30816cc 	movw	r1, #34508	; 0x86cc
7001f218:	e3471002 	movt	r1, #28674	; 0x7002
7001f21c:	e30827a4 	movw	r2, #34724	; 0x87a4
7001f220:	e3472002 	movt	r2, #28674	; 0x7002
7001f224:	e3a030b2 	mov	r3, #178	; 0xb2
7001f228:	ebffa171 	bl	700077f4 <rt_kprintf>
7001f22c:	e1a00000 	nop			; (mov r0, r0)
7001f230:	e55b3005 	ldrb	r3, [fp, #-5]
7001f234:	e6ef3073 	uxtb	r3, r3
7001f238:	e3530000 	cmp	r3, #0
7001f23c:	0afffffb 	beq	7001f230 <log_trace_session_set_level+0x64>
7001f240:	ea000008 	b	7001f268 <log_trace_session_set_level+0x9c>
7001f244:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f248:	e3473002 	movt	r3, #28674	; 0x7002
7001f24c:	e5933000 	ldr	r3, [r3]
7001f250:	e30806cc 	movw	r0, #34508	; 0x86cc
7001f254:	e3470002 	movt	r0, #28674	; 0x7002
7001f258:	e30817a4 	movw	r1, #34724	; 0x87a4
7001f25c:	e3471002 	movt	r1, #28674	; 0x7002
7001f260:	e3a020b2 	mov	r2, #178	; 0xb2
7001f264:	e12fff33 	blx	r3
    sess->lvl = level;
7001f268:	e51b3010 	ldr	r3, [fp, #-16]
7001f26c:	e55b2011 	ldrb	r2, [fp, #-17]
7001f270:	e5c32004 	strb	r2, [r3, #4]
}
7001f274:	e24bd004 	sub	sp, fp, #4
7001f278:	e8bd8800 	pop	{fp, pc}

7001f27c <_lg_parse_lvl>:
 * @param lvlp the pointer to level. It will store the level in the memory the
 *        lvlp points to. The default value is LOG_TRACE_LEVEL_DEFAULT.
 * @return the number of char it scaned.
 */
static rt_size_t _lg_parse_lvl(const char *fmt, rt_size_t flen, int *lvlp)
{
7001f27c:	e92d4800 	push	{fp, lr}
7001f280:	e28db004 	add	fp, sp, #4
7001f284:	e24dd018 	sub	sp, sp, #24
7001f288:	e50b0010 	str	r0, [fp, #-16]
7001f28c:	e50b1014 	str	r1, [fp, #-20]
7001f290:	e50b2018 	str	r2, [fp, #-24]
    RT_ASSERT(fmt);
7001f294:	e51b3010 	ldr	r3, [fp, #-16]
7001f298:	e3530000 	cmp	r3, #0
7001f29c:	1a00001d 	bne	7001f318 <_lg_parse_lvl+0x9c>
7001f2a0:	e3a03000 	mov	r3, #0
7001f2a4:	e54b3005 	strb	r3, [fp, #-5]
7001f2a8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f2ac:	e3473002 	movt	r3, #28674	; 0x7002
7001f2b0:	e5933000 	ldr	r3, [r3]
7001f2b4:	e3530000 	cmp	r3, #0
7001f2b8:	1a00000d 	bne	7001f2f4 <_lg_parse_lvl+0x78>
7001f2bc:	e3080640 	movw	r0, #34368	; 0x8640
7001f2c0:	e3470002 	movt	r0, #28674	; 0x7002
7001f2c4:	e30816d4 	movw	r1, #34516	; 0x86d4
7001f2c8:	e3471002 	movt	r1, #28674	; 0x7002
7001f2cc:	e30827c0 	movw	r2, #34752	; 0x87c0
7001f2d0:	e3472002 	movt	r2, #28674	; 0x7002
7001f2d4:	e3a030bf 	mov	r3, #191	; 0xbf
7001f2d8:	ebffa145 	bl	700077f4 <rt_kprintf>
7001f2dc:	e1a00000 	nop			; (mov r0, r0)
7001f2e0:	e55b3005 	ldrb	r3, [fp, #-5]
7001f2e4:	e6ef3073 	uxtb	r3, r3
7001f2e8:	e3530000 	cmp	r3, #0
7001f2ec:	0afffffb 	beq	7001f2e0 <_lg_parse_lvl+0x64>
7001f2f0:	ea000008 	b	7001f318 <_lg_parse_lvl+0x9c>
7001f2f4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f2f8:	e3473002 	movt	r3, #28674	; 0x7002
7001f2fc:	e5933000 	ldr	r3, [r3]
7001f300:	e30806d4 	movw	r0, #34516	; 0x86d4
7001f304:	e3470002 	movt	r0, #28674	; 0x7002
7001f308:	e30817c0 	movw	r1, #34752	; 0x87c0
7001f30c:	e3471002 	movt	r1, #28674	; 0x7002
7001f310:	e3a020bf 	mov	r2, #191	; 0xbf
7001f314:	e12fff33 	blx	r3
    RT_ASSERT(lvlp);
7001f318:	e51b3018 	ldr	r3, [fp, #-24]
7001f31c:	e3530000 	cmp	r3, #0
7001f320:	1a00001d 	bne	7001f39c <_lg_parse_lvl+0x120>
7001f324:	e3a03000 	mov	r3, #0
7001f328:	e54b3006 	strb	r3, [fp, #-6]
7001f32c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f330:	e3473002 	movt	r3, #28674	; 0x7002
7001f334:	e5933000 	ldr	r3, [r3]
7001f338:	e3530000 	cmp	r3, #0
7001f33c:	1a00000d 	bne	7001f378 <_lg_parse_lvl+0xfc>
7001f340:	e3080640 	movw	r0, #34368	; 0x8640
7001f344:	e3470002 	movt	r0, #28674	; 0x7002
7001f348:	e30816d8 	movw	r1, #34520	; 0x86d8
7001f34c:	e3471002 	movt	r1, #28674	; 0x7002
7001f350:	e30827c0 	movw	r2, #34752	; 0x87c0
7001f354:	e3472002 	movt	r2, #28674	; 0x7002
7001f358:	e3a030c0 	mov	r3, #192	; 0xc0
7001f35c:	ebffa124 	bl	700077f4 <rt_kprintf>
7001f360:	e1a00000 	nop			; (mov r0, r0)
7001f364:	e55b3006 	ldrb	r3, [fp, #-6]
7001f368:	e6ef3073 	uxtb	r3, r3
7001f36c:	e3530000 	cmp	r3, #0
7001f370:	0afffffb 	beq	7001f364 <_lg_parse_lvl+0xe8>
7001f374:	ea000008 	b	7001f39c <_lg_parse_lvl+0x120>
7001f378:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f37c:	e3473002 	movt	r3, #28674	; 0x7002
7001f380:	e5933000 	ldr	r3, [r3]
7001f384:	e30806d8 	movw	r0, #34520	; 0x86d8
7001f388:	e3470002 	movt	r0, #28674	; 0x7002
7001f38c:	e30817c0 	movw	r1, #34752	; 0x87c0
7001f390:	e3471002 	movt	r1, #28674	; 0x7002
7001f394:	e3a020c0 	mov	r2, #192	; 0xc0
7001f398:	e12fff33 	blx	r3

    /* setup default value */
    *lvlp = LOG_TRACE_LEVEL_DEFAULT;
7001f39c:	e51b3018 	ldr	r3, [fp, #-24]
7001f3a0:	e3a02005 	mov	r2, #5
7001f3a4:	e5832000 	str	r2, [r3]

    if (flen < 3)
7001f3a8:	e51b3014 	ldr	r3, [fp, #-20]
7001f3ac:	e3530002 	cmp	r3, #2
7001f3b0:	8a000001 	bhi	7001f3bc <_lg_parse_lvl+0x140>
    {
        return 0;
7001f3b4:	e3a03000 	mov	r3, #0
7001f3b8:	ea000011 	b	7001f404 <_lg_parse_lvl+0x188>
    }

    if (fmt[0] == '<' && fmt[2] == '>')
7001f3bc:	e51b3010 	ldr	r3, [fp, #-16]
7001f3c0:	e5d33000 	ldrb	r3, [r3]
7001f3c4:	e353003c 	cmp	r3, #60	; 0x3c
7001f3c8:	1a00000c 	bne	7001f400 <_lg_parse_lvl+0x184>
7001f3cc:	e51b3010 	ldr	r3, [fp, #-16]
7001f3d0:	e2833002 	add	r3, r3, #2
7001f3d4:	e5d33000 	ldrb	r3, [r3]
7001f3d8:	e353003e 	cmp	r3, #62	; 0x3e
7001f3dc:	1a000007 	bne	7001f400 <_lg_parse_lvl+0x184>
    {
        *lvlp = fmt[1] - '0';
7001f3e0:	e51b3010 	ldr	r3, [fp, #-16]
7001f3e4:	e2833001 	add	r3, r3, #1
7001f3e8:	e5d33000 	ldrb	r3, [r3]
7001f3ec:	e2432030 	sub	r2, r3, #48	; 0x30
7001f3f0:	e51b3018 	ldr	r3, [fp, #-24]
7001f3f4:	e5832000 	str	r2, [r3]
        return 3;
7001f3f8:	e3a03003 	mov	r3, #3
7001f3fc:	ea000000 	b	7001f404 <_lg_parse_lvl+0x188>
    }
    return 0;
7001f400:	e3a03000 	mov	r3, #0
}
7001f404:	e1a00003 	mov	r0, r3
7001f408:	e24bd004 	sub	sp, fp, #4
7001f40c:	e8bd8800 	pop	{fp, pc}

7001f410 <_lg_parse_session>:
 *        find the session, it will be setted to the default session.
 * @return the number of char it scaned, i.e., the length of header.
 */
static rt_size_t _lg_parse_session(
        const char *fmt, rt_size_t flen, struct log_trace_session **sessp)
{
7001f410:	e92d4800 	push	{fp, lr}
7001f414:	e28db004 	add	fp, sp, #4
7001f418:	e24dd020 	sub	sp, sp, #32
7001f41c:	e50b0018 	str	r0, [fp, #-24]
7001f420:	e50b101c 	str	r1, [fp, #-28]
7001f424:	e50b2020 	str	r2, [fp, #-32]
    unsigned int i;
    struct log_trace_session *tmpsess;
    union log_trace_id id;

    RT_ASSERT(fmt);
7001f428:	e51b3018 	ldr	r3, [fp, #-24]
7001f42c:	e3530000 	cmp	r3, #0
7001f430:	1a00001d 	bne	7001f4ac <_lg_parse_session+0x9c>
7001f434:	e3a03000 	mov	r3, #0
7001f438:	e54b3011 	strb	r3, [fp, #-17]
7001f43c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f440:	e3473002 	movt	r3, #28674	; 0x7002
7001f444:	e5933000 	ldr	r3, [r3]
7001f448:	e3530000 	cmp	r3, #0
7001f44c:	1a00000d 	bne	7001f488 <_lg_parse_session+0x78>
7001f450:	e3080640 	movw	r0, #34368	; 0x8640
7001f454:	e3470002 	movt	r0, #28674	; 0x7002
7001f458:	e30816d4 	movw	r1, #34516	; 0x86d4
7001f45c:	e3471002 	movt	r1, #28674	; 0x7002
7001f460:	e30827d0 	movw	r2, #34768	; 0x87d0
7001f464:	e3472002 	movt	r2, #28674	; 0x7002
7001f468:	e3a030e1 	mov	r3, #225	; 0xe1
7001f46c:	ebffa0e0 	bl	700077f4 <rt_kprintf>
7001f470:	e1a00000 	nop			; (mov r0, r0)
7001f474:	e55b3011 	ldrb	r3, [fp, #-17]
7001f478:	e6ef3073 	uxtb	r3, r3
7001f47c:	e3530000 	cmp	r3, #0
7001f480:	0afffffb 	beq	7001f474 <_lg_parse_session+0x64>
7001f484:	ea000008 	b	7001f4ac <_lg_parse_session+0x9c>
7001f488:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f48c:	e3473002 	movt	r3, #28674	; 0x7002
7001f490:	e5933000 	ldr	r3, [r3]
7001f494:	e30806d4 	movw	r0, #34516	; 0x86d4
7001f498:	e3470002 	movt	r0, #28674	; 0x7002
7001f49c:	e30817d0 	movw	r1, #34768	; 0x87d0
7001f4a0:	e3471002 	movt	r1, #28674	; 0x7002
7001f4a4:	e3a020e1 	mov	r2, #225	; 0xe1
7001f4a8:	e12fff33 	blx	r3
    RT_ASSERT(sessp);
7001f4ac:	e51b3020 	ldr	r3, [fp, #-32]
7001f4b0:	e3530000 	cmp	r3, #0
7001f4b4:	1a00001d 	bne	7001f530 <_lg_parse_session+0x120>
7001f4b8:	e3a03000 	mov	r3, #0
7001f4bc:	e54b3012 	strb	r3, [fp, #-18]
7001f4c0:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f4c4:	e3473002 	movt	r3, #28674	; 0x7002
7001f4c8:	e5933000 	ldr	r3, [r3]
7001f4cc:	e3530000 	cmp	r3, #0
7001f4d0:	1a00000d 	bne	7001f50c <_lg_parse_session+0xfc>
7001f4d4:	e3080640 	movw	r0, #34368	; 0x8640
7001f4d8:	e3470002 	movt	r0, #28674	; 0x7002
7001f4dc:	e30816e0 	movw	r1, #34528	; 0x86e0
7001f4e0:	e3471002 	movt	r1, #28674	; 0x7002
7001f4e4:	e30827d0 	movw	r2, #34768	; 0x87d0
7001f4e8:	e3472002 	movt	r2, #28674	; 0x7002
7001f4ec:	e3a030e2 	mov	r3, #226	; 0xe2
7001f4f0:	ebffa0bf 	bl	700077f4 <rt_kprintf>
7001f4f4:	e1a00000 	nop			; (mov r0, r0)
7001f4f8:	e55b3012 	ldrb	r3, [fp, #-18]
7001f4fc:	e6ef3073 	uxtb	r3, r3
7001f500:	e3530000 	cmp	r3, #0
7001f504:	0afffffb 	beq	7001f4f8 <_lg_parse_session+0xe8>
7001f508:	ea000008 	b	7001f530 <_lg_parse_session+0x120>
7001f50c:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f510:	e3473002 	movt	r3, #28674	; 0x7002
7001f514:	e5933000 	ldr	r3, [r3]
7001f518:	e30806e0 	movw	r0, #34528	; 0x86e0
7001f51c:	e3470002 	movt	r0, #28674	; 0x7002
7001f520:	e30817d0 	movw	r1, #34768	; 0x87d0
7001f524:	e3471002 	movt	r1, #28674	; 0x7002
7001f528:	e3a020e2 	mov	r2, #226	; 0xe2
7001f52c:	e12fff33 	blx	r3

    /* setup default value */
    *sessp = &_def_session;
7001f530:	e51b2020 	ldr	r2, [fp, #-32]
7001f534:	e3083e58 	movw	r3, #36440	; 0x8e58
7001f538:	e3473002 	movt	r3, #28674	; 0x7002
7001f53c:	e5823000 	str	r3, [r2]

    /* no name space left */
    if (flen < sizeof(id) + 2)
7001f540:	e51b301c 	ldr	r3, [fp, #-28]
7001f544:	e3530005 	cmp	r3, #5
7001f548:	8a000001 	bhi	7001f554 <_lg_parse_session+0x144>
        return 0;
7001f54c:	e3a03000 	mov	r3, #0
7001f550:	ea000031 	b	7001f61c <_lg_parse_session+0x20c>

    if (fmt[0] != '[')
7001f554:	e51b3018 	ldr	r3, [fp, #-24]
7001f558:	e5d33000 	ldrb	r3, [r3]
7001f55c:	e353005b 	cmp	r3, #91	; 0x5b
7001f560:	0a000001 	beq	7001f56c <_lg_parse_session+0x15c>
        return 0;
7001f564:	e3a03000 	mov	r3, #0
7001f568:	ea00002b 	b	7001f61c <_lg_parse_session+0x20c>

    id.num = 0;
7001f56c:	e3a03000 	mov	r3, #0
7001f570:	e50b3010 	str	r3, [fp, #-16]
    /* skip '[' and convert the string to id number. */
    for (i = 1; fmt[i] != ']'; i++)
7001f574:	e3a03001 	mov	r3, #1
7001f578:	e50b3008 	str	r3, [fp, #-8]
7001f57c:	ea000012 	b	7001f5cc <_lg_parse_session+0x1bc>
    {
        if (i - 1 == sizeof(id))
7001f580:	e51b3008 	ldr	r3, [fp, #-8]
7001f584:	e3530005 	cmp	r3, #5
7001f588:	1a000001 	bne	7001f594 <_lg_parse_session+0x184>
            return 0;
7001f58c:	e3a03000 	mov	r3, #0
7001f590:	ea000021 	b	7001f61c <_lg_parse_session+0x20c>
        id.name[i-1] = fmt[i];
7001f594:	e51b3008 	ldr	r3, [fp, #-8]
7001f598:	e2431001 	sub	r1, r3, #1
7001f59c:	e51b2018 	ldr	r2, [fp, #-24]
7001f5a0:	e51b3008 	ldr	r3, [fp, #-8]
7001f5a4:	e0823003 	add	r3, r2, r3
7001f5a8:	e5d32000 	ldrb	r2, [r3]
7001f5ac:	e3e0300b 	mvn	r3, #11
7001f5b0:	e24b0004 	sub	r0, fp, #4
7001f5b4:	e0801001 	add	r1, r0, r1
7001f5b8:	e0813003 	add	r3, r1, r3
7001f5bc:	e5c32000 	strb	r2, [r3]
    if (fmt[0] != '[')
        return 0;

    id.num = 0;
    /* skip '[' and convert the string to id number. */
    for (i = 1; fmt[i] != ']'; i++)
7001f5c0:	e51b3008 	ldr	r3, [fp, #-8]
7001f5c4:	e2833001 	add	r3, r3, #1
7001f5c8:	e50b3008 	str	r3, [fp, #-8]
7001f5cc:	e51b2018 	ldr	r2, [fp, #-24]
7001f5d0:	e51b3008 	ldr	r3, [fp, #-8]
7001f5d4:	e0823003 	add	r3, r2, r3
7001f5d8:	e5d33000 	ldrb	r3, [r3]
7001f5dc:	e353005d 	cmp	r3, #93	; 0x5d
7001f5e0:	1affffe6 	bne	7001f580 <_lg_parse_session+0x170>
    {
        if (i - 1 == sizeof(id))
            return 0;
        id.name[i-1] = fmt[i];
    }
    tmpsess = _lg_lookup_session(id.num);
7001f5e4:	e51b3010 	ldr	r3, [fp, #-16]
7001f5e8:	e1a00003 	mov	r0, r3
7001f5ec:	ebfffddf 	bl	7001ed70 <_lg_lookup_session>
7001f5f0:	e50b000c 	str	r0, [fp, #-12]
    if (tmpsess != RT_NULL)
7001f5f4:	e51b300c 	ldr	r3, [fp, #-12]
7001f5f8:	e3530000 	cmp	r3, #0
7001f5fc:	0a000005 	beq	7001f618 <_lg_parse_session+0x208>
    {
        *sessp = tmpsess;
7001f600:	e51b3020 	ldr	r3, [fp, #-32]
7001f604:	e51b200c 	ldr	r2, [fp, #-12]
7001f608:	e5832000 	str	r2, [r3]
        /* only count the header length when we found the session. So
         * the wrong [name] will be printed out. */
        return i + 1;
7001f60c:	e51b3008 	ldr	r3, [fp, #-8]
7001f610:	e2833001 	add	r3, r3, #1
7001f614:	ea000000 	b	7001f61c <_lg_parse_session+0x20c>
    }

    return 0;
7001f618:	e3a03000 	mov	r3, #0
}
7001f61c:	e1a00003 	mov	r0, r3
7001f620:	e24bd004 	sub	sp, fp, #4
7001f624:	e8bd8800 	pop	{fp, pc}

7001f628 <__logtrace_vfmtout>:

void __logtrace_vfmtout(const struct log_trace_session *session,
                        const char *fmt,
                        va_list argptr)
{
7001f628:	e92d4830 	push	{r4, r5, fp, lr}
7001f62c:	e28db00c 	add	fp, sp, #12
7001f630:	e24dd020 	sub	sp, sp, #32
7001f634:	e50b0020 	str	r0, [fp, #-32]
7001f638:	e50b1024 	str	r1, [fp, #-36]	; 0x24
7001f63c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    /* 1 for ']' */
    static char _trace_buf[1+LOG_TRACE_BUFSZ];
    char *ptr;
    rt_size_t length;

    RT_ASSERT(session);
7001f640:	e51b3020 	ldr	r3, [fp, #-32]
7001f644:	e3530000 	cmp	r3, #0
7001f648:	1a00001d 	bne	7001f6c4 <__logtrace_vfmtout+0x9c>
7001f64c:	e3a03000 	mov	r3, #0
7001f650:	e54b3015 	strb	r3, [fp, #-21]
7001f654:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f658:	e3473002 	movt	r3, #28674	; 0x7002
7001f65c:	e5933000 	ldr	r3, [r3]
7001f660:	e3530000 	cmp	r3, #0
7001f664:	1a00000d 	bne	7001f6a0 <__logtrace_vfmtout+0x78>
7001f668:	e3080640 	movw	r0, #34368	; 0x8640
7001f66c:	e3470002 	movt	r0, #28674	; 0x7002
7001f670:	e30816e8 	movw	r1, #34536	; 0x86e8
7001f674:	e3471002 	movt	r1, #28674	; 0x7002
7001f678:	e30827e4 	movw	r2, #34788	; 0x87e4
7001f67c:	e3472002 	movt	r2, #28674	; 0x7002
7001f680:	e300310b 	movw	r3, #267	; 0x10b
7001f684:	ebffa05a 	bl	700077f4 <rt_kprintf>
7001f688:	e1a00000 	nop			; (mov r0, r0)
7001f68c:	e55b3015 	ldrb	r3, [fp, #-21]
7001f690:	e6ef3073 	uxtb	r3, r3
7001f694:	e3530000 	cmp	r3, #0
7001f698:	0afffffb 	beq	7001f68c <__logtrace_vfmtout+0x64>
7001f69c:	ea000008 	b	7001f6c4 <__logtrace_vfmtout+0x9c>
7001f6a0:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f6a4:	e3473002 	movt	r3, #28674	; 0x7002
7001f6a8:	e5933000 	ldr	r3, [r3]
7001f6ac:	e30806e8 	movw	r0, #34536	; 0x86e8
7001f6b0:	e3470002 	movt	r0, #28674	; 0x7002
7001f6b4:	e30817e4 	movw	r1, #34788	; 0x87e4
7001f6b8:	e3471002 	movt	r1, #28674	; 0x7002
7001f6bc:	e300210b 	movw	r2, #267	; 0x10b
7001f6c0:	e12fff33 	blx	r3
    RT_ASSERT(fmt);
7001f6c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
7001f6c8:	e3530000 	cmp	r3, #0
7001f6cc:	1a00001d 	bne	7001f748 <__logtrace_vfmtout+0x120>
7001f6d0:	e3a03000 	mov	r3, #0
7001f6d4:	e54b3016 	strb	r3, [fp, #-22]
7001f6d8:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f6dc:	e3473002 	movt	r3, #28674	; 0x7002
7001f6e0:	e5933000 	ldr	r3, [r3]
7001f6e4:	e3530000 	cmp	r3, #0
7001f6e8:	1a00000d 	bne	7001f724 <__logtrace_vfmtout+0xfc>
7001f6ec:	e3080640 	movw	r0, #34368	; 0x8640
7001f6f0:	e3470002 	movt	r0, #28674	; 0x7002
7001f6f4:	e30816d4 	movw	r1, #34516	; 0x86d4
7001f6f8:	e3471002 	movt	r1, #28674	; 0x7002
7001f6fc:	e30827e4 	movw	r2, #34788	; 0x87e4
7001f700:	e3472002 	movt	r2, #28674	; 0x7002
7001f704:	e3a03f43 	mov	r3, #268	; 0x10c
7001f708:	ebffa039 	bl	700077f4 <rt_kprintf>
7001f70c:	e1a00000 	nop			; (mov r0, r0)
7001f710:	e55b3016 	ldrb	r3, [fp, #-22]
7001f714:	e6ef3073 	uxtb	r3, r3
7001f718:	e3530000 	cmp	r3, #0
7001f71c:	0afffffb 	beq	7001f710 <__logtrace_vfmtout+0xe8>
7001f720:	ea000008 	b	7001f748 <__logtrace_vfmtout+0x120>
7001f724:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f728:	e3473002 	movt	r3, #28674	; 0x7002
7001f72c:	e5933000 	ldr	r3, [r3]
7001f730:	e30806d4 	movw	r0, #34516	; 0x86d4
7001f734:	e3470002 	movt	r0, #28674	; 0x7002
7001f738:	e30817e4 	movw	r1, #34788	; 0x87e4
7001f73c:	e3471002 	movt	r1, #28674	; 0x7002
7001f740:	e3a02f43 	mov	r2, #268	; 0x10c
7001f744:	e12fff33 	blx	r3

    rt_snprintf(_trace_buf, sizeof(_trace_buf), "[%08x][", rt_tick_get());
7001f748:	ebff83df 	bl	700006cc <rt_tick_get>
7001f74c:	e1a03000 	mov	r3, r0
7001f750:	e30a0ab4 	movw	r0, #43700	; 0xaab4
7001f754:	e3470002 	movt	r0, #28674	; 0x7002
7001f758:	e3a01081 	mov	r1, #129	; 0x81
7001f75c:	e30826f0 	movw	r2, #34544	; 0x86f0
7001f760:	e3472002 	movt	r2, #28674	; 0x7002
7001f764:	ebff9fb7 	bl	70007648 <rt_snprintf>
    if (_traceout_device != RT_NULL)
7001f768:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001f76c:	e3473002 	movt	r3, #28674	; 0x7002
7001f770:	e5933000 	ldr	r3, [r3]
7001f774:	e3530000 	cmp	r3, #0
7001f778:	0a000015 	beq	7001f7d4 <__logtrace_vfmtout+0x1ac>
    {
        rt_device_write(_traceout_device, -1, _trace_buf, 11);
7001f77c:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001f780:	e3473002 	movt	r3, #28674	; 0x7002
7001f784:	e5933000 	ldr	r3, [r3]
7001f788:	e1a00003 	mov	r0, r3
7001f78c:	e3e01000 	mvn	r1, #0
7001f790:	e30a2ab4 	movw	r2, #43700	; 0xaab4
7001f794:	e3472002 	movt	r2, #28674	; 0x7002
7001f798:	e3a0300b 	mov	r3, #11
7001f79c:	ebff8645 	bl	700010b8 <rt_device_write>
        rt_device_write(_traceout_device, -1,
7001f7a0:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001f7a4:	e3473002 	movt	r3, #28674	; 0x7002
7001f7a8:	e5935000 	ldr	r5, [r3]
                session->id.name, _idname_len(session->id.num));
7001f7ac:	e51b4020 	ldr	r4, [fp, #-32]
7001f7b0:	e51b3020 	ldr	r3, [fp, #-32]
7001f7b4:	e5933000 	ldr	r3, [r3]
7001f7b8:	e1a00003 	mov	r0, r3
7001f7bc:	ebfffd4a 	bl	7001ecec <_idname_len>
7001f7c0:	e1a03000 	mov	r3, r0

    rt_snprintf(_trace_buf, sizeof(_trace_buf), "[%08x][", rt_tick_get());
    if (_traceout_device != RT_NULL)
    {
        rt_device_write(_traceout_device, -1, _trace_buf, 11);
        rt_device_write(_traceout_device, -1,
7001f7c4:	e1a00005 	mov	r0, r5
7001f7c8:	e3e01000 	mvn	r1, #0
7001f7cc:	e1a02004 	mov	r2, r4
7001f7d0:	ebff8638 	bl	700010b8 <rt_device_write>
                session->id.name, _idname_len(session->id.num));
    }

    _trace_buf[0] = ']';
7001f7d4:	e30a3ab4 	movw	r3, #43700	; 0xaab4
7001f7d8:	e3473002 	movt	r3, #28674	; 0x7002
7001f7dc:	e3a0205d 	mov	r2, #93	; 0x5d
7001f7e0:	e5c32000 	strb	r2, [r3]
    ptr = &_trace_buf[1];
7001f7e4:	e59f3074 	ldr	r3, [pc, #116]	; 7001f860 <__logtrace_vfmtout+0x238>
7001f7e8:	e50b3014 	str	r3, [fp, #-20]
    length = rt_vsnprintf(ptr, LOG_TRACE_BUFSZ, fmt, argptr);
7001f7ec:	e51b0014 	ldr	r0, [fp, #-20]
7001f7f0:	e3a01080 	mov	r1, #128	; 0x80
7001f7f4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
7001f7f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7001f7fc:	ebff9d5f 	bl	70006d80 <rt_vsnprintf>
7001f800:	e1a03000 	mov	r3, r0
7001f804:	e50b3010 	str	r3, [fp, #-16]

    if (length >= LOG_TRACE_BUFSZ)
7001f808:	e51b3010 	ldr	r3, [fp, #-16]
7001f80c:	e353007f 	cmp	r3, #127	; 0x7f
7001f810:	9a000001 	bls	7001f81c <__logtrace_vfmtout+0x1f4>
        length = LOG_TRACE_BUFSZ - 1;
7001f814:	e3a0307f 	mov	r3, #127	; 0x7f
7001f818:	e50b3010 	str	r3, [fp, #-16]

    if (_traceout_device != RT_NULL)
7001f81c:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001f820:	e3473002 	movt	r3, #28674	; 0x7002
7001f824:	e5933000 	ldr	r3, [r3]
7001f828:	e3530000 	cmp	r3, #0
7001f82c:	0a000009 	beq	7001f858 <__logtrace_vfmtout+0x230>
    {
        rt_device_write(_traceout_device, -1, _trace_buf, length + 1);
7001f830:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001f834:	e3473002 	movt	r3, #28674	; 0x7002
7001f838:	e5932000 	ldr	r2, [r3]
7001f83c:	e51b3010 	ldr	r3, [fp, #-16]
7001f840:	e2833001 	add	r3, r3, #1
7001f844:	e1a00002 	mov	r0, r2
7001f848:	e3e01000 	mvn	r1, #0
7001f84c:	e30a2ab4 	movw	r2, #43700	; 0xaab4
7001f850:	e3472002 	movt	r2, #28674	; 0x7002
7001f854:	ebff8617 	bl	700010b8 <rt_device_write>
    }
}
7001f858:	e24bd00c 	sub	sp, fp, #12
7001f85c:	e8bd8830 	pop	{r4, r5, fp, pc}
7001f860:	7002aab5 	.word	0x7002aab5

7001f864 <log_trace>:

void log_trace(const char *fmt, ...)
{
7001f864:	e92d000f 	push	{r0, r1, r2, r3}
7001f868:	e92d4800 	push	{fp, lr}
7001f86c:	e28db004 	add	fp, sp, #4
7001f870:	e24dd010 	sub	sp, sp, #16
    va_list args;
    int level;
    struct log_trace_session *session;

    RT_ASSERT(fmt);
7001f874:	e59b3004 	ldr	r3, [fp, #4]
7001f878:	e3530000 	cmp	r3, #0
7001f87c:	1a00001d 	bne	7001f8f8 <log_trace+0x94>
7001f880:	e3a03000 	mov	r3, #0
7001f884:	e54b3011 	strb	r3, [fp, #-17]
7001f888:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f88c:	e3473002 	movt	r3, #28674	; 0x7002
7001f890:	e5933000 	ldr	r3, [r3]
7001f894:	e3530000 	cmp	r3, #0
7001f898:	1a00000d 	bne	7001f8d4 <log_trace+0x70>
7001f89c:	e3080640 	movw	r0, #34368	; 0x8640
7001f8a0:	e3470002 	movt	r0, #28674	; 0x7002
7001f8a4:	e30816d4 	movw	r1, #34516	; 0x86d4
7001f8a8:	e3471002 	movt	r1, #28674	; 0x7002
7001f8ac:	e30827f8 	movw	r2, #34808	; 0x87f8
7001f8b0:	e3472002 	movt	r2, #28674	; 0x7002
7001f8b4:	e3003129 	movw	r3, #297	; 0x129
7001f8b8:	ebff9fcd 	bl	700077f4 <rt_kprintf>
7001f8bc:	e1a00000 	nop			; (mov r0, r0)
7001f8c0:	e55b3011 	ldrb	r3, [fp, #-17]
7001f8c4:	e6ef3073 	uxtb	r3, r3
7001f8c8:	e3530000 	cmp	r3, #0
7001f8cc:	0afffffb 	beq	7001f8c0 <log_trace+0x5c>
7001f8d0:	ea000008 	b	7001f8f8 <log_trace+0x94>
7001f8d4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f8d8:	e3473002 	movt	r3, #28674	; 0x7002
7001f8dc:	e5933000 	ldr	r3, [r3]
7001f8e0:	e30806d4 	movw	r0, #34516	; 0x86d4
7001f8e4:	e3470002 	movt	r0, #28674	; 0x7002
7001f8e8:	e30817f8 	movw	r1, #34808	; 0x87f8
7001f8ec:	e3471002 	movt	r1, #28674	; 0x7002
7001f8f0:	e3002129 	movw	r2, #297	; 0x129
7001f8f4:	e12fff33 	blx	r3

    fmt += _lg_parse_lvl(fmt, strlen(fmt), &level);
7001f8f8:	e59b0004 	ldr	r0, [fp, #4]
7001f8fc:	fa00128c 	blx	70024334 <strlen>
7001f900:	e1a02000 	mov	r2, r0
7001f904:	e24b300c 	sub	r3, fp, #12
7001f908:	e59b0004 	ldr	r0, [fp, #4]
7001f90c:	e1a01002 	mov	r1, r2
7001f910:	e1a02003 	mov	r2, r3
7001f914:	ebfffe58 	bl	7001f27c <_lg_parse_lvl>
7001f918:	e1a03000 	mov	r3, r0
7001f91c:	e59b2004 	ldr	r2, [fp, #4]
7001f920:	e0823003 	add	r3, r2, r3
7001f924:	e58b3004 	str	r3, [fp, #4]
    fmt += _lg_parse_session(fmt, strlen(fmt), &session);
7001f928:	e59b0004 	ldr	r0, [fp, #4]
7001f92c:	fa001280 	blx	70024334 <strlen>
7001f930:	e1a02000 	mov	r2, r0
7001f934:	e24b3010 	sub	r3, fp, #16
7001f938:	e59b0004 	ldr	r0, [fp, #4]
7001f93c:	e1a01002 	mov	r1, r2
7001f940:	e1a02003 	mov	r2, r3
7001f944:	ebfffeb1 	bl	7001f410 <_lg_parse_session>
7001f948:	e1a03000 	mov	r3, r0
7001f94c:	e59b2004 	ldr	r2, [fp, #4]
7001f950:	e0823003 	add	r3, r2, r3
7001f954:	e58b3004 	str	r3, [fp, #4]

    /* filter by level */
    if (level > session->lvl)
7001f958:	e51b3010 	ldr	r3, [fp, #-16]
7001f95c:	e5d33004 	ldrb	r3, [r3, #4]
7001f960:	e1a02003 	mov	r2, r3
7001f964:	e51b300c 	ldr	r3, [fp, #-12]
7001f968:	e1520003 	cmp	r2, r3
7001f96c:	ba000006 	blt	7001f98c <log_trace+0x128>
        return;

    va_start(args, fmt);
7001f970:	e28b3008 	add	r3, fp, #8
7001f974:	e50b3008 	str	r3, [fp, #-8]
    __logtrace_vfmtout(session, fmt, args);
7001f978:	e51b3010 	ldr	r3, [fp, #-16]
7001f97c:	e1a00003 	mov	r0, r3
7001f980:	e59b1004 	ldr	r1, [fp, #4]
7001f984:	e51b2008 	ldr	r2, [fp, #-8]
7001f988:	ebffff26 	bl	7001f628 <__logtrace_vfmtout>
    va_end(args);
}
7001f98c:	e24bd004 	sub	sp, fp, #4
7001f990:	e8bd4800 	pop	{fp, lr}
7001f994:	e28dd010 	add	sp, sp, #16
7001f998:	e12fff1e 	bx	lr

7001f99c <log_session>:
FINSH_FUNCTION_EXPORT(log_trace, log trace);

void log_session(const struct log_trace_session *session, const char *fmt, ...)
{
7001f99c:	e92d000e 	push	{r1, r2, r3}
7001f9a0:	e92d4800 	push	{fp, lr}
7001f9a4:	e28db004 	add	fp, sp, #4
7001f9a8:	e24dd01c 	sub	sp, sp, #28
7001f9ac:	e50b001c 	str	r0, [fp, #-28]
    va_list args;
    int level;

    RT_ASSERT(session);
7001f9b0:	e51b301c 	ldr	r3, [fp, #-28]
7001f9b4:	e3530000 	cmp	r3, #0
7001f9b8:	1a00001d 	bne	7001fa34 <log_session+0x98>
7001f9bc:	e3a03000 	mov	r3, #0
7001f9c0:	e54b3011 	strb	r3, [fp, #-17]
7001f9c4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001f9c8:	e3473002 	movt	r3, #28674	; 0x7002
7001f9cc:	e5933000 	ldr	r3, [r3]
7001f9d0:	e3530000 	cmp	r3, #0
7001f9d4:	1a00000d 	bne	7001fa10 <log_session+0x74>
7001f9d8:	e3080640 	movw	r0, #34368	; 0x8640
7001f9dc:	e3470002 	movt	r0, #28674	; 0x7002
7001f9e0:	e30816e8 	movw	r1, #34536	; 0x86e8
7001f9e4:	e3471002 	movt	r1, #28674	; 0x7002
7001f9e8:	e3082804 	movw	r2, #34820	; 0x8804
7001f9ec:	e3472002 	movt	r2, #28674	; 0x7002
7001f9f0:	e300313d 	movw	r3, #317	; 0x13d
7001f9f4:	ebff9f7e 	bl	700077f4 <rt_kprintf>
7001f9f8:	e1a00000 	nop			; (mov r0, r0)
7001f9fc:	e55b3011 	ldrb	r3, [fp, #-17]
7001fa00:	e6ef3073 	uxtb	r3, r3
7001fa04:	e3530000 	cmp	r3, #0
7001fa08:	0afffffb 	beq	7001f9fc <log_session+0x60>
7001fa0c:	ea000008 	b	7001fa34 <log_session+0x98>
7001fa10:	e30a3b74 	movw	r3, #43892	; 0xab74
7001fa14:	e3473002 	movt	r3, #28674	; 0x7002
7001fa18:	e5933000 	ldr	r3, [r3]
7001fa1c:	e30806e8 	movw	r0, #34536	; 0x86e8
7001fa20:	e3470002 	movt	r0, #28674	; 0x7002
7001fa24:	e3081804 	movw	r1, #34820	; 0x8804
7001fa28:	e3471002 	movt	r1, #28674	; 0x7002
7001fa2c:	e300213d 	movw	r2, #317	; 0x13d
7001fa30:	e12fff33 	blx	r3
    RT_ASSERT(fmt);
7001fa34:	e59b3004 	ldr	r3, [fp, #4]
7001fa38:	e3530000 	cmp	r3, #0
7001fa3c:	1a00001d 	bne	7001fab8 <log_session+0x11c>
7001fa40:	e3a03000 	mov	r3, #0
7001fa44:	e54b3012 	strb	r3, [fp, #-18]
7001fa48:	e30a3b74 	movw	r3, #43892	; 0xab74
7001fa4c:	e3473002 	movt	r3, #28674	; 0x7002
7001fa50:	e5933000 	ldr	r3, [r3]
7001fa54:	e3530000 	cmp	r3, #0
7001fa58:	1a00000d 	bne	7001fa94 <log_session+0xf8>
7001fa5c:	e3080640 	movw	r0, #34368	; 0x8640
7001fa60:	e3470002 	movt	r0, #28674	; 0x7002
7001fa64:	e30816d4 	movw	r1, #34516	; 0x86d4
7001fa68:	e3471002 	movt	r1, #28674	; 0x7002
7001fa6c:	e3082804 	movw	r2, #34820	; 0x8804
7001fa70:	e3472002 	movt	r2, #28674	; 0x7002
7001fa74:	e300313e 	movw	r3, #318	; 0x13e
7001fa78:	ebff9f5d 	bl	700077f4 <rt_kprintf>
7001fa7c:	e1a00000 	nop			; (mov r0, r0)
7001fa80:	e55b3012 	ldrb	r3, [fp, #-18]
7001fa84:	e6ef3073 	uxtb	r3, r3
7001fa88:	e3530000 	cmp	r3, #0
7001fa8c:	0afffffb 	beq	7001fa80 <log_session+0xe4>
7001fa90:	ea000008 	b	7001fab8 <log_session+0x11c>
7001fa94:	e30a3b74 	movw	r3, #43892	; 0xab74
7001fa98:	e3473002 	movt	r3, #28674	; 0x7002
7001fa9c:	e5933000 	ldr	r3, [r3]
7001faa0:	e30806d4 	movw	r0, #34516	; 0x86d4
7001faa4:	e3470002 	movt	r0, #28674	; 0x7002
7001faa8:	e3081804 	movw	r1, #34820	; 0x8804
7001faac:	e3471002 	movt	r1, #28674	; 0x7002
7001fab0:	e300213e 	movw	r2, #318	; 0x13e
7001fab4:	e12fff33 	blx	r3

    fmt += _lg_parse_lvl(fmt, strlen(fmt), &level);
7001fab8:	e59b0004 	ldr	r0, [fp, #4]
7001fabc:	fa00121c 	blx	70024334 <strlen>
7001fac0:	e1a02000 	mov	r2, r0
7001fac4:	e24b3010 	sub	r3, fp, #16
7001fac8:	e59b0004 	ldr	r0, [fp, #4]
7001facc:	e1a01002 	mov	r1, r2
7001fad0:	e1a02003 	mov	r2, r3
7001fad4:	ebfffde8 	bl	7001f27c <_lg_parse_lvl>
7001fad8:	e1a03000 	mov	r3, r0
7001fadc:	e59b2004 	ldr	r2, [fp, #4]
7001fae0:	e0823003 	add	r3, r2, r3
7001fae4:	e58b3004 	str	r3, [fp, #4]
    if (level > session->lvl)
7001fae8:	e51b301c 	ldr	r3, [fp, #-28]
7001faec:	e5d33004 	ldrb	r3, [r3, #4]
7001faf0:	e1a02003 	mov	r2, r3
7001faf4:	e51b3010 	ldr	r3, [fp, #-16]
7001faf8:	e1520003 	cmp	r2, r3
7001fafc:	ba000005 	blt	7001fb18 <log_session+0x17c>
        return;

    va_start(args, fmt);
7001fb00:	e28b3008 	add	r3, fp, #8
7001fb04:	e50b300c 	str	r3, [fp, #-12]
    __logtrace_vfmtout(session, fmt, args);
7001fb08:	e51b001c 	ldr	r0, [fp, #-28]
7001fb0c:	e59b1004 	ldr	r1, [fp, #4]
7001fb10:	e51b200c 	ldr	r2, [fp, #-12]
7001fb14:	ebfffec3 	bl	7001f628 <__logtrace_vfmtout>
    va_end(args);
}
7001fb18:	e24bd004 	sub	sp, fp, #4
7001fb1c:	e8bd4800 	pop	{fp, lr}
7001fb20:	e28dd00c 	add	sp, sp, #12
7001fb24:	e12fff1e 	bx	lr

7001fb28 <log_trace_flush>:

void log_trace_flush(void)
{
7001fb28:	e92d4800 	push	{fp, lr}
7001fb2c:	e28db004 	add	fp, sp, #4
    rt_device_control(_traceout_device, LOG_TRACE_CTRL_FLUSH, RT_NULL);
7001fb30:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fb34:	e3473002 	movt	r3, #28674	; 0x7002
7001fb38:	e5933000 	ldr	r3, [r3]
7001fb3c:	e1a00003 	mov	r0, r3
7001fb40:	e3a01010 	mov	r1, #16
7001fb44:	e3a02000 	mov	r2, #0
7001fb48:	ebff859d 	bl	700011c4 <rt_device_control>
}
7001fb4c:	e8bd8800 	pop	{fp, pc}

7001fb50 <_log_write>:
FINSH_FUNCTION_EXPORT_ALIAS(log_trace_flush, log_flush, flush log on the buffer);

/* RT-Thread common device interface */
static rt_size_t _log_write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size)
{
7001fb50:	e92d4830 	push	{r4, r5, fp, lr}
7001fb54:	e28db00c 	add	fp, sp, #12
7001fb58:	e24dd028 	sub	sp, sp, #40	; 0x28
7001fb5c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
7001fb60:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
7001fb64:	e50b2030 	str	r2, [fp, #-48]	; 0x30
7001fb68:	e50b3034 	str	r3, [fp, #-52]	; 0x34
    char c;
    int level;
    rt_size_t head_len;
    const char *ptr = buffer;
7001fb6c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
7001fb70:	e50b3010 	str	r3, [fp, #-16]
    struct log_trace_session *session;

    head_len = _lg_parse_lvl(ptr, size, &level);
7001fb74:	e24b301c 	sub	r3, fp, #28
7001fb78:	e51b0010 	ldr	r0, [fp, #-16]
7001fb7c:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
7001fb80:	e1a02003 	mov	r2, r3
7001fb84:	ebfffdbc 	bl	7001f27c <_lg_parse_lvl>
7001fb88:	e50b0014 	str	r0, [fp, #-20]
    head_len += _lg_parse_session(ptr+head_len, size-head_len, &session);
7001fb8c:	e51b2010 	ldr	r2, [fp, #-16]
7001fb90:	e51b3014 	ldr	r3, [fp, #-20]
7001fb94:	e0821003 	add	r1, r2, r3
7001fb98:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
7001fb9c:	e51b3014 	ldr	r3, [fp, #-20]
7001fba0:	e0632002 	rsb	r2, r3, r2
7001fba4:	e24b3020 	sub	r3, fp, #32
7001fba8:	e1a00001 	mov	r0, r1
7001fbac:	e1a01002 	mov	r1, r2
7001fbb0:	e1a02003 	mov	r2, r3
7001fbb4:	ebfffe15 	bl	7001f410 <_lg_parse_session>
7001fbb8:	e1a03000 	mov	r3, r0
7001fbbc:	e51b2014 	ldr	r2, [fp, #-20]
7001fbc0:	e0823003 	add	r3, r2, r3
7001fbc4:	e50b3014 	str	r3, [fp, #-20]

    /* filter by level */
    if (level > session->lvl)
7001fbc8:	e51b3020 	ldr	r3, [fp, #-32]
7001fbcc:	e5d33004 	ldrb	r3, [r3, #4]
7001fbd0:	e1a02003 	mov	r2, r3
7001fbd4:	e51b301c 	ldr	r3, [fp, #-28]
7001fbd8:	e1520003 	cmp	r2, r3
7001fbdc:	aa000001 	bge	7001fbe8 <_log_write+0x98>
        return size;
7001fbe0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
7001fbe4:	ea000035 	b	7001fcc0 <_log_write+0x170>

    if (_traceout_device != RT_NULL)
7001fbe8:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fbec:	e3473002 	movt	r3, #28674	; 0x7002
7001fbf0:	e5933000 	ldr	r3, [r3]
7001fbf4:	e3530000 	cmp	r3, #0
7001fbf8:	0a00002f 	beq	7001fcbc <_log_write+0x16c>
    {
        c = '[';
7001fbfc:	e3a0305b 	mov	r3, #91	; 0x5b
7001fc00:	e54b3015 	strb	r3, [fp, #-21]
        rt_device_write(_traceout_device, -1, &c, 1);
7001fc04:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fc08:	e3473002 	movt	r3, #28674	; 0x7002
7001fc0c:	e5932000 	ldr	r2, [r3]
7001fc10:	e24b3015 	sub	r3, fp, #21
7001fc14:	e1a00002 	mov	r0, r2
7001fc18:	e3e01000 	mvn	r1, #0
7001fc1c:	e1a02003 	mov	r2, r3
7001fc20:	e3a03001 	mov	r3, #1
7001fc24:	ebff8523 	bl	700010b8 <rt_device_write>
        rt_device_write(_traceout_device, -1, session->id.name, _idname_len(session->id.num));
7001fc28:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fc2c:	e3473002 	movt	r3, #28674	; 0x7002
7001fc30:	e5935000 	ldr	r5, [r3]
7001fc34:	e51b3020 	ldr	r3, [fp, #-32]
7001fc38:	e1a04003 	mov	r4, r3
7001fc3c:	e51b3020 	ldr	r3, [fp, #-32]
7001fc40:	e5933000 	ldr	r3, [r3]
7001fc44:	e1a00003 	mov	r0, r3
7001fc48:	ebfffc27 	bl	7001ecec <_idname_len>
7001fc4c:	e1a03000 	mov	r3, r0
7001fc50:	e1a00005 	mov	r0, r5
7001fc54:	e3e01000 	mvn	r1, #0
7001fc58:	e1a02004 	mov	r2, r4
7001fc5c:	ebff8515 	bl	700010b8 <rt_device_write>
        c = ']';
7001fc60:	e3a0305d 	mov	r3, #93	; 0x5d
7001fc64:	e54b3015 	strb	r3, [fp, #-21]
        rt_device_write(_traceout_device, -1, &c, 1);
7001fc68:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fc6c:	e3473002 	movt	r3, #28674	; 0x7002
7001fc70:	e5932000 	ldr	r2, [r3]
7001fc74:	e24b3015 	sub	r3, fp, #21
7001fc78:	e1a00002 	mov	r0, r2
7001fc7c:	e3e01000 	mvn	r1, #0
7001fc80:	e1a02003 	mov	r2, r3
7001fc84:	e3a03001 	mov	r3, #1
7001fc88:	ebff850a 	bl	700010b8 <rt_device_write>
        rt_device_write(_traceout_device, -1, ((char*)buffer)+head_len, size - head_len);
7001fc8c:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fc90:	e3473002 	movt	r3, #28674	; 0x7002
7001fc94:	e5931000 	ldr	r1, [r3]
7001fc98:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
7001fc9c:	e51b3014 	ldr	r3, [fp, #-20]
7001fca0:	e0822003 	add	r2, r2, r3
7001fca4:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
7001fca8:	e51b3014 	ldr	r3, [fp, #-20]
7001fcac:	e0633000 	rsb	r3, r3, r0
7001fcb0:	e1a00001 	mov	r0, r1
7001fcb4:	e3e01000 	mvn	r1, #0
7001fcb8:	ebff84fe 	bl	700010b8 <rt_device_write>
    }

    return size;
7001fcbc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
}
7001fcc0:	e1a00003 	mov	r0, r3
7001fcc4:	e24bd00c 	sub	sp, fp, #12
7001fcc8:	e8bd8830 	pop	{r4, r5, fp, pc}

7001fccc <_log_control>:

static rt_err_t _log_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
7001fccc:	e92d4800 	push	{fp, lr}
7001fcd0:	e28db004 	add	fp, sp, #4
7001fcd4:	e24dd010 	sub	sp, sp, #16
7001fcd8:	e50b0008 	str	r0, [fp, #-8]
7001fcdc:	e1a03001 	mov	r3, r1
7001fce0:	e50b2010 	str	r2, [fp, #-16]
7001fce4:	e54b3009 	strb	r3, [fp, #-9]
    if (_traceout_device == RT_NULL) return -RT_ERROR;
7001fce8:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fcec:	e3473002 	movt	r3, #28674	; 0x7002
7001fcf0:	e5933000 	ldr	r3, [r3]
7001fcf4:	e3530000 	cmp	r3, #0
7001fcf8:	1a000001 	bne	7001fd04 <_log_control+0x38>
7001fcfc:	e3e03000 	mvn	r3, #0
7001fd00:	ea000008 	b	7001fd28 <_log_control+0x5c>

    return rt_device_control(_traceout_device, cmd, arg);
7001fd04:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fd08:	e3473002 	movt	r3, #28674	; 0x7002
7001fd0c:	e5932000 	ldr	r2, [r3]
7001fd10:	e55b3009 	ldrb	r3, [fp, #-9]
7001fd14:	e1a00002 	mov	r0, r2
7001fd18:	e1a01003 	mov	r1, r3
7001fd1c:	e51b2010 	ldr	r2, [fp, #-16]
7001fd20:	ebff8527 	bl	700011c4 <rt_device_control>
7001fd24:	e1a03000 	mov	r3, r0
}
7001fd28:	e1a00003 	mov	r0, r3
7001fd2c:	e24bd004 	sub	sp, fp, #4
7001fd30:	e8bd8800 	pop	{fp, pc}

7001fd34 <log_trace_init>:

int log_trace_init(void)
{
7001fd34:	e92d4800 	push	{fp, lr}
7001fd38:	e28db004 	add	fp, sp, #4
    rt_memset(&_log_device, 0x00, sizeof(_log_device));
7001fd3c:	e30a0a74 	movw	r0, #43636	; 0xaa74
7001fd40:	e3470002 	movt	r0, #28674	; 0x7002
7001fd44:	e3a01000 	mov	r1, #0
7001fd48:	e3a0203c 	mov	r2, #60	; 0x3c
7001fd4c:	ebff98ae 	bl	7000600c <rt_memset>

    _log_device.type = RT_Device_Class_Char;
7001fd50:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fd54:	e3473002 	movt	r3, #28674	; 0x7002
7001fd58:	e3a02000 	mov	r2, #0
7001fd5c:	e5c32010 	strb	r2, [r3, #16]
    _log_device.init    = RT_NULL;
7001fd60:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fd64:	e3473002 	movt	r3, #28674	; 0x7002
7001fd68:	e3a02000 	mov	r2, #0
7001fd6c:	e5832020 	str	r2, [r3, #32]
    _log_device.open    = RT_NULL;
7001fd70:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fd74:	e3473002 	movt	r3, #28674	; 0x7002
7001fd78:	e3a02000 	mov	r2, #0
7001fd7c:	e5832024 	str	r2, [r3, #36]	; 0x24
    _log_device.close   = RT_NULL;
7001fd80:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fd84:	e3473002 	movt	r3, #28674	; 0x7002
7001fd88:	e3a02000 	mov	r2, #0
7001fd8c:	e5832028 	str	r2, [r3, #40]	; 0x28
    _log_device.read    = RT_NULL;
7001fd90:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fd94:	e3473002 	movt	r3, #28674	; 0x7002
7001fd98:	e3a02000 	mov	r2, #0
7001fd9c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    _log_device.write   = _log_write;
7001fda0:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fda4:	e3473002 	movt	r3, #28674	; 0x7002
7001fda8:	e30f2b50 	movw	r2, #64336	; 0xfb50
7001fdac:	e3472001 	movt	r2, #28673	; 0x7001
7001fdb0:	e5832030 	str	r2, [r3, #48]	; 0x30
    _log_device.control = _log_control;
7001fdb4:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fdb8:	e3473002 	movt	r3, #28674	; 0x7002
7001fdbc:	e30f2ccc 	movw	r2, #64716	; 0xfccc
7001fdc0:	e3472001 	movt	r2, #28673	; 0x7001
7001fdc4:	e5832034 	str	r2, [r3, #52]	; 0x34

    /* no indication and complete callback */
    _log_device.rx_indicate = RT_NULL;
7001fdc8:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fdcc:	e3473002 	movt	r3, #28674	; 0x7002
7001fdd0:	e3a02000 	mov	r2, #0
7001fdd4:	e5832018 	str	r2, [r3, #24]
    _log_device.tx_complete = RT_NULL;
7001fdd8:	e30a3a74 	movw	r3, #43636	; 0xaa74
7001fddc:	e3473002 	movt	r3, #28674	; 0x7002
7001fde0:	e3a02000 	mov	r2, #0
7001fde4:	e583201c 	str	r2, [r3, #28]

    rt_device_register(&_log_device, "log", RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR);
7001fde8:	e30a0a74 	movw	r0, #43636	; 0xaa74
7001fdec:	e3470002 	movt	r0, #28674	; 0x7002
7001fdf0:	e3081734 	movw	r1, #34612	; 0x8734
7001fdf4:	e3471002 	movt	r1, #28674	; 0x7002
7001fdf8:	e3a02043 	mov	r2, #67	; 0x43
7001fdfc:	ebff82b4 	bl	700008d4 <rt_device_register>

	/* set console as default device */
	_traceout_device = rt_console_get_device();
7001fe00:	ebff9e45 	bl	7000771c <rt_console_get_device>
7001fe04:	e1a02000 	mov	r2, r0
7001fe08:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fe0c:	e3473002 	movt	r3, #28674	; 0x7002
7001fe10:	e5832000 	str	r2, [r3]

    return 0;
7001fe14:	e3a03000 	mov	r3, #0
}
7001fe18:	e1a00003 	mov	r0, r3
7001fe1c:	e8bd8800 	pop	{fp, pc}

7001fe20 <log_trace_get_device>:

rt_device_t log_trace_get_device(void)
{
7001fe20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001fe24:	e28db000 	add	fp, sp, #0
    return _traceout_device;
7001fe28:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fe2c:	e3473002 	movt	r3, #28674	; 0x7002
7001fe30:	e5933000 	ldr	r3, [r3]
}
7001fe34:	e1a00003 	mov	r0, r3
7001fe38:	e24bd000 	sub	sp, fp, #0
7001fe3c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001fe40:	e12fff1e 	bx	lr

7001fe44 <log_trace_set_device>:

rt_err_t log_trace_set_device(const char *device_name)
{
7001fe44:	e92d4800 	push	{fp, lr}
7001fe48:	e28db004 	add	fp, sp, #4
7001fe4c:	e24dd010 	sub	sp, sp, #16
7001fe50:	e50b0010 	str	r0, [fp, #-16]
    struct rt_device *output_device;

    /* find out output device */
    output_device = rt_device_find(device_name);
7001fe54:	e51b0010 	ldr	r0, [fp, #-16]
7001fe58:	ebff82f2 	bl	70000a28 <rt_device_find>
7001fe5c:	e50b0008 	str	r0, [fp, #-8]
    if (output_device != RT_NULL)
7001fe60:	e51b3008 	ldr	r3, [fp, #-8]
7001fe64:	e3530000 	cmp	r3, #0
7001fe68:	0a00000b 	beq	7001fe9c <log_trace_set_device+0x58>
    {
        rt_err_t result;

        /* open device */
        result = rt_device_open(output_device, RT_DEVICE_FLAG_STREAM | RT_DEVICE_OFLAG_RDWR);
7001fe6c:	e51b0008 	ldr	r0, [fp, #-8]
7001fe70:	e3a01043 	mov	r1, #67	; 0x43
7001fe74:	ebff8367 	bl	70000c18 <rt_device_open>
7001fe78:	e50b000c 	str	r0, [fp, #-12]
        if (result != RT_EOK)
7001fe7c:	e51b300c 	ldr	r3, [fp, #-12]
7001fe80:	e3530000 	cmp	r3, #0
7001fe84:	0a000004 	beq	7001fe9c <log_trace_set_device+0x58>
        {
            rt_kprintf("Open trace device failed.\n");
7001fe88:	e3080738 	movw	r0, #34616	; 0x8738
7001fe8c:	e3470002 	movt	r0, #28674	; 0x7002
7001fe90:	ebff9e57 	bl	700077f4 <rt_kprintf>
            return -RT_ERROR;
7001fe94:	e3e03000 	mvn	r3, #0
7001fe98:	ea00000e 	b	7001fed8 <log_trace_set_device+0x94>
        }
    }

    /* set trace out device */
    if (_traceout_device != RT_NULL)
7001fe9c:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fea0:	e3473002 	movt	r3, #28674	; 0x7002
7001fea4:	e5933000 	ldr	r3, [r3]
7001fea8:	e3530000 	cmp	r3, #0
7001feac:	0a000004 	beq	7001fec4 <log_trace_set_device+0x80>
        rt_device_close(_traceout_device);
7001feb0:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001feb4:	e3473002 	movt	r3, #28674	; 0x7002
7001feb8:	e5933000 	ldr	r3, [r3]
7001febc:	e1a00003 	mov	r0, r3
7001fec0:	ebff83ea 	bl	70000e70 <rt_device_close>
    _traceout_device = output_device;
7001fec4:	e30a3ab0 	movw	r3, #43696	; 0xaab0
7001fec8:	e3473002 	movt	r3, #28674	; 0x7002
7001fecc:	e51b2008 	ldr	r2, [fp, #-8]
7001fed0:	e5832000 	str	r2, [r3]

    return RT_EOK;
7001fed4:	e3a03000 	mov	r3, #0
}
7001fed8:	e1a00003 	mov	r0, r3
7001fedc:	e24bd004 	sub	sp, fp, #4
7001fee0:	e8bd8800 	pop	{fp, pc}

7001fee4 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
7001fee4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001fee8:	e28db000 	add	fp, sp, #0
7001feec:	e24dd00c 	sub	sp, sp, #12
7001fef0:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
7001fef4:	e51b3008 	ldr	r3, [fp, #-8]
7001fef8:	e51b2008 	ldr	r2, [fp, #-8]
7001fefc:	e5832004 	str	r2, [r3, #4]
7001ff00:	e51b3008 	ldr	r3, [fp, #-8]
7001ff04:	e5932004 	ldr	r2, [r3, #4]
7001ff08:	e51b3008 	ldr	r3, [fp, #-8]
7001ff0c:	e5832000 	str	r2, [r3]
}
7001ff10:	e24bd000 	sub	sp, fp, #0
7001ff14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ff18:	e12fff1e 	bx	lr

7001ff1c <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
7001ff1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001ff20:	e28db000 	add	fp, sp, #0
7001ff24:	e24dd00c 	sub	sp, sp, #12
7001ff28:	e50b0008 	str	r0, [fp, #-8]
7001ff2c:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
7001ff30:	e51b3008 	ldr	r3, [fp, #-8]
7001ff34:	e5933004 	ldr	r3, [r3, #4]
7001ff38:	e51b200c 	ldr	r2, [fp, #-12]
7001ff3c:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
7001ff40:	e51b3008 	ldr	r3, [fp, #-8]
7001ff44:	e5932004 	ldr	r2, [r3, #4]
7001ff48:	e51b300c 	ldr	r3, [fp, #-12]
7001ff4c:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
7001ff50:	e51b3008 	ldr	r3, [fp, #-8]
7001ff54:	e51b200c 	ldr	r2, [fp, #-12]
7001ff58:	e5832004 	str	r2, [r3, #4]
    n->next = l;
7001ff5c:	e51b300c 	ldr	r3, [fp, #-12]
7001ff60:	e51b2008 	ldr	r2, [fp, #-8]
7001ff64:	e5832000 	str	r2, [r3]
}
7001ff68:	e24bd000 	sub	sp, fp, #0
7001ff6c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ff70:	e12fff1e 	bx	lr

7001ff74 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
7001ff74:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
7001ff78:	e28db000 	add	fp, sp, #0
7001ff7c:	e24dd00c 	sub	sp, sp, #12
7001ff80:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
7001ff84:	e51b3008 	ldr	r3, [fp, #-8]
7001ff88:	e5932000 	ldr	r2, [r3]
7001ff8c:	e51b3008 	ldr	r3, [fp, #-8]
7001ff90:	e1520003 	cmp	r2, r3
7001ff94:	13a03000 	movne	r3, #0
7001ff98:	03a03001 	moveq	r3, #1
7001ff9c:	e6ef3073 	uxtb	r3, r3
}
7001ffa0:	e1a00003 	mov	r0, r3
7001ffa4:	e24bd000 	sub	sp, fp, #0
7001ffa8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
7001ffac:	e12fff1e 	bx	lr

7001ffb0 <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
7001ffb0:	e92d4800 	push	{fp, lr}
7001ffb4:	e28db004 	add	fp, sp, #4
7001ffb8:	e24dd010 	sub	sp, sp, #16
7001ffbc:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
7001ffc0:	e51b3010 	ldr	r3, [fp, #-16]
7001ffc4:	e3530000 	cmp	r3, #0
7001ffc8:	1a00001d 	bne	70020044 <rt_completion_init+0x94>
7001ffcc:	e3a03000 	mov	r3, #0
7001ffd0:	e54b3009 	strb	r3, [fp, #-9]
7001ffd4:	e30a3b74 	movw	r3, #43892	; 0xab74
7001ffd8:	e3473002 	movt	r3, #28674	; 0x7002
7001ffdc:	e5933000 	ldr	r3, [r3]
7001ffe0:	e3530000 	cmp	r3, #0
7001ffe4:	1a00000d 	bne	70020020 <rt_completion_init+0x70>
7001ffe8:	e3080810 	movw	r0, #34832	; 0x8810
7001ffec:	e3470002 	movt	r0, #28674	; 0x7002
7001fff0:	e3081830 	movw	r1, #34864	; 0x8830
7001fff4:	e3471002 	movt	r1, #28674	; 0x7002
7001fff8:	e30828a0 	movw	r2, #34976	; 0x88a0
7001fffc:	e3472002 	movt	r2, #28674	; 0x7002
70020000:	e3a03023 	mov	r3, #35	; 0x23
70020004:	ebff9dfa 	bl	700077f4 <rt_kprintf>
70020008:	e1a00000 	nop			; (mov r0, r0)
7002000c:	e55b3009 	ldrb	r3, [fp, #-9]
70020010:	e6ef3073 	uxtb	r3, r3
70020014:	e3530000 	cmp	r3, #0
70020018:	0afffffb 	beq	7002000c <rt_completion_init+0x5c>
7002001c:	ea000008 	b	70020044 <rt_completion_init+0x94>
70020020:	e30a3b74 	movw	r3, #43892	; 0xab74
70020024:	e3473002 	movt	r3, #28674	; 0x7002
70020028:	e5933000 	ldr	r3, [r3]
7002002c:	e3080830 	movw	r0, #34864	; 0x8830
70020030:	e3470002 	movt	r0, #28674	; 0x7002
70020034:	e30818a0 	movw	r1, #34976	; 0x88a0
70020038:	e3471002 	movt	r1, #28674	; 0x7002
7002003c:	e3a02023 	mov	r2, #35	; 0x23
70020040:	e12fff33 	blx	r3

    level = rt_hw_interrupt_disable();
70020044:	ebffb87f 	bl	7000e248 <rt_hw_interrupt_disable>
70020048:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_UNCOMPLETED;
7002004c:	e51b3010 	ldr	r3, [fp, #-16]
70020050:	e3a02000 	mov	r2, #0
70020054:	e5832000 	str	r2, [r3]
    rt_list_init(&completion->suspended_list);
70020058:	e51b3010 	ldr	r3, [fp, #-16]
7002005c:	e2833004 	add	r3, r3, #4
70020060:	e1a00003 	mov	r0, r3
70020064:	ebffff9e 	bl	7001fee4 <rt_list_init>
    rt_hw_interrupt_enable(level);
70020068:	e51b0008 	ldr	r0, [fp, #-8]
7002006c:	ebffb878 	bl	7000e254 <rt_hw_interrupt_enable>
}
70020070:	e24bd004 	sub	sp, fp, #4
70020074:	e8bd8800 	pop	{fp, pc}

70020078 <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
70020078:	e92d4800 	push	{fp, lr}
7002007c:	e28db004 	add	fp, sp, #4
70020080:	e24dd020 	sub	sp, sp, #32
70020084:	e50b0020 	str	r0, [fp, #-32]
70020088:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
7002008c:	e51b3020 	ldr	r3, [fp, #-32]
70020090:	e3530000 	cmp	r3, #0
70020094:	1a00001d 	bne	70020110 <rt_completion_wait+0x98>
70020098:	e3a03000 	mov	r3, #0
7002009c:	e54b3015 	strb	r3, [fp, #-21]
700200a0:	e30a3b74 	movw	r3, #43892	; 0xab74
700200a4:	e3473002 	movt	r3, #28674	; 0x7002
700200a8:	e5933000 	ldr	r3, [r3]
700200ac:	e3530000 	cmp	r3, #0
700200b0:	1a00000d 	bne	700200ec <rt_completion_wait+0x74>
700200b4:	e3080810 	movw	r0, #34832	; 0x8810
700200b8:	e3470002 	movt	r0, #28674	; 0x7002
700200bc:	e3081830 	movw	r1, #34864	; 0x8830
700200c0:	e3471002 	movt	r1, #28674	; 0x7002
700200c4:	e30828b4 	movw	r2, #34996	; 0x88b4
700200c8:	e3472002 	movt	r2, #28674	; 0x7002
700200cc:	e3a03032 	mov	r3, #50	; 0x32
700200d0:	ebff9dc7 	bl	700077f4 <rt_kprintf>
700200d4:	e1a00000 	nop			; (mov r0, r0)
700200d8:	e55b3015 	ldrb	r3, [fp, #-21]
700200dc:	e6ef3073 	uxtb	r3, r3
700200e0:	e3530000 	cmp	r3, #0
700200e4:	0afffffb 	beq	700200d8 <rt_completion_wait+0x60>
700200e8:	ea000008 	b	70020110 <rt_completion_wait+0x98>
700200ec:	e30a3b74 	movw	r3, #43892	; 0xab74
700200f0:	e3473002 	movt	r3, #28674	; 0x7002
700200f4:	e5933000 	ldr	r3, [r3]
700200f8:	e3080830 	movw	r0, #34864	; 0x8830
700200fc:	e3470002 	movt	r0, #28674	; 0x7002
70020100:	e30818b4 	movw	r1, #34996	; 0x88b4
70020104:	e3471002 	movt	r1, #28674	; 0x7002
70020108:	e3a02032 	mov	r2, #50	; 0x32
7002010c:	e12fff33 	blx	r3

    result = RT_EOK;
70020110:	e3a03000 	mov	r3, #0
70020114:	e50b3008 	str	r3, [fp, #-8]
    thread = rt_thread_self();
70020118:	ebffa914 	bl	7000a570 <rt_thread_self>
7002011c:	e50b0010 	str	r0, [fp, #-16]

    level = rt_hw_interrupt_disable();
70020120:	ebffb848 	bl	7000e248 <rt_hw_interrupt_disable>
70020124:	e50b000c 	str	r0, [fp, #-12]
    if (completion->flag != RT_COMPLETED)
70020128:	e51b3020 	ldr	r3, [fp, #-32]
7002012c:	e5933000 	ldr	r3, [r3]
70020130:	e3530001 	cmp	r3, #1
70020134:	0a000077 	beq	70020318 <rt_completion_wait+0x2a0>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
70020138:	e51b3020 	ldr	r3, [fp, #-32]
7002013c:	e2833004 	add	r3, r3, #4
70020140:	e1a00003 	mov	r0, r3
70020144:	ebffff8a 	bl	7001ff74 <rt_list_isempty>
70020148:	e1a03000 	mov	r3, r0
7002014c:	e3530000 	cmp	r3, #0
70020150:	1a00001d 	bne	700201cc <rt_completion_wait+0x154>
70020154:	e3a03000 	mov	r3, #0
70020158:	e54b3016 	strb	r3, [fp, #-22]
7002015c:	e30a3b74 	movw	r3, #43892	; 0xab74
70020160:	e3473002 	movt	r3, #28674	; 0x7002
70020164:	e5933000 	ldr	r3, [r3]
70020168:	e3530000 	cmp	r3, #0
7002016c:	1a00000d 	bne	700201a8 <rt_completion_wait+0x130>
70020170:	e3080810 	movw	r0, #34832	; 0x8810
70020174:	e3470002 	movt	r0, #28674	; 0x7002
70020178:	e3081848 	movw	r1, #34888	; 0x8848
7002017c:	e3471002 	movt	r1, #28674	; 0x7002
70020180:	e30828b4 	movw	r2, #34996	; 0x88b4
70020184:	e3472002 	movt	r2, #28674	; 0x7002
70020188:	e3a0303b 	mov	r3, #59	; 0x3b
7002018c:	ebff9d98 	bl	700077f4 <rt_kprintf>
70020190:	e1a00000 	nop			; (mov r0, r0)
70020194:	e55b3016 	ldrb	r3, [fp, #-22]
70020198:	e6ef3073 	uxtb	r3, r3
7002019c:	e3530000 	cmp	r3, #0
700201a0:	0afffffb 	beq	70020194 <rt_completion_wait+0x11c>
700201a4:	ea000008 	b	700201cc <rt_completion_wait+0x154>
700201a8:	e30a3b74 	movw	r3, #43892	; 0xab74
700201ac:	e3473002 	movt	r3, #28674	; 0x7002
700201b0:	e5933000 	ldr	r3, [r3]
700201b4:	e3080848 	movw	r0, #34888	; 0x8848
700201b8:	e3470002 	movt	r0, #28674	; 0x7002
700201bc:	e30818b4 	movw	r1, #34996	; 0x88b4
700201c0:	e3471002 	movt	r1, #28674	; 0x7002
700201c4:	e3a0203b 	mov	r2, #59	; 0x3b
700201c8:	e12fff33 	blx	r3

        if (timeout == 0)
700201cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700201d0:	e3530000 	cmp	r3, #0
700201d4:	1a000002 	bne	700201e4 <rt_completion_wait+0x16c>
        {
            result = -RT_ETIMEOUT;
700201d8:	e3e03001 	mvn	r3, #1
700201dc:	e50b3008 	str	r3, [fp, #-8]
            goto __exit;
700201e0:	ea00004f 	b	70020324 <rt_completion_wait+0x2ac>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
700201e4:	e51b3010 	ldr	r3, [fp, #-16]
700201e8:	e3a02000 	mov	r2, #0
700201ec:	e583202c 	str	r2, [r3, #44]	; 0x2c

            /* suspend thread */
            rt_thread_suspend(thread);
700201f0:	e51b0010 	ldr	r0, [fp, #-16]
700201f4:	ebffaacc 	bl	7000ad2c <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
700201f8:	e51b3020 	ldr	r3, [fp, #-32]
700201fc:	e2832004 	add	r2, r3, #4
70020200:	e51b3010 	ldr	r3, [fp, #-16]
70020204:	e2833010 	add	r3, r3, #16
70020208:	e1a00002 	mov	r0, r2
7002020c:	e1a01003 	mov	r1, r3
70020210:	ebffff41 	bl	7001ff1c <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
70020214:	ebffb80b 	bl	7000e248 <rt_hw_interrupt_disable>
70020218:	e50b0014 	str	r0, [fp, #-20]
7002021c:	ebff9724 	bl	70005eb4 <rt_interrupt_get_nest>
70020220:	e1a03000 	mov	r3, r0
70020224:	e3530000 	cmp	r3, #0
70020228:	0a000022 	beq	700202b8 <rt_completion_wait+0x240>
7002022c:	e3080878 	movw	r0, #34936	; 0x8878
70020230:	e3470002 	movt	r0, #28674	; 0x7002
70020234:	e30818b4 	movw	r1, #34996	; 0x88b4
70020238:	e3471002 	movt	r1, #28674	; 0x7002
7002023c:	ebff9d6c 	bl	700077f4 <rt_kprintf>
70020240:	e3a03000 	mov	r3, #0
70020244:	e54b3017 	strb	r3, [fp, #-23]
70020248:	e30a3b74 	movw	r3, #43892	; 0xab74
7002024c:	e3473002 	movt	r3, #28674	; 0x7002
70020250:	e5933000 	ldr	r3, [r3]
70020254:	e3530000 	cmp	r3, #0
70020258:	1a00000d 	bne	70020294 <rt_completion_wait+0x21c>
7002025c:	e3080810 	movw	r0, #34832	; 0x8810
70020260:	e3470002 	movt	r0, #28674	; 0x7002
70020264:	e308189c 	movw	r1, #34972	; 0x889c
70020268:	e3471002 	movt	r1, #28674	; 0x7002
7002026c:	e30828b4 	movw	r2, #34996	; 0x88b4
70020270:	e3472002 	movt	r2, #28674	; 0x7002
70020274:	e3a0304e 	mov	r3, #78	; 0x4e
70020278:	ebff9d5d 	bl	700077f4 <rt_kprintf>
7002027c:	e1a00000 	nop			; (mov r0, r0)
70020280:	e55b3017 	ldrb	r3, [fp, #-23]
70020284:	e6ef3073 	uxtb	r3, r3
70020288:	e3530000 	cmp	r3, #0
7002028c:	0afffffb 	beq	70020280 <rt_completion_wait+0x208>
70020290:	ea000008 	b	700202b8 <rt_completion_wait+0x240>
70020294:	e30a3b74 	movw	r3, #43892	; 0xab74
70020298:	e3473002 	movt	r3, #28674	; 0x7002
7002029c:	e5933000 	ldr	r3, [r3]
700202a0:	e308089c 	movw	r0, #34972	; 0x889c
700202a4:	e3470002 	movt	r0, #28674	; 0x7002
700202a8:	e30818b4 	movw	r1, #34996	; 0x88b4
700202ac:	e3471002 	movt	r1, #28674	; 0x7002
700202b0:	e3a0204e 	mov	r2, #78	; 0x4e
700202b4:	e12fff33 	blx	r3
700202b8:	e51b0014 	ldr	r0, [fp, #-20]
700202bc:	ebffb7e4 	bl	7000e254 <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
700202c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
700202c4:	e3530000 	cmp	r3, #0
700202c8:	da00000a 	ble	700202f8 <rt_completion_wait+0x280>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
700202cc:	e51b3010 	ldr	r3, [fp, #-16]
700202d0:	e2832048 	add	r2, r3, #72	; 0x48
700202d4:	e24b3024 	sub	r3, fp, #36	; 0x24
700202d8:	e1a00002 	mov	r0, r2
700202dc:	e3a01000 	mov	r1, #0
700202e0:	e1a02003 	mov	r2, r3
700202e4:	ebffae3f 	bl	7000bbe8 <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
700202e8:	e51b3010 	ldr	r3, [fp, #-16]
700202ec:	e2833048 	add	r3, r3, #72	; 0x48
700202f0:	e1a00003 	mov	r0, r3
700202f4:	ebffacef 	bl	7000b6b8 <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
700202f8:	e51b000c 	ldr	r0, [fp, #-12]
700202fc:	ebffb7d4 	bl	7000e254 <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
70020300:	ebffa637 	bl	70009be4 <rt_schedule>

            /* thread is waked up */
            result = thread->error;
70020304:	e51b3010 	ldr	r3, [fp, #-16]
70020308:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
7002030c:	e50b3008 	str	r3, [fp, #-8]

            level = rt_hw_interrupt_disable();
70020310:	ebffb7cc 	bl	7000e248 <rt_hw_interrupt_disable>
70020314:	e50b000c 	str	r0, [fp, #-12]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
70020318:	e51b3020 	ldr	r3, [fp, #-32]
7002031c:	e3a02000 	mov	r2, #0
70020320:	e5832000 	str	r2, [r3]

__exit:
    rt_hw_interrupt_enable(level);
70020324:	e51b000c 	ldr	r0, [fp, #-12]
70020328:	ebffb7c9 	bl	7000e254 <rt_hw_interrupt_enable>

    return result;
7002032c:	e51b3008 	ldr	r3, [fp, #-8]
}
70020330:	e1a00003 	mov	r0, r3
70020334:	e24bd004 	sub	sp, fp, #4
70020338:	e8bd8800 	pop	{fp, pc}

7002033c <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
7002033c:	e92d4800 	push	{fp, lr}
70020340:	e28db004 	add	fp, sp, #4
70020344:	e24dd018 	sub	sp, sp, #24
70020348:	e50b0018 	str	r0, [fp, #-24]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
7002034c:	e51b3018 	ldr	r3, [fp, #-24]
70020350:	e3530000 	cmp	r3, #0
70020354:	1a00001d 	bne	700203d0 <rt_completion_done+0x94>
70020358:	e3a03000 	mov	r3, #0
7002035c:	e54b300d 	strb	r3, [fp, #-13]
70020360:	e30a3b74 	movw	r3, #43892	; 0xab74
70020364:	e3473002 	movt	r3, #28674	; 0x7002
70020368:	e5933000 	ldr	r3, [r3]
7002036c:	e3530000 	cmp	r3, #0
70020370:	1a00000d 	bne	700203ac <rt_completion_done+0x70>
70020374:	e3080810 	movw	r0, #34832	; 0x8810
70020378:	e3470002 	movt	r0, #28674	; 0x7002
7002037c:	e3081830 	movw	r1, #34864	; 0x8830
70020380:	e3471002 	movt	r1, #28674	; 0x7002
70020384:	e30828c8 	movw	r2, #35016	; 0x88c8
70020388:	e3472002 	movt	r2, #28674	; 0x7002
7002038c:	e3a03072 	mov	r3, #114	; 0x72
70020390:	ebff9d17 	bl	700077f4 <rt_kprintf>
70020394:	e1a00000 	nop			; (mov r0, r0)
70020398:	e55b300d 	ldrb	r3, [fp, #-13]
7002039c:	e6ef3073 	uxtb	r3, r3
700203a0:	e3530000 	cmp	r3, #0
700203a4:	0afffffb 	beq	70020398 <rt_completion_done+0x5c>
700203a8:	ea000008 	b	700203d0 <rt_completion_done+0x94>
700203ac:	e30a3b74 	movw	r3, #43892	; 0xab74
700203b0:	e3473002 	movt	r3, #28674	; 0x7002
700203b4:	e5933000 	ldr	r3, [r3]
700203b8:	e3080830 	movw	r0, #34864	; 0x8830
700203bc:	e3470002 	movt	r0, #28674	; 0x7002
700203c0:	e30818c8 	movw	r1, #35016	; 0x88c8
700203c4:	e3471002 	movt	r1, #28674	; 0x7002
700203c8:	e3a02072 	mov	r2, #114	; 0x72
700203cc:	e12fff33 	blx	r3

    if (completion->flag == RT_COMPLETED)
700203d0:	e51b3018 	ldr	r3, [fp, #-24]
700203d4:	e5933000 	ldr	r3, [r3]
700203d8:	e3530001 	cmp	r3, #1
700203dc:	1a000000 	bne	700203e4 <rt_completion_done+0xa8>
        return;
700203e0:	ea000017 	b	70020444 <rt_completion_done+0x108>

    level = rt_hw_interrupt_disable();
700203e4:	ebffb797 	bl	7000e248 <rt_hw_interrupt_disable>
700203e8:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_COMPLETED;
700203ec:	e51b3018 	ldr	r3, [fp, #-24]
700203f0:	e3a02001 	mov	r2, #1
700203f4:	e5832000 	str	r2, [r3]

    if (!rt_list_isempty(&(completion->suspended_list)))
700203f8:	e51b3018 	ldr	r3, [fp, #-24]
700203fc:	e2833004 	add	r3, r3, #4
70020400:	e1a00003 	mov	r0, r3
70020404:	ebfffeda 	bl	7001ff74 <rt_list_isempty>
70020408:	e1a03000 	mov	r3, r0
7002040c:	e3530000 	cmp	r3, #0
70020410:	1a000009 	bne	7002043c <rt_completion_done+0x100>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
70020414:	e51b3018 	ldr	r3, [fp, #-24]
70020418:	e5933004 	ldr	r3, [r3, #4]
7002041c:	e2433010 	sub	r3, r3, #16
70020420:	e50b300c 	str	r3, [fp, #-12]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
70020424:	e51b000c 	ldr	r0, [fp, #-12]
70020428:	ebffaa7c 	bl	7000ae20 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
7002042c:	e51b0008 	ldr	r0, [fp, #-8]
70020430:	ebffb787 	bl	7000e254 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
70020434:	ebffa5ea 	bl	70009be4 <rt_schedule>
70020438:	ea000001 	b	70020444 <rt_completion_done+0x108>
    }
    else
    {
        rt_hw_interrupt_enable(level);
7002043c:	e51b0008 	ldr	r0, [fp, #-8]
70020440:	ebffb783 	bl	7000e254 <rt_hw_interrupt_enable>
    }
}
70020444:	e24bd004 	sub	sp, fp, #4
70020448:	e8bd8800 	pop	{fp, pc}

7002044c <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
7002044c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70020450:	e28db000 	add	fp, sp, #0
70020454:	e24dd00c 	sub	sp, sp, #12
70020458:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
7002045c:	e51b3008 	ldr	r3, [fp, #-8]
70020460:	e51b2008 	ldr	r2, [fp, #-8]
70020464:	e5832004 	str	r2, [r3, #4]
70020468:	e51b3008 	ldr	r3, [fp, #-8]
7002046c:	e5932004 	ldr	r2, [r3, #4]
70020470:	e51b3008 	ldr	r3, [fp, #-8]
70020474:	e5832000 	str	r2, [r3]
}
70020478:	e24bd000 	sub	sp, fp, #0
7002047c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70020480:	e12fff1e 	bx	lr

70020484 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
70020484:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
70020488:	e28db000 	add	fp, sp, #0
7002048c:	e24dd00c 	sub	sp, sp, #12
70020490:	e50b0008 	str	r0, [fp, #-8]
70020494:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
70020498:	e51b3008 	ldr	r3, [fp, #-8]
7002049c:	e5933004 	ldr	r3, [r3, #4]
700204a0:	e51b200c 	ldr	r2, [fp, #-12]
700204a4:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
700204a8:	e51b3008 	ldr	r3, [fp, #-8]
700204ac:	e5932004 	ldr	r2, [r3, #4]
700204b0:	e51b300c 	ldr	r3, [fp, #-12]
700204b4:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
700204b8:	e51b3008 	ldr	r3, [fp, #-8]
700204bc:	e51b200c 	ldr	r2, [fp, #-12]
700204c0:	e5832004 	str	r2, [r3, #4]
    n->next = l;
700204c4:	e51b300c 	ldr	r3, [fp, #-12]
700204c8:	e51b2008 	ldr	r2, [fp, #-8]
700204cc:	e5832000 	str	r2, [r3]
}
700204d0:	e24bd000 	sub	sp, fp, #0
700204d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
700204d8:	e12fff1e 	bx	lr

700204dc <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
700204dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
700204e0:	e28db000 	add	fp, sp, #0
700204e4:	e24dd00c 	sub	sp, sp, #12
700204e8:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
700204ec:	e51b3008 	ldr	r3, [fp, #-8]
700204f0:	e5932000 	ldr	r2, [r3]
700204f4:	e51b3008 	ldr	r3, [fp, #-8]
700204f8:	e1520003 	cmp	r2, r3
700204fc:	13a03000 	movne	r3, #0
70020500:	03a03001 	moveq	r3, #1
70020504:	e6ef3073 	uxtb	r3, r3
}
70020508:	e1a00003 	mov	r0, r3
7002050c:	e24bd000 	sub	sp, fp, #0
70020510:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
70020514:	e12fff1e 	bx	lr

70020518 <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
70020518:	e92d4800 	push	{fp, lr}
7002051c:	e28db004 	add	fp, sp, #4
70020520:	e24dd018 	sub	sp, sp, #24
70020524:	e50b0010 	str	r0, [fp, #-16]
70020528:	e50b3018 	str	r3, [fp, #-24]
7002052c:	e14b11b2 	strh	r1, [fp, #-18]	; 0xffffffee
70020530:	e14b21b4 	strh	r2, [fp, #-20]	; 0xffffffec
    RT_ASSERT(queue != RT_NULL);
70020534:	e51b3010 	ldr	r3, [fp, #-16]
70020538:	e3530000 	cmp	r3, #0
7002053c:	1a00001d 	bne	700205b8 <rt_data_queue_init+0xa0>
70020540:	e3a03000 	mov	r3, #0
70020544:	e54b3005 	strb	r3, [fp, #-5]
70020548:	e30a3b74 	movw	r3, #43892	; 0xab74
7002054c:	e3473002 	movt	r3, #28674	; 0x7002
70020550:	e5933000 	ldr	r3, [r3]
70020554:	e3530000 	cmp	r3, #0
70020558:	1a00000d 	bne	70020594 <rt_data_queue_init+0x7c>
7002055c:	e30808dc 	movw	r0, #35036	; 0x88dc
70020560:	e3470002 	movt	r0, #28674	; 0x7002
70020564:	e30818fc 	movw	r1, #35068	; 0x88fc
70020568:	e3471002 	movt	r1, #28674	; 0x7002
7002056c:	e308295c 	movw	r2, #35164	; 0x895c
70020570:	e3472002 	movt	r2, #28674	; 0x7002
70020574:	e3a03029 	mov	r3, #41	; 0x29
70020578:	ebff9c9d 	bl	700077f4 <rt_kprintf>
7002057c:	e1a00000 	nop			; (mov r0, r0)
70020580:	e55b3005 	ldrb	r3, [fp, #-5]
70020584:	e6ef3073 	uxtb	r3, r3
70020588:	e3530000 	cmp	r3, #0
7002058c:	0afffffb 	beq	70020580 <rt_data_queue_init+0x68>
70020590:	ea000008 	b	700205b8 <rt_data_queue_init+0xa0>
70020594:	e30a3b74 	movw	r3, #43892	; 0xab74
70020598:	e3473002 	movt	r3, #28674	; 0x7002
7002059c:	e5933000 	ldr	r3, [r3]
700205a0:	e30808fc 	movw	r0, #35068	; 0x88fc
700205a4:	e3470002 	movt	r0, #28674	; 0x7002
700205a8:	e308195c 	movw	r1, #35164	; 0x895c
700205ac:	e3471002 	movt	r1, #28674	; 0x7002
700205b0:	e3a02029 	mov	r2, #41	; 0x29
700205b4:	e12fff33 	blx	r3

    queue->evt_notify = evt_notify;
700205b8:	e51b3010 	ldr	r3, [fp, #-16]
700205bc:	e51b2018 	ldr	r2, [fp, #-24]
700205c0:	e5832020 	str	r2, [r3, #32]

    queue->size = size;
700205c4:	e51b3010 	ldr	r3, [fp, #-16]
700205c8:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
700205cc:	e1c320b0 	strh	r2, [r3]
    queue->lwm = lwm;
700205d0:	e51b3010 	ldr	r3, [fp, #-16]
700205d4:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
700205d8:	e1c320b2 	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
700205dc:	e51b3010 	ldr	r3, [fp, #-16]
700205e0:	e3a02000 	mov	r2, #0
700205e4:	e5832004 	str	r2, [r3, #4]

    queue->get_index = 0;
700205e8:	e51b3010 	ldr	r3, [fp, #-16]
700205ec:	e3a02000 	mov	r2, #0
700205f0:	e1c320b8 	strh	r2, [r3, #8]
    queue->put_index = 0;
700205f4:	e51b3010 	ldr	r3, [fp, #-16]
700205f8:	e3a02000 	mov	r2, #0
700205fc:	e1c320ba 	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
70020600:	e51b3010 	ldr	r3, [fp, #-16]
70020604:	e2833010 	add	r3, r3, #16
70020608:	e1a00003 	mov	r0, r3
7002060c:	ebffff8e 	bl	7002044c <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
70020610:	e51b3010 	ldr	r3, [fp, #-16]
70020614:	e2833018 	add	r3, r3, #24
70020618:	e1a00003 	mov	r0, r3
7002061c:	ebffff8a 	bl	7002044c <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
70020620:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
70020624:	e1a03183 	lsl	r3, r3, #3
70020628:	e1a00003 	mov	r0, r3
7002062c:	ebff9ea2 	bl	700080bc <rt_malloc>
70020630:	e1a02000 	mov	r2, r0
70020634:	e51b3010 	ldr	r3, [fp, #-16]
70020638:	e583200c 	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
7002063c:	e51b3010 	ldr	r3, [fp, #-16]
70020640:	e593300c 	ldr	r3, [r3, #12]
70020644:	e3530000 	cmp	r3, #0
70020648:	1a000001 	bne	70020654 <rt_data_queue_init+0x13c>
    {
        return -RT_ENOMEM;
7002064c:	e3e03004 	mvn	r3, #4
70020650:	ea000000 	b	70020658 <rt_data_queue_init+0x140>
    }

    return RT_EOK;
70020654:	e3a03000 	mov	r3, #0
}
70020658:	e1a00003 	mov	r0, r3
7002065c:	e24bd004 	sub	sp, fp, #4
70020660:	e8bd8800 	pop	{fp, pc}

70020664 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
70020664:	e92d4800 	push	{fp, lr}
70020668:	e28db004 	add	fp, sp, #4
7002066c:	e24dd028 	sub	sp, sp, #40	; 0x28
70020670:	e50b0020 	str	r0, [fp, #-32]
70020674:	e50b1024 	str	r1, [fp, #-36]	; 0x24
70020678:	e50b2028 	str	r2, [fp, #-40]	; 0x28
7002067c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
70020680:	e51b3020 	ldr	r3, [fp, #-32]
70020684:	e3530000 	cmp	r3, #0
70020688:	1a00001d 	bne	70020704 <rt_data_queue_push+0xa0>
7002068c:	e3a03000 	mov	r3, #0
70020690:	e54b3019 	strb	r3, [fp, #-25]
70020694:	e30a3b74 	movw	r3, #43892	; 0xab74
70020698:	e3473002 	movt	r3, #28674	; 0x7002
7002069c:	e5933000 	ldr	r3, [r3]
700206a0:	e3530000 	cmp	r3, #0
700206a4:	1a00000d 	bne	700206e0 <rt_data_queue_push+0x7c>
700206a8:	e30808dc 	movw	r0, #35036	; 0x88dc
700206ac:	e3470002 	movt	r0, #28674	; 0x7002
700206b0:	e30818fc 	movw	r1, #35068	; 0x88fc
700206b4:	e3471002 	movt	r1, #28674	; 0x7002
700206b8:	e3082970 	movw	r2, #35184	; 0x8970
700206bc:	e3472002 	movt	r2, #28674	; 0x7002
700206c0:	e3a0304b 	mov	r3, #75	; 0x4b
700206c4:	ebff9c4a 	bl	700077f4 <rt_kprintf>
700206c8:	e1a00000 	nop			; (mov r0, r0)
700206cc:	e55b3019 	ldrb	r3, [fp, #-25]
700206d0:	e6ef3073 	uxtb	r3, r3
700206d4:	e3530000 	cmp	r3, #0
700206d8:	0afffffb 	beq	700206cc <rt_data_queue_push+0x68>
700206dc:	ea000008 	b	70020704 <rt_data_queue_push+0xa0>
700206e0:	e30a3b74 	movw	r3, #43892	; 0xab74
700206e4:	e3473002 	movt	r3, #28674	; 0x7002
700206e8:	e5933000 	ldr	r3, [r3]
700206ec:	e30808fc 	movw	r0, #35068	; 0x88fc
700206f0:	e3470002 	movt	r0, #28674	; 0x7002
700206f4:	e3081970 	movw	r1, #35184	; 0x8970
700206f8:	e3471002 	movt	r1, #28674	; 0x7002
700206fc:	e3a0204b 	mov	r2, #75	; 0x4b
70020700:	e12fff33 	blx	r3

    result = RT_EOK;
70020704:	e3a03000 	mov	r3, #0
70020708:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
7002070c:	ebffa797 	bl	7000a570 <rt_thread_self>
70020710:	e50b0010 	str	r0, [fp, #-16]
    mask = queue->size - 1;
70020714:	e51b3020 	ldr	r3, [fp, #-32]
70020718:	e1d330b0 	ldrh	r3, [r3]
7002071c:	e2433001 	sub	r3, r3, #1
70020720:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
70020724:	ebffb6c7 	bl	7000e248 <rt_hw_interrupt_disable>
70020728:	e1a03000 	mov	r3, r0
7002072c:	e50b3008 	str	r3, [fp, #-8]
    while (queue->put_index - queue->get_index == queue->size)
70020730:	ea00005b 	b	700208a4 <rt_data_queue_push+0x240>
    {
        queue->waiting_lwm = RT_TRUE;
70020734:	e51b3020 	ldr	r3, [fp, #-32]
70020738:	e3a02001 	mov	r2, #1
7002073c:	e5832004 	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
70020740:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70020744:	e3530000 	cmp	r3, #0
70020748:	1a000002 	bne	70020758 <rt_data_queue_push+0xf4>
        {
            result = -RT_ETIMEOUT;
7002074c:	e3e03001 	mvn	r3, #1
70020750:	e50b300c 	str	r3, [fp, #-12]

            goto __exit;
70020754:	ea00008b 	b	70020988 <rt_data_queue_push+0x324>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
70020758:	ebffb6ba 	bl	7000e248 <rt_hw_interrupt_disable>
7002075c:	e50b0018 	str	r0, [fp, #-24]
70020760:	ebff95d3 	bl	70005eb4 <rt_interrupt_get_nest>
70020764:	e1a03000 	mov	r3, r0
70020768:	e3530000 	cmp	r3, #0
7002076c:	0a000022 	beq	700207fc <rt_data_queue_push+0x198>
70020770:	e3080910 	movw	r0, #35088	; 0x8910
70020774:	e3470002 	movt	r0, #28674	; 0x7002
70020778:	e3081970 	movw	r1, #35184	; 0x8970
7002077c:	e3471002 	movt	r1, #28674	; 0x7002
70020780:	ebff9c1b 	bl	700077f4 <rt_kprintf>
70020784:	e3a03000 	mov	r3, #0
70020788:	e54b301a 	strb	r3, [fp, #-26]
7002078c:	e30a3b74 	movw	r3, #43892	; 0xab74
70020790:	e3473002 	movt	r3, #28674	; 0x7002
70020794:	e5933000 	ldr	r3, [r3]
70020798:	e3530000 	cmp	r3, #0
7002079c:	1a00000d 	bne	700207d8 <rt_data_queue_push+0x174>
700207a0:	e30808dc 	movw	r0, #35036	; 0x88dc
700207a4:	e3470002 	movt	r0, #28674	; 0x7002
700207a8:	e3081934 	movw	r1, #35124	; 0x8934
700207ac:	e3471002 	movt	r1, #28674	; 0x7002
700207b0:	e3082970 	movw	r2, #35184	; 0x8970
700207b4:	e3472002 	movt	r2, #28674	; 0x7002
700207b8:	e3a0305f 	mov	r3, #95	; 0x5f
700207bc:	ebff9c0c 	bl	700077f4 <rt_kprintf>
700207c0:	e1a00000 	nop			; (mov r0, r0)
700207c4:	e55b301a 	ldrb	r3, [fp, #-26]
700207c8:	e6ef3073 	uxtb	r3, r3
700207cc:	e3530000 	cmp	r3, #0
700207d0:	0afffffb 	beq	700207c4 <rt_data_queue_push+0x160>
700207d4:	ea000008 	b	700207fc <rt_data_queue_push+0x198>
700207d8:	e30a3b74 	movw	r3, #43892	; 0xab74
700207dc:	e3473002 	movt	r3, #28674	; 0x7002
700207e0:	e5933000 	ldr	r3, [r3]
700207e4:	e3080934 	movw	r0, #35124	; 0x8934
700207e8:	e3470002 	movt	r0, #28674	; 0x7002
700207ec:	e3081970 	movw	r1, #35184	; 0x8970
700207f0:	e3471002 	movt	r1, #28674	; 0x7002
700207f4:	e3a0205f 	mov	r2, #95	; 0x5f
700207f8:	e12fff33 	blx	r3
700207fc:	e51b0018 	ldr	r0, [fp, #-24]
70020800:	ebffb693 	bl	7000e254 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
70020804:	e51b3010 	ldr	r3, [fp, #-16]
70020808:	e3a02000 	mov	r2, #0
7002080c:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
70020810:	e51b0010 	ldr	r0, [fp, #-16]
70020814:	ebffa944 	bl	7000ad2c <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
70020818:	e51b3020 	ldr	r3, [fp, #-32]
7002081c:	e2832010 	add	r2, r3, #16
70020820:	e51b3010 	ldr	r3, [fp, #-16]
70020824:	e2833010 	add	r3, r3, #16
70020828:	e1a00002 	mov	r0, r2
7002082c:	e1a01003 	mov	r1, r3
70020830:	ebffff13 	bl	70020484 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
70020834:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70020838:	e3530000 	cmp	r3, #0
7002083c:	da00000a 	ble	7002086c <rt_data_queue_push+0x208>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
70020840:	e51b3010 	ldr	r3, [fp, #-16]
70020844:	e2832048 	add	r2, r3, #72	; 0x48
70020848:	e24b302c 	sub	r3, fp, #44	; 0x2c
7002084c:	e1a00002 	mov	r0, r2
70020850:	e3a01000 	mov	r1, #0
70020854:	e1a02003 	mov	r2, r3
70020858:	ebfface2 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
7002085c:	e51b3010 	ldr	r3, [fp, #-16]
70020860:	e2833048 	add	r3, r3, #72	; 0x48
70020864:	e1a00003 	mov	r0, r3
70020868:	ebffab92 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
7002086c:	e51b3008 	ldr	r3, [fp, #-8]
70020870:	e1a00003 	mov	r0, r3
70020874:	ebffb676 	bl	7000e254 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
70020878:	ebffa4d9 	bl	70009be4 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
7002087c:	e51b3010 	ldr	r3, [fp, #-16]
70020880:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70020884:	e50b300c 	str	r3, [fp, #-12]
        level = rt_hw_interrupt_disable();
70020888:	ebffb66e 	bl	7000e248 <rt_hw_interrupt_disable>
7002088c:	e1a03000 	mov	r3, r0
70020890:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK) goto __exit;
70020894:	e51b300c 	ldr	r3, [fp, #-12]
70020898:	e3530000 	cmp	r3, #0
7002089c:	0a000000 	beq	700208a4 <rt_data_queue_push+0x240>
700208a0:	ea000038 	b	70020988 <rt_data_queue_push+0x324>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
700208a4:	e51b3020 	ldr	r3, [fp, #-32]
700208a8:	e1d330ba 	ldrh	r3, [r3, #10]
700208ac:	e1a02003 	mov	r2, r3
700208b0:	e51b3020 	ldr	r3, [fp, #-32]
700208b4:	e1d330b8 	ldrh	r3, [r3, #8]
700208b8:	e0632002 	rsb	r2, r3, r2
700208bc:	e51b3020 	ldr	r3, [fp, #-32]
700208c0:	e1d330b0 	ldrh	r3, [r3]
700208c4:	e1520003 	cmp	r2, r3
700208c8:	0affff99 	beq	70020734 <rt_data_queue_push+0xd0>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
700208cc:	e51b3020 	ldr	r3, [fp, #-32]
700208d0:	e593200c 	ldr	r2, [r3, #12]
700208d4:	e51b3020 	ldr	r3, [fp, #-32]
700208d8:	e1d310ba 	ldrh	r1, [r3, #10]
700208dc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
700208e0:	e0013003 	and	r3, r1, r3
700208e4:	e6ff3073 	uxth	r3, r3
700208e8:	e1a03183 	lsl	r3, r3, #3
700208ec:	e0823003 	add	r3, r2, r3
700208f0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
700208f4:	e5832000 	str	r2, [r3]
    queue->queue[queue->put_index & mask].data_size = data_size;
700208f8:	e51b3020 	ldr	r3, [fp, #-32]
700208fc:	e593200c 	ldr	r2, [r3, #12]
70020900:	e51b3020 	ldr	r3, [fp, #-32]
70020904:	e1d310ba 	ldrh	r1, [r3, #10]
70020908:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
7002090c:	e0013003 	and	r3, r1, r3
70020910:	e6ff3073 	uxth	r3, r3
70020914:	e1a03183 	lsl	r3, r3, #3
70020918:	e0823003 	add	r3, r2, r3
7002091c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
70020920:	e5832004 	str	r2, [r3, #4]
    queue->put_index += 1;
70020924:	e51b3020 	ldr	r3, [fp, #-32]
70020928:	e1d330ba 	ldrh	r3, [r3, #10]
7002092c:	e2833001 	add	r3, r3, #1
70020930:	e6ff2073 	uxth	r2, r3
70020934:	e51b3020 	ldr	r3, [fp, #-32]
70020938:	e1c320ba 	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
7002093c:	e51b3020 	ldr	r3, [fp, #-32]
70020940:	e2833018 	add	r3, r3, #24
70020944:	e1a00003 	mov	r0, r3
70020948:	ebfffee3 	bl	700204dc <rt_list_isempty>
7002094c:	e1a03000 	mov	r3, r0
70020950:	e3530000 	cmp	r3, #0
70020954:	1a00000b 	bne	70020988 <rt_data_queue_push+0x324>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
70020958:	e51b3020 	ldr	r3, [fp, #-32]
7002095c:	e5933018 	ldr	r3, [r3, #24]
70020960:	e2433010 	sub	r3, r3, #16
70020964:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
70020968:	e51b0010 	ldr	r0, [fp, #-16]
7002096c:	ebffa92b 	bl	7000ae20 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
70020970:	e51b3008 	ldr	r3, [fp, #-8]
70020974:	e1a00003 	mov	r0, r3
70020978:	ebffb635 	bl	7000e254 <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
7002097c:	ebffa498 	bl	70009be4 <rt_schedule>

        return result;
70020980:	e51b300c 	ldr	r3, [fp, #-12]
70020984:	ea00000f 	b	700209c8 <rt_data_queue_push+0x364>
    }

__exit:
    rt_hw_interrupt_enable(level);
70020988:	e51b3008 	ldr	r3, [fp, #-8]
7002098c:	e1a00003 	mov	r0, r3
70020990:	ebffb62f 	bl	7000e254 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
70020994:	e51b300c 	ldr	r3, [fp, #-12]
70020998:	e3530000 	cmp	r3, #0
7002099c:	1a000008 	bne	700209c4 <rt_data_queue_push+0x360>
700209a0:	e51b3020 	ldr	r3, [fp, #-32]
700209a4:	e5933020 	ldr	r3, [r3, #32]
700209a8:	e3530000 	cmp	r3, #0
700209ac:	0a000004 	beq	700209c4 <rt_data_queue_push+0x360>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
700209b0:	e51b3020 	ldr	r3, [fp, #-32]
700209b4:	e5933020 	ldr	r3, [r3, #32]
700209b8:	e51b0020 	ldr	r0, [fp, #-32]
700209bc:	e3a01002 	mov	r1, #2
700209c0:	e12fff33 	blx	r3
    }

    return result;
700209c4:	e51b300c 	ldr	r3, [fp, #-12]
}
700209c8:	e1a00003 	mov	r0, r3
700209cc:	e24bd004 	sub	sp, fp, #4
700209d0:	e8bd8800 	pop	{fp, pc}

700209d4 <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
700209d4:	e92d4800 	push	{fp, lr}
700209d8:	e28db004 	add	fp, sp, #4
700209dc:	e24dd028 	sub	sp, sp, #40	; 0x28
700209e0:	e50b0020 	str	r0, [fp, #-32]
700209e4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
700209e8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
700209ec:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
700209f0:	e51b3020 	ldr	r3, [fp, #-32]
700209f4:	e3530000 	cmp	r3, #0
700209f8:	1a00001d 	bne	70020a74 <rt_data_queue_pop+0xa0>
700209fc:	e3a03000 	mov	r3, #0
70020a00:	e54b3019 	strb	r3, [fp, #-25]
70020a04:	e30a3b74 	movw	r3, #43892	; 0xab74
70020a08:	e3473002 	movt	r3, #28674	; 0x7002
70020a0c:	e5933000 	ldr	r3, [r3]
70020a10:	e3530000 	cmp	r3, #0
70020a14:	1a00000d 	bne	70020a50 <rt_data_queue_pop+0x7c>
70020a18:	e30808dc 	movw	r0, #35036	; 0x88dc
70020a1c:	e3470002 	movt	r0, #28674	; 0x7002
70020a20:	e30818fc 	movw	r1, #35068	; 0x88fc
70020a24:	e3471002 	movt	r1, #28674	; 0x7002
70020a28:	e3082984 	movw	r2, #35204	; 0x8984
70020a2c:	e3472002 	movt	r2, #28674	; 0x7002
70020a30:	e3a030a9 	mov	r3, #169	; 0xa9
70020a34:	ebff9b6e 	bl	700077f4 <rt_kprintf>
70020a38:	e1a00000 	nop			; (mov r0, r0)
70020a3c:	e55b3019 	ldrb	r3, [fp, #-25]
70020a40:	e6ef3073 	uxtb	r3, r3
70020a44:	e3530000 	cmp	r3, #0
70020a48:	0afffffb 	beq	70020a3c <rt_data_queue_pop+0x68>
70020a4c:	ea000008 	b	70020a74 <rt_data_queue_pop+0xa0>
70020a50:	e30a3b74 	movw	r3, #43892	; 0xab74
70020a54:	e3473002 	movt	r3, #28674	; 0x7002
70020a58:	e5933000 	ldr	r3, [r3]
70020a5c:	e30808fc 	movw	r0, #35068	; 0x88fc
70020a60:	e3470002 	movt	r0, #28674	; 0x7002
70020a64:	e3081984 	movw	r1, #35204	; 0x8984
70020a68:	e3471002 	movt	r1, #28674	; 0x7002
70020a6c:	e3a020a9 	mov	r2, #169	; 0xa9
70020a70:	e12fff33 	blx	r3
    RT_ASSERT(data_ptr != RT_NULL);
70020a74:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70020a78:	e3530000 	cmp	r3, #0
70020a7c:	1a00001d 	bne	70020af8 <rt_data_queue_pop+0x124>
70020a80:	e3a03000 	mov	r3, #0
70020a84:	e54b301a 	strb	r3, [fp, #-26]
70020a88:	e30a3b74 	movw	r3, #43892	; 0xab74
70020a8c:	e3473002 	movt	r3, #28674	; 0x7002
70020a90:	e5933000 	ldr	r3, [r3]
70020a94:	e3530000 	cmp	r3, #0
70020a98:	1a00000d 	bne	70020ad4 <rt_data_queue_pop+0x100>
70020a9c:	e30808dc 	movw	r0, #35036	; 0x88dc
70020aa0:	e3470002 	movt	r0, #28674	; 0x7002
70020aa4:	e3081938 	movw	r1, #35128	; 0x8938
70020aa8:	e3471002 	movt	r1, #28674	; 0x7002
70020aac:	e3082984 	movw	r2, #35204	; 0x8984
70020ab0:	e3472002 	movt	r2, #28674	; 0x7002
70020ab4:	e3a030aa 	mov	r3, #170	; 0xaa
70020ab8:	ebff9b4d 	bl	700077f4 <rt_kprintf>
70020abc:	e1a00000 	nop			; (mov r0, r0)
70020ac0:	e55b301a 	ldrb	r3, [fp, #-26]
70020ac4:	e6ef3073 	uxtb	r3, r3
70020ac8:	e3530000 	cmp	r3, #0
70020acc:	0afffffb 	beq	70020ac0 <rt_data_queue_pop+0xec>
70020ad0:	ea000008 	b	70020af8 <rt_data_queue_pop+0x124>
70020ad4:	e30a3b74 	movw	r3, #43892	; 0xab74
70020ad8:	e3473002 	movt	r3, #28674	; 0x7002
70020adc:	e5933000 	ldr	r3, [r3]
70020ae0:	e3080938 	movw	r0, #35128	; 0x8938
70020ae4:	e3470002 	movt	r0, #28674	; 0x7002
70020ae8:	e3081984 	movw	r1, #35204	; 0x8984
70020aec:	e3471002 	movt	r1, #28674	; 0x7002
70020af0:	e3a020aa 	mov	r2, #170	; 0xaa
70020af4:	e12fff33 	blx	r3
    RT_ASSERT(size != RT_NULL);
70020af8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70020afc:	e3530000 	cmp	r3, #0
70020b00:	1a00001d 	bne	70020b7c <rt_data_queue_pop+0x1a8>
70020b04:	e3a03000 	mov	r3, #0
70020b08:	e54b301b 	strb	r3, [fp, #-27]
70020b0c:	e30a3b74 	movw	r3, #43892	; 0xab74
70020b10:	e3473002 	movt	r3, #28674	; 0x7002
70020b14:	e5933000 	ldr	r3, [r3]
70020b18:	e3530000 	cmp	r3, #0
70020b1c:	1a00000d 	bne	70020b58 <rt_data_queue_pop+0x184>
70020b20:	e30808dc 	movw	r0, #35036	; 0x88dc
70020b24:	e3470002 	movt	r0, #28674	; 0x7002
70020b28:	e308194c 	movw	r1, #35148	; 0x894c
70020b2c:	e3471002 	movt	r1, #28674	; 0x7002
70020b30:	e3082984 	movw	r2, #35204	; 0x8984
70020b34:	e3472002 	movt	r2, #28674	; 0x7002
70020b38:	e3a030ab 	mov	r3, #171	; 0xab
70020b3c:	ebff9b2c 	bl	700077f4 <rt_kprintf>
70020b40:	e1a00000 	nop			; (mov r0, r0)
70020b44:	e55b301b 	ldrb	r3, [fp, #-27]
70020b48:	e6ef3073 	uxtb	r3, r3
70020b4c:	e3530000 	cmp	r3, #0
70020b50:	0afffffb 	beq	70020b44 <rt_data_queue_pop+0x170>
70020b54:	ea000008 	b	70020b7c <rt_data_queue_pop+0x1a8>
70020b58:	e30a3b74 	movw	r3, #43892	; 0xab74
70020b5c:	e3473002 	movt	r3, #28674	; 0x7002
70020b60:	e5933000 	ldr	r3, [r3]
70020b64:	e308094c 	movw	r0, #35148	; 0x894c
70020b68:	e3470002 	movt	r0, #28674	; 0x7002
70020b6c:	e3081984 	movw	r1, #35204	; 0x8984
70020b70:	e3471002 	movt	r1, #28674	; 0x7002
70020b74:	e3a020ab 	mov	r2, #171	; 0xab
70020b78:	e12fff33 	blx	r3

    result = RT_EOK;
70020b7c:	e3a03000 	mov	r3, #0
70020b80:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
70020b84:	ebffa679 	bl	7000a570 <rt_thread_self>
70020b88:	e50b0010 	str	r0, [fp, #-16]
    mask   = queue->size - 1;
70020b8c:	e51b3020 	ldr	r3, [fp, #-32]
70020b90:	e1d330b0 	ldrh	r3, [r3]
70020b94:	e2433001 	sub	r3, r3, #1
70020b98:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
70020b9c:	ebffb5a9 	bl	7000e248 <rt_hw_interrupt_disable>
70020ba0:	e1a03000 	mov	r3, r0
70020ba4:	e50b3008 	str	r3, [fp, #-8]
    while (queue->get_index == queue->put_index)
70020ba8:	ea000058 	b	70020d10 <rt_data_queue_pop+0x33c>
    {
        /* queue is empty */
        if (timeout == 0)
70020bac:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70020bb0:	e3530000 	cmp	r3, #0
70020bb4:	1a000002 	bne	70020bc4 <rt_data_queue_pop+0x1f0>
        {
            result = -RT_ETIMEOUT;
70020bb8:	e3e03001 	mvn	r3, #1
70020bbc:	e50b300c 	str	r3, [fp, #-12]
            goto __exit;
70020bc0:	ea0000a3 	b	70020e54 <rt_data_queue_pop+0x480>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
70020bc4:	ebffb59f 	bl	7000e248 <rt_hw_interrupt_disable>
70020bc8:	e50b0018 	str	r0, [fp, #-24]
70020bcc:	ebff94b8 	bl	70005eb4 <rt_interrupt_get_nest>
70020bd0:	e1a03000 	mov	r3, r0
70020bd4:	e3530000 	cmp	r3, #0
70020bd8:	0a000022 	beq	70020c68 <rt_data_queue_pop+0x294>
70020bdc:	e3080910 	movw	r0, #35088	; 0x8910
70020be0:	e3470002 	movt	r0, #28674	; 0x7002
70020be4:	e3081984 	movw	r1, #35204	; 0x8984
70020be8:	e3471002 	movt	r1, #28674	; 0x7002
70020bec:	ebff9b00 	bl	700077f4 <rt_kprintf>
70020bf0:	e3a03000 	mov	r3, #0
70020bf4:	e54b301c 	strb	r3, [fp, #-28]
70020bf8:	e30a3b74 	movw	r3, #43892	; 0xab74
70020bfc:	e3473002 	movt	r3, #28674	; 0x7002
70020c00:	e5933000 	ldr	r3, [r3]
70020c04:	e3530000 	cmp	r3, #0
70020c08:	1a00000d 	bne	70020c44 <rt_data_queue_pop+0x270>
70020c0c:	e30808dc 	movw	r0, #35036	; 0x88dc
70020c10:	e3470002 	movt	r0, #28674	; 0x7002
70020c14:	e3081934 	movw	r1, #35124	; 0x8934
70020c18:	e3471002 	movt	r1, #28674	; 0x7002
70020c1c:	e3082984 	movw	r2, #35204	; 0x8984
70020c20:	e3472002 	movt	r2, #28674	; 0x7002
70020c24:	e3a030bc 	mov	r3, #188	; 0xbc
70020c28:	ebff9af1 	bl	700077f4 <rt_kprintf>
70020c2c:	e1a00000 	nop			; (mov r0, r0)
70020c30:	e55b301c 	ldrb	r3, [fp, #-28]
70020c34:	e6ef3073 	uxtb	r3, r3
70020c38:	e3530000 	cmp	r3, #0
70020c3c:	0afffffb 	beq	70020c30 <rt_data_queue_pop+0x25c>
70020c40:	ea000008 	b	70020c68 <rt_data_queue_pop+0x294>
70020c44:	e30a3b74 	movw	r3, #43892	; 0xab74
70020c48:	e3473002 	movt	r3, #28674	; 0x7002
70020c4c:	e5933000 	ldr	r3, [r3]
70020c50:	e3080934 	movw	r0, #35124	; 0x8934
70020c54:	e3470002 	movt	r0, #28674	; 0x7002
70020c58:	e3081984 	movw	r1, #35204	; 0x8984
70020c5c:	e3471002 	movt	r1, #28674	; 0x7002
70020c60:	e3a020bc 	mov	r2, #188	; 0xbc
70020c64:	e12fff33 	blx	r3
70020c68:	e51b0018 	ldr	r0, [fp, #-24]
70020c6c:	ebffb578 	bl	7000e254 <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
70020c70:	e51b3010 	ldr	r3, [fp, #-16]
70020c74:	e3a02000 	mov	r2, #0
70020c78:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
70020c7c:	e51b0010 	ldr	r0, [fp, #-16]
70020c80:	ebffa829 	bl	7000ad2c <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
70020c84:	e51b3020 	ldr	r3, [fp, #-32]
70020c88:	e2832018 	add	r2, r3, #24
70020c8c:	e51b3010 	ldr	r3, [fp, #-16]
70020c90:	e2833010 	add	r3, r3, #16
70020c94:	e1a00002 	mov	r0, r2
70020c98:	e1a01003 	mov	r1, r3
70020c9c:	ebfffdf8 	bl	70020484 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
70020ca0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
70020ca4:	e3530000 	cmp	r3, #0
70020ca8:	da00000a 	ble	70020cd8 <rt_data_queue_pop+0x304>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
70020cac:	e51b3010 	ldr	r3, [fp, #-16]
70020cb0:	e2832048 	add	r2, r3, #72	; 0x48
70020cb4:	e24b302c 	sub	r3, fp, #44	; 0x2c
70020cb8:	e1a00002 	mov	r0, r2
70020cbc:	e3a01000 	mov	r1, #0
70020cc0:	e1a02003 	mov	r2, r3
70020cc4:	ebffabc7 	bl	7000bbe8 <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
70020cc8:	e51b3010 	ldr	r3, [fp, #-16]
70020ccc:	e2833048 	add	r3, r3, #72	; 0x48
70020cd0:	e1a00003 	mov	r0, r3
70020cd4:	ebffaa77 	bl	7000b6b8 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70020cd8:	e51b3008 	ldr	r3, [fp, #-8]
70020cdc:	e1a00003 	mov	r0, r3
70020ce0:	ebffb55b 	bl	7000e254 <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
70020ce4:	ebffa3be 	bl	70009be4 <rt_schedule>

        /* thread is waked up */
        result = thread->error;
70020ce8:	e51b3010 	ldr	r3, [fp, #-16]
70020cec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
70020cf0:	e50b300c 	str	r3, [fp, #-12]
        level  = rt_hw_interrupt_disable();
70020cf4:	ebffb553 	bl	7000e248 <rt_hw_interrupt_disable>
70020cf8:	e1a03000 	mov	r3, r0
70020cfc:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK)
70020d00:	e51b300c 	ldr	r3, [fp, #-12]
70020d04:	e3530000 	cmp	r3, #0
70020d08:	0a000000 	beq	70020d10 <rt_data_queue_pop+0x33c>
            goto __exit;
70020d0c:	ea000050 	b	70020e54 <rt_data_queue_pop+0x480>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
70020d10:	e51b3020 	ldr	r3, [fp, #-32]
70020d14:	e1d320b8 	ldrh	r2, [r3, #8]
70020d18:	e51b3020 	ldr	r3, [fp, #-32]
70020d1c:	e1d330ba 	ldrh	r3, [r3, #10]
70020d20:	e1520003 	cmp	r2, r3
70020d24:	0affffa0 	beq	70020bac <rt_data_queue_pop+0x1d8>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
70020d28:	e51b3020 	ldr	r3, [fp, #-32]
70020d2c:	e593200c 	ldr	r2, [r3, #12]
70020d30:	e51b3020 	ldr	r3, [fp, #-32]
70020d34:	e1d310b8 	ldrh	r1, [r3, #8]
70020d38:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
70020d3c:	e0013003 	and	r3, r1, r3
70020d40:	e6ff3073 	uxth	r3, r3
70020d44:	e1a03183 	lsl	r3, r3, #3
70020d48:	e0823003 	add	r3, r2, r3
70020d4c:	e5932000 	ldr	r2, [r3]
70020d50:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70020d54:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
70020d58:	e51b3020 	ldr	r3, [fp, #-32]
70020d5c:	e593200c 	ldr	r2, [r3, #12]
70020d60:	e51b3020 	ldr	r3, [fp, #-32]
70020d64:	e1d310b8 	ldrh	r1, [r3, #8]
70020d68:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
70020d6c:	e0013003 	and	r3, r1, r3
70020d70:	e6ff3073 	uxth	r3, r3
70020d74:	e1a03183 	lsl	r3, r3, #3
70020d78:	e0823003 	add	r3, r2, r3
70020d7c:	e5932004 	ldr	r2, [r3, #4]
70020d80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70020d84:	e5832000 	str	r2, [r3]

    queue->get_index += 1;
70020d88:	e51b3020 	ldr	r3, [fp, #-32]
70020d8c:	e1d330b8 	ldrh	r3, [r3, #8]
70020d90:	e2833001 	add	r3, r3, #1
70020d94:	e6ff2073 	uxth	r2, r3
70020d98:	e51b3020 	ldr	r3, [fp, #-32]
70020d9c:	e1c320b8 	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
70020da0:	e51b3020 	ldr	r3, [fp, #-32]
70020da4:	e5933004 	ldr	r3, [r3, #4]
70020da8:	e3530001 	cmp	r3, #1
70020dac:	1a000028 	bne	70020e54 <rt_data_queue_pop+0x480>
        (queue->put_index - queue->get_index) <= queue->lwm)
70020db0:	e51b3020 	ldr	r3, [fp, #-32]
70020db4:	e1d330ba 	ldrh	r3, [r3, #10]
70020db8:	e1a02003 	mov	r2, r3
70020dbc:	e51b3020 	ldr	r3, [fp, #-32]
70020dc0:	e1d330b8 	ldrh	r3, [r3, #8]
70020dc4:	e0632002 	rsb	r2, r3, r2
70020dc8:	e51b3020 	ldr	r3, [fp, #-32]
70020dcc:	e1d330b2 	ldrh	r3, [r3, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
70020dd0:	e1520003 	cmp	r2, r3
70020dd4:	ca00001e 	bgt	70020e54 <rt_data_queue_pop+0x480>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
70020dd8:	e51b3020 	ldr	r3, [fp, #-32]
70020ddc:	e3a02000 	mov	r2, #0
70020de0:	e5832004 	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
70020de4:	e51b3020 	ldr	r3, [fp, #-32]
70020de8:	e2833010 	add	r3, r3, #16
70020dec:	e1a00003 	mov	r0, r3
70020df0:	ebfffdb9 	bl	700204dc <rt_list_isempty>
70020df4:	e1a03000 	mov	r3, r0
70020df8:	e3530000 	cmp	r3, #0
70020dfc:	1a000009 	bne	70020e28 <rt_data_queue_pop+0x454>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
70020e00:	e51b3020 	ldr	r3, [fp, #-32]
70020e04:	e5933010 	ldr	r3, [r3, #16]
70020e08:	e2433010 	sub	r3, r3, #16
70020e0c:	e50b3010 	str	r3, [fp, #-16]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
70020e10:	e51b0010 	ldr	r0, [fp, #-16]
70020e14:	ebffa801 	bl	7000ae20 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
70020e18:	e51b3008 	ldr	r3, [fp, #-8]
70020e1c:	e1a00003 	mov	r0, r3
70020e20:	ebffb50b 	bl	7000e254 <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
70020e24:	ebffa36e 	bl	70009be4 <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
70020e28:	e51b3020 	ldr	r3, [fp, #-32]
70020e2c:	e5933020 	ldr	r3, [r3, #32]
70020e30:	e3530000 	cmp	r3, #0
70020e34:	0a000004 	beq	70020e4c <rt_data_queue_pop+0x478>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
70020e38:	e51b3020 	ldr	r3, [fp, #-32]
70020e3c:	e5933020 	ldr	r3, [r3, #32]
70020e40:	e51b0020 	ldr	r0, [fp, #-32]
70020e44:	e3a01003 	mov	r1, #3
70020e48:	e12fff33 	blx	r3

        return result;
70020e4c:	e51b300c 	ldr	r3, [fp, #-12]
70020e50:	ea00000f 	b	70020e94 <rt_data_queue_pop+0x4c0>
    }

__exit:
    rt_hw_interrupt_enable(level);
70020e54:	e51b3008 	ldr	r3, [fp, #-8]
70020e58:	e1a00003 	mov	r0, r3
70020e5c:	ebffb4fc 	bl	7000e254 <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
70020e60:	e51b300c 	ldr	r3, [fp, #-12]
70020e64:	e3530000 	cmp	r3, #0
70020e68:	1a000008 	bne	70020e90 <rt_data_queue_pop+0x4bc>
70020e6c:	e51b3020 	ldr	r3, [fp, #-32]
70020e70:	e5933020 	ldr	r3, [r3, #32]
70020e74:	e3530000 	cmp	r3, #0
70020e78:	0a000004 	beq	70020e90 <rt_data_queue_pop+0x4bc>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
70020e7c:	e51b3020 	ldr	r3, [fp, #-32]
70020e80:	e5933020 	ldr	r3, [r3, #32]
70020e84:	e51b0020 	ldr	r0, [fp, #-32]
70020e88:	e3a01001 	mov	r1, #1
70020e8c:	e12fff33 	blx	r3
    }

    return result;
70020e90:	e51b300c 	ldr	r3, [fp, #-12]
}
70020e94:	e1a00003 	mov	r0, r3
70020e98:	e24bd004 	sub	sp, fp, #4
70020e9c:	e8bd8800 	pop	{fp, pc}

70020ea0 <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
70020ea0:	e92d4800 	push	{fp, lr}
70020ea4:	e28db004 	add	fp, sp, #4
70020ea8:	e24dd020 	sub	sp, sp, #32
70020eac:	e50b0018 	str	r0, [fp, #-24]
70020eb0:	e50b101c 	str	r1, [fp, #-28]
70020eb4:	e50b2020 	str	r2, [fp, #-32]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
70020eb8:	e51b3018 	ldr	r3, [fp, #-24]
70020ebc:	e3530000 	cmp	r3, #0
70020ec0:	1a00001d 	bne	70020f3c <rt_data_queue_peak+0x9c>
70020ec4:	e3a03000 	mov	r3, #0
70020ec8:	e54b300d 	strb	r3, [fp, #-13]
70020ecc:	e30a3b74 	movw	r3, #43892	; 0xab74
70020ed0:	e3473002 	movt	r3, #28674	; 0x7002
70020ed4:	e5933000 	ldr	r3, [r3]
70020ed8:	e3530000 	cmp	r3, #0
70020edc:	1a00000d 	bne	70020f18 <rt_data_queue_peak+0x78>
70020ee0:	e30808dc 	movw	r0, #35036	; 0x88dc
70020ee4:	e3470002 	movt	r0, #28674	; 0x7002
70020ee8:	e30818fc 	movw	r1, #35068	; 0x88fc
70020eec:	e3471002 	movt	r1, #28674	; 0x7002
70020ef0:	e3082998 	movw	r2, #35224	; 0x8998
70020ef4:	e3472002 	movt	r2, #28674	; 0x7002
70020ef8:	e3a03e11 	mov	r3, #272	; 0x110
70020efc:	ebff9a3c 	bl	700077f4 <rt_kprintf>
70020f00:	e1a00000 	nop			; (mov r0, r0)
70020f04:	e55b300d 	ldrb	r3, [fp, #-13]
70020f08:	e6ef3073 	uxtb	r3, r3
70020f0c:	e3530000 	cmp	r3, #0
70020f10:	0afffffb 	beq	70020f04 <rt_data_queue_peak+0x64>
70020f14:	ea000008 	b	70020f3c <rt_data_queue_peak+0x9c>
70020f18:	e30a3b74 	movw	r3, #43892	; 0xab74
70020f1c:	e3473002 	movt	r3, #28674	; 0x7002
70020f20:	e5933000 	ldr	r3, [r3]
70020f24:	e30808fc 	movw	r0, #35068	; 0x88fc
70020f28:	e3470002 	movt	r0, #28674	; 0x7002
70020f2c:	e3081998 	movw	r1, #35224	; 0x8998
70020f30:	e3471002 	movt	r1, #28674	; 0x7002
70020f34:	e3a02e11 	mov	r2, #272	; 0x110
70020f38:	e12fff33 	blx	r3

    mask = queue->size - 1;
70020f3c:	e51b3018 	ldr	r3, [fp, #-24]
70020f40:	e1d330b0 	ldrh	r3, [r3]
70020f44:	e2433001 	sub	r3, r3, #1
70020f48:	e14b30b6 	strh	r3, [fp, #-6]

    level = rt_hw_interrupt_disable();
70020f4c:	ebffb4bd 	bl	7000e248 <rt_hw_interrupt_disable>
70020f50:	e1a03000 	mov	r3, r0
70020f54:	e50b300c 	str	r3, [fp, #-12]

    if (queue->get_index == queue->put_index) 
70020f58:	e51b3018 	ldr	r3, [fp, #-24]
70020f5c:	e1d320b8 	ldrh	r2, [r3, #8]
70020f60:	e51b3018 	ldr	r3, [fp, #-24]
70020f64:	e1d330ba 	ldrh	r3, [r3, #10]
70020f68:	e1520003 	cmp	r2, r3
70020f6c:	1a000004 	bne	70020f84 <rt_data_queue_peak+0xe4>
    {
        rt_hw_interrupt_enable(level);
70020f70:	e51b300c 	ldr	r3, [fp, #-12]
70020f74:	e1a00003 	mov	r0, r3
70020f78:	ebffb4b5 	bl	7000e254 <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
70020f7c:	e3e03003 	mvn	r3, #3
70020f80:	ea00001b 	b	70020ff4 <rt_data_queue_peak+0x154>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
70020f84:	e51b3018 	ldr	r3, [fp, #-24]
70020f88:	e593200c 	ldr	r2, [r3, #12]
70020f8c:	e51b3018 	ldr	r3, [fp, #-24]
70020f90:	e1d310b8 	ldrh	r1, [r3, #8]
70020f94:	e15b30b6 	ldrh	r3, [fp, #-6]
70020f98:	e0013003 	and	r3, r1, r3
70020f9c:	e6ff3073 	uxth	r3, r3
70020fa0:	e1a03183 	lsl	r3, r3, #3
70020fa4:	e0823003 	add	r3, r2, r3
70020fa8:	e5932000 	ldr	r2, [r3]
70020fac:	e51b301c 	ldr	r3, [fp, #-28]
70020fb0:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
70020fb4:	e51b3018 	ldr	r3, [fp, #-24]
70020fb8:	e593200c 	ldr	r2, [r3, #12]
70020fbc:	e51b3018 	ldr	r3, [fp, #-24]
70020fc0:	e1d310b8 	ldrh	r1, [r3, #8]
70020fc4:	e15b30b6 	ldrh	r3, [fp, #-6]
70020fc8:	e0013003 	and	r3, r1, r3
70020fcc:	e6ff3073 	uxth	r3, r3
70020fd0:	e1a03183 	lsl	r3, r3, #3
70020fd4:	e0823003 	add	r3, r2, r3
70020fd8:	e5932004 	ldr	r2, [r3, #4]
70020fdc:	e51b3020 	ldr	r3, [fp, #-32]
70020fe0:	e5832000 	str	r2, [r3]

    rt_hw_interrupt_enable(level);
70020fe4:	e51b300c 	ldr	r3, [fp, #-12]
70020fe8:	e1a00003 	mov	r0, r3
70020fec:	ebffb498 	bl	7000e254 <rt_hw_interrupt_enable>

    return RT_EOK;
70020ff0:	e3a03000 	mov	r3, #0
}
70020ff4:	e1a00003 	mov	r0, r3
70020ff8:	e24bd004 	sub	sp, fp, #4
70020ffc:	e8bd8800 	pop	{fp, pc}

70021000 <rt_data_queue_reset>:
RTM_EXPORT(rt_data_queue_peak);

void rt_data_queue_reset(struct rt_data_queue *queue)
{
70021000:	e92d4810 	push	{r4, fp, lr}
70021004:	e28db008 	add	fp, sp, #8
70021008:	e24dd014 	sub	sp, sp, #20
7002100c:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    rt_enter_critical();
70021010:	ebffa3c8 	bl	70009f38 <rt_enter_critical>
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
70021014:	ea00000e 	b	70021054 <rt_data_queue_reset+0x54>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70021018:	ebffb48a 	bl	7000e248 <rt_hw_interrupt_disable>
7002101c:	e1a03000 	mov	r3, r0
70021020:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_pop_list.next,
70021024:	e51b3018 	ldr	r3, [fp, #-24]
70021028:	e5933018 	ldr	r3, [r3, #24]
7002102c:	e2433010 	sub	r3, r3, #16
70021030:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
70021034:	e51b3010 	ldr	r3, [fp, #-16]
70021038:	e3e02000 	mvn	r2, #0
7002103c:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
70021040:	e51b0010 	ldr	r0, [fp, #-16]
70021044:	ebffa775 	bl	7000ae20 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
70021048:	e1a03004 	mov	r3, r4
7002104c:	e1a00003 	mov	r0, r3
70021050:	ebffb47f 	bl	7000e254 <rt_hw_interrupt_enable>

    rt_enter_critical();
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
70021054:	e51b3018 	ldr	r3, [fp, #-24]
70021058:	e2833018 	add	r3, r3, #24
7002105c:	e1a00003 	mov	r0, r3
70021060:	ebfffd1d 	bl	700204dc <rt_list_isempty>
70021064:	e1a03000 	mov	r3, r0
70021068:	e3530000 	cmp	r3, #0
7002106c:	0affffe9 	beq	70021018 <rt_data_queue_reset+0x18>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
70021070:	ea00000e 	b	700210b0 <rt_data_queue_reset+0xb0>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
70021074:	ebffb473 	bl	7000e248 <rt_hw_interrupt_disable>
70021078:	e1a03000 	mov	r3, r0
7002107c:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_push_list.next,
70021080:	e51b3018 	ldr	r3, [fp, #-24]
70021084:	e5933010 	ldr	r3, [r3, #16]
70021088:	e2433010 	sub	r3, r3, #16
7002108c:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
70021090:	e51b3010 	ldr	r3, [fp, #-16]
70021094:	e3e02000 	mvn	r2, #0
70021098:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
7002109c:	e51b0010 	ldr	r0, [fp, #-16]
700210a0:	ebffa75e 	bl	7000ae20 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
700210a4:	e1a03004 	mov	r3, r4
700210a8:	e1a00003 	mov	r0, r3
700210ac:	ebffb468 	bl	7000e254 <rt_hw_interrupt_enable>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
700210b0:	e51b3018 	ldr	r3, [fp, #-24]
700210b4:	e2833010 	add	r3, r3, #16
700210b8:	e1a00003 	mov	r0, r3
700210bc:	ebfffd06 	bl	700204dc <rt_list_isempty>
700210c0:	e1a03000 	mov	r3, r0
700210c4:	e3530000 	cmp	r3, #0
700210c8:	0affffe9 	beq	70021074 <rt_data_queue_reset+0x74>
        rt_thread_resume(thread);

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }
    rt_exit_critical();
700210cc:	ebffa3a9 	bl	70009f78 <rt_exit_critical>

    rt_schedule();
700210d0:	ebffa2c3 	bl	70009be4 <rt_schedule>
}
700210d4:	e24bd008 	sub	sp, fp, #8
700210d8:	e8bd8810 	pop	{r4, fp, pc}

700210dc <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
700210dc:	e92d4800 	push	{fp, lr}
700210e0:	e28db004 	add	fp, sp, #4
700210e4:	e24dd020 	sub	sp, sp, #32
700210e8:	e50b0018 	str	r0, [fp, #-24]
700210ec:	e50b101c 	str	r1, [fp, #-28]
700210f0:	e50b2020 	str	r2, [fp, #-32]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
700210f4:	e51b3018 	ldr	r3, [fp, #-24]
700210f8:	e3530000 	cmp	r3, #0
700210fc:	1a00001d 	bne	70021178 <_serial_poll_rx+0x9c>
70021100:	e3a03000 	mov	r3, #0
70021104:	e54b300d 	strb	r3, [fp, #-13]
70021108:	e30a3b74 	movw	r3, #43892	; 0xab74
7002110c:	e3473002 	movt	r3, #28674	; 0x7002
70021110:	e5933000 	ldr	r3, [r3]
70021114:	e3530000 	cmp	r3, #0
70021118:	1a00000d 	bne	70021154 <_serial_poll_rx+0x78>
7002111c:	e30809ac 	movw	r0, #35244	; 0x89ac
70021120:	e3470002 	movt	r0, #28674	; 0x7002
70021124:	e30819cc 	movw	r1, #35276	; 0x89cc
70021128:	e3471002 	movt	r1, #28674	; 0x7002
7002112c:	e3082b10 	movw	r2, #35600	; 0x8b10
70021130:	e3472002 	movt	r2, #28674	; 0x7002
70021134:	e3a0302c 	mov	r3, #44	; 0x2c
70021138:	ebff99ad 	bl	700077f4 <rt_kprintf>
7002113c:	e1a00000 	nop			; (mov r0, r0)
70021140:	e55b300d 	ldrb	r3, [fp, #-13]
70021144:	e6ef3073 	uxtb	r3, r3
70021148:	e3530000 	cmp	r3, #0
7002114c:	0afffffb 	beq	70021140 <_serial_poll_rx+0x64>
70021150:	ea000008 	b	70021178 <_serial_poll_rx+0x9c>
70021154:	e30a3b74 	movw	r3, #43892	; 0xab74
70021158:	e3473002 	movt	r3, #28674	; 0x7002
7002115c:	e5933000 	ldr	r3, [r3]
70021160:	e30809cc 	movw	r0, #35276	; 0x89cc
70021164:	e3470002 	movt	r0, #28674	; 0x7002
70021168:	e3081b10 	movw	r1, #35600	; 0x8b10
7002116c:	e3471002 	movt	r1, #28674	; 0x7002
70021170:	e3a0202c 	mov	r2, #44	; 0x2c
70021174:	e12fff33 	blx	r3
    size = length;
70021178:	e51b3020 	ldr	r3, [fp, #-32]
7002117c:	e50b3008 	str	r3, [fp, #-8]

    while (length)
70021180:	ea000013 	b	700211d4 <_serial_poll_rx+0xf8>
    {
        ch = serial->ops->getc(serial);
70021184:	e51b3018 	ldr	r3, [fp, #-24]
70021188:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
7002118c:	e593300c 	ldr	r3, [r3, #12]
70021190:	e51b0018 	ldr	r0, [fp, #-24]
70021194:	e12fff33 	blx	r3
70021198:	e50b000c 	str	r0, [fp, #-12]
        *data = ch; 
7002119c:	e51b300c 	ldr	r3, [fp, #-12]
700211a0:	e6ef2073 	uxtb	r2, r3
700211a4:	e51b301c 	ldr	r3, [fp, #-28]
700211a8:	e5c32000 	strb	r2, [r3]
        data ++; length --;
700211ac:	e51b301c 	ldr	r3, [fp, #-28]
700211b0:	e2833001 	add	r3, r3, #1
700211b4:	e50b301c 	str	r3, [fp, #-28]
700211b8:	e51b3020 	ldr	r3, [fp, #-32]
700211bc:	e2433001 	sub	r3, r3, #1
700211c0:	e50b3020 	str	r3, [fp, #-32]

        if (ch == '\n') break;
700211c4:	e51b300c 	ldr	r3, [fp, #-12]
700211c8:	e353000a 	cmp	r3, #10
700211cc:	1a000000 	bne	700211d4 <_serial_poll_rx+0xf8>
700211d0:	ea000002 	b	700211e0 <_serial_poll_rx+0x104>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
700211d4:	e51b3020 	ldr	r3, [fp, #-32]
700211d8:	e3530000 	cmp	r3, #0
700211dc:	1affffe8 	bne	70021184 <_serial_poll_rx+0xa8>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
700211e0:	e51b2008 	ldr	r2, [fp, #-8]
700211e4:	e51b3020 	ldr	r3, [fp, #-32]
700211e8:	e0633002 	rsb	r3, r3, r2
}
700211ec:	e1a00003 	mov	r0, r3
700211f0:	e24bd004 	sub	sp, fp, #4
700211f4:	e8bd8800 	pop	{fp, pc}

700211f8 <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
700211f8:	e92d4800 	push	{fp, lr}
700211fc:	e28db004 	add	fp, sp, #4
70021200:	e24dd018 	sub	sp, sp, #24
70021204:	e50b0010 	str	r0, [fp, #-16]
70021208:	e50b1014 	str	r1, [fp, #-20]
7002120c:	e50b2018 	str	r2, [fp, #-24]
    int size;
    RT_ASSERT(serial != RT_NULL);
70021210:	e51b3010 	ldr	r3, [fp, #-16]
70021214:	e3530000 	cmp	r3, #0
70021218:	1a00001d 	bne	70021294 <_serial_poll_tx+0x9c>
7002121c:	e3a03000 	mov	r3, #0
70021220:	e54b3009 	strb	r3, [fp, #-9]
70021224:	e30a3b74 	movw	r3, #43892	; 0xab74
70021228:	e3473002 	movt	r3, #28674	; 0x7002
7002122c:	e5933000 	ldr	r3, [r3]
70021230:	e3530000 	cmp	r3, #0
70021234:	1a00000d 	bne	70021270 <_serial_poll_tx+0x78>
70021238:	e30809ac 	movw	r0, #35244	; 0x89ac
7002123c:	e3470002 	movt	r0, #28674	; 0x7002
70021240:	e30819cc 	movw	r1, #35276	; 0x89cc
70021244:	e3471002 	movt	r1, #28674	; 0x7002
70021248:	e3082b40 	movw	r2, #35648	; 0x8b40
7002124c:	e3472002 	movt	r2, #28674	; 0x7002
70021250:	e3a0303e 	mov	r3, #62	; 0x3e
70021254:	ebff9966 	bl	700077f4 <rt_kprintf>
70021258:	e1a00000 	nop			; (mov r0, r0)
7002125c:	e55b3009 	ldrb	r3, [fp, #-9]
70021260:	e6ef3073 	uxtb	r3, r3
70021264:	e3530000 	cmp	r3, #0
70021268:	0afffffb 	beq	7002125c <_serial_poll_tx+0x64>
7002126c:	ea000008 	b	70021294 <_serial_poll_tx+0x9c>
70021270:	e30a3b74 	movw	r3, #43892	; 0xab74
70021274:	e3473002 	movt	r3, #28674	; 0x7002
70021278:	e5933000 	ldr	r3, [r3]
7002127c:	e30809cc 	movw	r0, #35276	; 0x89cc
70021280:	e3470002 	movt	r0, #28674	; 0x7002
70021284:	e3081b40 	movw	r1, #35648	; 0x8b40
70021288:	e3471002 	movt	r1, #28674	; 0x7002
7002128c:	e3a0203e 	mov	r2, #62	; 0x3e
70021290:	e12fff33 	blx	r3

    size = length;
70021294:	e51b3018 	ldr	r3, [fp, #-24]
70021298:	e50b3008 	str	r3, [fp, #-8]
    while (length)
7002129c:	ea00001c 	b	70021314 <_serial_poll_tx+0x11c>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
700212a0:	e51b3014 	ldr	r3, [fp, #-20]
700212a4:	e5d33000 	ldrb	r3, [r3]
700212a8:	e353000a 	cmp	r3, #10
700212ac:	1a00000a 	bne	700212dc <_serial_poll_tx+0xe4>
700212b0:	e51b3010 	ldr	r3, [fp, #-16]
700212b4:	e1d331b4 	ldrh	r3, [r3, #20]
700212b8:	e2033040 	and	r3, r3, #64	; 0x40
700212bc:	e3530000 	cmp	r3, #0
700212c0:	0a000005 	beq	700212dc <_serial_poll_tx+0xe4>
        {
            serial->ops->putc(serial, '\r');
700212c4:	e51b3010 	ldr	r3, [fp, #-16]
700212c8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
700212cc:	e5933008 	ldr	r3, [r3, #8]
700212d0:	e51b0010 	ldr	r0, [fp, #-16]
700212d4:	e3a0100d 	mov	r1, #13
700212d8:	e12fff33 	blx	r3
        }
    
        serial->ops->putc(serial, *data);
700212dc:	e51b3010 	ldr	r3, [fp, #-16]
700212e0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
700212e4:	e5933008 	ldr	r3, [r3, #8]
700212e8:	e51b2014 	ldr	r2, [fp, #-20]
700212ec:	e5d22000 	ldrb	r2, [r2]
700212f0:	e51b0010 	ldr	r0, [fp, #-16]
700212f4:	e1a01002 	mov	r1, r2
700212f8:	e12fff33 	blx	r3
    
        ++ data;
700212fc:	e51b3014 	ldr	r3, [fp, #-20]
70021300:	e2833001 	add	r3, r3, #1
70021304:	e50b3014 	str	r3, [fp, #-20]
        -- length;
70021308:	e51b3018 	ldr	r3, [fp, #-24]
7002130c:	e2433001 	sub	r3, r3, #1
70021310:	e50b3018 	str	r3, [fp, #-24]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
70021314:	e51b3018 	ldr	r3, [fp, #-24]
70021318:	e3530000 	cmp	r3, #0
7002131c:	1affffdf 	bne	700212a0 <_serial_poll_tx+0xa8>
    
        ++ data;
        -- length;
    }

    return size - length;
70021320:	e51b2008 	ldr	r2, [fp, #-8]
70021324:	e51b3018 	ldr	r3, [fp, #-24]
70021328:	e0633002 	rsb	r3, r3, r2
}
7002132c:	e1a00003 	mov	r0, r3
70021330:	e24bd004 	sub	sp, fp, #4
70021334:	e8bd8800 	pop	{fp, pc}

70021338 <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
70021338:	e92d4800 	push	{fp, lr}
7002133c:	e28db004 	add	fp, sp, #4
70021340:	e24dd028 	sub	sp, sp, #40	; 0x28
70021344:	e50b0020 	str	r0, [fp, #-32]
70021348:	e50b1024 	str	r1, [fp, #-36]	; 0x24
7002134c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
70021350:	e51b3020 	ldr	r3, [fp, #-32]
70021354:	e3530000 	cmp	r3, #0
70021358:	1a00001d 	bne	700213d4 <_serial_int_rx+0x9c>
7002135c:	e3a03000 	mov	r3, #0
70021360:	e54b3015 	strb	r3, [fp, #-21]
70021364:	e30a3b74 	movw	r3, #43892	; 0xab74
70021368:	e3473002 	movt	r3, #28674	; 0x7002
7002136c:	e5933000 	ldr	r3, [r3]
70021370:	e3530000 	cmp	r3, #0
70021374:	1a00000d 	bne	700213b0 <_serial_int_rx+0x78>
70021378:	e30809ac 	movw	r0, #35244	; 0x89ac
7002137c:	e3470002 	movt	r0, #28674	; 0x7002
70021380:	e30819cc 	movw	r1, #35276	; 0x89cc
70021384:	e3471002 	movt	r1, #28674	; 0x7002
70021388:	e3082af0 	movw	r2, #35568	; 0x8af0
7002138c:	e3472002 	movt	r2, #28674	; 0x7002
70021390:	e3a0305d 	mov	r3, #93	; 0x5d
70021394:	ebff9916 	bl	700077f4 <rt_kprintf>
70021398:	e1a00000 	nop			; (mov r0, r0)
7002139c:	e55b3015 	ldrb	r3, [fp, #-21]
700213a0:	e6ef3073 	uxtb	r3, r3
700213a4:	e3530000 	cmp	r3, #0
700213a8:	0afffffb 	beq	7002139c <_serial_int_rx+0x64>
700213ac:	ea000008 	b	700213d4 <_serial_int_rx+0x9c>
700213b0:	e30a3b74 	movw	r3, #43892	; 0xab74
700213b4:	e3473002 	movt	r3, #28674	; 0x7002
700213b8:	e5933000 	ldr	r3, [r3]
700213bc:	e30809cc 	movw	r0, #35276	; 0x89cc
700213c0:	e3470002 	movt	r0, #28674	; 0x7002
700213c4:	e3081af0 	movw	r1, #35568	; 0x8af0
700213c8:	e3471002 	movt	r1, #28674	; 0x7002
700213cc:	e3a0205d 	mov	r2, #93	; 0x5d
700213d0:	e12fff33 	blx	r3
    size = length; 
700213d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700213d8:	e50b3008 	str	r3, [fp, #-8]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
700213dc:	e51b3020 	ldr	r3, [fp, #-32]
700213e0:	e5933048 	ldr	r3, [r3, #72]	; 0x48
700213e4:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_fifo != RT_NULL);
700213e8:	e51b300c 	ldr	r3, [fp, #-12]
700213ec:	e3530000 	cmp	r3, #0
700213f0:	1a00001e 	bne	70021470 <_serial_int_rx+0x138>
700213f4:	e3a03000 	mov	r3, #0
700213f8:	e54b3016 	strb	r3, [fp, #-22]
700213fc:	e30a3b74 	movw	r3, #43892	; 0xab74
70021400:	e3473002 	movt	r3, #28674	; 0x7002
70021404:	e5933000 	ldr	r3, [r3]
70021408:	e3530000 	cmp	r3, #0
7002140c:	1a00000d 	bne	70021448 <_serial_int_rx+0x110>
70021410:	e30809ac 	movw	r0, #35244	; 0x89ac
70021414:	e3470002 	movt	r0, #28674	; 0x7002
70021418:	e30819e0 	movw	r1, #35296	; 0x89e0
7002141c:	e3471002 	movt	r1, #28674	; 0x7002
70021420:	e3082af0 	movw	r2, #35568	; 0x8af0
70021424:	e3472002 	movt	r2, #28674	; 0x7002
70021428:	e3a03061 	mov	r3, #97	; 0x61
7002142c:	ebff98f0 	bl	700077f4 <rt_kprintf>
70021430:	e1a00000 	nop			; (mov r0, r0)
70021434:	e55b3016 	ldrb	r3, [fp, #-22]
70021438:	e6ef3073 	uxtb	r3, r3
7002143c:	e3530000 	cmp	r3, #0
70021440:	0afffffb 	beq	70021434 <_serial_int_rx+0xfc>

    /* read from software FIFO */
    while (length)
70021444:	ea00003a 	b	70021534 <_serial_int_rx+0x1fc>

    RT_ASSERT(serial != RT_NULL);
    size = length; 
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);
70021448:	e30a3b74 	movw	r3, #43892	; 0xab74
7002144c:	e3473002 	movt	r3, #28674	; 0x7002
70021450:	e5933000 	ldr	r3, [r3]
70021454:	e30809e0 	movw	r0, #35296	; 0x89e0
70021458:	e3470002 	movt	r0, #28674	; 0x7002
7002145c:	e3081af0 	movw	r1, #35568	; 0x8af0
70021460:	e3471002 	movt	r1, #28674	; 0x7002
70021464:	e3a02061 	mov	r2, #97	; 0x61
70021468:	e12fff33 	blx	r3

    /* read from software FIFO */
    while (length)
7002146c:	ea000030 	b	70021534 <_serial_int_rx+0x1fc>
70021470:	ea00002f 	b	70021534 <_serial_int_rx+0x1fc>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
70021474:	ebffb373 	bl	7000e248 <rt_hw_interrupt_disable>
70021478:	e50b0010 	str	r0, [fp, #-16]
        if (rx_fifo->get_index != rx_fifo->put_index)
7002147c:	e51b300c 	ldr	r3, [fp, #-12]
70021480:	e1d320b6 	ldrh	r2, [r3, #6]
70021484:	e51b300c 	ldr	r3, [fp, #-12]
70021488:	e1d330b4 	ldrh	r3, [r3, #4]
7002148c:	e1520003 	cmp	r2, r3
70021490:	0a000018 	beq	700214f8 <_serial_int_rx+0x1c0>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
70021494:	e51b300c 	ldr	r3, [fp, #-12]
70021498:	e5932000 	ldr	r2, [r3]
7002149c:	e51b300c 	ldr	r3, [fp, #-12]
700214a0:	e1d330b6 	ldrh	r3, [r3, #6]
700214a4:	e0823003 	add	r3, r2, r3
700214a8:	e5d33000 	ldrb	r3, [r3]
700214ac:	e50b3014 	str	r3, [fp, #-20]
            rx_fifo->get_index += 1;
700214b0:	e51b300c 	ldr	r3, [fp, #-12]
700214b4:	e1d330b6 	ldrh	r3, [r3, #6]
700214b8:	e2833001 	add	r3, r3, #1
700214bc:	e6ff2073 	uxth	r2, r3
700214c0:	e51b300c 	ldr	r3, [fp, #-12]
700214c4:	e1c320b6 	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
700214c8:	e51b300c 	ldr	r3, [fp, #-12]
700214cc:	e1d320b6 	ldrh	r2, [r3, #6]
700214d0:	e51b3020 	ldr	r3, [fp, #-32]
700214d4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
700214d8:	e7ef3553 	ubfx	r3, r3, #10, #16
700214dc:	e6ff3073 	uxth	r3, r3
700214e0:	e1520003 	cmp	r2, r3
700214e4:	3a000006 	bcc	70021504 <_serial_int_rx+0x1cc>
700214e8:	e51b300c 	ldr	r3, [fp, #-12]
700214ec:	e3a02000 	mov	r2, #0
700214f0:	e1c320b6 	strh	r2, [r3, #6]
700214f4:	ea000002 	b	70021504 <_serial_int_rx+0x1cc>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
700214f8:	e51b0010 	ldr	r0, [fp, #-16]
700214fc:	ebffb354 	bl	7000e254 <rt_hw_interrupt_enable>
            break;
70021500:	ea00000e 	b	70021540 <_serial_int_rx+0x208>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
70021504:	e51b0010 	ldr	r0, [fp, #-16]
70021508:	ebffb351 	bl	7000e254 <rt_hw_interrupt_enable>

        *data = ch & 0xff;
7002150c:	e51b3014 	ldr	r3, [fp, #-20]
70021510:	e6ef2073 	uxtb	r2, r3
70021514:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70021518:	e5c32000 	strb	r2, [r3]
        data ++; length --;
7002151c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
70021520:	e2833001 	add	r3, r3, #1
70021524:	e50b3024 	str	r3, [fp, #-36]	; 0x24
70021528:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002152c:	e2433001 	sub	r3, r3, #1
70021530:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
70021534:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021538:	e3530000 	cmp	r3, #0
7002153c:	1affffcc 	bne	70021474 <_serial_int_rx+0x13c>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
70021540:	e51b2008 	ldr	r2, [fp, #-8]
70021544:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021548:	e0633002 	rsb	r3, r3, r2
}
7002154c:	e1a00003 	mov	r0, r3
70021550:	e24bd004 	sub	sp, fp, #4
70021554:	e8bd8800 	pop	{fp, pc}

70021558 <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
70021558:	e92d4800 	push	{fp, lr}
7002155c:	e28db004 	add	fp, sp, #4
70021560:	e24dd020 	sub	sp, sp, #32
70021564:	e50b0018 	str	r0, [fp, #-24]
70021568:	e50b101c 	str	r1, [fp, #-28]
7002156c:	e50b2020 	str	r2, [fp, #-32]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
70021570:	e51b3018 	ldr	r3, [fp, #-24]
70021574:	e3530000 	cmp	r3, #0
70021578:	1a00001d 	bne	700215f4 <_serial_int_tx+0x9c>
7002157c:	e3a03000 	mov	r3, #0
70021580:	e54b300d 	strb	r3, [fp, #-13]
70021584:	e30a3b74 	movw	r3, #43892	; 0xab74
70021588:	e3473002 	movt	r3, #28674	; 0x7002
7002158c:	e5933000 	ldr	r3, [r3]
70021590:	e3530000 	cmp	r3, #0
70021594:	1a00000d 	bne	700215d0 <_serial_int_tx+0x78>
70021598:	e30809ac 	movw	r0, #35244	; 0x89ac
7002159c:	e3470002 	movt	r0, #28674	; 0x7002
700215a0:	e30819cc 	movw	r1, #35276	; 0x89cc
700215a4:	e3471002 	movt	r1, #28674	; 0x7002
700215a8:	e3082b30 	movw	r2, #35632	; 0x8b30
700215ac:	e3472002 	movt	r2, #28674	; 0x7002
700215b0:	e3a03087 	mov	r3, #135	; 0x87
700215b4:	ebff988e 	bl	700077f4 <rt_kprintf>
700215b8:	e1a00000 	nop			; (mov r0, r0)
700215bc:	e55b300d 	ldrb	r3, [fp, #-13]
700215c0:	e6ef3073 	uxtb	r3, r3
700215c4:	e3530000 	cmp	r3, #0
700215c8:	0afffffb 	beq	700215bc <_serial_int_tx+0x64>
700215cc:	ea000008 	b	700215f4 <_serial_int_tx+0x9c>
700215d0:	e30a3b74 	movw	r3, #43892	; 0xab74
700215d4:	e3473002 	movt	r3, #28674	; 0x7002
700215d8:	e5933000 	ldr	r3, [r3]
700215dc:	e30809cc 	movw	r0, #35276	; 0x89cc
700215e0:	e3470002 	movt	r0, #28674	; 0x7002
700215e4:	e3081b30 	movw	r1, #35632	; 0x8b30
700215e8:	e3471002 	movt	r1, #28674	; 0x7002
700215ec:	e3a02087 	mov	r2, #135	; 0x87
700215f0:	e12fff33 	blx	r3

    size = length;
700215f4:	e51b3020 	ldr	r3, [fp, #-32]
700215f8:	e50b3008 	str	r3, [fp, #-8]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
700215fc:	e51b3018 	ldr	r3, [fp, #-24]
70021600:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
70021604:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(tx != RT_NULL);
70021608:	e51b300c 	ldr	r3, [fp, #-12]
7002160c:	e3530000 	cmp	r3, #0
70021610:	1a00001e 	bne	70021690 <_serial_int_tx+0x138>
70021614:	e3a03000 	mov	r3, #0
70021618:	e54b300e 	strb	r3, [fp, #-14]
7002161c:	e30a3b74 	movw	r3, #43892	; 0xab74
70021620:	e3473002 	movt	r3, #28674	; 0x7002
70021624:	e5933000 	ldr	r3, [r3]
70021628:	e3530000 	cmp	r3, #0
7002162c:	1a00000d 	bne	70021668 <_serial_int_tx+0x110>
70021630:	e30809ac 	movw	r0, #35244	; 0x89ac
70021634:	e3470002 	movt	r0, #28674	; 0x7002
70021638:	e30819f4 	movw	r1, #35316	; 0x89f4
7002163c:	e3471002 	movt	r1, #28674	; 0x7002
70021640:	e3082b30 	movw	r2, #35632	; 0x8b30
70021644:	e3472002 	movt	r2, #28674	; 0x7002
70021648:	e3a0308b 	mov	r3, #139	; 0x8b
7002164c:	ebff9868 	bl	700077f4 <rt_kprintf>
70021650:	e1a00000 	nop			; (mov r0, r0)
70021654:	e55b300e 	ldrb	r3, [fp, #-14]
70021658:	e6ef3073 	uxtb	r3, r3
7002165c:	e3530000 	cmp	r3, #0
70021660:	0afffffb 	beq	70021654 <_serial_int_tx+0xfc>

    while (length)
70021664:	ea000020 	b	700216ec <_serial_int_tx+0x194>
    
    RT_ASSERT(serial != RT_NULL);

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);
70021668:	e30a3b74 	movw	r3, #43892	; 0xab74
7002166c:	e3473002 	movt	r3, #28674	; 0x7002
70021670:	e5933000 	ldr	r3, [r3]
70021674:	e30809f4 	movw	r0, #35316	; 0x89f4
70021678:	e3470002 	movt	r0, #28674	; 0x7002
7002167c:	e3081b30 	movw	r1, #35632	; 0x8b30
70021680:	e3471002 	movt	r1, #28674	; 0x7002
70021684:	e3a0208b 	mov	r2, #139	; 0x8b
70021688:	e12fff33 	blx	r3

    while (length)
7002168c:	ea000016 	b	700216ec <_serial_int_tx+0x194>
70021690:	ea000015 	b	700216ec <_serial_int_tx+0x194>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
70021694:	e51b3018 	ldr	r3, [fp, #-24]
70021698:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
7002169c:	e5933008 	ldr	r3, [r3, #8]
700216a0:	e51b201c 	ldr	r2, [fp, #-28]
700216a4:	e5d22000 	ldrb	r2, [r2]
700216a8:	e51b0018 	ldr	r0, [fp, #-24]
700216ac:	e1a01002 	mov	r1, r2
700216b0:	e12fff33 	blx	r3
700216b4:	e1a03000 	mov	r3, r0
700216b8:	e3730001 	cmn	r3, #1
700216bc:	1a000004 	bne	700216d4 <_serial_int_tx+0x17c>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
700216c0:	e51b300c 	ldr	r3, [fp, #-12]
700216c4:	e1a00003 	mov	r0, r3
700216c8:	e3e01000 	mvn	r1, #0
700216cc:	ebfffa69 	bl	70020078 <rt_completion_wait>
            continue;
700216d0:	ea000005 	b	700216ec <_serial_int_tx+0x194>
        }

        data ++; length --;
700216d4:	e51b301c 	ldr	r3, [fp, #-28]
700216d8:	e2833001 	add	r3, r3, #1
700216dc:	e50b301c 	str	r3, [fp, #-28]
700216e0:	e51b3020 	ldr	r3, [fp, #-32]
700216e4:	e2433001 	sub	r3, r3, #1
700216e8:	e50b3020 	str	r3, [fp, #-32]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
700216ec:	e51b3020 	ldr	r3, [fp, #-32]
700216f0:	e3530000 	cmp	r3, #0
700216f4:	1affffe6 	bne	70021694 <_serial_int_tx+0x13c>
        }

        data ++; length --;
    }

    return size - length;
700216f8:	e51b2008 	ldr	r2, [fp, #-8]
700216fc:	e51b3020 	ldr	r3, [fp, #-32]
70021700:	e0633002 	rsb	r3, r3, r2
}
70021704:	e1a00003 	mov	r0, r3
70021708:	e24bd004 	sub	sp, fp, #4
7002170c:	e8bd8800 	pop	{fp, pc}

70021710 <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
70021710:	e92d4800 	push	{fp, lr}
70021714:	e28db004 	add	fp, sp, #4
70021718:	e24dd020 	sub	sp, sp, #32
7002171c:	e50b0018 	str	r0, [fp, #-24]
70021720:	e50b101c 	str	r1, [fp, #-28]
70021724:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    int result = RT_EOK;
70021728:	e3a03000 	mov	r3, #0
7002172c:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
70021730:	e51b3018 	ldr	r3, [fp, #-24]
70021734:	e3530000 	cmp	r3, #0
70021738:	0a000002 	beq	70021748 <_serial_dma_rx+0x38>
7002173c:	e51b301c 	ldr	r3, [fp, #-28]
70021740:	e3530000 	cmp	r3, #0
70021744:	1a00001d 	bne	700217c0 <_serial_dma_rx+0xb0>
70021748:	e3a03000 	mov	r3, #0
7002174c:	e54b3011 	strb	r3, [fp, #-17]
70021750:	e30a3b74 	movw	r3, #43892	; 0xab74
70021754:	e3473002 	movt	r3, #28674	; 0x7002
70021758:	e5933000 	ldr	r3, [r3]
7002175c:	e3530000 	cmp	r3, #0
70021760:	1a00000d 	bne	7002179c <_serial_dma_rx+0x8c>
70021764:	e30809ac 	movw	r0, #35244	; 0x89ac
70021768:	e3470002 	movt	r0, #28674	; 0x7002
7002176c:	e3081a04 	movw	r1, #35332	; 0x8a04
70021770:	e3471002 	movt	r1, #28674	; 0x7002
70021774:	e3082b00 	movw	r2, #35584	; 0x8b00
70021778:	e3472002 	movt	r2, #28674	; 0x7002
7002177c:	e3a030a4 	mov	r3, #164	; 0xa4
70021780:	ebff981b 	bl	700077f4 <rt_kprintf>
70021784:	e1a00000 	nop			; (mov r0, r0)
70021788:	e55b3011 	ldrb	r3, [fp, #-17]
7002178c:	e6ef3073 	uxtb	r3, r3
70021790:	e3530000 	cmp	r3, #0
70021794:	0afffffb 	beq	70021788 <_serial_dma_rx+0x78>
70021798:	ea000008 	b	700217c0 <_serial_dma_rx+0xb0>
7002179c:	e30a3b74 	movw	r3, #43892	; 0xab74
700217a0:	e3473002 	movt	r3, #28674	; 0x7002
700217a4:	e5933000 	ldr	r3, [r3]
700217a8:	e3080a04 	movw	r0, #35332	; 0x8a04
700217ac:	e3470002 	movt	r0, #28674	; 0x7002
700217b0:	e3081b00 	movw	r1, #35584	; 0x8b00
700217b4:	e3471002 	movt	r1, #28674	; 0x7002
700217b8:	e3a020a4 	mov	r2, #164	; 0xa4
700217bc:	e12fff33 	blx	r3
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
700217c0:	e51b3018 	ldr	r3, [fp, #-24]
700217c4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
700217c8:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_dma != RT_NULL);
700217cc:	e51b300c 	ldr	r3, [fp, #-12]
700217d0:	e3530000 	cmp	r3, #0
700217d4:	1a00001d 	bne	70021850 <_serial_dma_rx+0x140>
700217d8:	e3a03000 	mov	r3, #0
700217dc:	e54b3012 	strb	r3, [fp, #-18]
700217e0:	e30a3b74 	movw	r3, #43892	; 0xab74
700217e4:	e3473002 	movt	r3, #28674	; 0x7002
700217e8:	e5933000 	ldr	r3, [r3]
700217ec:	e3530000 	cmp	r3, #0
700217f0:	1a00000d 	bne	7002182c <_serial_dma_rx+0x11c>
700217f4:	e30809ac 	movw	r0, #35244	; 0x89ac
700217f8:	e3470002 	movt	r0, #28674	; 0x7002
700217fc:	e3081a30 	movw	r1, #35376	; 0x8a30
70021800:	e3471002 	movt	r1, #28674	; 0x7002
70021804:	e3082b00 	movw	r2, #35584	; 0x8b00
70021808:	e3472002 	movt	r2, #28674	; 0x7002
7002180c:	e3a030a6 	mov	r3, #166	; 0xa6
70021810:	ebff97f7 	bl	700077f4 <rt_kprintf>
70021814:	e1a00000 	nop			; (mov r0, r0)
70021818:	e55b3012 	ldrb	r3, [fp, #-18]
7002181c:	e6ef3073 	uxtb	r3, r3
70021820:	e3530000 	cmp	r3, #0
70021824:	0afffffb 	beq	70021818 <_serial_dma_rx+0x108>
70021828:	ea000008 	b	70021850 <_serial_dma_rx+0x140>
7002182c:	e30a3b74 	movw	r3, #43892	; 0xab74
70021830:	e3473002 	movt	r3, #28674	; 0x7002
70021834:	e5933000 	ldr	r3, [r3]
70021838:	e3080a30 	movw	r0, #35376	; 0x8a30
7002183c:	e3470002 	movt	r0, #28674	; 0x7002
70021840:	e3081b00 	movw	r1, #35584	; 0x8b00
70021844:	e3471002 	movt	r1, #28674	; 0x7002
70021848:	e3a020a6 	mov	r2, #166	; 0xa6
7002184c:	e12fff33 	blx	r3

    level = rt_hw_interrupt_disable();
70021850:	ebffb27c 	bl	7000e248 <rt_hw_interrupt_disable>
70021854:	e50b0010 	str	r0, [fp, #-16]
    if (rx_dma->activated != RT_TRUE)
70021858:	e51b300c 	ldr	r3, [fp, #-12]
7002185c:	e5933000 	ldr	r3, [r3]
70021860:	e3530001 	cmp	r3, #1
70021864:	0a00000c 	beq	7002189c <_serial_dma_rx+0x18c>
    {
        rx_dma->activated = RT_TRUE;
70021868:	e51b300c 	ldr	r3, [fp, #-12]
7002186c:	e3a02001 	mov	r2, #1
70021870:	e5832000 	str	r2, [r3]
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
70021874:	e51b3018 	ldr	r3, [fp, #-24]
70021878:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
7002187c:	e593c010 	ldr	ip, [r3, #16]
70021880:	e51b3020 	ldr	r3, [fp, #-32]
70021884:	e51b0018 	ldr	r0, [fp, #-24]
70021888:	e51b101c 	ldr	r1, [fp, #-28]
7002188c:	e1a02003 	mov	r2, r3
70021890:	e3a03001 	mov	r3, #1
70021894:	e12fff3c 	blx	ip
70021898:	ea000001 	b	700218a4 <_serial_dma_rx+0x194>
    }
    else result = -RT_EBUSY;
7002189c:	e3e03006 	mvn	r3, #6
700218a0:	e50b3008 	str	r3, [fp, #-8]
    rt_hw_interrupt_enable(level);
700218a4:	e51b0010 	ldr	r0, [fp, #-16]
700218a8:	ebffb269 	bl	7000e254 <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
700218ac:	e51b3008 	ldr	r3, [fp, #-8]
700218b0:	e3530000 	cmp	r3, #0
700218b4:	1a000001 	bne	700218c0 <_serial_dma_rx+0x1b0>
700218b8:	e51b3020 	ldr	r3, [fp, #-32]
700218bc:	ea000002 	b	700218cc <_serial_dma_rx+0x1bc>

    rt_set_errno(result);
700218c0:	e51b0008 	ldr	r0, [fp, #-8]
700218c4:	ebff919d 	bl	70005f40 <rt_set_errno>
    return 0;
700218c8:	e3a03000 	mov	r3, #0
}
700218cc:	e1a00003 	mov	r0, r3
700218d0:	e24bd004 	sub	sp, fp, #4
700218d4:	e8bd8800 	pop	{fp, pc}

700218d8 <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
700218d8:	e92d4800 	push	{fp, lr}
700218dc:	e28db004 	add	fp, sp, #4
700218e0:	e24dd020 	sub	sp, sp, #32
700218e4:	e50b0018 	str	r0, [fp, #-24]
700218e8:	e50b101c 	str	r1, [fp, #-28]
700218ec:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
700218f0:	e51b3018 	ldr	r3, [fp, #-24]
700218f4:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
700218f8:	e50b3008 	str	r3, [fp, #-8]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
700218fc:	e51b3008 	ldr	r3, [fp, #-8]
70021900:	e2832004 	add	r2, r3, #4
70021904:	e51b3020 	ldr	r3, [fp, #-32]
70021908:	e1a00002 	mov	r0, r2
7002190c:	e51b101c 	ldr	r1, [fp, #-28]
70021910:	e1a02003 	mov	r2, r3
70021914:	e3e03000 	mvn	r3, #0
70021918:	ebfffb51 	bl	70020664 <rt_data_queue_push>
7002191c:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
70021920:	e51b300c 	ldr	r3, [fp, #-12]
70021924:	e3530000 	cmp	r3, #0
70021928:	1a000018 	bne	70021990 <_serial_dma_tx+0xb8>
    {
        level = rt_hw_interrupt_disable();
7002192c:	ebffb245 	bl	7000e248 <rt_hw_interrupt_disable>
70021930:	e50b0010 	str	r0, [fp, #-16]
        if (tx_dma->activated != RT_TRUE)
70021934:	e51b3008 	ldr	r3, [fp, #-8]
70021938:	e5933000 	ldr	r3, [r3]
7002193c:	e3530001 	cmp	r3, #1
70021940:	0a00000e 	beq	70021980 <_serial_dma_tx+0xa8>
        {
            tx_dma->activated = RT_TRUE;
70021944:	e51b3008 	ldr	r3, [fp, #-8]
70021948:	e3a02001 	mov	r2, #1
7002194c:	e5832000 	str	r2, [r3]
            rt_hw_interrupt_enable(level);
70021950:	e51b0010 	ldr	r0, [fp, #-16]
70021954:	ebffb23e 	bl	7000e254 <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
70021958:	e51b3018 	ldr	r3, [fp, #-24]
7002195c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70021960:	e593c010 	ldr	ip, [r3, #16]
70021964:	e51b3020 	ldr	r3, [fp, #-32]
70021968:	e51b0018 	ldr	r0, [fp, #-24]
7002196c:	e51b101c 	ldr	r1, [fp, #-28]
70021970:	e1a02003 	mov	r2, r3
70021974:	e3a03002 	mov	r3, #2
70021978:	e12fff3c 	blx	ip
7002197c:	ea000001 	b	70021988 <_serial_dma_tx+0xb0>
        }
        else
        {
            rt_hw_interrupt_enable(level);
70021980:	e51b0010 	ldr	r0, [fp, #-16]
70021984:	ebffb232 	bl	7000e254 <rt_hw_interrupt_enable>
        }

        return length;
70021988:	e51b3020 	ldr	r3, [fp, #-32]
7002198c:	ea000002 	b	7002199c <_serial_dma_tx+0xc4>
    }
    else
    {
        rt_set_errno(result);
70021990:	e51b000c 	ldr	r0, [fp, #-12]
70021994:	ebff9169 	bl	70005f40 <rt_set_errno>
        return 0;
70021998:	e3a03000 	mov	r3, #0
    }
}
7002199c:	e1a00003 	mov	r0, r3
700219a0:	e24bd004 	sub	sp, fp, #4
700219a4:	e8bd8800 	pop	{fp, pc}

700219a8 <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
700219a8:	e92d4800 	push	{fp, lr}
700219ac:	e28db004 	add	fp, sp, #4
700219b0:	e24dd018 	sub	sp, sp, #24
700219b4:	e50b0018 	str	r0, [fp, #-24]
    rt_err_t result = RT_EOK;
700219b8:	e3a03000 	mov	r3, #0
700219bc:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
700219c0:	e51b3018 	ldr	r3, [fp, #-24]
700219c4:	e3530000 	cmp	r3, #0
700219c8:	1a00001d 	bne	70021a44 <rt_serial_init+0x9c>
700219cc:	e3a03000 	mov	r3, #0
700219d0:	e54b300d 	strb	r3, [fp, #-13]
700219d4:	e30a3b74 	movw	r3, #43892	; 0xab74
700219d8:	e3473002 	movt	r3, #28674	; 0x7002
700219dc:	e5933000 	ldr	r3, [r3]
700219e0:	e3530000 	cmp	r3, #0
700219e4:	1a00000d 	bne	70021a20 <rt_serial_init+0x78>
700219e8:	e30809ac 	movw	r0, #35244	; 0x89ac
700219ec:	e3470002 	movt	r0, #28674	; 0x7002
700219f0:	e3081a44 	movw	r1, #35396	; 0x8a44
700219f4:	e3471002 	movt	r1, #28674	; 0x7002
700219f8:	e3082ab0 	movw	r2, #35504	; 0x8ab0
700219fc:	e3472002 	movt	r2, #28674	; 0x7002
70021a00:	e3a030e2 	mov	r3, #226	; 0xe2
70021a04:	ebff977a 	bl	700077f4 <rt_kprintf>
70021a08:	e1a00000 	nop			; (mov r0, r0)
70021a0c:	e55b300d 	ldrb	r3, [fp, #-13]
70021a10:	e6ef3073 	uxtb	r3, r3
70021a14:	e3530000 	cmp	r3, #0
70021a18:	0afffffb 	beq	70021a0c <rt_serial_init+0x64>
70021a1c:	ea000008 	b	70021a44 <rt_serial_init+0x9c>
70021a20:	e30a3b74 	movw	r3, #43892	; 0xab74
70021a24:	e3473002 	movt	r3, #28674	; 0x7002
70021a28:	e5933000 	ldr	r3, [r3]
70021a2c:	e3080a44 	movw	r0, #35396	; 0x8a44
70021a30:	e3470002 	movt	r0, #28674	; 0x7002
70021a34:	e3081ab0 	movw	r1, #35504	; 0x8ab0
70021a38:	e3471002 	movt	r1, #28674	; 0x7002
70021a3c:	e3a020e2 	mov	r2, #226	; 0xe2
70021a40:	e12fff33 	blx	r3
    serial = (struct rt_serial_device *)dev;
70021a44:	e51b3018 	ldr	r3, [fp, #-24]
70021a48:	e50b300c 	str	r3, [fp, #-12]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
70021a4c:	e51b300c 	ldr	r3, [fp, #-12]
70021a50:	e3a02000 	mov	r2, #0
70021a54:	e5832048 	str	r2, [r3, #72]	; 0x48
    serial->serial_tx = RT_NULL;
70021a58:	e51b300c 	ldr	r3, [fp, #-12]
70021a5c:	e3a02000 	mov	r2, #0
70021a60:	e583204c 	str	r2, [r3, #76]	; 0x4c

    /* apply configuration */
    if (serial->ops->configure)
70021a64:	e51b300c 	ldr	r3, [fp, #-12]
70021a68:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70021a6c:	e5933000 	ldr	r3, [r3]
70021a70:	e3530000 	cmp	r3, #0
70021a74:	0a000008 	beq	70021a9c <rt_serial_init+0xf4>
        result = serial->ops->configure(serial, &serial->config);
70021a78:	e51b300c 	ldr	r3, [fp, #-12]
70021a7c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70021a80:	e5933000 	ldr	r3, [r3]
70021a84:	e51b200c 	ldr	r2, [fp, #-12]
70021a88:	e2822040 	add	r2, r2, #64	; 0x40
70021a8c:	e51b000c 	ldr	r0, [fp, #-12]
70021a90:	e1a01002 	mov	r1, r2
70021a94:	e12fff33 	blx	r3
70021a98:	e50b0008 	str	r0, [fp, #-8]

    return result;
70021a9c:	e51b3008 	ldr	r3, [fp, #-8]
}
70021aa0:	e1a00003 	mov	r0, r3
70021aa4:	e24bd004 	sub	sp, fp, #4
70021aa8:	e8bd8800 	pop	{fp, pc}

70021aac <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
70021aac:	e92d4800 	push	{fp, lr}
70021ab0:	e28db004 	add	fp, sp, #4
70021ab4:	e24dd028 	sub	sp, sp, #40	; 0x28
70021ab8:	e50b0028 	str	r0, [fp, #-40]	; 0x28
70021abc:	e1a03001 	mov	r3, r1
70021ac0:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
70021ac4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021ac8:	e3530000 	cmp	r3, #0
70021acc:	1a00001d 	bne	70021b48 <rt_serial_open+0x9c>
70021ad0:	e3a03000 	mov	r3, #0
70021ad4:	e54b3019 	strb	r3, [fp, #-25]
70021ad8:	e30a3b74 	movw	r3, #43892	; 0xab74
70021adc:	e3473002 	movt	r3, #28674	; 0x7002
70021ae0:	e5933000 	ldr	r3, [r3]
70021ae4:	e3530000 	cmp	r3, #0
70021ae8:	1a00000d 	bne	70021b24 <rt_serial_open+0x78>
70021aec:	e30809ac 	movw	r0, #35244	; 0x89ac
70021af0:	e3470002 	movt	r0, #28674	; 0x7002
70021af4:	e3081a44 	movw	r1, #35396	; 0x8a44
70021af8:	e3471002 	movt	r1, #28674	; 0x7002
70021afc:	e3082ac0 	movw	r2, #35520	; 0x8ac0
70021b00:	e3472002 	movt	r2, #28674	; 0x7002
70021b04:	e3a030f4 	mov	r3, #244	; 0xf4
70021b08:	ebff9739 	bl	700077f4 <rt_kprintf>
70021b0c:	e1a00000 	nop			; (mov r0, r0)
70021b10:	e55b3019 	ldrb	r3, [fp, #-25]
70021b14:	e6ef3073 	uxtb	r3, r3
70021b18:	e3530000 	cmp	r3, #0
70021b1c:	0afffffb 	beq	70021b10 <rt_serial_open+0x64>
70021b20:	ea000008 	b	70021b48 <rt_serial_open+0x9c>
70021b24:	e30a3b74 	movw	r3, #43892	; 0xab74
70021b28:	e3473002 	movt	r3, #28674	; 0x7002
70021b2c:	e5933000 	ldr	r3, [r3]
70021b30:	e3080a44 	movw	r0, #35396	; 0x8a44
70021b34:	e3470002 	movt	r0, #28674	; 0x7002
70021b38:	e3081ac0 	movw	r1, #35520	; 0x8ac0
70021b3c:	e3471002 	movt	r1, #28674	; 0x7002
70021b40:	e3a020f4 	mov	r2, #244	; 0xf4
70021b44:	e12fff33 	blx	r3
    serial = (struct rt_serial_device *)dev;
70021b48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021b4c:	e50b3008 	str	r3, [fp, #-8]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
70021b50:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021b54:	e2033c02 	and	r3, r3, #512	; 0x200
70021b58:	e3530000 	cmp	r3, #0
70021b5c:	0a000006 	beq	70021b7c <rt_serial_open+0xd0>
70021b60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021b64:	e1d331b2 	ldrh	r3, [r3, #18]
70021b68:	e2033c02 	and	r3, r3, #512	; 0x200
70021b6c:	e3530000 	cmp	r3, #0
70021b70:	1a000001 	bne	70021b7c <rt_serial_open+0xd0>
        return -RT_EIO;
70021b74:	e3e03007 	mvn	r3, #7
70021b78:	ea000130 	b	70022040 <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
70021b7c:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021b80:	e2033b02 	and	r3, r3, #2048	; 0x800
70021b84:	e3530000 	cmp	r3, #0
70021b88:	0a000006 	beq	70021ba8 <rt_serial_open+0xfc>
70021b8c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021b90:	e1d331b2 	ldrh	r3, [r3, #18]
70021b94:	e2033b02 	and	r3, r3, #2048	; 0x800
70021b98:	e3530000 	cmp	r3, #0
70021b9c:	1a000001 	bne	70021ba8 <rt_serial_open+0xfc>
        return -RT_EIO;
70021ba0:	e3e03007 	mvn	r3, #7
70021ba4:	ea000125 	b	70022040 <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
70021ba8:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021bac:	e2033c01 	and	r3, r3, #256	; 0x100
70021bb0:	e3530000 	cmp	r3, #0
70021bb4:	0a000006 	beq	70021bd4 <rt_serial_open+0x128>
70021bb8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021bbc:	e1d331b2 	ldrh	r3, [r3, #18]
70021bc0:	e2033c01 	and	r3, r3, #256	; 0x100
70021bc4:	e3530000 	cmp	r3, #0
70021bc8:	1a000001 	bne	70021bd4 <rt_serial_open+0x128>
        return -RT_EIO;
70021bcc:	e3e03007 	mvn	r3, #7
70021bd0:	ea00011a 	b	70022040 <rt_serial_open+0x594>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
70021bd4:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021bd8:	e2033b01 	and	r3, r3, #1024	; 0x400
70021bdc:	e3530000 	cmp	r3, #0
70021be0:	0a000006 	beq	70021c00 <rt_serial_open+0x154>
70021be4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021be8:	e1d331b2 	ldrh	r3, [r3, #18]
70021bec:	e2033b01 	and	r3, r3, #1024	; 0x400
70021bf0:	e3530000 	cmp	r3, #0
70021bf4:	1a000001 	bne	70021c00 <rt_serial_open+0x154>
        return -RT_EIO;
70021bf8:	e3e03007 	mvn	r3, #7
70021bfc:	ea00010f 	b	70022040 <rt_serial_open+0x594>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
70021c00:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021c04:	e6ef3073 	uxtb	r3, r3
70021c08:	e6ff2073 	uxth	r2, r3
70021c0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021c10:	e1c321b4 	strh	r2, [r3, #20]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
70021c14:	e51b3008 	ldr	r3, [fp, #-8]
70021c18:	e5933048 	ldr	r3, [r3, #72]	; 0x48
70021c1c:	e3530000 	cmp	r3, #0
70021c20:	1a000089 	bne	70021e4c <rt_serial_open+0x3a0>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
70021c24:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021c28:	e2033c02 	and	r3, r3, #512	; 0x200
70021c2c:	e3530000 	cmp	r3, #0
70021c30:	0a000030 	beq	70021cf8 <rt_serial_open+0x24c>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
70021c34:	e3a00004 	mov	r0, #4
70021c38:	ebff991f 	bl	700080bc <rt_malloc>
70021c3c:	e50b000c 	str	r0, [fp, #-12]
            RT_ASSERT(rx_dma != RT_NULL);
70021c40:	e51b300c 	ldr	r3, [fp, #-12]
70021c44:	e3530000 	cmp	r3, #0
70021c48:	1a00001d 	bne	70021cc4 <rt_serial_open+0x218>
70021c4c:	e3a03000 	mov	r3, #0
70021c50:	e54b301a 	strb	r3, [fp, #-26]
70021c54:	e30a3b74 	movw	r3, #43892	; 0xab74
70021c58:	e3473002 	movt	r3, #28674	; 0x7002
70021c5c:	e5933000 	ldr	r3, [r3]
70021c60:	e3530000 	cmp	r3, #0
70021c64:	1a00000d 	bne	70021ca0 <rt_serial_open+0x1f4>
70021c68:	e30809ac 	movw	r0, #35244	; 0x89ac
70021c6c:	e3470002 	movt	r0, #28674	; 0x7002
70021c70:	e3081a30 	movw	r1, #35376	; 0x8a30
70021c74:	e3471002 	movt	r1, #28674	; 0x7002
70021c78:	e3082ac0 	movw	r2, #35520	; 0x8ac0
70021c7c:	e3472002 	movt	r2, #28674	; 0x7002
70021c80:	e3a03f43 	mov	r3, #268	; 0x10c
70021c84:	ebff96da 	bl	700077f4 <rt_kprintf>
70021c88:	e1a00000 	nop			; (mov r0, r0)
70021c8c:	e55b301a 	ldrb	r3, [fp, #-26]
70021c90:	e6ef3073 	uxtb	r3, r3
70021c94:	e3530000 	cmp	r3, #0
70021c98:	0afffffb 	beq	70021c8c <rt_serial_open+0x1e0>
70021c9c:	ea000008 	b	70021cc4 <rt_serial_open+0x218>
70021ca0:	e30a3b74 	movw	r3, #43892	; 0xab74
70021ca4:	e3473002 	movt	r3, #28674	; 0x7002
70021ca8:	e5933000 	ldr	r3, [r3]
70021cac:	e3080a30 	movw	r0, #35376	; 0x8a30
70021cb0:	e3470002 	movt	r0, #28674	; 0x7002
70021cb4:	e3081ac0 	movw	r1, #35520	; 0x8ac0
70021cb8:	e3471002 	movt	r1, #28674	; 0x7002
70021cbc:	e3a02f43 	mov	r2, #268	; 0x10c
70021cc0:	e12fff33 	blx	r3
            rx_dma->activated = RT_FALSE;
70021cc4:	e51b300c 	ldr	r3, [fp, #-12]
70021cc8:	e3a02000 	mov	r2, #0
70021ccc:	e5832000 	str	r2, [r3]

            serial->serial_rx = rx_dma;
70021cd0:	e51b3008 	ldr	r3, [fp, #-8]
70021cd4:	e51b200c 	ldr	r2, [fp, #-12]
70021cd8:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
70021cdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021ce0:	e1d331b4 	ldrh	r3, [r3, #20]
70021ce4:	e3833c02 	orr	r3, r3, #512	; 0x200
70021ce8:	e6ff2073 	uxth	r2, r3
70021cec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021cf0:	e1c321b4 	strh	r2, [r3, #20]
70021cf4:	ea000054 	b	70021e4c <rt_serial_open+0x3a0>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
70021cf8:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021cfc:	e2033c01 	and	r3, r3, #256	; 0x100
70021d00:	e3530000 	cmp	r3, #0
70021d04:	0a00004d 	beq	70021e40 <rt_serial_open+0x394>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
70021d08:	e51b3008 	ldr	r3, [fp, #-8]
70021d0c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70021d10:	e7ef3553 	ubfx	r3, r3, #10, #16
70021d14:	e6ff3073 	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
70021d18:	e2833008 	add	r3, r3, #8
70021d1c:	e1a00003 	mov	r0, r3
70021d20:	ebff98e5 	bl	700080bc <rt_malloc>
70021d24:	e50b0010 	str	r0, [fp, #-16]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
70021d28:	e51b3010 	ldr	r3, [fp, #-16]
70021d2c:	e3530000 	cmp	r3, #0
70021d30:	1a00001d 	bne	70021dac <rt_serial_open+0x300>
70021d34:	e3a03000 	mov	r3, #0
70021d38:	e54b301b 	strb	r3, [fp, #-27]
70021d3c:	e30a3b74 	movw	r3, #43892	; 0xab74
70021d40:	e3473002 	movt	r3, #28674	; 0x7002
70021d44:	e5933000 	ldr	r3, [r3]
70021d48:	e3530000 	cmp	r3, #0
70021d4c:	1a00000d 	bne	70021d88 <rt_serial_open+0x2dc>
70021d50:	e30809ac 	movw	r0, #35244	; 0x89ac
70021d54:	e3470002 	movt	r0, #28674	; 0x7002
70021d58:	e30819e0 	movw	r1, #35296	; 0x89e0
70021d5c:	e3471002 	movt	r1, #28674	; 0x7002
70021d60:	e3082ac0 	movw	r2, #35520	; 0x8ac0
70021d64:	e3472002 	movt	r2, #28674	; 0x7002
70021d68:	e3a03f46 	mov	r3, #280	; 0x118
70021d6c:	ebff96a0 	bl	700077f4 <rt_kprintf>
70021d70:	e1a00000 	nop			; (mov r0, r0)
70021d74:	e55b301b 	ldrb	r3, [fp, #-27]
70021d78:	e6ef3073 	uxtb	r3, r3
70021d7c:	e3530000 	cmp	r3, #0
70021d80:	0afffffb 	beq	70021d74 <rt_serial_open+0x2c8>
70021d84:	ea000008 	b	70021dac <rt_serial_open+0x300>
70021d88:	e30a3b74 	movw	r3, #43892	; 0xab74
70021d8c:	e3473002 	movt	r3, #28674	; 0x7002
70021d90:	e5933000 	ldr	r3, [r3]
70021d94:	e30809e0 	movw	r0, #35296	; 0x89e0
70021d98:	e3470002 	movt	r0, #28674	; 0x7002
70021d9c:	e3081ac0 	movw	r1, #35520	; 0x8ac0
70021da0:	e3471002 	movt	r1, #28674	; 0x7002
70021da4:	e3a02f46 	mov	r2, #280	; 0x118
70021da8:	e12fff33 	blx	r3
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
70021dac:	e51b3010 	ldr	r3, [fp, #-16]
70021db0:	e2832008 	add	r2, r3, #8
70021db4:	e51b3010 	ldr	r3, [fp, #-16]
70021db8:	e5832000 	str	r2, [r3]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
70021dbc:	e51b3010 	ldr	r3, [fp, #-16]
70021dc0:	e5932000 	ldr	r2, [r3]
70021dc4:	e51b3008 	ldr	r3, [fp, #-8]
70021dc8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70021dcc:	e7ef3553 	ubfx	r3, r3, #10, #16
70021dd0:	e6ff3073 	uxth	r3, r3
70021dd4:	e1a00002 	mov	r0, r2
70021dd8:	e3a01000 	mov	r1, #0
70021ddc:	e1a02003 	mov	r2, r3
70021de0:	ebff9089 	bl	7000600c <rt_memset>
            rx_fifo->put_index = 0;
70021de4:	e51b3010 	ldr	r3, [fp, #-16]
70021de8:	e3a02000 	mov	r2, #0
70021dec:	e1c320b4 	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
70021df0:	e51b3010 	ldr	r3, [fp, #-16]
70021df4:	e3a02000 	mov	r2, #0
70021df8:	e1c320b6 	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
70021dfc:	e51b3008 	ldr	r3, [fp, #-8]
70021e00:	e51b2010 	ldr	r2, [fp, #-16]
70021e04:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
70021e08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021e0c:	e1d331b4 	ldrh	r3, [r3, #20]
70021e10:	e3833c01 	orr	r3, r3, #256	; 0x100
70021e14:	e6ff2073 	uxth	r2, r3
70021e18:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021e1c:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
70021e20:	e51b3008 	ldr	r3, [fp, #-8]
70021e24:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70021e28:	e5933004 	ldr	r3, [r3, #4]
70021e2c:	e51b0008 	ldr	r0, [fp, #-8]
70021e30:	e3a01010 	mov	r1, #16
70021e34:	e3a02c01 	mov	r2, #256	; 0x100
70021e38:	e12fff33 	blx	r3
70021e3c:	ea000002 	b	70021e4c <rt_serial_open+0x3a0>
        }
        else
        {
            serial->serial_rx = RT_NULL;
70021e40:	e51b3008 	ldr	r3, [fp, #-8]
70021e44:	e3a02000 	mov	r2, #0
70021e48:	e5832048 	str	r2, [r3, #72]	; 0x48
        }
    }

    if (serial->serial_tx == RT_NULL)
70021e4c:	e51b3008 	ldr	r3, [fp, #-8]
70021e50:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
70021e54:	e3530000 	cmp	r3, #0
70021e58:	1a000077 	bne	7002203c <rt_serial_open+0x590>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
70021e5c:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021e60:	e2033b02 	and	r3, r3, #2048	; 0x800
70021e64:	e3530000 	cmp	r3, #0
70021e68:	0a000034 	beq	70021f40 <rt_serial_open+0x494>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
70021e6c:	e3a00028 	mov	r0, #40	; 0x28
70021e70:	ebff9891 	bl	700080bc <rt_malloc>
70021e74:	e50b0014 	str	r0, [fp, #-20]
            RT_ASSERT(tx_dma != RT_NULL);
70021e78:	e51b3014 	ldr	r3, [fp, #-20]
70021e7c:	e3530000 	cmp	r3, #0
70021e80:	1a00001d 	bne	70021efc <rt_serial_open+0x450>
70021e84:	e3a03000 	mov	r3, #0
70021e88:	e54b301c 	strb	r3, [fp, #-28]
70021e8c:	e30a3b74 	movw	r3, #43892	; 0xab74
70021e90:	e3473002 	movt	r3, #28674	; 0x7002
70021e94:	e5933000 	ldr	r3, [r3]
70021e98:	e3530000 	cmp	r3, #0
70021e9c:	1a00000d 	bne	70021ed8 <rt_serial_open+0x42c>
70021ea0:	e30809ac 	movw	r0, #35244	; 0x89ac
70021ea4:	e3470002 	movt	r0, #28674	; 0x7002
70021ea8:	e3081a54 	movw	r1, #35412	; 0x8a54
70021eac:	e3471002 	movt	r1, #28674	; 0x7002
70021eb0:	e3082ac0 	movw	r2, #35520	; 0x8ac0
70021eb4:	e3472002 	movt	r2, #28674	; 0x7002
70021eb8:	e3a03e13 	mov	r3, #304	; 0x130
70021ebc:	ebff964c 	bl	700077f4 <rt_kprintf>
70021ec0:	e1a00000 	nop			; (mov r0, r0)
70021ec4:	e55b301c 	ldrb	r3, [fp, #-28]
70021ec8:	e6ef3073 	uxtb	r3, r3
70021ecc:	e3530000 	cmp	r3, #0
70021ed0:	0afffffb 	beq	70021ec4 <rt_serial_open+0x418>
70021ed4:	ea000008 	b	70021efc <rt_serial_open+0x450>
70021ed8:	e30a3b74 	movw	r3, #43892	; 0xab74
70021edc:	e3473002 	movt	r3, #28674	; 0x7002
70021ee0:	e5933000 	ldr	r3, [r3]
70021ee4:	e3080a54 	movw	r0, #35412	; 0x8a54
70021ee8:	e3470002 	movt	r0, #28674	; 0x7002
70021eec:	e3081ac0 	movw	r1, #35520	; 0x8ac0
70021ef0:	e3471002 	movt	r1, #28674	; 0x7002
70021ef4:	e3a02e13 	mov	r2, #304	; 0x130
70021ef8:	e12fff33 	blx	r3
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
70021efc:	e51b3014 	ldr	r3, [fp, #-20]
70021f00:	e2833004 	add	r3, r3, #4
70021f04:	e1a00003 	mov	r0, r3
70021f08:	e3a01008 	mov	r1, #8
70021f0c:	e3a02004 	mov	r2, #4
70021f10:	e3a03000 	mov	r3, #0
70021f14:	ebfff97f 	bl	70020518 <rt_data_queue_init>
            serial->serial_tx = tx_dma;
70021f18:	e51b3008 	ldr	r3, [fp, #-8]
70021f1c:	e51b2014 	ldr	r2, [fp, #-20]
70021f20:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
70021f24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021f28:	e1d331b4 	ldrh	r3, [r3, #20]
70021f2c:	e3833b02 	orr	r3, r3, #2048	; 0x800
70021f30:	e6ff2073 	uxth	r2, r3
70021f34:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021f38:	e1c321b4 	strh	r2, [r3, #20]
70021f3c:	ea00003e 	b	7002203c <rt_serial_open+0x590>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
70021f40:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
70021f44:	e2033b01 	and	r3, r3, #1024	; 0x400
70021f48:	e3530000 	cmp	r3, #0
70021f4c:	0a000037 	beq	70022030 <rt_serial_open+0x584>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
70021f50:	e3a0000c 	mov	r0, #12
70021f54:	ebff9858 	bl	700080bc <rt_malloc>
70021f58:	e50b0018 	str	r0, [fp, #-24]
            RT_ASSERT(tx_fifo != RT_NULL);
70021f5c:	e51b3018 	ldr	r3, [fp, #-24]
70021f60:	e3530000 	cmp	r3, #0
70021f64:	1a00001d 	bne	70021fe0 <rt_serial_open+0x534>
70021f68:	e3a03000 	mov	r3, #0
70021f6c:	e54b301d 	strb	r3, [fp, #-29]
70021f70:	e30a3b74 	movw	r3, #43892	; 0xab74
70021f74:	e3473002 	movt	r3, #28674	; 0x7002
70021f78:	e5933000 	ldr	r3, [r3]
70021f7c:	e3530000 	cmp	r3, #0
70021f80:	1a00000d 	bne	70021fbc <rt_serial_open+0x510>
70021f84:	e30809ac 	movw	r0, #35244	; 0x89ac
70021f88:	e3470002 	movt	r0, #28674	; 0x7002
70021f8c:	e3081a68 	movw	r1, #35432	; 0x8a68
70021f90:	e3471002 	movt	r1, #28674	; 0x7002
70021f94:	e3082ac0 	movw	r2, #35520	; 0x8ac0
70021f98:	e3472002 	movt	r2, #28674	; 0x7002
70021f9c:	e3a03f4f 	mov	r3, #316	; 0x13c
70021fa0:	ebff9613 	bl	700077f4 <rt_kprintf>
70021fa4:	e1a00000 	nop			; (mov r0, r0)
70021fa8:	e55b301d 	ldrb	r3, [fp, #-29]
70021fac:	e6ef3073 	uxtb	r3, r3
70021fb0:	e3530000 	cmp	r3, #0
70021fb4:	0afffffb 	beq	70021fa8 <rt_serial_open+0x4fc>
70021fb8:	ea000008 	b	70021fe0 <rt_serial_open+0x534>
70021fbc:	e30a3b74 	movw	r3, #43892	; 0xab74
70021fc0:	e3473002 	movt	r3, #28674	; 0x7002
70021fc4:	e5933000 	ldr	r3, [r3]
70021fc8:	e3080a68 	movw	r0, #35432	; 0x8a68
70021fcc:	e3470002 	movt	r0, #28674	; 0x7002
70021fd0:	e3081ac0 	movw	r1, #35520	; 0x8ac0
70021fd4:	e3471002 	movt	r1, #28674	; 0x7002
70021fd8:	e3a02f4f 	mov	r2, #316	; 0x13c
70021fdc:	e12fff33 	blx	r3

            rt_completion_init(&(tx_fifo->completion));
70021fe0:	e51b3018 	ldr	r3, [fp, #-24]
70021fe4:	e1a00003 	mov	r0, r3
70021fe8:	ebfff7f0 	bl	7001ffb0 <rt_completion_init>
            serial->serial_tx = tx_fifo;
70021fec:	e51b3008 	ldr	r3, [fp, #-8]
70021ff0:	e51b2018 	ldr	r2, [fp, #-24]
70021ff4:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
70021ff8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70021ffc:	e1d331b4 	ldrh	r3, [r3, #20]
70022000:	e3833b01 	orr	r3, r3, #1024	; 0x400
70022004:	e6ff2073 	uxth	r2, r3
70022008:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002200c:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
70022010:	e51b3008 	ldr	r3, [fp, #-8]
70022014:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022018:	e5933004 	ldr	r3, [r3, #4]
7002201c:	e51b0008 	ldr	r0, [fp, #-8]
70022020:	e3a01010 	mov	r1, #16
70022024:	e3a02b01 	mov	r2, #1024	; 0x400
70022028:	e12fff33 	blx	r3
7002202c:	ea000002 	b	7002203c <rt_serial_open+0x590>
        }
        else
        {
            serial->serial_tx = RT_NULL;
70022030:	e51b3008 	ldr	r3, [fp, #-8]
70022034:	e3a02000 	mov	r2, #0
70022038:	e583204c 	str	r2, [r3, #76]	; 0x4c
        }
    }

    return RT_EOK;
7002203c:	e3a03000 	mov	r3, #0
}
70022040:	e1a00003 	mov	r0, r3
70022044:	e24bd004 	sub	sp, fp, #4
70022048:	e8bd8800 	pop	{fp, pc}

7002204c <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
7002204c:	e92d4800 	push	{fp, lr}
70022050:	e28db004 	add	fp, sp, #4
70022054:	e24dd028 	sub	sp, sp, #40	; 0x28
70022058:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
7002205c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70022060:	e3530000 	cmp	r3, #0
70022064:	1a00001d 	bne	700220e0 <rt_serial_close+0x94>
70022068:	e3a03000 	mov	r3, #0
7002206c:	e54b3019 	strb	r3, [fp, #-25]
70022070:	e30a3b74 	movw	r3, #43892	; 0xab74
70022074:	e3473002 	movt	r3, #28674	; 0x7002
70022078:	e5933000 	ldr	r3, [r3]
7002207c:	e3530000 	cmp	r3, #0
70022080:	1a00000d 	bne	700220bc <rt_serial_close+0x70>
70022084:	e30809ac 	movw	r0, #35244	; 0x89ac
70022088:	e3470002 	movt	r0, #28674	; 0x7002
7002208c:	e3081a44 	movw	r1, #35396	; 0x8a44
70022090:	e3471002 	movt	r1, #28674	; 0x7002
70022094:	e3082ad0 	movw	r2, #35536	; 0x8ad0
70022098:	e3472002 	movt	r2, #28674	; 0x7002
7002209c:	e3003152 	movw	r3, #338	; 0x152
700220a0:	ebff95d3 	bl	700077f4 <rt_kprintf>
700220a4:	e1a00000 	nop			; (mov r0, r0)
700220a8:	e55b3019 	ldrb	r3, [fp, #-25]
700220ac:	e6ef3073 	uxtb	r3, r3
700220b0:	e3530000 	cmp	r3, #0
700220b4:	0afffffb 	beq	700220a8 <rt_serial_close+0x5c>
700220b8:	ea000008 	b	700220e0 <rt_serial_close+0x94>
700220bc:	e30a3b74 	movw	r3, #43892	; 0xab74
700220c0:	e3473002 	movt	r3, #28674	; 0x7002
700220c4:	e5933000 	ldr	r3, [r3]
700220c8:	e3080a44 	movw	r0, #35396	; 0x8a44
700220cc:	e3470002 	movt	r0, #28674	; 0x7002
700220d0:	e3081ad0 	movw	r1, #35536	; 0x8ad0
700220d4:	e3471002 	movt	r1, #28674	; 0x7002
700220d8:	e3002152 	movw	r2, #338	; 0x152
700220dc:	e12fff33 	blx	r3
    serial = (struct rt_serial_device *)dev;
700220e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700220e4:	e50b3008 	str	r3, [fp, #-8]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
700220e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700220ec:	e5d33016 	ldrb	r3, [r3, #22]
700220f0:	e3530001 	cmp	r3, #1
700220f4:	9a000001 	bls	70022100 <rt_serial_close+0xb4>
700220f8:	e3a03000 	mov	r3, #0
700220fc:	ea0000e0 	b	70022484 <rt_serial_close+0x438>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
70022100:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
70022104:	e1d331b4 	ldrh	r3, [r3, #20]
70022108:	e2033c01 	and	r3, r3, #256	; 0x100
7002210c:	e3530000 	cmp	r3, #0
70022110:	0a000036 	beq	700221f0 <rt_serial_close+0x1a4>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
70022114:	e51b3008 	ldr	r3, [fp, #-8]
70022118:	e5933048 	ldr	r3, [r3, #72]	; 0x48
7002211c:	e50b300c 	str	r3, [fp, #-12]
        RT_ASSERT(rx_fifo != RT_NULL);
70022120:	e51b300c 	ldr	r3, [fp, #-12]
70022124:	e3530000 	cmp	r3, #0
70022128:	1a00001d 	bne	700221a4 <rt_serial_close+0x158>
7002212c:	e3a03000 	mov	r3, #0
70022130:	e54b301a 	strb	r3, [fp, #-26]
70022134:	e30a3b74 	movw	r3, #43892	; 0xab74
70022138:	e3473002 	movt	r3, #28674	; 0x7002
7002213c:	e5933000 	ldr	r3, [r3]
70022140:	e3530000 	cmp	r3, #0
70022144:	1a00000d 	bne	70022180 <rt_serial_close+0x134>
70022148:	e30809ac 	movw	r0, #35244	; 0x89ac
7002214c:	e3470002 	movt	r0, #28674	; 0x7002
70022150:	e30819e0 	movw	r1, #35296	; 0x89e0
70022154:	e3471002 	movt	r1, #28674	; 0x7002
70022158:	e3082ad0 	movw	r2, #35536	; 0x8ad0
7002215c:	e3472002 	movt	r2, #28674	; 0x7002
70022160:	e300315d 	movw	r3, #349	; 0x15d
70022164:	ebff95a2 	bl	700077f4 <rt_kprintf>
70022168:	e1a00000 	nop			; (mov r0, r0)
7002216c:	e55b301a 	ldrb	r3, [fp, #-26]
70022170:	e6ef3073 	uxtb	r3, r3
70022174:	e3530000 	cmp	r3, #0
70022178:	0afffffb 	beq	7002216c <rt_serial_close+0x120>
7002217c:	ea000008 	b	700221a4 <rt_serial_close+0x158>
70022180:	e30a3b74 	movw	r3, #43892	; 0xab74
70022184:	e3473002 	movt	r3, #28674	; 0x7002
70022188:	e5933000 	ldr	r3, [r3]
7002218c:	e30809e0 	movw	r0, #35296	; 0x89e0
70022190:	e3470002 	movt	r0, #28674	; 0x7002
70022194:	e3081ad0 	movw	r1, #35536	; 0x8ad0
70022198:	e3471002 	movt	r1, #28674	; 0x7002
7002219c:	e300215d 	movw	r2, #349	; 0x15d
700221a0:	e12fff33 	blx	r3

        rt_free(rx_fifo);
700221a4:	e51b000c 	ldr	r0, [fp, #-12]
700221a8:	ebff9a86 	bl	70008bc8 <rt_free>
        serial->serial_rx = RT_NULL;
700221ac:	e51b3008 	ldr	r3, [fp, #-8]
700221b0:	e3a02000 	mov	r2, #0
700221b4:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
700221b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700221bc:	e1d331b4 	ldrh	r3, [r3, #20]
700221c0:	e3c33c01 	bic	r3, r3, #256	; 0x100
700221c4:	e6ff2073 	uxth	r2, r3
700221c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700221cc:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
700221d0:	e51b3008 	ldr	r3, [fp, #-8]
700221d4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
700221d8:	e5933004 	ldr	r3, [r3, #4]
700221dc:	e51b0008 	ldr	r0, [fp, #-8]
700221e0:	e3a01011 	mov	r1, #17
700221e4:	e3a02b01 	mov	r2, #1024	; 0x400
700221e8:	e12fff33 	blx	r3
700221ec:	ea000033 	b	700222c0 <rt_serial_close+0x274>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
700221f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700221f4:	e1d331b4 	ldrh	r3, [r3, #20]
700221f8:	e2033c02 	and	r3, r3, #512	; 0x200
700221fc:	e3530000 	cmp	r3, #0
70022200:	0a00002e 	beq	700222c0 <rt_serial_close+0x274>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
70022204:	e51b3008 	ldr	r3, [fp, #-8]
70022208:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
7002220c:	e50b3010 	str	r3, [fp, #-16]
        RT_ASSERT(rx_dma != RT_NULL);
70022210:	e51b3010 	ldr	r3, [fp, #-16]
70022214:	e3530000 	cmp	r3, #0
70022218:	1a00001d 	bne	70022294 <rt_serial_close+0x248>
7002221c:	e3a03000 	mov	r3, #0
70022220:	e54b301b 	strb	r3, [fp, #-27]
70022224:	e30a3b74 	movw	r3, #43892	; 0xab74
70022228:	e3473002 	movt	r3, #28674	; 0x7002
7002222c:	e5933000 	ldr	r3, [r3]
70022230:	e3530000 	cmp	r3, #0
70022234:	1a00000d 	bne	70022270 <rt_serial_close+0x224>
70022238:	e30809ac 	movw	r0, #35244	; 0x89ac
7002223c:	e3470002 	movt	r0, #28674	; 0x7002
70022240:	e3081a30 	movw	r1, #35376	; 0x8a30
70022244:	e3471002 	movt	r1, #28674	; 0x7002
70022248:	e3082ad0 	movw	r2, #35536	; 0x8ad0
7002224c:	e3472002 	movt	r2, #28674	; 0x7002
70022250:	e300316a 	movw	r3, #362	; 0x16a
70022254:	ebff9566 	bl	700077f4 <rt_kprintf>
70022258:	e1a00000 	nop			; (mov r0, r0)
7002225c:	e55b301b 	ldrb	r3, [fp, #-27]
70022260:	e6ef3073 	uxtb	r3, r3
70022264:	e3530000 	cmp	r3, #0
70022268:	0afffffb 	beq	7002225c <rt_serial_close+0x210>
7002226c:	ea000008 	b	70022294 <rt_serial_close+0x248>
70022270:	e30a3b74 	movw	r3, #43892	; 0xab74
70022274:	e3473002 	movt	r3, #28674	; 0x7002
70022278:	e5933000 	ldr	r3, [r3]
7002227c:	e3080a30 	movw	r0, #35376	; 0x8a30
70022280:	e3470002 	movt	r0, #28674	; 0x7002
70022284:	e3081ad0 	movw	r1, #35536	; 0x8ad0
70022288:	e3471002 	movt	r1, #28674	; 0x7002
7002228c:	e300216a 	movw	r2, #362	; 0x16a
70022290:	e12fff33 	blx	r3

        rt_free(rx_dma);
70022294:	e51b0010 	ldr	r0, [fp, #-16]
70022298:	ebff9a4a 	bl	70008bc8 <rt_free>
        serial->serial_rx = RT_NULL;
7002229c:	e51b3008 	ldr	r3, [fp, #-8]
700222a0:	e3a02000 	mov	r2, #0
700222a4:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
700222a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700222ac:	e1d331b4 	ldrh	r3, [r3, #20]
700222b0:	e3c33c02 	bic	r3, r3, #512	; 0x200
700222b4:	e6ff2073 	uxth	r2, r3
700222b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700222bc:	e1c321b4 	strh	r2, [r3, #20]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
700222c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700222c4:	e1d331b4 	ldrh	r3, [r3, #20]
700222c8:	e2033b01 	and	r3, r3, #1024	; 0x400
700222cc:	e3530000 	cmp	r3, #0
700222d0:	0a000036 	beq	700223b0 <rt_serial_close+0x364>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
700222d4:	e51b3008 	ldr	r3, [fp, #-8]
700222d8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
700222dc:	e50b3014 	str	r3, [fp, #-20]
        RT_ASSERT(tx_fifo != RT_NULL);
700222e0:	e51b3014 	ldr	r3, [fp, #-20]
700222e4:	e3530000 	cmp	r3, #0
700222e8:	1a00001d 	bne	70022364 <rt_serial_close+0x318>
700222ec:	e3a03000 	mov	r3, #0
700222f0:	e54b301c 	strb	r3, [fp, #-28]
700222f4:	e30a3b74 	movw	r3, #43892	; 0xab74
700222f8:	e3473002 	movt	r3, #28674	; 0x7002
700222fc:	e5933000 	ldr	r3, [r3]
70022300:	e3530000 	cmp	r3, #0
70022304:	1a00000d 	bne	70022340 <rt_serial_close+0x2f4>
70022308:	e30809ac 	movw	r0, #35244	; 0x89ac
7002230c:	e3470002 	movt	r0, #28674	; 0x7002
70022310:	e3081a68 	movw	r1, #35432	; 0x8a68
70022314:	e3471002 	movt	r1, #28674	; 0x7002
70022318:	e3082ad0 	movw	r2, #35536	; 0x8ad0
7002231c:	e3472002 	movt	r2, #28674	; 0x7002
70022320:	e3003176 	movw	r3, #374	; 0x176
70022324:	ebff9532 	bl	700077f4 <rt_kprintf>
70022328:	e1a00000 	nop			; (mov r0, r0)
7002232c:	e55b301c 	ldrb	r3, [fp, #-28]
70022330:	e6ef3073 	uxtb	r3, r3
70022334:	e3530000 	cmp	r3, #0
70022338:	0afffffb 	beq	7002232c <rt_serial_close+0x2e0>
7002233c:	ea000008 	b	70022364 <rt_serial_close+0x318>
70022340:	e30a3b74 	movw	r3, #43892	; 0xab74
70022344:	e3473002 	movt	r3, #28674	; 0x7002
70022348:	e5933000 	ldr	r3, [r3]
7002234c:	e3080a68 	movw	r0, #35432	; 0x8a68
70022350:	e3470002 	movt	r0, #28674	; 0x7002
70022354:	e3081ad0 	movw	r1, #35536	; 0x8ad0
70022358:	e3471002 	movt	r1, #28674	; 0x7002
7002235c:	e3002176 	movw	r2, #374	; 0x176
70022360:	e12fff33 	blx	r3

        rt_free(tx_fifo);
70022364:	e51b0014 	ldr	r0, [fp, #-20]
70022368:	ebff9a16 	bl	70008bc8 <rt_free>
        serial->serial_tx = RT_NULL;
7002236c:	e51b3008 	ldr	r3, [fp, #-8]
70022370:	e3a02000 	mov	r2, #0
70022374:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
70022378:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002237c:	e1d331b4 	ldrh	r3, [r3, #20]
70022380:	e3c33b01 	bic	r3, r3, #1024	; 0x400
70022384:	e6ff2073 	uxth	r2, r3
70022388:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002238c:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
70022390:	e51b3008 	ldr	r3, [fp, #-8]
70022394:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022398:	e5933004 	ldr	r3, [r3, #4]
7002239c:	e51b0008 	ldr	r0, [fp, #-8]
700223a0:	e3a01011 	mov	r1, #17
700223a4:	e3a02b01 	mov	r2, #1024	; 0x400
700223a8:	e12fff33 	blx	r3
700223ac:	ea000033 	b	70022480 <rt_serial_close+0x434>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
700223b0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
700223b4:	e1d331b4 	ldrh	r3, [r3, #20]
700223b8:	e2033b02 	and	r3, r3, #2048	; 0x800
700223bc:	e3530000 	cmp	r3, #0
700223c0:	0a00002e 	beq	70022480 <rt_serial_close+0x434>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
700223c4:	e51b3008 	ldr	r3, [fp, #-8]
700223c8:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
700223cc:	e50b3018 	str	r3, [fp, #-24]
        RT_ASSERT(tx_dma != RT_NULL);
700223d0:	e51b3018 	ldr	r3, [fp, #-24]
700223d4:	e3530000 	cmp	r3, #0
700223d8:	1a00001d 	bne	70022454 <rt_serial_close+0x408>
700223dc:	e3a03000 	mov	r3, #0
700223e0:	e54b301d 	strb	r3, [fp, #-29]
700223e4:	e30a3b74 	movw	r3, #43892	; 0xab74
700223e8:	e3473002 	movt	r3, #28674	; 0x7002
700223ec:	e5933000 	ldr	r3, [r3]
700223f0:	e3530000 	cmp	r3, #0
700223f4:	1a00000d 	bne	70022430 <rt_serial_close+0x3e4>
700223f8:	e30809ac 	movw	r0, #35244	; 0x89ac
700223fc:	e3470002 	movt	r0, #28674	; 0x7002
70022400:	e3081a54 	movw	r1, #35412	; 0x8a54
70022404:	e3471002 	movt	r1, #28674	; 0x7002
70022408:	e3082ad0 	movw	r2, #35536	; 0x8ad0
7002240c:	e3472002 	movt	r2, #28674	; 0x7002
70022410:	e3003183 	movw	r3, #387	; 0x183
70022414:	ebff94f6 	bl	700077f4 <rt_kprintf>
70022418:	e1a00000 	nop			; (mov r0, r0)
7002241c:	e55b301d 	ldrb	r3, [fp, #-29]
70022420:	e6ef3073 	uxtb	r3, r3
70022424:	e3530000 	cmp	r3, #0
70022428:	0afffffb 	beq	7002241c <rt_serial_close+0x3d0>
7002242c:	ea000008 	b	70022454 <rt_serial_close+0x408>
70022430:	e30a3b74 	movw	r3, #43892	; 0xab74
70022434:	e3473002 	movt	r3, #28674	; 0x7002
70022438:	e5933000 	ldr	r3, [r3]
7002243c:	e3080a54 	movw	r0, #35412	; 0x8a54
70022440:	e3470002 	movt	r0, #28674	; 0x7002
70022444:	e3081ad0 	movw	r1, #35536	; 0x8ad0
70022448:	e3471002 	movt	r1, #28674	; 0x7002
7002244c:	e3002183 	movw	r2, #387	; 0x183
70022450:	e12fff33 	blx	r3

        rt_free(tx_dma);
70022454:	e51b0018 	ldr	r0, [fp, #-24]
70022458:	ebff99da 	bl	70008bc8 <rt_free>
        serial->serial_tx = RT_NULL;
7002245c:	e51b3008 	ldr	r3, [fp, #-8]
70022460:	e3a02000 	mov	r2, #0
70022464:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
70022468:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002246c:	e1d331b4 	ldrh	r3, [r3, #20]
70022470:	e3c33b02 	bic	r3, r3, #2048	; 0x800
70022474:	e6ff2073 	uxth	r2, r3
70022478:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
7002247c:	e1c321b4 	strh	r2, [r3, #20]
    }

    return RT_EOK;
70022480:	e3a03000 	mov	r3, #0
}
70022484:	e1a00003 	mov	r0, r3
70022488:	e24bd004 	sub	sp, fp, #4
7002248c:	e8bd8800 	pop	{fp, pc}

70022490 <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
70022490:	e92d4800 	push	{fp, lr}
70022494:	e28db004 	add	fp, sp, #4
70022498:	e24dd018 	sub	sp, sp, #24
7002249c:	e50b0010 	str	r0, [fp, #-16]
700224a0:	e50b1014 	str	r1, [fp, #-20]
700224a4:	e50b2018 	str	r2, [fp, #-24]
700224a8:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
700224ac:	e51b3010 	ldr	r3, [fp, #-16]
700224b0:	e3530000 	cmp	r3, #0
700224b4:	1a00001d 	bne	70022530 <rt_serial_read+0xa0>
700224b8:	e3a03000 	mov	r3, #0
700224bc:	e54b3009 	strb	r3, [fp, #-9]
700224c0:	e30a3b74 	movw	r3, #43892	; 0xab74
700224c4:	e3473002 	movt	r3, #28674	; 0x7002
700224c8:	e5933000 	ldr	r3, [r3]
700224cc:	e3530000 	cmp	r3, #0
700224d0:	1a00000d 	bne	7002250c <rt_serial_read+0x7c>
700224d4:	e30809ac 	movw	r0, #35244	; 0x89ac
700224d8:	e3470002 	movt	r0, #28674	; 0x7002
700224dc:	e3081a44 	movw	r1, #35396	; 0x8a44
700224e0:	e3471002 	movt	r1, #28674	; 0x7002
700224e4:	e3082ae0 	movw	r2, #35552	; 0x8ae0
700224e8:	e3472002 	movt	r2, #28674	; 0x7002
700224ec:	e3a03f65 	mov	r3, #404	; 0x194
700224f0:	ebff94bf 	bl	700077f4 <rt_kprintf>
700224f4:	e1a00000 	nop			; (mov r0, r0)
700224f8:	e55b3009 	ldrb	r3, [fp, #-9]
700224fc:	e6ef3073 	uxtb	r3, r3
70022500:	e3530000 	cmp	r3, #0
70022504:	0afffffb 	beq	700224f8 <rt_serial_read+0x68>
70022508:	ea000008 	b	70022530 <rt_serial_read+0xa0>
7002250c:	e30a3b74 	movw	r3, #43892	; 0xab74
70022510:	e3473002 	movt	r3, #28674	; 0x7002
70022514:	e5933000 	ldr	r3, [r3]
70022518:	e3080a44 	movw	r0, #35396	; 0x8a44
7002251c:	e3470002 	movt	r0, #28674	; 0x7002
70022520:	e3081ae0 	movw	r1, #35552	; 0x8ae0
70022524:	e3471002 	movt	r1, #28674	; 0x7002
70022528:	e3a02f65 	mov	r2, #404	; 0x194
7002252c:	e12fff33 	blx	r3
    if (size == 0) return 0;
70022530:	e51b301c 	ldr	r3, [fp, #-28]
70022534:	e3530000 	cmp	r3, #0
70022538:	1a000001 	bne	70022544 <rt_serial_read+0xb4>
7002253c:	e3a03000 	mov	r3, #0
70022540:	ea00001f 	b	700225c4 <rt_serial_read+0x134>

    serial = (struct rt_serial_device *)dev;
70022544:	e51b3010 	ldr	r3, [fp, #-16]
70022548:	e50b3008 	str	r3, [fp, #-8]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
7002254c:	e51b3010 	ldr	r3, [fp, #-16]
70022550:	e1d331b4 	ldrh	r3, [r3, #20]
70022554:	e2033c01 	and	r3, r3, #256	; 0x100
70022558:	e3530000 	cmp	r3, #0
7002255c:	0a000006 	beq	7002257c <rt_serial_read+0xec>
    {
        return _serial_int_rx(serial, buffer, size);
70022560:	e51b301c 	ldr	r3, [fp, #-28]
70022564:	e51b0008 	ldr	r0, [fp, #-8]
70022568:	e51b1018 	ldr	r1, [fp, #-24]
7002256c:	e1a02003 	mov	r2, r3
70022570:	ebfffb70 	bl	70021338 <_serial_int_rx>
70022574:	e1a03000 	mov	r3, r0
70022578:	ea000011 	b	700225c4 <rt_serial_read+0x134>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
7002257c:	e51b3010 	ldr	r3, [fp, #-16]
70022580:	e1d331b4 	ldrh	r3, [r3, #20]
70022584:	e2033c02 	and	r3, r3, #512	; 0x200
70022588:	e3530000 	cmp	r3, #0
7002258c:	0a000006 	beq	700225ac <rt_serial_read+0x11c>
    {
        return _serial_dma_rx(serial, buffer, size);
70022590:	e51b301c 	ldr	r3, [fp, #-28]
70022594:	e51b0008 	ldr	r0, [fp, #-8]
70022598:	e51b1018 	ldr	r1, [fp, #-24]
7002259c:	e1a02003 	mov	r2, r3
700225a0:	ebfffc5a 	bl	70021710 <_serial_dma_rx>
700225a4:	e1a03000 	mov	r3, r0
700225a8:	ea000005 	b	700225c4 <rt_serial_read+0x134>
    }

    return _serial_poll_rx(serial, buffer, size);
700225ac:	e51b301c 	ldr	r3, [fp, #-28]
700225b0:	e51b0008 	ldr	r0, [fp, #-8]
700225b4:	e51b1018 	ldr	r1, [fp, #-24]
700225b8:	e1a02003 	mov	r2, r3
700225bc:	ebfffac6 	bl	700210dc <_serial_poll_rx>
700225c0:	e1a03000 	mov	r3, r0
}
700225c4:	e1a00003 	mov	r0, r3
700225c8:	e24bd004 	sub	sp, fp, #4
700225cc:	e8bd8800 	pop	{fp, pc}

700225d0 <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
700225d0:	e92d4800 	push	{fp, lr}
700225d4:	e28db004 	add	fp, sp, #4
700225d8:	e24dd018 	sub	sp, sp, #24
700225dc:	e50b0010 	str	r0, [fp, #-16]
700225e0:	e50b1014 	str	r1, [fp, #-20]
700225e4:	e50b2018 	str	r2, [fp, #-24]
700225e8:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
700225ec:	e51b3010 	ldr	r3, [fp, #-16]
700225f0:	e3530000 	cmp	r3, #0
700225f4:	1a00001d 	bne	70022670 <rt_serial_write+0xa0>
700225f8:	e3a03000 	mov	r3, #0
700225fc:	e54b3009 	strb	r3, [fp, #-9]
70022600:	e30a3b74 	movw	r3, #43892	; 0xab74
70022604:	e3473002 	movt	r3, #28674	; 0x7002
70022608:	e5933000 	ldr	r3, [r3]
7002260c:	e3530000 	cmp	r3, #0
70022610:	1a00000d 	bne	7002264c <rt_serial_write+0x7c>
70022614:	e30809ac 	movw	r0, #35244	; 0x89ac
70022618:	e3470002 	movt	r0, #28674	; 0x7002
7002261c:	e3081a44 	movw	r1, #35396	; 0x8a44
70022620:	e3471002 	movt	r1, #28674	; 0x7002
70022624:	e3082b20 	movw	r2, #35616	; 0x8b20
70022628:	e3472002 	movt	r2, #28674	; 0x7002
7002262c:	e3a03f6b 	mov	r3, #428	; 0x1ac
70022630:	ebff946f 	bl	700077f4 <rt_kprintf>
70022634:	e1a00000 	nop			; (mov r0, r0)
70022638:	e55b3009 	ldrb	r3, [fp, #-9]
7002263c:	e6ef3073 	uxtb	r3, r3
70022640:	e3530000 	cmp	r3, #0
70022644:	0afffffb 	beq	70022638 <rt_serial_write+0x68>
70022648:	ea000008 	b	70022670 <rt_serial_write+0xa0>
7002264c:	e30a3b74 	movw	r3, #43892	; 0xab74
70022650:	e3473002 	movt	r3, #28674	; 0x7002
70022654:	e5933000 	ldr	r3, [r3]
70022658:	e3080a44 	movw	r0, #35396	; 0x8a44
7002265c:	e3470002 	movt	r0, #28674	; 0x7002
70022660:	e3081b20 	movw	r1, #35616	; 0x8b20
70022664:	e3471002 	movt	r1, #28674	; 0x7002
70022668:	e3a02f6b 	mov	r2, #428	; 0x1ac
7002266c:	e12fff33 	blx	r3
    if (size == 0) return 0;
70022670:	e51b301c 	ldr	r3, [fp, #-28]
70022674:	e3530000 	cmp	r3, #0
70022678:	1a000001 	bne	70022684 <rt_serial_write+0xb4>
7002267c:	e3a03000 	mov	r3, #0
70022680:	ea00001f 	b	70022704 <rt_serial_write+0x134>

    serial = (struct rt_serial_device *)dev;
70022684:	e51b3010 	ldr	r3, [fp, #-16]
70022688:	e50b3008 	str	r3, [fp, #-8]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
7002268c:	e51b3010 	ldr	r3, [fp, #-16]
70022690:	e1d331b4 	ldrh	r3, [r3, #20]
70022694:	e2033b01 	and	r3, r3, #1024	; 0x400
70022698:	e3530000 	cmp	r3, #0
7002269c:	0a000006 	beq	700226bc <rt_serial_write+0xec>
    {
        return _serial_int_tx(serial, buffer, size);
700226a0:	e51b301c 	ldr	r3, [fp, #-28]
700226a4:	e51b0008 	ldr	r0, [fp, #-8]
700226a8:	e51b1018 	ldr	r1, [fp, #-24]
700226ac:	e1a02003 	mov	r2, r3
700226b0:	ebfffba8 	bl	70021558 <_serial_int_tx>
700226b4:	e1a03000 	mov	r3, r0
700226b8:	ea000011 	b	70022704 <rt_serial_write+0x134>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
700226bc:	e51b3010 	ldr	r3, [fp, #-16]
700226c0:	e1d331b4 	ldrh	r3, [r3, #20]
700226c4:	e2033b02 	and	r3, r3, #2048	; 0x800
700226c8:	e3530000 	cmp	r3, #0
700226cc:	0a000006 	beq	700226ec <rt_serial_write+0x11c>
    {
        return _serial_dma_tx(serial, buffer, size);
700226d0:	e51b301c 	ldr	r3, [fp, #-28]
700226d4:	e51b0008 	ldr	r0, [fp, #-8]
700226d8:	e51b1018 	ldr	r1, [fp, #-24]
700226dc:	e1a02003 	mov	r2, r3
700226e0:	ebfffc7c 	bl	700218d8 <_serial_dma_tx>
700226e4:	e1a03000 	mov	r3, r0
700226e8:	ea000005 	b	70022704 <rt_serial_write+0x134>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
700226ec:	e51b301c 	ldr	r3, [fp, #-28]
700226f0:	e51b0008 	ldr	r0, [fp, #-8]
700226f4:	e51b1018 	ldr	r1, [fp, #-24]
700226f8:	e1a02003 	mov	r2, r3
700226fc:	ebfffabd 	bl	700211f8 <_serial_poll_tx>
70022700:	e1a03000 	mov	r3, r0
    }
}
70022704:	e1a00003 	mov	r0, r3
70022708:	e24bd004 	sub	sp, fp, #4
7002270c:	e8bd8800 	pop	{fp, pc}

70022710 <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
70022710:	e92d4800 	push	{fp, lr}
70022714:	e28db004 	add	fp, sp, #4
70022718:	e24dd018 	sub	sp, sp, #24
7002271c:	e50b0010 	str	r0, [fp, #-16]
70022720:	e1a03001 	mov	r3, r1
70022724:	e50b2018 	str	r2, [fp, #-24]
70022728:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
7002272c:	e51b3010 	ldr	r3, [fp, #-16]
70022730:	e3530000 	cmp	r3, #0
70022734:	1a00001d 	bne	700227b0 <rt_serial_control+0xa0>
70022738:	e3a03000 	mov	r3, #0
7002273c:	e54b3009 	strb	r3, [fp, #-9]
70022740:	e30a3b74 	movw	r3, #43892	; 0xab74
70022744:	e3473002 	movt	r3, #28674	; 0x7002
70022748:	e5933000 	ldr	r3, [r3]
7002274c:	e3530000 	cmp	r3, #0
70022750:	1a00000d 	bne	7002278c <rt_serial_control+0x7c>
70022754:	e30809ac 	movw	r0, #35244	; 0x89ac
70022758:	e3470002 	movt	r0, #28674	; 0x7002
7002275c:	e3081a44 	movw	r1, #35396	; 0x8a44
70022760:	e3471002 	movt	r1, #28674	; 0x7002
70022764:	e3082b50 	movw	r2, #35664	; 0x8b50
70022768:	e3472002 	movt	r2, #28674	; 0x7002
7002276c:	e30031c5 	movw	r3, #453	; 0x1c5
70022770:	ebff941f 	bl	700077f4 <rt_kprintf>
70022774:	e1a00000 	nop			; (mov r0, r0)
70022778:	e55b3009 	ldrb	r3, [fp, #-9]
7002277c:	e6ef3073 	uxtb	r3, r3
70022780:	e3530000 	cmp	r3, #0
70022784:	0afffffb 	beq	70022778 <rt_serial_control+0x68>
70022788:	ea000008 	b	700227b0 <rt_serial_control+0xa0>
7002278c:	e30a3b74 	movw	r3, #43892	; 0xab74
70022790:	e3473002 	movt	r3, #28674	; 0x7002
70022794:	e5933000 	ldr	r3, [r3]
70022798:	e3080a44 	movw	r0, #35396	; 0x8a44
7002279c:	e3470002 	movt	r0, #28674	; 0x7002
700227a0:	e3081b50 	movw	r1, #35664	; 0x8b50
700227a4:	e3471002 	movt	r1, #28674	; 0x7002
700227a8:	e30021c5 	movw	r2, #453	; 0x1c5
700227ac:	e12fff33 	blx	r3
    serial = (struct rt_serial_device *)dev;
700227b0:	e51b3010 	ldr	r3, [fp, #-16]
700227b4:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
700227b8:	e55b3011 	ldrb	r3, [fp, #-17]
700227bc:	e3530002 	cmp	r3, #2
700227c0:	0a000004 	beq	700227d8 <rt_serial_control+0xc8>
700227c4:	e3530003 	cmp	r3, #3
700227c8:	0a000010 	beq	70022810 <rt_serial_control+0x100>
700227cc:	e3530001 	cmp	r3, #1
700227d0:	0a000007 	beq	700227f4 <rt_serial_control+0xe4>
700227d4:	ea000014 	b	7002282c <rt_serial_control+0x11c>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
700227d8:	e51b3010 	ldr	r3, [fp, #-16]
700227dc:	e1d331b2 	ldrh	r3, [r3, #18]
700227e0:	e3833020 	orr	r3, r3, #32
700227e4:	e6ff2073 	uxth	r2, r3
700227e8:	e51b3010 	ldr	r3, [fp, #-16]
700227ec:	e1c321b2 	strh	r2, [r3, #18]
            break;
700227f0:	ea000016 	b	70022850 <rt_serial_control+0x140>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
700227f4:	e51b3010 	ldr	r3, [fp, #-16]
700227f8:	e1d331b2 	ldrh	r3, [r3, #18]
700227fc:	e3c33020 	bic	r3, r3, #32
70022800:	e6ff2073 	uxth	r2, r3
70022804:	e51b3010 	ldr	r3, [fp, #-16]
70022808:	e1c321b2 	strh	r2, [r3, #18]
            break;
7002280c:	ea00000f 	b	70022850 <rt_serial_control+0x140>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
70022810:	e51b3008 	ldr	r3, [fp, #-8]
70022814:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022818:	e5933000 	ldr	r3, [r3]
7002281c:	e51b0008 	ldr	r0, [fp, #-8]
70022820:	e51b1018 	ldr	r1, [fp, #-24]
70022824:	e12fff33 	blx	r3
            break;
70022828:	ea000008 	b	70022850 <rt_serial_control+0x140>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
7002282c:	e51b3008 	ldr	r3, [fp, #-8]
70022830:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022834:	e5933004 	ldr	r3, [r3, #4]
70022838:	e55b2011 	ldrb	r2, [fp, #-17]
7002283c:	e51b0008 	ldr	r0, [fp, #-8]
70022840:	e1a01002 	mov	r1, r2
70022844:	e51b2018 	ldr	r2, [fp, #-24]
70022848:	e12fff33 	blx	r3
            break;
7002284c:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
70022850:	e3a03000 	mov	r3, #0
}
70022854:	e1a00003 	mov	r0, r3
70022858:	e24bd004 	sub	sp, fp, #4
7002285c:	e8bd8800 	pop	{fp, pc}

70022860 <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
70022860:	e92d4800 	push	{fp, lr}
70022864:	e28db004 	add	fp, sp, #4
70022868:	e24dd018 	sub	sp, sp, #24
7002286c:	e50b0010 	str	r0, [fp, #-16]
70022870:	e50b1014 	str	r1, [fp, #-20]
70022874:	e50b2018 	str	r2, [fp, #-24]
70022878:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
7002287c:	e51b3010 	ldr	r3, [fp, #-16]
70022880:	e3530000 	cmp	r3, #0
70022884:	1a00001d 	bne	70022900 <rt_hw_serial_register+0xa0>
70022888:	e3a03000 	mov	r3, #0
7002288c:	e54b3009 	strb	r3, [fp, #-9]
70022890:	e30a3b74 	movw	r3, #43892	; 0xab74
70022894:	e3473002 	movt	r3, #28674	; 0x7002
70022898:	e5933000 	ldr	r3, [r3]
7002289c:	e3530000 	cmp	r3, #0
700228a0:	1a00000d 	bne	700228dc <rt_hw_serial_register+0x7c>
700228a4:	e30809ac 	movw	r0, #35244	; 0x89ac
700228a8:	e3470002 	movt	r0, #28674	; 0x7002
700228ac:	e30819cc 	movw	r1, #35276	; 0x89cc
700228b0:	e3471002 	movt	r1, #28674	; 0x7002
700228b4:	e3082b64 	movw	r2, #35684	; 0x8b64
700228b8:	e3472002 	movt	r2, #28674	; 0x7002
700228bc:	e30031eb 	movw	r3, #491	; 0x1eb
700228c0:	ebff93cb 	bl	700077f4 <rt_kprintf>
700228c4:	e1a00000 	nop			; (mov r0, r0)
700228c8:	e55b3009 	ldrb	r3, [fp, #-9]
700228cc:	e6ef3073 	uxtb	r3, r3
700228d0:	e3530000 	cmp	r3, #0
700228d4:	0afffffb 	beq	700228c8 <rt_hw_serial_register+0x68>
700228d8:	ea000008 	b	70022900 <rt_hw_serial_register+0xa0>
700228dc:	e30a3b74 	movw	r3, #43892	; 0xab74
700228e0:	e3473002 	movt	r3, #28674	; 0x7002
700228e4:	e5933000 	ldr	r3, [r3]
700228e8:	e30809cc 	movw	r0, #35276	; 0x89cc
700228ec:	e3470002 	movt	r0, #28674	; 0x7002
700228f0:	e3081b64 	movw	r1, #35684	; 0x8b64
700228f4:	e3471002 	movt	r1, #28674	; 0x7002
700228f8:	e30021eb 	movw	r2, #491	; 0x1eb
700228fc:	e12fff33 	blx	r3

    device = &(serial->parent);
70022900:	e51b3010 	ldr	r3, [fp, #-16]
70022904:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Char;
70022908:	e51b3008 	ldr	r3, [fp, #-8]
7002290c:	e3a02000 	mov	r2, #0
70022910:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
70022914:	e51b3008 	ldr	r3, [fp, #-8]
70022918:	e3a02000 	mov	r2, #0
7002291c:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
70022920:	e51b3008 	ldr	r3, [fp, #-8]
70022924:	e3a02000 	mov	r2, #0
70022928:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_serial_init;
7002292c:	e51b2008 	ldr	r2, [fp, #-8]
70022930:	e30139a8 	movw	r3, #6568	; 0x19a8
70022934:	e3473002 	movt	r3, #28674	; 0x7002
70022938:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_serial_open;
7002293c:	e51b2008 	ldr	r2, [fp, #-8]
70022940:	e3013aac 	movw	r3, #6828	; 0x1aac
70022944:	e3473002 	movt	r3, #28674	; 0x7002
70022948:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_serial_close;
7002294c:	e51b2008 	ldr	r2, [fp, #-8]
70022950:	e302304c 	movw	r3, #8268	; 0x204c
70022954:	e3473002 	movt	r3, #28674	; 0x7002
70022958:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->read        = rt_serial_read;
7002295c:	e51b2008 	ldr	r2, [fp, #-8]
70022960:	e3023490 	movw	r3, #9360	; 0x2490
70022964:	e3473002 	movt	r3, #28674	; 0x7002
70022968:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->write       = rt_serial_write;
7002296c:	e51b2008 	ldr	r2, [fp, #-8]
70022970:	e30235d0 	movw	r3, #9680	; 0x25d0
70022974:	e3473002 	movt	r3, #28674	; 0x7002
70022978:	e5823030 	str	r3, [r2, #48]	; 0x30
    device->control     = rt_serial_control;
7002297c:	e51b2008 	ldr	r2, [fp, #-8]
70022980:	e3023710 	movw	r3, #10000	; 0x2710
70022984:	e3473002 	movt	r3, #28674	; 0x7002
70022988:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->user_data   = data;
7002298c:	e51b3008 	ldr	r3, [fp, #-8]
70022990:	e51b201c 	ldr	r2, [fp, #-28]
70022994:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
70022998:	e51b3018 	ldr	r3, [fp, #-24]
7002299c:	e6ff3073 	uxth	r3, r3
700229a0:	e51b0008 	ldr	r0, [fp, #-8]
700229a4:	e51b1014 	ldr	r1, [fp, #-20]
700229a8:	e1a02003 	mov	r2, r3
700229ac:	ebff77c8 	bl	700008d4 <rt_device_register>
700229b0:	e1a03000 	mov	r3, r0
}
700229b4:	e1a00003 	mov	r0, r3
700229b8:	e24bd004 	sub	sp, fp, #4
700229bc:	e8bd8800 	pop	{fp, pc}

700229c0 <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
700229c0:	e92d4800 	push	{fp, lr}
700229c4:	e28db004 	add	fp, sp, #4
700229c8:	e24dd038 	sub	sp, sp, #56	; 0x38
700229cc:	e50b0038 	str	r0, [fp, #-56]	; 0x38
700229d0:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
    switch (event & 0xff)
700229d4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
700229d8:	e6ef3073 	uxtb	r3, r3
700229dc:	e2433001 	sub	r3, r3, #1
700229e0:	e3530003 	cmp	r3, #3
700229e4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
700229e8:	ea000103 	b	70022dfc <rt_hw_serial_isr+0x43c>
700229ec:	700229fc 	.word	0x700229fc
700229f0:	70022cc8 	.word	0x70022cc8
700229f4:	70022db8 	.word	0x70022db8
700229f8:	70022ce4 	.word	0x70022ce4
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
700229fc:	e3e03000 	mvn	r3, #0
70022a00:	e50b3008 	str	r3, [fp, #-8]
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
70022a04:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022a08:	e5933048 	ldr	r3, [r3, #72]	; 0x48
70022a0c:	e50b300c 	str	r3, [fp, #-12]
            RT_ASSERT(rx_fifo != RT_NULL);
70022a10:	e51b300c 	ldr	r3, [fp, #-12]
70022a14:	e3530000 	cmp	r3, #0
70022a18:	1a00001d 	bne	70022a94 <rt_hw_serial_isr+0xd4>
70022a1c:	e3a03000 	mov	r3, #0
70022a20:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
70022a24:	e30a3b74 	movw	r3, #43892	; 0xab74
70022a28:	e3473002 	movt	r3, #28674	; 0x7002
70022a2c:	e5933000 	ldr	r3, [r3]
70022a30:	e3530000 	cmp	r3, #0
70022a34:	1a00000d 	bne	70022a70 <rt_hw_serial_isr+0xb0>
70022a38:	e30809ac 	movw	r0, #35244	; 0x89ac
70022a3c:	e3470002 	movt	r0, #28674	; 0x7002
70022a40:	e30819e0 	movw	r1, #35296	; 0x89e0
70022a44:	e3471002 	movt	r1, #28674	; 0x7002
70022a48:	e3082b7c 	movw	r2, #35708	; 0x8b7c
70022a4c:	e3472002 	movt	r2, #28674	; 0x7002
70022a50:	e300320b 	movw	r3, #523	; 0x20b
70022a54:	ebff9366 	bl	700077f4 <rt_kprintf>
70022a58:	e1a00000 	nop			; (mov r0, r0)
70022a5c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
70022a60:	e6ef3073 	uxtb	r3, r3
70022a64:	e3530000 	cmp	r3, #0
70022a68:	0afffffb 	beq	70022a5c <rt_hw_serial_isr+0x9c>
70022a6c:	ea000008 	b	70022a94 <rt_hw_serial_isr+0xd4>
70022a70:	e30a3b74 	movw	r3, #43892	; 0xab74
70022a74:	e3473002 	movt	r3, #28674	; 0x7002
70022a78:	e5933000 	ldr	r3, [r3]
70022a7c:	e30809e0 	movw	r0, #35296	; 0x89e0
70022a80:	e3470002 	movt	r0, #28674	; 0x7002
70022a84:	e3081b7c 	movw	r1, #35708	; 0x8b7c
70022a88:	e3471002 	movt	r1, #28674	; 0x7002
70022a8c:	e300220b 	movw	r2, #523	; 0x20b
70022a90:	e12fff33 	blx	r3
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
70022a94:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022a98:	e1d331b4 	ldrh	r3, [r3, #20]
70022a9c:	e2033c01 	and	r3, r3, #256	; 0x100
70022aa0:	e3530000 	cmp	r3, #0
70022aa4:	1a00001d 	bne	70022b20 <rt_hw_serial_isr+0x160>
70022aa8:	e3a03000 	mov	r3, #0
70022aac:	e54b3026 	strb	r3, [fp, #-38]	; 0x26
70022ab0:	e30a3b74 	movw	r3, #43892	; 0xab74
70022ab4:	e3473002 	movt	r3, #28674	; 0x7002
70022ab8:	e5933000 	ldr	r3, [r3]
70022abc:	e3530000 	cmp	r3, #0
70022ac0:	1a00000d 	bne	70022afc <rt_hw_serial_isr+0x13c>
70022ac4:	e30809ac 	movw	r0, #35244	; 0x89ac
70022ac8:	e3470002 	movt	r0, #28674	; 0x7002
70022acc:	e3081a7c 	movw	r1, #35452	; 0x8a7c
70022ad0:	e3471002 	movt	r1, #28674	; 0x7002
70022ad4:	e3082b7c 	movw	r2, #35708	; 0x8b7c
70022ad8:	e3472002 	movt	r2, #28674	; 0x7002
70022adc:	e300320e 	movw	r3, #526	; 0x20e
70022ae0:	ebff9343 	bl	700077f4 <rt_kprintf>
70022ae4:	e1a00000 	nop			; (mov r0, r0)
70022ae8:	e55b3026 	ldrb	r3, [fp, #-38]	; 0x26
70022aec:	e6ef3073 	uxtb	r3, r3
70022af0:	e3530000 	cmp	r3, #0
70022af4:	0afffffb 	beq	70022ae8 <rt_hw_serial_isr+0x128>
70022af8:	ea000008 	b	70022b20 <rt_hw_serial_isr+0x160>
70022afc:	e30a3b74 	movw	r3, #43892	; 0xab74
70022b00:	e3473002 	movt	r3, #28674	; 0x7002
70022b04:	e5933000 	ldr	r3, [r3]
70022b08:	e3080a7c 	movw	r0, #35452	; 0x8a7c
70022b0c:	e3470002 	movt	r0, #28674	; 0x7002
70022b10:	e3081b7c 	movw	r1, #35708	; 0x8b7c
70022b14:	e3471002 	movt	r1, #28674	; 0x7002
70022b18:	e300220e 	movw	r2, #526	; 0x20e
70022b1c:	e12fff33 	blx	r3
            
            while (1)
            {
                ch = serial->ops->getc(serial);
70022b20:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022b24:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022b28:	e593300c 	ldr	r3, [r3, #12]
70022b2c:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
70022b30:	e12fff33 	blx	r3
70022b34:	e50b0008 	str	r0, [fp, #-8]
                if (ch == -1) break;
70022b38:	e51b3008 	ldr	r3, [fp, #-8]
70022b3c:	e3730001 	cmn	r3, #1
70022b40:	1a000005 	bne	70022b5c <rt_hw_serial_isr+0x19c>
70022b44:	e1a00000 	nop			; (mov r0, r0)
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
70022b48:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022b4c:	e5933018 	ldr	r3, [r3, #24]
70022b50:	e3530000 	cmp	r3, #0
70022b54:	0a00005a 	beq	70022cc4 <rt_hw_serial_isr+0x304>
70022b58:	ea000034 	b	70022c30 <rt_hw_serial_isr+0x270>
                ch = serial->ops->getc(serial);
                if (ch == -1) break;

                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
70022b5c:	ebffadb9 	bl	7000e248 <rt_hw_interrupt_disable>
70022b60:	e50b0010 	str	r0, [fp, #-16]
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
70022b64:	e51b300c 	ldr	r3, [fp, #-12]
70022b68:	e5932000 	ldr	r2, [r3]
70022b6c:	e51b300c 	ldr	r3, [fp, #-12]
70022b70:	e1d330b4 	ldrh	r3, [r3, #4]
70022b74:	e0823003 	add	r3, r2, r3
70022b78:	e51b2008 	ldr	r2, [fp, #-8]
70022b7c:	e6ef2072 	uxtb	r2, r2
70022b80:	e5c32000 	strb	r2, [r3]
                rx_fifo->put_index += 1;
70022b84:	e51b300c 	ldr	r3, [fp, #-12]
70022b88:	e1d330b4 	ldrh	r3, [r3, #4]
70022b8c:	e2833001 	add	r3, r3, #1
70022b90:	e6ff2073 	uxth	r2, r3
70022b94:	e51b300c 	ldr	r3, [fp, #-12]
70022b98:	e1c320b4 	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
70022b9c:	e51b300c 	ldr	r3, [fp, #-12]
70022ba0:	e1d320b4 	ldrh	r2, [r3, #4]
70022ba4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022ba8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70022bac:	e7ef3553 	ubfx	r3, r3, #10, #16
70022bb0:	e6ff3073 	uxth	r3, r3
70022bb4:	e1520003 	cmp	r2, r3
70022bb8:	3a000002 	bcc	70022bc8 <rt_hw_serial_isr+0x208>
70022bbc:	e51b300c 	ldr	r3, [fp, #-12]
70022bc0:	e3a02000 	mov	r2, #0
70022bc4:	e1c320b4 	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
70022bc8:	e51b300c 	ldr	r3, [fp, #-12]
70022bcc:	e1d320b4 	ldrh	r2, [r3, #4]
70022bd0:	e51b300c 	ldr	r3, [fp, #-12]
70022bd4:	e1d330b6 	ldrh	r3, [r3, #6]
70022bd8:	e1520003 	cmp	r2, r3
70022bdc:	1a000010 	bne	70022c24 <rt_hw_serial_isr+0x264>
                {
                    rx_fifo->get_index += 1;
70022be0:	e51b300c 	ldr	r3, [fp, #-12]
70022be4:	e1d330b6 	ldrh	r3, [r3, #6]
70022be8:	e2833001 	add	r3, r3, #1
70022bec:	e6ff2073 	uxth	r2, r3
70022bf0:	e51b300c 	ldr	r3, [fp, #-12]
70022bf4:	e1c320b6 	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
70022bf8:	e51b300c 	ldr	r3, [fp, #-12]
70022bfc:	e1d320b6 	ldrh	r2, [r3, #6]
70022c00:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022c04:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70022c08:	e7ef3553 	ubfx	r3, r3, #10, #16
70022c0c:	e6ff3073 	uxth	r3, r3
70022c10:	e1520003 	cmp	r2, r3
70022c14:	3a000002 	bcc	70022c24 <rt_hw_serial_isr+0x264>
70022c18:	e51b300c 	ldr	r3, [fp, #-12]
70022c1c:	e3a02000 	mov	r2, #0
70022c20:	e1c320b6 	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
70022c24:	e51b0010 	ldr	r0, [fp, #-16]
70022c28:	ebffad89 	bl	7000e254 <rt_hw_interrupt_enable>
            }
70022c2c:	eaffffbb 	b	70022b20 <rt_hw_serial_isr+0x160>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
70022c30:	ebffad84 	bl	7000e248 <rt_hw_interrupt_disable>
70022c34:	e50b0010 	str	r0, [fp, #-16]
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
70022c38:	e51b300c 	ldr	r3, [fp, #-12]
70022c3c:	e1d320b4 	ldrh	r2, [r3, #4]
70022c40:	e51b300c 	ldr	r3, [fp, #-12]
70022c44:	e1d330b6 	ldrh	r3, [r3, #6]
70022c48:	e1520003 	cmp	r2, r3
70022c4c:	3a000006 	bcc	70022c6c <rt_hw_serial_isr+0x2ac>
70022c50:	e51b300c 	ldr	r3, [fp, #-12]
70022c54:	e1d330b4 	ldrh	r3, [r3, #4]
70022c58:	e1a02003 	mov	r2, r3
70022c5c:	e51b300c 	ldr	r3, [fp, #-12]
70022c60:	e1d330b6 	ldrh	r3, [r3, #6]
70022c64:	e0633002 	rsb	r3, r3, r2
70022c68:	ea00000b 	b	70022c9c <rt_hw_serial_isr+0x2dc>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
70022c6c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022c70:	e5933044 	ldr	r3, [r3, #68]	; 0x44
70022c74:	e7ef3553 	ubfx	r3, r3, #10, #16
70022c78:	e6ff3073 	uxth	r3, r3
70022c7c:	e1a02003 	mov	r2, r3
70022c80:	e51b300c 	ldr	r3, [fp, #-12]
70022c84:	e1d330b4 	ldrh	r3, [r3, #4]
70022c88:	e1a01003 	mov	r1, r3
70022c8c:	e51b300c 	ldr	r3, [fp, #-12]
70022c90:	e1d330b6 	ldrh	r3, [r3, #6]
70022c94:	e0633001 	rsb	r3, r3, r1
70022c98:	e0823003 	add	r3, r2, r3
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
70022c9c:	e50b3014 	str	r3, [fp, #-20]
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
70022ca0:	e51b0010 	ldr	r0, [fp, #-16]
70022ca4:	ebffad6a 	bl	7000e254 <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
70022ca8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022cac:	e5933018 	ldr	r3, [r3, #24]
70022cb0:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
70022cb4:	e1a00002 	mov	r0, r2
70022cb8:	e51b1014 	ldr	r1, [fp, #-20]
70022cbc:	e12fff33 	blx	r3
            }
            break;
70022cc0:	ea00004d 	b	70022dfc <rt_hw_serial_isr+0x43c>
70022cc4:	ea00004c 	b	70022dfc <rt_hw_serial_isr+0x43c>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
70022cc8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022ccc:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
70022cd0:	e50b3018 	str	r3, [fp, #-24]
            rt_completion_done(&(tx_fifo->completion));
70022cd4:	e51b3018 	ldr	r3, [fp, #-24]
70022cd8:	e1a00003 	mov	r0, r3
70022cdc:	ebfff596 	bl	7002033c <rt_completion_done>
            break;
70022ce0:	ea000045 	b	70022dfc <rt_hw_serial_isr+0x43c>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
70022ce4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022ce8:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
70022cec:	e50b301c 	str	r3, [fp, #-28]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
70022cf0:	e51b301c 	ldr	r3, [fp, #-28]
70022cf4:	e2831004 	add	r1, r3, #4
70022cf8:	e24b2034 	sub	r2, fp, #52	; 0x34
70022cfc:	e24b3030 	sub	r3, fp, #48	; 0x30
70022d00:	e1a00001 	mov	r0, r1
70022d04:	e1a01002 	mov	r1, r2
70022d08:	e1a02003 	mov	r2, r3
70022d0c:	e3a03000 	mov	r3, #0
70022d10:	ebfff72f 	bl	700209d4 <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
70022d14:	e51b301c 	ldr	r3, [fp, #-28]
70022d18:	e2831004 	add	r1, r3, #4
70022d1c:	e24b202c 	sub	r2, fp, #44	; 0x2c
70022d20:	e24b3030 	sub	r3, fp, #48	; 0x30
70022d24:	e1a00001 	mov	r0, r1
70022d28:	e1a01002 	mov	r1, r2
70022d2c:	e1a02003 	mov	r2, r3
70022d30:	ebfff85a 	bl	70020ea0 <rt_data_queue_peak>
70022d34:	e1a03000 	mov	r3, r0
70022d38:	e3530000 	cmp	r3, #0
70022d3c:	1a00000d 	bne	70022d78 <rt_hw_serial_isr+0x3b8>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
70022d40:	e51b301c 	ldr	r3, [fp, #-28]
70022d44:	e3a02001 	mov	r2, #1
70022d48:	e5832000 	str	r2, [r3]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
70022d4c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022d50:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
70022d54:	e593c010 	ldr	ip, [r3, #16]
70022d58:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
70022d5c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
70022d60:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
70022d64:	e1a01002 	mov	r1, r2
70022d68:	e1a02003 	mov	r2, r3
70022d6c:	e3a03002 	mov	r3, #2
70022d70:	e12fff3c 	blx	ip
70022d74:	ea000002 	b	70022d84 <rt_hw_serial_isr+0x3c4>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
70022d78:	e51b301c 	ldr	r3, [fp, #-28]
70022d7c:	e3a02000 	mov	r2, #0
70022d80:	e5832000 	str	r2, [r3]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
70022d84:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022d88:	e593301c 	ldr	r3, [r3, #28]
70022d8c:	e3530000 	cmp	r3, #0
70022d90:	0a000006 	beq	70022db0 <rt_hw_serial_isr+0x3f0>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
70022d94:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022d98:	e593301c 	ldr	r3, [r3, #28]
70022d9c:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
70022da0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
70022da4:	e1a00001 	mov	r0, r1
70022da8:	e1a01002 	mov	r1, r2
70022dac:	e12fff33 	blx	r3
            }
            break;
70022db0:	e1a00000 	nop			; (mov r0, r0)
70022db4:	ea000010 	b	70022dfc <rt_hw_serial_isr+0x43c>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
70022db8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022dbc:	e5933048 	ldr	r3, [r3, #72]	; 0x48
70022dc0:	e50b3020 	str	r3, [fp, #-32]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
70022dc4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
70022dc8:	e1a03443 	asr	r3, r3, #8
70022dcc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            serial->parent.rx_indicate(&(serial->parent), length);
70022dd0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
70022dd4:	e5933018 	ldr	r3, [r3, #24]
70022dd8:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
70022ddc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
70022de0:	e1a00001 	mov	r0, r1
70022de4:	e1a01002 	mov	r1, r2
70022de8:	e12fff33 	blx	r3
            rx_dma->activated = RT_FALSE;
70022dec:	e51b3020 	ldr	r3, [fp, #-32]
70022df0:	e3a02000 	mov	r2, #0
70022df4:	e5832000 	str	r2, [r3]
            break;
70022df8:	e1a00000 	nop			; (mov r0, r0)
        }
    }
}
70022dfc:	e24bd004 	sub	sp, fp, #4
70022e00:	e8bd8800 	pop	{fp, pc}

70022e04 <strcmp>:
70022e04:	ea40 0c01 	orr.w	ip, r0, r1
70022e08:	f01c 0f07 	tst.w	ip, #7
70022e0c:	d127      	bne.n	70022e5e <strcmp+0x5a>
70022e0e:	f1bd 0d10 	subs.w	sp, sp, #16
70022e12:	e9cd 4502 	strd	r4, r5, [sp, #8]
70022e16:	e9cd 6700 	strd	r6, r7, [sp]
70022e1a:	f06f 0600 	mvn.w	r6, #0
70022e1e:	f04f 0700 	mov.w	r7, #0
70022e22:	bf00      	nop
70022e24:	e8f0 2302 	ldrd	r2, r3, [r0], #8
70022e28:	e8f1 4502 	ldrd	r4, r5, [r1], #8
70022e2c:	42a2      	cmp	r2, r4
70022e2e:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
70022e32:	ea2c 0c02 	bic.w	ip, ip, r2
70022e36:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022e3a:	bf08      	it	eq
70022e3c:	f1bc 0f00 	cmpeq.w	ip, #0
70022e40:	f040 80e5 	bne.w	7002300e <strcmp+0x20a>
70022e44:	42ab      	cmp	r3, r5
70022e46:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
70022e4a:	ea2c 0c03 	bic.w	ip, ip, r3
70022e4e:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022e52:	bf08      	it	eq
70022e54:	f1bc 0f00 	cmpeq.w	ip, #0
70022e58:	f040 80d6 	bne.w	70023008 <strcmp+0x204>
70022e5c:	e7e2      	b.n	70022e24 <strcmp+0x20>
70022e5e:	f010 0c03 	ands.w	ip, r0, #3
70022e62:	d021      	beq.n	70022ea8 <strcmp+0xa4>
70022e64:	f020 0003 	bic.w	r0, r0, #3
70022e68:	f850 2b04 	ldr.w	r2, [r0], #4
70022e6c:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
70022e70:	d008      	beq.n	70022e84 <strcmp+0x80>
70022e72:	d20f      	bcs.n	70022e94 <strcmp+0x90>
70022e74:	f811 cb01 	ldrb.w	ip, [r1], #1
70022e78:	fa5f f392 	uxtb.w	r3, r2, ror #8
70022e7c:	ebb3 0c0c 	subs.w	ip, r3, ip
70022e80:	d110      	bne.n	70022ea4 <strcmp+0xa0>
70022e82:	b17b      	cbz	r3, 70022ea4 <strcmp+0xa0>
70022e84:	f811 cb01 	ldrb.w	ip, [r1], #1
70022e88:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
70022e8c:	ebb3 0c0c 	subs.w	ip, r3, ip
70022e90:	d108      	bne.n	70022ea4 <strcmp+0xa0>
70022e92:	b13b      	cbz	r3, 70022ea4 <strcmp+0xa0>
70022e94:	f811 cb01 	ldrb.w	ip, [r1], #1
70022e98:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
70022e9c:	ebb3 0c0c 	subs.w	ip, r3, ip
70022ea0:	d100      	bne.n	70022ea4 <strcmp+0xa0>
70022ea2:	b90b      	cbnz	r3, 70022ea8 <strcmp+0xa4>
70022ea4:	4660      	mov	r0, ip
70022ea6:	4770      	bx	lr
70022ea8:	f1bd 0d10 	subs.w	sp, sp, #16
70022eac:	e9cd 4502 	strd	r4, r5, [sp, #8]
70022eb0:	e9cd 6700 	strd	r6, r7, [sp]
70022eb4:	f06f 0600 	mvn.w	r6, #0
70022eb8:	f04f 0700 	mov.w	r7, #0
70022ebc:	f011 0c03 	ands.w	ip, r1, #3
70022ec0:	d133      	bne.n	70022f2a <strcmp+0x126>
70022ec2:	f010 0f04 	tst.w	r0, #4
70022ec6:	d00f      	beq.n	70022ee8 <strcmp+0xe4>
70022ec8:	f850 2b04 	ldr.w	r2, [r0], #4
70022ecc:	f851 4b04 	ldr.w	r4, [r1], #4
70022ed0:	42a2      	cmp	r2, r4
70022ed2:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
70022ed6:	ea2c 0c02 	bic.w	ip, ip, r2
70022eda:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022ede:	bf08      	it	eq
70022ee0:	f1bc 0f00 	cmpeq.w	ip, #0
70022ee4:	f040 8093 	bne.w	7002300e <strcmp+0x20a>
70022ee8:	f011 0f04 	tst.w	r1, #4
70022eec:	d099      	beq.n	70022e22 <strcmp+0x1e>
70022eee:	f851 5b04 	ldr.w	r5, [r1], #4
70022ef2:	bf00      	nop
70022ef4:	e8f0 2302 	ldrd	r2, r3, [r0], #8
70022ef8:	42aa      	cmp	r2, r5
70022efa:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
70022efe:	ea2c 0c02 	bic.w	ip, ip, r2
70022f02:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022f06:	bf08      	it	eq
70022f08:	f1bc 0f00 	cmpeq.w	ip, #0
70022f0c:	d179      	bne.n	70023002 <strcmp+0x1fe>
70022f0e:	e8f1 4502 	ldrd	r4, r5, [r1], #8
70022f12:	42a3      	cmp	r3, r4
70022f14:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
70022f18:	ea2c 0c03 	bic.w	ip, ip, r3
70022f1c:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022f20:	bf08      	it	eq
70022f22:	f1bc 0f00 	cmpeq.w	ip, #0
70022f26:	d169      	bne.n	70022ffc <strcmp+0x1f8>
70022f28:	e7e4      	b.n	70022ef4 <strcmp+0xf0>
70022f2a:	f021 0103 	bic.w	r1, r1, #3
70022f2e:	f1bc 0f02 	cmp.w	ip, #2
70022f32:	d020      	beq.n	70022f76 <strcmp+0x172>
70022f34:	da3f      	bge.n	70022fb6 <strcmp+0x1b2>
70022f36:	f851 5b04 	ldr.w	r5, [r1], #4
70022f3a:	bf00      	nop
70022f3c:	f850 3b04 	ldr.w	r3, [r0], #4
70022f40:	ea4f 2515 	mov.w	r5, r5, lsr #8
70022f44:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
70022f48:	ea2c 0c03 	bic.w	ip, ip, r3
70022f4c:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022f50:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
70022f54:	ea03 2216 	and.w	r2, r3, r6, lsr #8
70022f58:	bf08      	it	eq
70022f5a:	42aa      	cmpeq	r2, r5
70022f5c:	d151      	bne.n	70023002 <strcmp+0x1fe>
70022f5e:	f851 5b04 	ldr.w	r5, [r1], #4
70022f62:	f1bc 0f00 	cmp.w	ip, #0
70022f66:	ea82 0303 	eor.w	r3, r2, r3
70022f6a:	ea4f 6205 	mov.w	r2, r5, lsl #24
70022f6e:	bf08      	it	eq
70022f70:	4293      	cmpeq	r3, r2
70022f72:	d140      	bne.n	70022ff6 <strcmp+0x1f2>
70022f74:	e7e2      	b.n	70022f3c <strcmp+0x138>
70022f76:	f851 5b04 	ldr.w	r5, [r1], #4
70022f7a:	bf00      	nop
70022f7c:	f850 3b04 	ldr.w	r3, [r0], #4
70022f80:	ea4f 4515 	mov.w	r5, r5, lsr #16
70022f84:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
70022f88:	ea2c 0c03 	bic.w	ip, ip, r3
70022f8c:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022f90:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
70022f94:	ea03 4216 	and.w	r2, r3, r6, lsr #16
70022f98:	bf08      	it	eq
70022f9a:	42aa      	cmpeq	r2, r5
70022f9c:	d131      	bne.n	70023002 <strcmp+0x1fe>
70022f9e:	f851 5b04 	ldr.w	r5, [r1], #4
70022fa2:	f1bc 0f00 	cmp.w	ip, #0
70022fa6:	ea82 0303 	eor.w	r3, r2, r3
70022faa:	ea4f 4205 	mov.w	r2, r5, lsl #16
70022fae:	bf08      	it	eq
70022fb0:	4293      	cmpeq	r3, r2
70022fb2:	d120      	bne.n	70022ff6 <strcmp+0x1f2>
70022fb4:	e7e2      	b.n	70022f7c <strcmp+0x178>
70022fb6:	f851 5b04 	ldr.w	r5, [r1], #4
70022fba:	bf00      	nop
70022fbc:	f850 3b04 	ldr.w	r3, [r0], #4
70022fc0:	ea4f 6515 	mov.w	r5, r5, lsr #24
70022fc4:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
70022fc8:	ea2c 0c03 	bic.w	ip, ip, r3
70022fcc:	f00c 3c80 	and.w	ip, ip, #2155905152	; 0x80808080
70022fd0:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
70022fd4:	ea03 6216 	and.w	r2, r3, r6, lsr #24
70022fd8:	bf08      	it	eq
70022fda:	42aa      	cmpeq	r2, r5
70022fdc:	d111      	bne.n	70023002 <strcmp+0x1fe>
70022fde:	f851 5b04 	ldr.w	r5, [r1], #4
70022fe2:	f1bc 0f00 	cmp.w	ip, #0
70022fe6:	ea82 0303 	eor.w	r3, r2, r3
70022fea:	ea4f 2205 	mov.w	r2, r5, lsl #8
70022fee:	bf08      	it	eq
70022ff0:	4293      	cmpeq	r3, r2
70022ff2:	d100      	bne.n	70022ff6 <strcmp+0x1f2>
70022ff4:	e7e2      	b.n	70022fbc <strcmp+0x1b8>
70022ff6:	ba19      	rev	r1, r3
70022ff8:	ba12      	rev	r2, r2
70022ffa:	e00a      	b.n	70023012 <strcmp+0x20e>
70022ffc:	ba19      	rev	r1, r3
70022ffe:	ba22      	rev	r2, r4
70023000:	e007      	b.n	70023012 <strcmp+0x20e>
70023002:	ba11      	rev	r1, r2
70023004:	ba2a      	rev	r2, r5
70023006:	e004      	b.n	70023012 <strcmp+0x20e>
70023008:	ba19      	rev	r1, r3
7002300a:	ba2a      	rev	r2, r5
7002300c:	e001      	b.n	70023012 <strcmp+0x20e>
7002300e:	ba11      	rev	r1, r2
70023010:	ba22      	rev	r2, r4
70023012:	fa9c f08c 	rev.w	r0, ip
70023016:	e9dd 6700 	ldrd	r6, r7, [sp]
7002301a:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
7002301e:	f11d 0d10 	adds.w	sp, sp, #16
70023022:	b138      	cbz	r0, 70023034 <strcmp+0x230>
70023024:	fab0 f080 	clz	r0, r0
70023028:	f1c0 0018 	rsb	r0, r0, #24
7002302c:	fa21 f100 	lsr.w	r1, r1, r0
70023030:	fa22 f200 	lsr.w	r2, r2, r0
70023034:	2001      	movs	r0, #1
70023036:	4291      	cmp	r1, r2
70023038:	bf98      	it	ls
7002303a:	4180      	sbcls	r0, r0
7002303c:	4770      	bx	lr
7002303e:	bf00      	nop

70023040 <__aeabi_uidiv>:
70023040:	1e4a      	subs	r2, r1, #1
70023042:	bf08      	it	eq
70023044:	4770      	bxeq	lr
70023046:	f0c0 8124 	bcc.w	70023292 <__aeabi_uidiv+0x252>
7002304a:	4288      	cmp	r0, r1
7002304c:	f240 8116 	bls.w	7002327c <__aeabi_uidiv+0x23c>
70023050:	4211      	tst	r1, r2
70023052:	f000 8117 	beq.w	70023284 <__aeabi_uidiv+0x244>
70023056:	fab0 f380 	clz	r3, r0
7002305a:	fab1 f281 	clz	r2, r1
7002305e:	eba2 0303 	sub.w	r3, r2, r3
70023062:	f1c3 031f 	rsb	r3, r3, #31
70023066:	a204      	add	r2, pc, #16	; (adr r2, 70023078 <__aeabi_uidiv+0x38>)
70023068:	eb02 1303 	add.w	r3, r2, r3, lsl #4
7002306c:	f04f 0200 	mov.w	r2, #0
70023070:	469f      	mov	pc, r3
70023072:	bf00      	nop
70023074:	f3af 8000 	nop.w
70023078:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
7002307c:	bf00      	nop
7002307e:	eb42 0202 	adc.w	r2, r2, r2
70023082:	bf28      	it	cs
70023084:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
70023088:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
7002308c:	bf00      	nop
7002308e:	eb42 0202 	adc.w	r2, r2, r2
70023092:	bf28      	it	cs
70023094:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
70023098:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
7002309c:	bf00      	nop
7002309e:	eb42 0202 	adc.w	r2, r2, r2
700230a2:	bf28      	it	cs
700230a4:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
700230a8:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
700230ac:	bf00      	nop
700230ae:	eb42 0202 	adc.w	r2, r2, r2
700230b2:	bf28      	it	cs
700230b4:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
700230b8:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
700230bc:	bf00      	nop
700230be:	eb42 0202 	adc.w	r2, r2, r2
700230c2:	bf28      	it	cs
700230c4:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
700230c8:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
700230cc:	bf00      	nop
700230ce:	eb42 0202 	adc.w	r2, r2, r2
700230d2:	bf28      	it	cs
700230d4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
700230d8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
700230dc:	bf00      	nop
700230de:	eb42 0202 	adc.w	r2, r2, r2
700230e2:	bf28      	it	cs
700230e4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
700230e8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
700230ec:	bf00      	nop
700230ee:	eb42 0202 	adc.w	r2, r2, r2
700230f2:	bf28      	it	cs
700230f4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
700230f8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
700230fc:	bf00      	nop
700230fe:	eb42 0202 	adc.w	r2, r2, r2
70023102:	bf28      	it	cs
70023104:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
70023108:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
7002310c:	bf00      	nop
7002310e:	eb42 0202 	adc.w	r2, r2, r2
70023112:	bf28      	it	cs
70023114:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
70023118:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
7002311c:	bf00      	nop
7002311e:	eb42 0202 	adc.w	r2, r2, r2
70023122:	bf28      	it	cs
70023124:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
70023128:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
7002312c:	bf00      	nop
7002312e:	eb42 0202 	adc.w	r2, r2, r2
70023132:	bf28      	it	cs
70023134:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
70023138:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
7002313c:	bf00      	nop
7002313e:	eb42 0202 	adc.w	r2, r2, r2
70023142:	bf28      	it	cs
70023144:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
70023148:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
7002314c:	bf00      	nop
7002314e:	eb42 0202 	adc.w	r2, r2, r2
70023152:	bf28      	it	cs
70023154:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
70023158:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
7002315c:	bf00      	nop
7002315e:	eb42 0202 	adc.w	r2, r2, r2
70023162:	bf28      	it	cs
70023164:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
70023168:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
7002316c:	bf00      	nop
7002316e:	eb42 0202 	adc.w	r2, r2, r2
70023172:	bf28      	it	cs
70023174:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
70023178:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
7002317c:	bf00      	nop
7002317e:	eb42 0202 	adc.w	r2, r2, r2
70023182:	bf28      	it	cs
70023184:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
70023188:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
7002318c:	bf00      	nop
7002318e:	eb42 0202 	adc.w	r2, r2, r2
70023192:	bf28      	it	cs
70023194:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
70023198:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
7002319c:	bf00      	nop
7002319e:	eb42 0202 	adc.w	r2, r2, r2
700231a2:	bf28      	it	cs
700231a4:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
700231a8:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
700231ac:	bf00      	nop
700231ae:	eb42 0202 	adc.w	r2, r2, r2
700231b2:	bf28      	it	cs
700231b4:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
700231b8:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
700231bc:	bf00      	nop
700231be:	eb42 0202 	adc.w	r2, r2, r2
700231c2:	bf28      	it	cs
700231c4:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
700231c8:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
700231cc:	bf00      	nop
700231ce:	eb42 0202 	adc.w	r2, r2, r2
700231d2:	bf28      	it	cs
700231d4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
700231d8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
700231dc:	bf00      	nop
700231de:	eb42 0202 	adc.w	r2, r2, r2
700231e2:	bf28      	it	cs
700231e4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
700231e8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
700231ec:	bf00      	nop
700231ee:	eb42 0202 	adc.w	r2, r2, r2
700231f2:	bf28      	it	cs
700231f4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
700231f8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
700231fc:	bf00      	nop
700231fe:	eb42 0202 	adc.w	r2, r2, r2
70023202:	bf28      	it	cs
70023204:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
70023208:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
7002320c:	bf00      	nop
7002320e:	eb42 0202 	adc.w	r2, r2, r2
70023212:	bf28      	it	cs
70023214:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
70023218:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
7002321c:	bf00      	nop
7002321e:	eb42 0202 	adc.w	r2, r2, r2
70023222:	bf28      	it	cs
70023224:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
70023228:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
7002322c:	bf00      	nop
7002322e:	eb42 0202 	adc.w	r2, r2, r2
70023232:	bf28      	it	cs
70023234:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
70023238:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
7002323c:	bf00      	nop
7002323e:	eb42 0202 	adc.w	r2, r2, r2
70023242:	bf28      	it	cs
70023244:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
70023248:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
7002324c:	bf00      	nop
7002324e:	eb42 0202 	adc.w	r2, r2, r2
70023252:	bf28      	it	cs
70023254:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
70023258:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
7002325c:	bf00      	nop
7002325e:	eb42 0202 	adc.w	r2, r2, r2
70023262:	bf28      	it	cs
70023264:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
70023268:	ebb0 0f01 	cmp.w	r0, r1
7002326c:	bf00      	nop
7002326e:	eb42 0202 	adc.w	r2, r2, r2
70023272:	bf28      	it	cs
70023274:	eba0 0001 	subcs.w	r0, r0, r1
70023278:	4610      	mov	r0, r2
7002327a:	4770      	bx	lr
7002327c:	bf0c      	ite	eq
7002327e:	2001      	moveq	r0, #1
70023280:	2000      	movne	r0, #0
70023282:	4770      	bx	lr
70023284:	fab1 f281 	clz	r2, r1
70023288:	f1c2 021f 	rsb	r2, r2, #31
7002328c:	fa20 f002 	lsr.w	r0, r0, r2
70023290:	4770      	bx	lr
70023292:	b108      	cbz	r0, 70023298 <__aeabi_uidiv+0x258>
70023294:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70023298:	f000 b966 	b.w	70023568 <__aeabi_idiv0>

7002329c <__aeabi_uidivmod>:
7002329c:	2900      	cmp	r1, #0
7002329e:	d0f8      	beq.n	70023292 <__aeabi_uidiv+0x252>
700232a0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
700232a4:	f7ff fecc 	bl	70023040 <__aeabi_uidiv>
700232a8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
700232ac:	fb02 f300 	mul.w	r3, r2, r0
700232b0:	eba1 0103 	sub.w	r1, r1, r3
700232b4:	4770      	bx	lr
700232b6:	bf00      	nop

700232b8 <__aeabi_idiv>:
700232b8:	2900      	cmp	r1, #0
700232ba:	f000 813e 	beq.w	7002353a <.divsi3_skip_div0_test+0x27c>

700232be <.divsi3_skip_div0_test>:
700232be:	ea80 0c01 	eor.w	ip, r0, r1
700232c2:	bf48      	it	mi
700232c4:	4249      	negmi	r1, r1
700232c6:	1e4a      	subs	r2, r1, #1
700232c8:	f000 811f 	beq.w	7002350a <.divsi3_skip_div0_test+0x24c>
700232cc:	0003      	movs	r3, r0
700232ce:	bf48      	it	mi
700232d0:	4243      	negmi	r3, r0
700232d2:	428b      	cmp	r3, r1
700232d4:	f240 811e 	bls.w	70023514 <.divsi3_skip_div0_test+0x256>
700232d8:	4211      	tst	r1, r2
700232da:	f000 8123 	beq.w	70023524 <.divsi3_skip_div0_test+0x266>
700232de:	fab3 f283 	clz	r2, r3
700232e2:	fab1 f081 	clz	r0, r1
700232e6:	eba0 0202 	sub.w	r2, r0, r2
700232ea:	f1c2 021f 	rsb	r2, r2, #31
700232ee:	a004      	add	r0, pc, #16	; (adr r0, 70023300 <.divsi3_skip_div0_test+0x42>)
700232f0:	eb00 1202 	add.w	r2, r0, r2, lsl #4
700232f4:	f04f 0000 	mov.w	r0, #0
700232f8:	4697      	mov	pc, r2
700232fa:	bf00      	nop
700232fc:	f3af 8000 	nop.w
70023300:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
70023304:	bf00      	nop
70023306:	eb40 0000 	adc.w	r0, r0, r0
7002330a:	bf28      	it	cs
7002330c:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
70023310:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
70023314:	bf00      	nop
70023316:	eb40 0000 	adc.w	r0, r0, r0
7002331a:	bf28      	it	cs
7002331c:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
70023320:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
70023324:	bf00      	nop
70023326:	eb40 0000 	adc.w	r0, r0, r0
7002332a:	bf28      	it	cs
7002332c:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
70023330:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
70023334:	bf00      	nop
70023336:	eb40 0000 	adc.w	r0, r0, r0
7002333a:	bf28      	it	cs
7002333c:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
70023340:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
70023344:	bf00      	nop
70023346:	eb40 0000 	adc.w	r0, r0, r0
7002334a:	bf28      	it	cs
7002334c:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
70023350:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
70023354:	bf00      	nop
70023356:	eb40 0000 	adc.w	r0, r0, r0
7002335a:	bf28      	it	cs
7002335c:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
70023360:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
70023364:	bf00      	nop
70023366:	eb40 0000 	adc.w	r0, r0, r0
7002336a:	bf28      	it	cs
7002336c:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
70023370:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
70023374:	bf00      	nop
70023376:	eb40 0000 	adc.w	r0, r0, r0
7002337a:	bf28      	it	cs
7002337c:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
70023380:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
70023384:	bf00      	nop
70023386:	eb40 0000 	adc.w	r0, r0, r0
7002338a:	bf28      	it	cs
7002338c:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
70023390:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
70023394:	bf00      	nop
70023396:	eb40 0000 	adc.w	r0, r0, r0
7002339a:	bf28      	it	cs
7002339c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
700233a0:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
700233a4:	bf00      	nop
700233a6:	eb40 0000 	adc.w	r0, r0, r0
700233aa:	bf28      	it	cs
700233ac:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
700233b0:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
700233b4:	bf00      	nop
700233b6:	eb40 0000 	adc.w	r0, r0, r0
700233ba:	bf28      	it	cs
700233bc:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
700233c0:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
700233c4:	bf00      	nop
700233c6:	eb40 0000 	adc.w	r0, r0, r0
700233ca:	bf28      	it	cs
700233cc:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
700233d0:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
700233d4:	bf00      	nop
700233d6:	eb40 0000 	adc.w	r0, r0, r0
700233da:	bf28      	it	cs
700233dc:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
700233e0:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
700233e4:	bf00      	nop
700233e6:	eb40 0000 	adc.w	r0, r0, r0
700233ea:	bf28      	it	cs
700233ec:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
700233f0:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
700233f4:	bf00      	nop
700233f6:	eb40 0000 	adc.w	r0, r0, r0
700233fa:	bf28      	it	cs
700233fc:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
70023400:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
70023404:	bf00      	nop
70023406:	eb40 0000 	adc.w	r0, r0, r0
7002340a:	bf28      	it	cs
7002340c:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
70023410:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
70023414:	bf00      	nop
70023416:	eb40 0000 	adc.w	r0, r0, r0
7002341a:	bf28      	it	cs
7002341c:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
70023420:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
70023424:	bf00      	nop
70023426:	eb40 0000 	adc.w	r0, r0, r0
7002342a:	bf28      	it	cs
7002342c:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
70023430:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
70023434:	bf00      	nop
70023436:	eb40 0000 	adc.w	r0, r0, r0
7002343a:	bf28      	it	cs
7002343c:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
70023440:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
70023444:	bf00      	nop
70023446:	eb40 0000 	adc.w	r0, r0, r0
7002344a:	bf28      	it	cs
7002344c:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
70023450:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
70023454:	bf00      	nop
70023456:	eb40 0000 	adc.w	r0, r0, r0
7002345a:	bf28      	it	cs
7002345c:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
70023460:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
70023464:	bf00      	nop
70023466:	eb40 0000 	adc.w	r0, r0, r0
7002346a:	bf28      	it	cs
7002346c:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
70023470:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
70023474:	bf00      	nop
70023476:	eb40 0000 	adc.w	r0, r0, r0
7002347a:	bf28      	it	cs
7002347c:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
70023480:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
70023484:	bf00      	nop
70023486:	eb40 0000 	adc.w	r0, r0, r0
7002348a:	bf28      	it	cs
7002348c:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
70023490:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
70023494:	bf00      	nop
70023496:	eb40 0000 	adc.w	r0, r0, r0
7002349a:	bf28      	it	cs
7002349c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
700234a0:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
700234a4:	bf00      	nop
700234a6:	eb40 0000 	adc.w	r0, r0, r0
700234aa:	bf28      	it	cs
700234ac:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
700234b0:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
700234b4:	bf00      	nop
700234b6:	eb40 0000 	adc.w	r0, r0, r0
700234ba:	bf28      	it	cs
700234bc:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
700234c0:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
700234c4:	bf00      	nop
700234c6:	eb40 0000 	adc.w	r0, r0, r0
700234ca:	bf28      	it	cs
700234cc:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
700234d0:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
700234d4:	bf00      	nop
700234d6:	eb40 0000 	adc.w	r0, r0, r0
700234da:	bf28      	it	cs
700234dc:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
700234e0:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
700234e4:	bf00      	nop
700234e6:	eb40 0000 	adc.w	r0, r0, r0
700234ea:	bf28      	it	cs
700234ec:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
700234f0:	ebb3 0f01 	cmp.w	r3, r1
700234f4:	bf00      	nop
700234f6:	eb40 0000 	adc.w	r0, r0, r0
700234fa:	bf28      	it	cs
700234fc:	eba3 0301 	subcs.w	r3, r3, r1
70023500:	f1bc 0f00 	cmp.w	ip, #0
70023504:	bf48      	it	mi
70023506:	4240      	negmi	r0, r0
70023508:	4770      	bx	lr
7002350a:	ea9c 0f00 	teq	ip, r0
7002350e:	bf48      	it	mi
70023510:	4240      	negmi	r0, r0
70023512:	4770      	bx	lr
70023514:	bf38      	it	cc
70023516:	2000      	movcc	r0, #0
70023518:	bf04      	itt	eq
7002351a:	ea4f 70ec 	moveq.w	r0, ip, asr #31
7002351e:	f040 0001 	orreq.w	r0, r0, #1
70023522:	4770      	bx	lr
70023524:	fab1 f281 	clz	r2, r1
70023528:	f1c2 021f 	rsb	r2, r2, #31
7002352c:	f1bc 0f00 	cmp.w	ip, #0
70023530:	fa23 f002 	lsr.w	r0, r3, r2
70023534:	bf48      	it	mi
70023536:	4240      	negmi	r0, r0
70023538:	4770      	bx	lr
7002353a:	2800      	cmp	r0, #0
7002353c:	bfc8      	it	gt
7002353e:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
70023542:	bfb8      	it	lt
70023544:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
70023548:	f000 b80e 	b.w	70023568 <__aeabi_idiv0>

7002354c <__aeabi_idivmod>:
7002354c:	2900      	cmp	r1, #0
7002354e:	d0f4      	beq.n	7002353a <.divsi3_skip_div0_test+0x27c>
70023550:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
70023554:	f7ff feb3 	bl	700232be <.divsi3_skip_div0_test>
70023558:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
7002355c:	fb02 f300 	mul.w	r3, r2, r0
70023560:	eba1 0103 	sub.w	r1, r1, r3
70023564:	4770      	bx	lr
70023566:	bf00      	nop

70023568 <__aeabi_idiv0>:
70023568:	4770      	bx	lr
7002356a:	bf00      	nop

7002356c <__aeabi_uldivmod>:
7002356c:	b94b      	cbnz	r3, 70023582 <__aeabi_uldivmod+0x16>
7002356e:	b942      	cbnz	r2, 70023582 <__aeabi_uldivmod+0x16>
70023570:	2900      	cmp	r1, #0
70023572:	bf08      	it	eq
70023574:	2800      	cmpeq	r0, #0
70023576:	d002      	beq.n	7002357e <__aeabi_uldivmod+0x12>
70023578:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
7002357c:	4608      	mov	r0, r1
7002357e:	f7ff bff3 	b.w	70023568 <__aeabi_idiv0>
70023582:	b082      	sub	sp, #8
70023584:	46ec      	mov	ip, sp
70023586:	e92d 5000 	stmdb	sp!, {ip, lr}
7002358a:	f000 f81d 	bl	700235c8 <__gnu_uldivmod_helper>
7002358e:	f8dd e004 	ldr.w	lr, [sp, #4]
70023592:	b002      	add	sp, #8
70023594:	bc0c      	pop	{r2, r3}
70023596:	4770      	bx	lr

70023598 <__gnu_ldivmod_helper>:
70023598:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
7002359c:	4617      	mov	r7, r2
7002359e:	4680      	mov	r8, r0
700235a0:	4689      	mov	r9, r1
700235a2:	469a      	mov	sl, r3
700235a4:	9e08      	ldr	r6, [sp, #32]
700235a6:	f000 f827 	bl	700235f8 <__divdi3>
700235aa:	fba7 4500 	umull	r4, r5, r7, r0
700235ae:	fb07 f701 	mul.w	r7, r7, r1
700235b2:	fb00 720a 	mla	r2, r0, sl, r7
700235b6:	4415      	add	r5, r2
700235b8:	ebb8 0404 	subs.w	r4, r8, r4
700235bc:	eb69 0505 	sbc.w	r5, r9, r5
700235c0:	e9c6 4500 	strd	r4, r5, [r6]
700235c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

700235c8 <__gnu_uldivmod_helper>:
700235c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
700235cc:	4617      	mov	r7, r2
700235ce:	4680      	mov	r8, r0
700235d0:	4689      	mov	r9, r1
700235d2:	461d      	mov	r5, r3
700235d4:	9e08      	ldr	r6, [sp, #32]
700235d6:	f000 f9b9 	bl	7002394c <__udivdi3>
700235da:	fb00 f305 	mul.w	r3, r0, r5
700235de:	fba0 4507 	umull	r4, r5, r0, r7
700235e2:	fb07 3701 	mla	r7, r7, r1, r3
700235e6:	443d      	add	r5, r7
700235e8:	ebb8 0404 	subs.w	r4, r8, r4
700235ec:	eb69 0505 	sbc.w	r5, r9, r5
700235f0:	e9c6 4500 	strd	r4, r5, [r6]
700235f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

700235f8 <__divdi3>:
700235f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
700235fc:	4244      	negs	r4, r0
700235fe:	eb61 0541 	sbc.w	r5, r1, r1, lsl #1
70023602:	2900      	cmp	r1, #0
70023604:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
70023608:	b083      	sub	sp, #12
7002360a:	bfa2      	ittt	ge
7002360c:	4604      	movge	r4, r0
7002360e:	460d      	movge	r5, r1
70023610:	2600      	movge	r6, #0
70023612:	2b00      	cmp	r3, #0
70023614:	f2c0 80c7 	blt.w	700237a6 <__divdi3+0x1ae>
70023618:	4620      	mov	r0, r4
7002361a:	46aa      	mov	sl, r5
7002361c:	4694      	mov	ip, r2
7002361e:	4619      	mov	r1, r3
70023620:	4690      	mov	r8, r2
70023622:	4627      	mov	r7, r4
70023624:	46a9      	mov	r9, r5
70023626:	2b00      	cmp	r3, #0
70023628:	d158      	bne.n	700236dc <__divdi3+0xe4>
7002362a:	42aa      	cmp	r2, r5
7002362c:	d96c      	bls.n	70023708 <__divdi3+0x110>
7002362e:	fab2 f382 	clz	r3, r2
70023632:	b15b      	cbz	r3, 7002364c <__divdi3+0x54>
70023634:	f1c3 0220 	rsb	r2, r3, #32
70023638:	fa05 f903 	lsl.w	r9, r5, r3
7002363c:	fa24 f202 	lsr.w	r2, r4, r2
70023640:	fa0c f803 	lsl.w	r8, ip, r3
70023644:	ea42 0909 	orr.w	r9, r2, r9
70023648:	fa04 f703 	lsl.w	r7, r4, r3
7002364c:	ea4f 4418 	mov.w	r4, r8, lsr #16
70023650:	4648      	mov	r0, r9
70023652:	fa1f fa88 	uxth.w	sl, r8
70023656:	4621      	mov	r1, r4
70023658:	f7ff fcf2 	bl	70023040 <__aeabi_uidiv>
7002365c:	4621      	mov	r1, r4
7002365e:	4683      	mov	fp, r0
70023660:	4648      	mov	r0, r9
70023662:	f7ff fe1b 	bl	7002329c <__aeabi_uidivmod>
70023666:	fb0a f00b 	mul.w	r0, sl, fp
7002366a:	0c3a      	lsrs	r2, r7, #16
7002366c:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
70023670:	4288      	cmp	r0, r1
70023672:	d90b      	bls.n	7002368c <__divdi3+0x94>
70023674:	eb11 0108 	adds.w	r1, r1, r8
70023678:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
7002367c:	d205      	bcs.n	7002368a <__divdi3+0x92>
7002367e:	4288      	cmp	r0, r1
70023680:	bf84      	itt	hi
70023682:	f1ab 0b02 	subhi.w	fp, fp, #2
70023686:	4441      	addhi	r1, r8
70023688:	d800      	bhi.n	7002368c <__divdi3+0x94>
7002368a:	469b      	mov	fp, r3
7002368c:	ebc0 0901 	rsb	r9, r0, r1
70023690:	4621      	mov	r1, r4
70023692:	b2bf      	uxth	r7, r7
70023694:	4648      	mov	r0, r9
70023696:	f7ff fcd3 	bl	70023040 <__aeabi_uidiv>
7002369a:	4621      	mov	r1, r4
7002369c:	4605      	mov	r5, r0
7002369e:	4648      	mov	r0, r9
700236a0:	f7ff fdfc 	bl	7002329c <__aeabi_uidivmod>
700236a4:	fb0a fa05 	mul.w	sl, sl, r5
700236a8:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
700236ac:	458a      	cmp	sl, r1
700236ae:	d909      	bls.n	700236c4 <__divdi3+0xcc>
700236b0:	eb11 0808 	adds.w	r8, r1, r8
700236b4:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
700236b8:	d203      	bcs.n	700236c2 <__divdi3+0xca>
700236ba:	45c2      	cmp	sl, r8
700236bc:	bf88      	it	hi
700236be:	3d02      	subhi	r5, #2
700236c0:	d800      	bhi.n	700236c4 <__divdi3+0xcc>
700236c2:	461d      	mov	r5, r3
700236c4:	ea45 430b 	orr.w	r3, r5, fp, lsl #16
700236c8:	2400      	movs	r4, #0
700236ca:	4618      	mov	r0, r3
700236cc:	4621      	mov	r1, r4
700236ce:	b116      	cbz	r6, 700236d6 <__divdi3+0xde>
700236d0:	4240      	negs	r0, r0
700236d2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
700236d6:	b003      	add	sp, #12
700236d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
700236dc:	42ab      	cmp	r3, r5
700236de:	bf84      	itt	hi
700236e0:	2400      	movhi	r4, #0
700236e2:	4623      	movhi	r3, r4
700236e4:	d8f1      	bhi.n	700236ca <__divdi3+0xd2>
700236e6:	fab1 f581 	clz	r5, r1
700236ea:	2d00      	cmp	r5, #0
700236ec:	f040 80b5 	bne.w	7002385a <__divdi3+0x262>
700236f0:	4551      	cmp	r1, sl
700236f2:	bf28      	it	cs
700236f4:	4282      	cmpcs	r2, r0
700236f6:	bf8c      	ite	hi
700236f8:	2400      	movhi	r4, #0
700236fa:	2401      	movls	r4, #1
700236fc:	bf9c      	itt	ls
700236fe:	2301      	movls	r3, #1
70023700:	462c      	movls	r4, r5
70023702:	d9e2      	bls.n	700236ca <__divdi3+0xd2>
70023704:	4623      	mov	r3, r4
70023706:	e7e0      	b.n	700236ca <__divdi3+0xd2>
70023708:	b922      	cbnz	r2, 70023714 <__divdi3+0x11c>
7002370a:	4611      	mov	r1, r2
7002370c:	2001      	movs	r0, #1
7002370e:	f7ff fc97 	bl	70023040 <__aeabi_uidiv>
70023712:	4680      	mov	r8, r0
70023714:	fab8 f388 	clz	r3, r8
70023718:	2b00      	cmp	r3, #0
7002371a:	d149      	bne.n	700237b0 <__divdi3+0x1b8>
7002371c:	ebc8 0909 	rsb	r9, r8, r9
70023720:	ea4f 4518 	mov.w	r5, r8, lsr #16
70023724:	fa1f fa88 	uxth.w	sl, r8
70023728:	2401      	movs	r4, #1
7002372a:	4629      	mov	r1, r5
7002372c:	4648      	mov	r0, r9
7002372e:	f7ff fc87 	bl	70023040 <__aeabi_uidiv>
70023732:	4629      	mov	r1, r5
70023734:	4683      	mov	fp, r0
70023736:	4648      	mov	r0, r9
70023738:	f7ff fdb0 	bl	7002329c <__aeabi_uidivmod>
7002373c:	fb0a f00b 	mul.w	r0, sl, fp
70023740:	0c3a      	lsrs	r2, r7, #16
70023742:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
70023746:	4288      	cmp	r0, r1
70023748:	d90c      	bls.n	70023764 <__divdi3+0x16c>
7002374a:	eb11 0108 	adds.w	r1, r1, r8
7002374e:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
70023752:	f080 80f3 	bcs.w	7002393c <__divdi3+0x344>
70023756:	4288      	cmp	r0, r1
70023758:	bf84      	itt	hi
7002375a:	f1ab 0b02 	subhi.w	fp, fp, #2
7002375e:	4441      	addhi	r1, r8
70023760:	f240 80ec 	bls.w	7002393c <__divdi3+0x344>
70023764:	1a0a      	subs	r2, r1, r0
70023766:	4629      	mov	r1, r5
70023768:	9200      	str	r2, [sp, #0]
7002376a:	b2bf      	uxth	r7, r7
7002376c:	4610      	mov	r0, r2
7002376e:	f7ff fc67 	bl	70023040 <__aeabi_uidiv>
70023772:	9a00      	ldr	r2, [sp, #0]
70023774:	4629      	mov	r1, r5
70023776:	4681      	mov	r9, r0
70023778:	4610      	mov	r0, r2
7002377a:	f7ff fd8f 	bl	7002329c <__aeabi_uidivmod>
7002377e:	fb0a fa09 	mul.w	sl, sl, r9
70023782:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
70023786:	458a      	cmp	sl, r1
70023788:	d90a      	bls.n	700237a0 <__divdi3+0x1a8>
7002378a:	eb11 0808 	adds.w	r8, r1, r8
7002378e:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
70023792:	d204      	bcs.n	7002379e <__divdi3+0x1a6>
70023794:	45c2      	cmp	sl, r8
70023796:	bf88      	it	hi
70023798:	f1a9 0902 	subhi.w	r9, r9, #2
7002379c:	d800      	bhi.n	700237a0 <__divdi3+0x1a8>
7002379e:	4699      	mov	r9, r3
700237a0:	ea49 430b 	orr.w	r3, r9, fp, lsl #16
700237a4:	e791      	b.n	700236ca <__divdi3+0xd2>
700237a6:	43f6      	mvns	r6, r6
700237a8:	4252      	negs	r2, r2
700237aa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
700237ae:	e733      	b.n	70023618 <__divdi3+0x20>
700237b0:	fa08 f803 	lsl.w	r8, r8, r3
700237b4:	f1c3 0b20 	rsb	fp, r3, #32
700237b8:	fa29 f40b 	lsr.w	r4, r9, fp
700237bc:	fa09 f903 	lsl.w	r9, r9, r3
700237c0:	ea4f 4518 	mov.w	r5, r8, lsr #16
700237c4:	fa27 fb0b 	lsr.w	fp, r7, fp
700237c8:	4620      	mov	r0, r4
700237ca:	409f      	lsls	r7, r3
700237cc:	4629      	mov	r1, r5
700237ce:	fa1f fa88 	uxth.w	sl, r8
700237d2:	f7ff fc35 	bl	70023040 <__aeabi_uidiv>
700237d6:	4629      	mov	r1, r5
700237d8:	ea4b 0b09 	orr.w	fp, fp, r9
700237dc:	4602      	mov	r2, r0
700237de:	4620      	mov	r0, r4
700237e0:	9200      	str	r2, [sp, #0]
700237e2:	f7ff fd5b 	bl	7002329c <__aeabi_uidivmod>
700237e6:	9a00      	ldr	r2, [sp, #0]
700237e8:	ea4f 431b 	mov.w	r3, fp, lsr #16
700237ec:	fb0a f002 	mul.w	r0, sl, r2
700237f0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
700237f4:	4288      	cmp	r0, r1
700237f6:	d90b      	bls.n	70023810 <__divdi3+0x218>
700237f8:	eb11 0108 	adds.w	r1, r1, r8
700237fc:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
70023800:	f080 80a2 	bcs.w	70023948 <__divdi3+0x350>
70023804:	4288      	cmp	r0, r1
70023806:	bf84      	itt	hi
70023808:	3a02      	subhi	r2, #2
7002380a:	4441      	addhi	r1, r8
7002380c:	f240 809c 	bls.w	70023948 <__divdi3+0x350>
70023810:	ebc0 0901 	rsb	r9, r0, r1
70023814:	4629      	mov	r1, r5
70023816:	9200      	str	r2, [sp, #0]
70023818:	fa1f fb8b 	uxth.w	fp, fp
7002381c:	4648      	mov	r0, r9
7002381e:	f7ff fc0f 	bl	70023040 <__aeabi_uidiv>
70023822:	4629      	mov	r1, r5
70023824:	4604      	mov	r4, r0
70023826:	4648      	mov	r0, r9
70023828:	f7ff fd38 	bl	7002329c <__aeabi_uidivmod>
7002382c:	fb0a f904 	mul.w	r9, sl, r4
70023830:	9a00      	ldr	r2, [sp, #0]
70023832:	ea4b 4101 	orr.w	r1, fp, r1, lsl #16
70023836:	4589      	cmp	r9, r1
70023838:	d90a      	bls.n	70023850 <__divdi3+0x258>
7002383a:	eb11 0108 	adds.w	r1, r1, r8
7002383e:	f104 33ff 	add.w	r3, r4, #4294967295	; 0xffffffff
70023842:	d204      	bcs.n	7002384e <__divdi3+0x256>
70023844:	4589      	cmp	r9, r1
70023846:	bf84      	itt	hi
70023848:	3c02      	subhi	r4, #2
7002384a:	4441      	addhi	r1, r8
7002384c:	d800      	bhi.n	70023850 <__divdi3+0x258>
7002384e:	461c      	mov	r4, r3
70023850:	ebc9 0901 	rsb	r9, r9, r1
70023854:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
70023858:	e767      	b.n	7002372a <__divdi3+0x132>
7002385a:	f1c5 0320 	rsb	r3, r5, #32
7002385e:	40a9      	lsls	r1, r5
70023860:	fa22 f803 	lsr.w	r8, r2, r3
70023864:	fa2a f203 	lsr.w	r2, sl, r3
70023868:	ea48 0801 	orr.w	r8, r8, r1
7002386c:	fa20 f303 	lsr.w	r3, r0, r3
70023870:	fa0a fa05 	lsl.w	sl, sl, r5
70023874:	4610      	mov	r0, r2
70023876:	ea4f 4918 	mov.w	r9, r8, lsr #16
7002387a:	fa0c fc05 	lsl.w	ip, ip, r5
7002387e:	ea43 0a0a 	orr.w	sl, r3, sl
70023882:	f8cd c004 	str.w	ip, [sp, #4]
70023886:	4649      	mov	r1, r9
70023888:	9200      	str	r2, [sp, #0]
7002388a:	f7ff fbd9 	bl	70023040 <__aeabi_uidiv>
7002388e:	9a00      	ldr	r2, [sp, #0]
70023890:	4649      	mov	r1, r9
70023892:	fa1f fb88 	uxth.w	fp, r8
70023896:	4604      	mov	r4, r0
70023898:	4610      	mov	r0, r2
7002389a:	f7ff fcff 	bl	7002329c <__aeabi_uidivmod>
7002389e:	fb0b f004 	mul.w	r0, fp, r4
700238a2:	ea4f 421a 	mov.w	r2, sl, lsr #16
700238a6:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
700238aa:	4288      	cmp	r0, r1
700238ac:	d909      	bls.n	700238c2 <__divdi3+0x2ca>
700238ae:	eb11 0108 	adds.w	r1, r1, r8
700238b2:	f104 32ff 	add.w	r2, r4, #4294967295	; 0xffffffff
700238b6:	d245      	bcs.n	70023944 <__divdi3+0x34c>
700238b8:	4288      	cmp	r0, r1
700238ba:	bf84      	itt	hi
700238bc:	3c02      	subhi	r4, #2
700238be:	4441      	addhi	r1, r8
700238c0:	d940      	bls.n	70023944 <__divdi3+0x34c>
700238c2:	ebc0 0c01 	rsb	ip, r0, r1
700238c6:	4649      	mov	r1, r9
700238c8:	f8cd c000 	str.w	ip, [sp]
700238cc:	fa1f fa8a 	uxth.w	sl, sl
700238d0:	4660      	mov	r0, ip
700238d2:	f7ff fbb5 	bl	70023040 <__aeabi_uidiv>
700238d6:	f8dd c000 	ldr.w	ip, [sp]
700238da:	4649      	mov	r1, r9
700238dc:	4602      	mov	r2, r0
700238de:	4660      	mov	r0, ip
700238e0:	9200      	str	r2, [sp, #0]
700238e2:	f7ff fcdb 	bl	7002329c <__aeabi_uidivmod>
700238e6:	9a00      	ldr	r2, [sp, #0]
700238e8:	fb0b fb02 	mul.w	fp, fp, r2
700238ec:	ea4a 4101 	orr.w	r1, sl, r1, lsl #16
700238f0:	458b      	cmp	fp, r1
700238f2:	d909      	bls.n	70023908 <__divdi3+0x310>
700238f4:	eb11 0108 	adds.w	r1, r1, r8
700238f8:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
700238fc:	d220      	bcs.n	70023940 <__divdi3+0x348>
700238fe:	458b      	cmp	fp, r1
70023900:	bf84      	itt	hi
70023902:	3a02      	subhi	r2, #2
70023904:	4441      	addhi	r1, r8
70023906:	d91b      	bls.n	70023940 <__divdi3+0x348>
70023908:	ebcb 0b01 	rsb	fp, fp, r1
7002390c:	9901      	ldr	r1, [sp, #4]
7002390e:	ea42 4004 	orr.w	r0, r2, r4, lsl #16
70023912:	fba0 2301 	umull	r2, r3, r0, r1
70023916:	459b      	cmp	fp, r3
70023918:	d30d      	bcc.n	70023936 <__divdi3+0x33e>
7002391a:	bf14      	ite	ne
7002391c:	2300      	movne	r3, #0
7002391e:	2301      	moveq	r3, #1
70023920:	fa07 f405 	lsl.w	r4, r7, r5
70023924:	4294      	cmp	r4, r2
70023926:	bf2c      	ite	cs
70023928:	2400      	movcs	r4, #0
7002392a:	f003 0401 	andcc.w	r4, r3, #1
7002392e:	4603      	mov	r3, r0
70023930:	2c00      	cmp	r4, #0
70023932:	f43f aeca 	beq.w	700236ca <__divdi3+0xd2>
70023936:	1e43      	subs	r3, r0, #1
70023938:	2400      	movs	r4, #0
7002393a:	e6c6      	b.n	700236ca <__divdi3+0xd2>
7002393c:	469b      	mov	fp, r3
7002393e:	e711      	b.n	70023764 <__divdi3+0x16c>
70023940:	4602      	mov	r2, r0
70023942:	e7e1      	b.n	70023908 <__divdi3+0x310>
70023944:	4614      	mov	r4, r2
70023946:	e7bc      	b.n	700238c2 <__divdi3+0x2ca>
70023948:	461a      	mov	r2, r3
7002394a:	e761      	b.n	70023810 <__divdi3+0x218>

7002394c <__udivdi3>:
7002394c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70023950:	4606      	mov	r6, r0
70023952:	b083      	sub	sp, #12
70023954:	460d      	mov	r5, r1
70023956:	4614      	mov	r4, r2
70023958:	4607      	mov	r7, r0
7002395a:	4688      	mov	r8, r1
7002395c:	2b00      	cmp	r3, #0
7002395e:	d151      	bne.n	70023a04 <__udivdi3+0xb8>
70023960:	428a      	cmp	r2, r1
70023962:	d964      	bls.n	70023a2e <__udivdi3+0xe2>
70023964:	fab2 f382 	clz	r3, r2
70023968:	b15b      	cbz	r3, 70023982 <__udivdi3+0x36>
7002396a:	f1c3 0820 	rsb	r8, r3, #32
7002396e:	fa01 f503 	lsl.w	r5, r1, r3
70023972:	fa20 f808 	lsr.w	r8, r0, r8
70023976:	fa02 f403 	lsl.w	r4, r2, r3
7002397a:	ea48 0805 	orr.w	r8, r8, r5
7002397e:	fa00 f703 	lsl.w	r7, r0, r3
70023982:	0c25      	lsrs	r5, r4, #16
70023984:	4640      	mov	r0, r8
70023986:	fa1f fa84 	uxth.w	sl, r4
7002398a:	4629      	mov	r1, r5
7002398c:	f7ff fb58 	bl	70023040 <__aeabi_uidiv>
70023990:	4629      	mov	r1, r5
70023992:	4681      	mov	r9, r0
70023994:	4640      	mov	r0, r8
70023996:	f7ff fc81 	bl	7002329c <__aeabi_uidivmod>
7002399a:	fb0a f009 	mul.w	r0, sl, r9
7002399e:	0c3b      	lsrs	r3, r7, #16
700239a0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
700239a4:	4288      	cmp	r0, r1
700239a6:	d90a      	bls.n	700239be <__udivdi3+0x72>
700239a8:	1909      	adds	r1, r1, r4
700239aa:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
700239ae:	d205      	bcs.n	700239bc <__udivdi3+0x70>
700239b0:	4288      	cmp	r0, r1
700239b2:	bf84      	itt	hi
700239b4:	f1a9 0902 	subhi.w	r9, r9, #2
700239b8:	1909      	addhi	r1, r1, r4
700239ba:	d800      	bhi.n	700239be <__udivdi3+0x72>
700239bc:	4691      	mov	r9, r2
700239be:	ebc0 0801 	rsb	r8, r0, r1
700239c2:	4629      	mov	r1, r5
700239c4:	b2bf      	uxth	r7, r7
700239c6:	4640      	mov	r0, r8
700239c8:	f7ff fb3a 	bl	70023040 <__aeabi_uidiv>
700239cc:	4629      	mov	r1, r5
700239ce:	4606      	mov	r6, r0
700239d0:	4640      	mov	r0, r8
700239d2:	f7ff fc63 	bl	7002329c <__aeabi_uidivmod>
700239d6:	fb0a fa06 	mul.w	sl, sl, r6
700239da:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
700239de:	458a      	cmp	sl, r1
700239e0:	d909      	bls.n	700239f6 <__udivdi3+0xaa>
700239e2:	190c      	adds	r4, r1, r4
700239e4:	f106 33ff 	add.w	r3, r6, #4294967295	; 0xffffffff
700239e8:	f080 811a 	bcs.w	70023c20 <__udivdi3+0x2d4>
700239ec:	45a2      	cmp	sl, r4
700239ee:	bf88      	it	hi
700239f0:	3e02      	subhi	r6, #2
700239f2:	f240 8115 	bls.w	70023c20 <__udivdi3+0x2d4>
700239f6:	ea46 4009 	orr.w	r0, r6, r9, lsl #16
700239fa:	2600      	movs	r6, #0
700239fc:	4631      	mov	r1, r6
700239fe:	b003      	add	sp, #12
70023a00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70023a04:	428b      	cmp	r3, r1
70023a06:	bf84      	itt	hi
70023a08:	2600      	movhi	r6, #0
70023a0a:	4630      	movhi	r0, r6
70023a0c:	d8f6      	bhi.n	700239fc <__udivdi3+0xb0>
70023a0e:	fab3 f483 	clz	r4, r3
70023a12:	2c00      	cmp	r4, #0
70023a14:	d15a      	bne.n	70023acc <__udivdi3+0x180>
70023a16:	428b      	cmp	r3, r1
70023a18:	bf28      	it	cs
70023a1a:	42b2      	cmpcs	r2, r6
70023a1c:	bf8c      	ite	hi
70023a1e:	2600      	movhi	r6, #0
70023a20:	2601      	movls	r6, #1
70023a22:	bf9c      	itt	ls
70023a24:	2001      	movls	r0, #1
70023a26:	4626      	movls	r6, r4
70023a28:	d9e8      	bls.n	700239fc <__udivdi3+0xb0>
70023a2a:	4630      	mov	r0, r6
70023a2c:	e7e6      	b.n	700239fc <__udivdi3+0xb0>
70023a2e:	b922      	cbnz	r2, 70023a3a <__udivdi3+0xee>
70023a30:	4611      	mov	r1, r2
70023a32:	2001      	movs	r0, #1
70023a34:	f7ff fb04 	bl	70023040 <__aeabi_uidiv>
70023a38:	4604      	mov	r4, r0
70023a3a:	fab4 f384 	clz	r3, r4
70023a3e:	2b00      	cmp	r3, #0
70023a40:	f040 80a3 	bne.w	70023b8a <__udivdi3+0x23e>
70023a44:	1b2d      	subs	r5, r5, r4
70023a46:	ea4f 4814 	mov.w	r8, r4, lsr #16
70023a4a:	fa1f fa84 	uxth.w	sl, r4
70023a4e:	2601      	movs	r6, #1
70023a50:	4641      	mov	r1, r8
70023a52:	4628      	mov	r0, r5
70023a54:	f7ff faf4 	bl	70023040 <__aeabi_uidiv>
70023a58:	4641      	mov	r1, r8
70023a5a:	4681      	mov	r9, r0
70023a5c:	4628      	mov	r0, r5
70023a5e:	f7ff fc1d 	bl	7002329c <__aeabi_uidivmod>
70023a62:	fb0a f009 	mul.w	r0, sl, r9
70023a66:	0c3b      	lsrs	r3, r7, #16
70023a68:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
70023a6c:	4288      	cmp	r0, r1
70023a6e:	d90b      	bls.n	70023a88 <__udivdi3+0x13c>
70023a70:	1909      	adds	r1, r1, r4
70023a72:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
70023a76:	f080 80d5 	bcs.w	70023c24 <__udivdi3+0x2d8>
70023a7a:	4288      	cmp	r0, r1
70023a7c:	bf84      	itt	hi
70023a7e:	f1a9 0902 	subhi.w	r9, r9, #2
70023a82:	1909      	addhi	r1, r1, r4
70023a84:	f240 80ce 	bls.w	70023c24 <__udivdi3+0x2d8>
70023a88:	ebc0 0b01 	rsb	fp, r0, r1
70023a8c:	4641      	mov	r1, r8
70023a8e:	b2bf      	uxth	r7, r7
70023a90:	4658      	mov	r0, fp
70023a92:	f7ff fad5 	bl	70023040 <__aeabi_uidiv>
70023a96:	4641      	mov	r1, r8
70023a98:	4605      	mov	r5, r0
70023a9a:	4658      	mov	r0, fp
70023a9c:	f7ff fbfe 	bl	7002329c <__aeabi_uidivmod>
70023aa0:	fb0a fa05 	mul.w	sl, sl, r5
70023aa4:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
70023aa8:	458a      	cmp	sl, r1
70023aaa:	d909      	bls.n	70023ac0 <__udivdi3+0x174>
70023aac:	190c      	adds	r4, r1, r4
70023aae:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
70023ab2:	f080 80b9 	bcs.w	70023c28 <__udivdi3+0x2dc>
70023ab6:	45a2      	cmp	sl, r4
70023ab8:	bf88      	it	hi
70023aba:	3d02      	subhi	r5, #2
70023abc:	f240 80b4 	bls.w	70023c28 <__udivdi3+0x2dc>
70023ac0:	ea45 4009 	orr.w	r0, r5, r9, lsl #16
70023ac4:	4631      	mov	r1, r6
70023ac6:	b003      	add	sp, #12
70023ac8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70023acc:	f1c4 0120 	rsb	r1, r4, #32
70023ad0:	40a3      	lsls	r3, r4
70023ad2:	fa22 f801 	lsr.w	r8, r2, r1
70023ad6:	fa25 f701 	lsr.w	r7, r5, r1
70023ada:	ea48 0803 	orr.w	r8, r8, r3
70023ade:	fa26 f101 	lsr.w	r1, r6, r1
70023ae2:	40a5      	lsls	r5, r4
70023ae4:	4638      	mov	r0, r7
70023ae6:	ea4f 4918 	mov.w	r9, r8, lsr #16
70023aea:	430d      	orrs	r5, r1
70023aec:	40a2      	lsls	r2, r4
70023aee:	9201      	str	r2, [sp, #4]
70023af0:	4649      	mov	r1, r9
70023af2:	fa1f fb88 	uxth.w	fp, r8
70023af6:	f7ff faa3 	bl	70023040 <__aeabi_uidiv>
70023afa:	4649      	mov	r1, r9
70023afc:	4682      	mov	sl, r0
70023afe:	4638      	mov	r0, r7
70023b00:	f7ff fbcc 	bl	7002329c <__aeabi_uidivmod>
70023b04:	fb0b f00a 	mul.w	r0, fp, sl
70023b08:	0c2f      	lsrs	r7, r5, #16
70023b0a:	ea47 4101 	orr.w	r1, r7, r1, lsl #16
70023b0e:	4288      	cmp	r0, r1
70023b10:	d906      	bls.n	70023b20 <__udivdi3+0x1d4>
70023b12:	eb11 0108 	adds.w	r1, r1, r8
70023b16:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
70023b1a:	f0c0 808d 	bcc.w	70023c38 <__udivdi3+0x2ec>
70023b1e:	4692      	mov	sl, r2
70023b20:	1a0a      	subs	r2, r1, r0
70023b22:	4649      	mov	r1, r9
70023b24:	9200      	str	r2, [sp, #0]
70023b26:	b2ad      	uxth	r5, r5
70023b28:	4610      	mov	r0, r2
70023b2a:	f7ff fa89 	bl	70023040 <__aeabi_uidiv>
70023b2e:	9a00      	ldr	r2, [sp, #0]
70023b30:	4649      	mov	r1, r9
70023b32:	4607      	mov	r7, r0
70023b34:	4610      	mov	r0, r2
70023b36:	f7ff fbb1 	bl	7002329c <__aeabi_uidivmod>
70023b3a:	fb0b fb07 	mul.w	fp, fp, r7
70023b3e:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
70023b42:	458b      	cmp	fp, r1
70023b44:	d905      	bls.n	70023b52 <__udivdi3+0x206>
70023b46:	eb11 0108 	adds.w	r1, r1, r8
70023b4a:	f107 32ff 	add.w	r2, r7, #4294967295	; 0xffffffff
70023b4e:	d36d      	bcc.n	70023c2c <__udivdi3+0x2e0>
70023b50:	4617      	mov	r7, r2
70023b52:	ebcb 0b01 	rsb	fp, fp, r1
70023b56:	9901      	ldr	r1, [sp, #4]
70023b58:	ea47 400a 	orr.w	r0, r7, sl, lsl #16
70023b5c:	fba0 2301 	umull	r2, r3, r0, r1
70023b60:	459b      	cmp	fp, r3
70023b62:	d30c      	bcc.n	70023b7e <__udivdi3+0x232>
70023b64:	fa06 f604 	lsl.w	r6, r6, r4
70023b68:	bf14      	ite	ne
70023b6a:	2100      	movne	r1, #0
70023b6c:	2101      	moveq	r1, #1
70023b6e:	4296      	cmp	r6, r2
70023b70:	bf2c      	ite	cs
70023b72:	2600      	movcs	r6, #0
70023b74:	f001 0601 	andcc.w	r6, r1, #1
70023b78:	2e00      	cmp	r6, #0
70023b7a:	f43f af3f 	beq.w	700239fc <__udivdi3+0xb0>
70023b7e:	2600      	movs	r6, #0
70023b80:	3801      	subs	r0, #1
70023b82:	4631      	mov	r1, r6
70023b84:	b003      	add	sp, #12
70023b86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70023b8a:	409c      	lsls	r4, r3
70023b8c:	f1c3 0920 	rsb	r9, r3, #32
70023b90:	fa25 fa09 	lsr.w	sl, r5, r9
70023b94:	fa06 f703 	lsl.w	r7, r6, r3
70023b98:	ea4f 4814 	mov.w	r8, r4, lsr #16
70023b9c:	409d      	lsls	r5, r3
70023b9e:	4650      	mov	r0, sl
70023ba0:	fa26 f909 	lsr.w	r9, r6, r9
70023ba4:	4641      	mov	r1, r8
70023ba6:	ea49 0905 	orr.w	r9, r9, r5
70023baa:	f7ff fa49 	bl	70023040 <__aeabi_uidiv>
70023bae:	4641      	mov	r1, r8
70023bb0:	4683      	mov	fp, r0
70023bb2:	4650      	mov	r0, sl
70023bb4:	f7ff fb72 	bl	7002329c <__aeabi_uidivmod>
70023bb8:	fa1f fa84 	uxth.w	sl, r4
70023bbc:	ea4f 4319 	mov.w	r3, r9, lsr #16
70023bc0:	fb0a f00b 	mul.w	r0, sl, fp
70023bc4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
70023bc8:	4288      	cmp	r0, r1
70023bca:	d909      	bls.n	70023be0 <__udivdi3+0x294>
70023bcc:	1909      	adds	r1, r1, r4
70023bce:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
70023bd2:	d239      	bcs.n	70023c48 <__udivdi3+0x2fc>
70023bd4:	4288      	cmp	r0, r1
70023bd6:	bf84      	itt	hi
70023bd8:	f1ab 0b02 	subhi.w	fp, fp, #2
70023bdc:	1909      	addhi	r1, r1, r4
70023bde:	d933      	bls.n	70023c48 <__udivdi3+0x2fc>
70023be0:	1a0d      	subs	r5, r1, r0
70023be2:	4641      	mov	r1, r8
70023be4:	fa1f f989 	uxth.w	r9, r9
70023be8:	4628      	mov	r0, r5
70023bea:	f7ff fa29 	bl	70023040 <__aeabi_uidiv>
70023bee:	4641      	mov	r1, r8
70023bf0:	4606      	mov	r6, r0
70023bf2:	4628      	mov	r0, r5
70023bf4:	f7ff fb52 	bl	7002329c <__aeabi_uidivmod>
70023bf8:	fb0a f506 	mul.w	r5, sl, r6
70023bfc:	ea49 4101 	orr.w	r1, r9, r1, lsl #16
70023c00:	428d      	cmp	r5, r1
70023c02:	d909      	bls.n	70023c18 <__udivdi3+0x2cc>
70023c04:	1909      	adds	r1, r1, r4
70023c06:	f106 33ff 	add.w	r3, r6, #4294967295	; 0xffffffff
70023c0a:	d204      	bcs.n	70023c16 <__udivdi3+0x2ca>
70023c0c:	428d      	cmp	r5, r1
70023c0e:	bf84      	itt	hi
70023c10:	3e02      	subhi	r6, #2
70023c12:	1909      	addhi	r1, r1, r4
70023c14:	d800      	bhi.n	70023c18 <__udivdi3+0x2cc>
70023c16:	461e      	mov	r6, r3
70023c18:	1b4d      	subs	r5, r1, r5
70023c1a:	ea46 460b 	orr.w	r6, r6, fp, lsl #16
70023c1e:	e717      	b.n	70023a50 <__udivdi3+0x104>
70023c20:	461e      	mov	r6, r3
70023c22:	e6e8      	b.n	700239f6 <__udivdi3+0xaa>
70023c24:	4691      	mov	r9, r2
70023c26:	e72f      	b.n	70023a88 <__udivdi3+0x13c>
70023c28:	461d      	mov	r5, r3
70023c2a:	e749      	b.n	70023ac0 <__udivdi3+0x174>
70023c2c:	458b      	cmp	fp, r1
70023c2e:	bf84      	itt	hi
70023c30:	3f02      	subhi	r7, #2
70023c32:	4441      	addhi	r1, r8
70023c34:	d88d      	bhi.n	70023b52 <__udivdi3+0x206>
70023c36:	e78b      	b.n	70023b50 <__udivdi3+0x204>
70023c38:	4288      	cmp	r0, r1
70023c3a:	bf84      	itt	hi
70023c3c:	f1aa 0a02 	subhi.w	sl, sl, #2
70023c40:	4441      	addhi	r1, r8
70023c42:	f63f af6d 	bhi.w	70023b20 <__udivdi3+0x1d4>
70023c46:	e76a      	b.n	70023b1e <__udivdi3+0x1d2>
70023c48:	469b      	mov	fp, r3
70023c4a:	e7c9      	b.n	70023be0 <__udivdi3+0x294>

70023c4c <rt_hw_context_switch>:
 * r0 --> from
 * r1 --> to
 */
.globl rt_hw_context_switch
rt_hw_context_switch:
    stmfd   sp!, {lr}       @ push pc (lr should be pushed in place of PC)
70023c4c:	e92d4000 	stmfd	sp!, {lr}
    stmfd   sp!, {r0-r12, lr}   @ push lr & register file
70023c50:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

    mrs r4, cpsr
70023c54:	e10f4000 	mrs	r4, CPSR
    tst lr, #0x01
70023c58:	e31e0001 	tst	lr, #1
    orrne r4, r4, #0x20     @ it's thumb code
70023c5c:	13844020 	orrne	r4, r4, #32

    stmfd sp!, {r4}         @ push cpsr
70023c60:	e92d0010 	stmfd	sp!, {r4}

    str sp, [r0]            @ store sp in preempted tasks TCB
70023c64:	e580d000 	str	sp, [r0]
    ldr sp, [r1]            @ get new task stack pointer
70023c68:	e591d000 	ldr	sp, [r1]
    ldr     r0, [r1]
    mcr     p15, 0, r0, c3, c0
#endif
_switch_through:
#endif /* RT_USING_VMM */
    ldmfd sp!, {r4}         @ pop new task cpsr to spsr
70023c6c:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
70023c70:	e16ff004 	msr	SPSR_fsxc, r4
    ldmfd sp!, {r0-r12, lr, pc}^  @ pop new task r0-r12, lr & pc, copy spsr to cpsr
70023c74:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

70023c78 <rt_hw_context_switch_interrupt>:
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
70023c78:	e59f2024 	ldr	r2, [pc, #36]	; 70023ca4 <_reswitch+0xc>
    ldr r3, [r2]
70023c7c:	e5923000 	ldr	r3, [r2]
    cmp r3, #1
70023c80:	e3530001 	cmp	r3, #1
    beq _reswitch
70023c84:	0a000003 	beq	70023c98 <_reswitch>
    ldr ip, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
70023c88:	e59fc018 	ldr	ip, [pc, #24]	; 70023ca8 <_reswitch+0x10>
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
70023c8c:	e3a03001 	mov	r3, #1
    str r0, [ip]
70023c90:	e58c0000 	str	r0, [ip]
    str r3, [r2]
70023c94:	e5823000 	str	r3, [r2]

70023c98 <_reswitch>:
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
70023c98:	e59f200c 	ldr	r2, [pc, #12]	; 70023cac <_reswitch+0x14>
    str r1, [r2]
70023c9c:	e5821000 	str	r1, [r2]
    bx  lr
70023ca0:	e12fff1e 	bx	lr
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
70023ca4:	7002ab40 	.word	0x7002ab40
    ldr r3, [r2]
    cmp r3, #1
    beq _reswitch
    ldr ip, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
70023ca8:	7002ab38 	.word	0x7002ab38
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
    str r0, [ip]
    str r3, [r2]
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
70023cac:	7002ab3c 	.word	0x7002ab3c
	...

70023cc0 <vector_fiq>:
/* exception handlers: undef, swi, padt, dabt, resv, irq, fiq          */
.section .text.isr, "ax"
    .align  5
.globl vector_fiq
vector_fiq:
    stmfd   sp!,{r0-r7,lr}
70023cc0:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    bl      rt_hw_trap_fiq
70023cc4:	ebffa934 	bl	7000e19c <rt_hw_trap_fiq>
    ldmfd   sp!,{r0-r7,lr}
70023cc8:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    subs    pc, lr, #4
70023ccc:	e25ef004 	subs	pc, lr, #4
70023cd0:	e320f000 	nop	{0}
70023cd4:	e320f000 	nop	{0}
70023cd8:	e320f000 	nop	{0}
70023cdc:	e320f000 	nop	{0}

70023ce0 <vector_irq>:
.globl      vmm_virq_check

    .align  5
.globl vector_irq
vector_irq:
    stmfd   sp!, {r0-r12,lr}
70023ce0:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    ldr     r1, =vmm_domain_val
    ldr     r4, [r1]
    mcr     p15, 0, r4, c3, c0
#endif

    bl      rt_interrupt_enter
70023ce4:	ebff884e 	bl	70005e24 <rt_interrupt_enter>
    bl      rt_hw_trap_irq
70023ce8:	ebffa8e1 	bl	7000e074 <rt_hw_trap_irq>
    bl      rt_interrupt_leave
70023cec:	ebff885e 	bl	70005e6c <rt_interrupt_leave>
    mcr     p15, 0, r5, c3, c0
#endif

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
70023cf0:	e59f0194 	ldr	r0, [pc, #404]	; 70023e8c <vector_resv+0x2c>
    ldr     r1, [r0]
70023cf4:	e5901000 	ldr	r1, [r0]
    cmp     r1, #1
70023cf8:	e3510001 	cmp	r1, #1
    beq     rt_hw_context_switch_interrupt_do
70023cfc:	0a000001 	beq	70023d08 <rt_hw_context_switch_interrupt_do>

#ifndef RT_USING_VMM
    ldmfd   sp!, {r0-r12,lr}
70023d00:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    subs    pc,  lr, #4
70023d04:	e25ef004 	subs	pc, lr, #4

70023d08 <rt_hw_context_switch_interrupt_do>:
    ldmfd   sp!, {r0-r12,lr}
    b       orig_irq_isr
#endif /* RT_USING_VMM */

rt_hw_context_switch_interrupt_do:
    mov     r1,  #0         @ clear flag
70023d08:	e3a01000 	mov	r1, #0
    str     r1,  [r0]
70023d0c:	e5801000 	str	r1, [r0]

    mov     r1, sp          @ r1 point to {r0-r3} in stack
70023d10:	e1a0100d 	mov	r1, sp
    add     sp, sp, #4*4
70023d14:	e28dd010 	add	sp, sp, #16
    ldmfd   sp!, {r4-r12,lr}@ reload saved registers
70023d18:	e8bd5ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    mrs     r0,  spsr       @ get cpsr of interrupt thread
70023d1c:	e14f0000 	mrs	r0, SPSR
    sub     r2,  lr, #4     @ save old task's pc to r2
70023d20:	e24e2004 	sub	r2, lr, #4

    @ Switch to SVC mode with no interrupt. If the usr mode guest is
    @ interrupted, this will just switch to the stack of kernel space.
    @ save the registers in kernel space won't trigger data abort.
    msr     cpsr_c, #I_Bit|F_Bit|Mode_SVC
70023d24:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

    stmfd   sp!, {r2}       @ push old task's pc
70023d28:	e92d0004 	stmfd	sp!, {r2}
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
70023d2c:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
70023d30:	e891001e 	ldm	r1, {r1, r2, r3, r4}
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
70023d34:	e92d001e 	push	{r1, r2, r3, r4}
    stmfd   sp!, {r0}       @ push old task's cpsr
70023d38:	e92d0001 	stmfd	sp!, {r0}

    ldr     r4,  =rt_interrupt_from_thread
70023d3c:	e59f414c 	ldr	r4, [pc, #332]	; 70023e90 <vector_resv+0x30>
    ldr     r5,  [r4]
70023d40:	e5945000 	ldr	r5, [r4]
    str     sp,  [r5]       @ store sp in preempted tasks's TCB
70023d44:	e585d000 	str	sp, [r5]
    @ Make sure the domain is correct.
    ldr     r1, =vmm_domain_val
    ldr     r2, [r1]
    mcr     p15, 0, r2, c3, c0
#endif
    ldr     r6,  =rt_interrupt_to_thread
70023d48:	e59f6144 	ldr	r6, [pc, #324]	; 70023e94 <vector_resv+0x34>
    ldr     r6,  [r6]
70023d4c:	e5966000 	ldr	r6, [r6]
    ldr     sp,  [r6]       @ get new task's stack pointer
70023d50:	e596d000 	ldr	sp, [r6]

    ldmfd   sp!, {r4}       @ pop new task's cpsr to spsr
70023d54:	e8bd0010 	ldmfd	sp!, {r4}
    msr     spsr_cxsf, r4
70023d58:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd   sp!, {r0-r12,lr,pc}^ @ pop new task's r0-r12,lr & pc, copy spsr to cpsr
70023d5c:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

70023d60 <vector_swi>:
.endm

    .align  5
    .globl	vector_swi
vector_swi:
    push_svc_reg
70023d60:	e24dd044 	sub	sp, sp, #68	; 0x44
70023d64:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
70023d68:	e1a0000d 	mov	r0, sp
70023d6c:	e14f6000 	mrs	r6, SPSR
70023d70:	e580e03c 	str	lr, [r0, #60]	; 0x3c
70023d74:	e5806040 	str	r6, [r0, #64]	; 0x40
70023d78:	f1020013 	cps	#19
70023d7c:	e580d034 	str	sp, [r0, #52]	; 0x34
70023d80:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_swi
70023d84:	ebffa886 	bl	7000dfa4 <rt_hw_trap_swi>
    b       .
70023d88:	eafffffe 	b	70023d88 <vector_swi+0x28>
70023d8c:	e320f000 	nop	{0}
70023d90:	e320f000 	nop	{0}
70023d94:	e320f000 	nop	{0}
70023d98:	e320f000 	nop	{0}
70023d9c:	e320f000 	nop	{0}

70023da0 <vector_undef>:

    .align  5
    .globl	vector_undef
vector_undef:
    push_svc_reg
70023da0:	e24dd044 	sub	sp, sp, #68	; 0x44
70023da4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
70023da8:	e1a0000d 	mov	r0, sp
70023dac:	e14f6000 	mrs	r6, SPSR
70023db0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
70023db4:	e5806040 	str	r6, [r0, #64]	; 0x40
70023db8:	f1020013 	cps	#19
70023dbc:	e580d034 	str	sp, [r0, #52]	; 0x34
70023dc0:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_undef
70023dc4:	ebffa869 	bl	7000df70 <rt_hw_trap_undef>
    b       .
70023dc8:	eafffffe 	b	70023dc8 <vector_undef+0x28>
70023dcc:	e320f000 	nop	{0}
70023dd0:	e320f000 	nop	{0}
70023dd4:	e320f000 	nop	{0}
70023dd8:	e320f000 	nop	{0}
70023ddc:	e320f000 	nop	{0}

70023de0 <vector_pabt>:

    .align  5
    .globl	vector_pabt
vector_pabt:
    push_svc_reg
70023de0:	e24dd044 	sub	sp, sp, #68	; 0x44
70023de4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
70023de8:	e1a0000d 	mov	r0, sp
70023dec:	e14f6000 	mrs	r6, SPSR
70023df0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
70023df4:	e5806040 	str	r6, [r0, #64]	; 0x40
70023df8:	f1020013 	cps	#19
70023dfc:	e580d034 	str	sp, [r0, #52]	; 0x34
70023e00:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_pabt
70023e04:	ebffa873 	bl	7000dfd8 <rt_hw_trap_pabt>
    b       .
70023e08:	eafffffe 	b	70023e08 <vector_pabt+0x28>
70023e0c:	e320f000 	nop	{0}
70023e10:	e320f000 	nop	{0}
70023e14:	e320f000 	nop	{0}
70023e18:	e320f000 	nop	{0}
70023e1c:	e320f000 	nop	{0}

70023e20 <vector_dabt>:

    .align  5
    .globl	vector_dabt
vector_dabt:
    push_svc_reg
70023e20:	e24dd044 	sub	sp, sp, #68	; 0x44
70023e24:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
70023e28:	e1a0000d 	mov	r0, sp
70023e2c:	e14f6000 	mrs	r6, SPSR
70023e30:	e580e03c 	str	lr, [r0, #60]	; 0x3c
70023e34:	e5806040 	str	r6, [r0, #64]	; 0x40
70023e38:	f1020013 	cps	#19
70023e3c:	e580d034 	str	sp, [r0, #52]	; 0x34
70023e40:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_dabt
70023e44:	ebffa870 	bl	7000e00c <rt_hw_trap_dabt>
    b       .
70023e48:	eafffffe 	b	70023e48 <vector_dabt+0x28>
70023e4c:	e320f000 	nop	{0}
70023e50:	e320f000 	nop	{0}
70023e54:	e320f000 	nop	{0}
70023e58:	e320f000 	nop	{0}
70023e5c:	e320f000 	nop	{0}

70023e60 <vector_resv>:

    .align  5
    .globl	vector_resv
vector_resv:
    push_svc_reg
70023e60:	e24dd044 	sub	sp, sp, #68	; 0x44
70023e64:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
70023e68:	e1a0000d 	mov	r0, sp
70023e6c:	e14f6000 	mrs	r6, SPSR
70023e70:	e580e03c 	str	lr, [r0, #60]	; 0x3c
70023e74:	e5806040 	str	r6, [r0, #64]	; 0x40
70023e78:	f1020013 	cps	#19
70023e7c:	e580d034 	str	sp, [r0, #52]	; 0x34
70023e80:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_resv
70023e84:	ebffa86d 	bl	7000e040 <rt_hw_trap_resv>
    b       .
70023e88:	eafffffe 	b	70023e88 <vector_resv+0x28>
    mcr     p15, 0, r5, c3, c0
#endif

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
70023e8c:	7002ab40 	.word	0x7002ab40
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
    stmfd   sp!, {r0}       @ push old task's cpsr

    ldr     r4,  =rt_interrupt_from_thread
70023e90:	7002ab38 	.word	0x7002ab38
    @ Make sure the domain is correct.
    ldr     r1, =vmm_domain_val
    ldr     r2, [r1]
    mcr     p15, 0, r2, c3, c0
#endif
    ldr     r6,  =rt_interrupt_to_thread
70023e94:	7002ab3c 	.word	0x7002ab3c
70023e98:	e320f000 	nop	{0}
70023e9c:	e320f000 	nop	{0}

70023ea0 <atoi>:
70023ea0:	2100      	movs	r1, #0
70023ea2:	220a      	movs	r2, #10
70023ea4:	f000 bba4 	b.w	700245f0 <strtol>

70023ea8 <memcpy>:
70023ea8:	2a0f      	cmp	r2, #15
70023eaa:	b4f0      	push	{r4, r5, r6, r7}
70023eac:	d945      	bls.n	70023f3a <memcpy+0x92>
70023eae:	ea40 0301 	orr.w	r3, r0, r1
70023eb2:	079b      	lsls	r3, r3, #30
70023eb4:	d145      	bne.n	70023f42 <memcpy+0x9a>
70023eb6:	f1a2 0710 	sub.w	r7, r2, #16
70023eba:	460c      	mov	r4, r1
70023ebc:	4603      	mov	r3, r0
70023ebe:	093f      	lsrs	r7, r7, #4
70023ec0:	eb00 1607 	add.w	r6, r0, r7, lsl #4
70023ec4:	3610      	adds	r6, #16
70023ec6:	6825      	ldr	r5, [r4, #0]
70023ec8:	3310      	adds	r3, #16
70023eca:	3410      	adds	r4, #16
70023ecc:	f843 5c10 	str.w	r5, [r3, #-16]
70023ed0:	f854 5c0c 	ldr.w	r5, [r4, #-12]
70023ed4:	f843 5c0c 	str.w	r5, [r3, #-12]
70023ed8:	f854 5c08 	ldr.w	r5, [r4, #-8]
70023edc:	f843 5c08 	str.w	r5, [r3, #-8]
70023ee0:	f854 5c04 	ldr.w	r5, [r4, #-4]
70023ee4:	f843 5c04 	str.w	r5, [r3, #-4]
70023ee8:	42b3      	cmp	r3, r6
70023eea:	d1ec      	bne.n	70023ec6 <memcpy+0x1e>
70023eec:	1c7b      	adds	r3, r7, #1
70023eee:	f002 0c0f 	and.w	ip, r2, #15
70023ef2:	f1bc 0f03 	cmp.w	ip, #3
70023ef6:	ea4f 1303 	mov.w	r3, r3, lsl #4
70023efa:	4419      	add	r1, r3
70023efc:	4403      	add	r3, r0
70023efe:	d922      	bls.n	70023f46 <memcpy+0x9e>
70023f00:	460e      	mov	r6, r1
70023f02:	461d      	mov	r5, r3
70023f04:	4664      	mov	r4, ip
70023f06:	f856 7b04 	ldr.w	r7, [r6], #4
70023f0a:	3c04      	subs	r4, #4
70023f0c:	2c03      	cmp	r4, #3
70023f0e:	f845 7b04 	str.w	r7, [r5], #4
70023f12:	d8f8      	bhi.n	70023f06 <memcpy+0x5e>
70023f14:	f1ac 0404 	sub.w	r4, ip, #4
70023f18:	f002 0203 	and.w	r2, r2, #3
70023f1c:	f024 0403 	bic.w	r4, r4, #3
70023f20:	3404      	adds	r4, #4
70023f22:	4423      	add	r3, r4
70023f24:	4421      	add	r1, r4
70023f26:	b132      	cbz	r2, 70023f36 <memcpy+0x8e>
70023f28:	440a      	add	r2, r1
70023f2a:	f811 4b01 	ldrb.w	r4, [r1], #1
70023f2e:	4291      	cmp	r1, r2
70023f30:	f803 4b01 	strb.w	r4, [r3], #1
70023f34:	d1f9      	bne.n	70023f2a <memcpy+0x82>
70023f36:	bcf0      	pop	{r4, r5, r6, r7}
70023f38:	4770      	bx	lr
70023f3a:	4603      	mov	r3, r0
70023f3c:	2a00      	cmp	r2, #0
70023f3e:	d1f3      	bne.n	70023f28 <memcpy+0x80>
70023f40:	e7f9      	b.n	70023f36 <memcpy+0x8e>
70023f42:	4603      	mov	r3, r0
70023f44:	e7f0      	b.n	70023f28 <memcpy+0x80>
70023f46:	4662      	mov	r2, ip
70023f48:	2a00      	cmp	r2, #0
70023f4a:	d1ed      	bne.n	70023f28 <memcpy+0x80>
70023f4c:	e7f3      	b.n	70023f36 <memcpy+0x8e>
70023f4e:	bf00      	nop

70023f50 <memset>:
70023f50:	0783      	lsls	r3, r0, #30
70023f52:	b4f0      	push	{r4, r5, r6, r7}
70023f54:	d048      	beq.n	70023fe8 <memset+0x98>
70023f56:	1e54      	subs	r4, r2, #1
70023f58:	2a00      	cmp	r2, #0
70023f5a:	d043      	beq.n	70023fe4 <memset+0x94>
70023f5c:	b2cd      	uxtb	r5, r1
70023f5e:	4603      	mov	r3, r0
70023f60:	e002      	b.n	70023f68 <memset+0x18>
70023f62:	2c00      	cmp	r4, #0
70023f64:	d03e      	beq.n	70023fe4 <memset+0x94>
70023f66:	4614      	mov	r4, r2
70023f68:	f803 5b01 	strb.w	r5, [r3], #1
70023f6c:	f013 0f03 	tst.w	r3, #3
70023f70:	f104 32ff 	add.w	r2, r4, #4294967295	; 0xffffffff
70023f74:	d1f5      	bne.n	70023f62 <memset+0x12>
70023f76:	2c03      	cmp	r4, #3
70023f78:	d92d      	bls.n	70023fd6 <memset+0x86>
70023f7a:	b2cd      	uxtb	r5, r1
70023f7c:	2c0f      	cmp	r4, #15
70023f7e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
70023f82:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
70023f86:	d918      	bls.n	70023fba <memset+0x6a>
70023f88:	f1a4 0710 	sub.w	r7, r4, #16
70023f8c:	f103 0610 	add.w	r6, r3, #16
70023f90:	461a      	mov	r2, r3
70023f92:	093f      	lsrs	r7, r7, #4
70023f94:	eb06 1607 	add.w	r6, r6, r7, lsl #4
70023f98:	6015      	str	r5, [r2, #0]
70023f9a:	3210      	adds	r2, #16
70023f9c:	f842 5c0c 	str.w	r5, [r2, #-12]
70023fa0:	f842 5c08 	str.w	r5, [r2, #-8]
70023fa4:	f842 5c04 	str.w	r5, [r2, #-4]
70023fa8:	42b2      	cmp	r2, r6
70023faa:	d1f5      	bne.n	70023f98 <memset+0x48>
70023fac:	f004 040f 	and.w	r4, r4, #15
70023fb0:	3701      	adds	r7, #1
70023fb2:	2c03      	cmp	r4, #3
70023fb4:	eb03 1307 	add.w	r3, r3, r7, lsl #4
70023fb8:	d90d      	bls.n	70023fd6 <memset+0x86>
70023fba:	461e      	mov	r6, r3
70023fbc:	4622      	mov	r2, r4
70023fbe:	3a04      	subs	r2, #4
70023fc0:	f846 5b04 	str.w	r5, [r6], #4
70023fc4:	2a03      	cmp	r2, #3
70023fc6:	d8fa      	bhi.n	70023fbe <memset+0x6e>
70023fc8:	1f22      	subs	r2, r4, #4
70023fca:	f004 0403 	and.w	r4, r4, #3
70023fce:	f022 0203 	bic.w	r2, r2, #3
70023fd2:	3204      	adds	r2, #4
70023fd4:	4413      	add	r3, r2
70023fd6:	b12c      	cbz	r4, 70023fe4 <memset+0x94>
70023fd8:	b2c9      	uxtb	r1, r1
70023fda:	441c      	add	r4, r3
70023fdc:	f803 1b01 	strb.w	r1, [r3], #1
70023fe0:	42a3      	cmp	r3, r4
70023fe2:	d1fb      	bne.n	70023fdc <memset+0x8c>
70023fe4:	bcf0      	pop	{r4, r5, r6, r7}
70023fe6:	4770      	bx	lr
70023fe8:	4614      	mov	r4, r2
70023fea:	4603      	mov	r3, r0
70023fec:	e7c3      	b.n	70023f76 <memset+0x26>
70023fee:	bf00      	nop

70023ff0 <putenv>:
70023ff0:	f249 43d0 	movw	r3, #38096	; 0x94d0
70023ff4:	f2c7 0302 	movt	r3, #28674	; 0x7002
70023ff8:	4601      	mov	r1, r0
70023ffa:	6818      	ldr	r0, [r3, #0]
70023ffc:	f000 b800 	b.w	70024000 <_putenv_r>

70024000 <_putenv_r>:
70024000:	b570      	push	{r4, r5, r6, lr}
70024002:	4605      	mov	r5, r0
70024004:	f000 f982 	bl	7002430c <_strdup_r>
70024008:	4604      	mov	r4, r0
7002400a:	b198      	cbz	r0, 70024034 <_putenv_r+0x34>
7002400c:	213d      	movs	r1, #61	; 0x3d
7002400e:	f000 f901 	bl	70024214 <strchr>
70024012:	b188      	cbz	r0, 70024038 <_putenv_r+0x38>
70024014:	4602      	mov	r2, r0
70024016:	4621      	mov	r1, r4
70024018:	2300      	movs	r3, #0
7002401a:	4628      	mov	r0, r5
7002401c:	f802 3b01 	strb.w	r3, [r2], #1
70024020:	2301      	movs	r3, #1
70024022:	f000 f80f 	bl	70024044 <_setenv_r>
70024026:	4621      	mov	r1, r4
70024028:	4606      	mov	r6, r0
7002402a:	4628      	mov	r0, r5
7002402c:	f7fa ede8 	blx	7001ec00 <_free_r>
70024030:	4630      	mov	r0, r6
70024032:	bd70      	pop	{r4, r5, r6, pc}
70024034:	2001      	movs	r0, #1
70024036:	bd70      	pop	{r4, r5, r6, pc}
70024038:	4628      	mov	r0, r5
7002403a:	4621      	mov	r1, r4
7002403c:	f7fa ede0 	blx	7001ec00 <_free_r>
70024040:	2001      	movs	r0, #1
70024042:	bd70      	pop	{r4, r5, r6, pc}

70024044 <_setenv_r>:
70024044:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024048:	4688      	mov	r8, r1
7002404a:	b083      	sub	sp, #12
7002404c:	4606      	mov	r6, r0
7002404e:	213d      	movs	r1, #61	; 0x3d
70024050:	4640      	mov	r0, r8
70024052:	4614      	mov	r4, r2
70024054:	461f      	mov	r7, r3
70024056:	f000 f8dd 	bl	70024214 <strchr>
7002405a:	2800      	cmp	r0, #0
7002405c:	f040 8091 	bne.w	70024182 <_setenv_r+0x13e>
70024060:	4630      	mov	r0, r6
70024062:	f000 fcb5 	bl	700249d0 <__env_lock>
70024066:	4620      	mov	r0, r4
70024068:	f000 f964 	bl	70024334 <strlen>
7002406c:	4641      	mov	r1, r8
7002406e:	aa01      	add	r2, sp, #4
70024070:	4681      	mov	r9, r0
70024072:	4630      	mov	r0, r6
70024074:	f000 fcb6 	bl	700249e4 <_findenv_r>
70024078:	4605      	mov	r5, r0
7002407a:	2800      	cmp	r0, #0
7002407c:	f000 808b 	beq.w	70024196 <_setenv_r+0x152>
70024080:	2f00      	cmp	r7, #0
70024082:	d076      	beq.n	70024172 <_setenv_r+0x12e>
70024084:	f000 f956 	bl	70024334 <strlen>
70024088:	4581      	cmp	r9, r0
7002408a:	d95d      	bls.n	70024148 <_setenv_r+0x104>
7002408c:	9b01      	ldr	r3, [sp, #4]
7002408e:	f249 47e0 	movw	r7, #38112	; 0x94e0
70024092:	f2c7 0702 	movt	r7, #28674	; 0x7002
70024096:	ea4f 0a83 	mov.w	sl, r3, lsl #2
7002409a:	f898 2000 	ldrb.w	r2, [r8]
7002409e:	2a3d      	cmp	r2, #61	; 0x3d
700240a0:	bf18      	it	ne
700240a2:	2a00      	cmpne	r2, #0
700240a4:	bf0c      	ite	eq
700240a6:	2200      	moveq	r2, #0
700240a8:	2201      	movne	r2, #1
700240aa:	d00a      	beq.n	700240c2 <_setenv_r+0x7e>
700240ac:	f108 0301 	add.w	r3, r8, #1
700240b0:	461a      	mov	r2, r3
700240b2:	f813 5b01 	ldrb.w	r5, [r3], #1
700240b6:	2d3d      	cmp	r5, #61	; 0x3d
700240b8:	bf18      	it	ne
700240ba:	2d00      	cmpne	r5, #0
700240bc:	d1f8      	bne.n	700240b0 <_setenv_r+0x6c>
700240be:	ebc8 0202 	rsb	r2, r8, r2
700240c2:	eb09 0102 	add.w	r1, r9, r2
700240c6:	4630      	mov	r0, r6
700240c8:	3102      	adds	r1, #2
700240ca:	683d      	ldr	r5, [r7, #0]
700240cc:	f7fa ed24 	blx	7001eb18 <_malloc_r>
700240d0:	f249 43e0 	movw	r3, #38112	; 0x94e0
700240d4:	f2c7 0302 	movt	r3, #28674	; 0x7002
700240d8:	f845 000a 	str.w	r0, [r5, sl]
700240dc:	2800      	cmp	r0, #0
700240de:	f000 8092 	beq.w	70024206 <_setenv_r+0x1c2>
700240e2:	6819      	ldr	r1, [r3, #0]
700240e4:	9a01      	ldr	r2, [sp, #4]
700240e6:	f898 3000 	ldrb.w	r3, [r8]
700240ea:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
700240ee:	7003      	strb	r3, [r0, #0]
700240f0:	b16b      	cbz	r3, 7002410e <_setenv_r+0xca>
700240f2:	2b3d      	cmp	r3, #61	; 0x3d
700240f4:	d00b      	beq.n	7002410e <_setenv_r+0xca>
700240f6:	1c42      	adds	r2, r0, #1
700240f8:	4641      	mov	r1, r8
700240fa:	e001      	b.n	70024100 <_setenv_r+0xbc>
700240fc:	2b3d      	cmp	r3, #61	; 0x3d
700240fe:	d006      	beq.n	7002410e <_setenv_r+0xca>
70024100:	f811 3f01 	ldrb.w	r3, [r1, #1]!
70024104:	4610      	mov	r0, r2
70024106:	f802 3b01 	strb.w	r3, [r2], #1
7002410a:	2b00      	cmp	r3, #0
7002410c:	d1f6      	bne.n	700240fc <_setenv_r+0xb8>
7002410e:	4602      	mov	r2, r0
70024110:	233d      	movs	r3, #61	; 0x3d
70024112:	7003      	strb	r3, [r0, #0]
70024114:	f814 3b01 	ldrb.w	r3, [r4], #1
70024118:	f802 3f01 	strb.w	r3, [r2, #1]!
7002411c:	2b00      	cmp	r3, #0
7002411e:	d1f9      	bne.n	70024114 <_setenv_r+0xd0>
70024120:	4630      	mov	r0, r6
70024122:	f000 fc57 	bl	700249d4 <__env_unlock>
70024126:	6838      	ldr	r0, [r7, #0]
70024128:	9b01      	ldr	r3, [sp, #4]
7002412a:	f648 3198 	movw	r1, #35736	; 0x8b98
7002412e:	2203      	movs	r2, #3
70024130:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024134:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
70024138:	f000 f92c 	bl	70024394 <strncmp>
7002413c:	b1b0      	cbz	r0, 7002416c <_setenv_r+0x128>
7002413e:	2300      	movs	r3, #0
70024140:	4618      	mov	r0, r3
70024142:	b003      	add	sp, #12
70024144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024148:	f814 3b01 	ldrb.w	r3, [r4], #1
7002414c:	f805 3b01 	strb.w	r3, [r5], #1
70024150:	2b00      	cmp	r3, #0
70024152:	d1f9      	bne.n	70024148 <_setenv_r+0x104>
70024154:	4630      	mov	r0, r6
70024156:	f000 fc3d 	bl	700249d4 <__env_unlock>
7002415a:	f648 3194 	movw	r1, #35732	; 0x8b94
7002415e:	4640      	mov	r0, r8
70024160:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024164:	f7fe fe4e 	bl	70022e04 <strcmp>
70024168:	2800      	cmp	r0, #0
7002416a:	d1e8      	bne.n	7002413e <_setenv_r+0xfa>
7002416c:	f000 fa4e 	bl	7002460c <tzset>
70024170:	e7e5      	b.n	7002413e <_setenv_r+0xfa>
70024172:	4630      	mov	r0, r6
70024174:	f000 fc2e 	bl	700249d4 <__env_unlock>
70024178:	463b      	mov	r3, r7
7002417a:	4618      	mov	r0, r3
7002417c:	b003      	add	sp, #12
7002417e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024182:	f000 fc29 	bl	700249d8 <__errno>
70024186:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
7002418a:	2216      	movs	r2, #22
7002418c:	6002      	str	r2, [r0, #0]
7002418e:	4618      	mov	r0, r3
70024190:	b003      	add	sp, #12
70024192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024196:	f249 47e0 	movw	r7, #38112	; 0x94e0
7002419a:	f2c7 0702 	movt	r7, #28674	; 0x7002
7002419e:	6839      	ldr	r1, [r7, #0]
700241a0:	680b      	ldr	r3, [r1, #0]
700241a2:	b36b      	cbz	r3, 70024200 <_setenv_r+0x1bc>
700241a4:	460b      	mov	r3, r1
700241a6:	f853 2f04 	ldr.w	r2, [r3, #4]!
700241aa:	3501      	adds	r5, #1
700241ac:	2a00      	cmp	r2, #0
700241ae:	d1fa      	bne.n	700241a6 <_setenv_r+0x162>
700241b0:	1caa      	adds	r2, r5, #2
700241b2:	0092      	lsls	r2, r2, #2
700241b4:	f64a 3344 	movw	r3, #43844	; 0xab44
700241b8:	f2c7 0302 	movt	r3, #28674	; 0x7002
700241bc:	6818      	ldr	r0, [r3, #0]
700241be:	b168      	cbz	r0, 700241dc <_setenv_r+0x198>
700241c0:	4630      	mov	r0, r6
700241c2:	f7fa ecce 	blx	7001eb60 <_realloc_r>
700241c6:	6038      	str	r0, [r7, #0]
700241c8:	b1e8      	cbz	r0, 70024206 <_setenv_r+0x1c2>
700241ca:	ea4f 0a85 	mov.w	sl, r5, lsl #2
700241ce:	4603      	mov	r3, r0
700241d0:	1c6a      	adds	r2, r5, #1
700241d2:	2100      	movs	r1, #0
700241d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
700241d8:	9501      	str	r5, [sp, #4]
700241da:	e75e      	b.n	7002409a <_setenv_r+0x56>
700241dc:	4611      	mov	r1, r2
700241de:	4630      	mov	r0, r6
700241e0:	2201      	movs	r2, #1
700241e2:	601a      	str	r2, [r3, #0]
700241e4:	f7fa ec98 	blx	7001eb18 <_malloc_r>
700241e8:	4683      	mov	fp, r0
700241ea:	b160      	cbz	r0, 70024206 <_setenv_r+0x1c2>
700241ec:	ea4f 0a85 	mov.w	sl, r5, lsl #2
700241f0:	6839      	ldr	r1, [r7, #0]
700241f2:	4652      	mov	r2, sl
700241f4:	f7ff fe58 	bl	70023ea8 <memcpy>
700241f8:	465b      	mov	r3, fp
700241fa:	f8c7 b000 	str.w	fp, [r7]
700241fe:	e7e7      	b.n	700241d0 <_setenv_r+0x18c>
70024200:	461d      	mov	r5, r3
70024202:	2208      	movs	r2, #8
70024204:	e7d6      	b.n	700241b4 <_setenv_r+0x170>
70024206:	4630      	mov	r0, r6
70024208:	f000 fbe4 	bl	700249d4 <__env_unlock>
7002420c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
70024210:	e7b3      	b.n	7002417a <_setenv_r+0x136>
70024212:	bf00      	nop

70024214 <strchr>:
70024214:	b2c9      	uxtb	r1, r1
70024216:	b4f0      	push	{r4, r5, r6, r7}
70024218:	2900      	cmp	r1, #0
7002421a:	d047      	beq.n	700242ac <strchr+0x98>
7002421c:	0784      	lsls	r4, r0, #30
7002421e:	d00f      	beq.n	70024240 <strchr+0x2c>
70024220:	7802      	ldrb	r2, [r0, #0]
70024222:	2a00      	cmp	r2, #0
70024224:	d03f      	beq.n	700242a6 <strchr+0x92>
70024226:	4291      	cmp	r1, r2
70024228:	d03e      	beq.n	700242a8 <strchr+0x94>
7002422a:	1c43      	adds	r3, r0, #1
7002422c:	e005      	b.n	7002423a <strchr+0x26>
7002422e:	f813 2b01 	ldrb.w	r2, [r3], #1
70024232:	2a00      	cmp	r2, #0
70024234:	d037      	beq.n	700242a6 <strchr+0x92>
70024236:	4291      	cmp	r1, r2
70024238:	d036      	beq.n	700242a8 <strchr+0x94>
7002423a:	079a      	lsls	r2, r3, #30
7002423c:	4618      	mov	r0, r3
7002423e:	d1f6      	bne.n	7002422e <strchr+0x1a>
70024240:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
70024244:	6803      	ldr	r3, [r0, #0]
70024246:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
7002424a:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
7002424e:	ea83 0207 	eor.w	r2, r3, r7
70024252:	ea24 0303 	bic.w	r3, r4, r3
70024256:	f1a2 3401 	sub.w	r4, r2, #16843009	; 0x1010101
7002425a:	ea24 0202 	bic.w	r2, r4, r2
7002425e:	4313      	orrs	r3, r2
70024260:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
70024264:	d111      	bne.n	7002428a <strchr+0x76>
70024266:	1d02      	adds	r2, r0, #4
70024268:	4610      	mov	r0, r2
7002426a:	f852 3b04 	ldr.w	r3, [r2], #4
7002426e:	ea83 0407 	eor.w	r4, r3, r7
70024272:	f1a3 3601 	sub.w	r6, r3, #16843009	; 0x1010101
70024276:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
7002427a:	ea26 0303 	bic.w	r3, r6, r3
7002427e:	ea25 0404 	bic.w	r4, r5, r4
70024282:	4323      	orrs	r3, r4
70024284:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
70024288:	d0ee      	beq.n	70024268 <strchr+0x54>
7002428a:	7803      	ldrb	r3, [r0, #0]
7002428c:	2b00      	cmp	r3, #0
7002428e:	d03b      	beq.n	70024308 <strchr+0xf4>
70024290:	4299      	cmp	r1, r3
70024292:	d009      	beq.n	700242a8 <strchr+0x94>
70024294:	1c43      	adds	r3, r0, #1
70024296:	e001      	b.n	7002429c <strchr+0x88>
70024298:	4291      	cmp	r1, r2
7002429a:	d005      	beq.n	700242a8 <strchr+0x94>
7002429c:	4618      	mov	r0, r3
7002429e:	f813 2b01 	ldrb.w	r2, [r3], #1
700242a2:	2a00      	cmp	r2, #0
700242a4:	d1f8      	bne.n	70024298 <strchr+0x84>
700242a6:	4610      	mov	r0, r2
700242a8:	bcf0      	pop	{r4, r5, r6, r7}
700242aa:	4770      	bx	lr
700242ac:	0781      	lsls	r1, r0, #30
700242ae:	d00d      	beq.n	700242cc <strchr+0xb8>
700242b0:	7803      	ldrb	r3, [r0, #0]
700242b2:	2b00      	cmp	r3, #0
700242b4:	d0f8      	beq.n	700242a8 <strchr+0x94>
700242b6:	1c43      	adds	r3, r0, #1
700242b8:	e002      	b.n	700242c0 <strchr+0xac>
700242ba:	7802      	ldrb	r2, [r0, #0]
700242bc:	2a00      	cmp	r2, #0
700242be:	d0f3      	beq.n	700242a8 <strchr+0x94>
700242c0:	f013 0f03 	tst.w	r3, #3
700242c4:	4618      	mov	r0, r3
700242c6:	f103 0301 	add.w	r3, r3, #1
700242ca:	d1f6      	bne.n	700242ba <strchr+0xa6>
700242cc:	6803      	ldr	r3, [r0, #0]
700242ce:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
700242d2:	ea22 0303 	bic.w	r3, r2, r3
700242d6:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
700242da:	d10a      	bne.n	700242f2 <strchr+0xde>
700242dc:	1d03      	adds	r3, r0, #4
700242de:	4618      	mov	r0, r3
700242e0:	f853 2b04 	ldr.w	r2, [r3], #4
700242e4:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
700242e8:	ea21 0202 	bic.w	r2, r1, r2
700242ec:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
700242f0:	d0f5      	beq.n	700242de <strchr+0xca>
700242f2:	7803      	ldrb	r3, [r0, #0]
700242f4:	2b00      	cmp	r3, #0
700242f6:	d0d7      	beq.n	700242a8 <strchr+0x94>
700242f8:	1c43      	adds	r3, r0, #1
700242fa:	4618      	mov	r0, r3
700242fc:	3301      	adds	r3, #1
700242fe:	7802      	ldrb	r2, [r0, #0]
70024300:	2a00      	cmp	r2, #0
70024302:	d1fa      	bne.n	700242fa <strchr+0xe6>
70024304:	bcf0      	pop	{r4, r5, r6, r7}
70024306:	4770      	bx	lr
70024308:	4618      	mov	r0, r3
7002430a:	e7cd      	b.n	700242a8 <strchr+0x94>

7002430c <_strdup_r>:
7002430c:	b570      	push	{r4, r5, r6, lr}
7002430e:	4606      	mov	r6, r0
70024310:	4608      	mov	r0, r1
70024312:	460d      	mov	r5, r1
70024314:	f000 f80e 	bl	70024334 <strlen>
70024318:	1c44      	adds	r4, r0, #1
7002431a:	4630      	mov	r0, r6
7002431c:	4621      	mov	r1, r4
7002431e:	f7fa ebfc 	blx	7001eb18 <_malloc_r>
70024322:	4606      	mov	r6, r0
70024324:	b118      	cbz	r0, 7002432e <_strdup_r+0x22>
70024326:	4629      	mov	r1, r5
70024328:	4622      	mov	r2, r4
7002432a:	f7ff fdbd 	bl	70023ea8 <memcpy>
7002432e:	4630      	mov	r0, r6
70024330:	bd70      	pop	{r4, r5, r6, pc}
70024332:	bf00      	nop

70024334 <strlen>:
70024334:	f020 0103 	bic.w	r1, r0, #3
70024338:	f010 0003 	ands.w	r0, r0, #3
7002433c:	f1c0 0000 	rsb	r0, r0, #0
70024340:	f851 3b04 	ldr.w	r3, [r1], #4
70024344:	f100 0c04 	add.w	ip, r0, #4
70024348:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
7002434c:	f06f 0200 	mvn.w	r2, #0
70024350:	bf1c      	itt	ne
70024352:	fa22 f20c 	lsrne.w	r2, r2, ip
70024356:	4313      	orrne	r3, r2
70024358:	f04f 0c01 	mov.w	ip, #1
7002435c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
70024360:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
70024364:	eba3 020c 	sub.w	r2, r3, ip
70024368:	ea22 0203 	bic.w	r2, r2, r3
7002436c:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
70024370:	bf04      	itt	eq
70024372:	f851 3b04 	ldreq.w	r3, [r1], #4
70024376:	3004      	addeq	r0, #4
70024378:	d0f4      	beq.n	70024364 <strlen+0x30>
7002437a:	f013 0fff 	tst.w	r3, #255	; 0xff
7002437e:	bf1f      	itttt	ne
70024380:	3001      	addne	r0, #1
70024382:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
70024386:	3001      	addne	r0, #1
70024388:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
7002438c:	bf18      	it	ne
7002438e:	3001      	addne	r0, #1
70024390:	4770      	bx	lr
70024392:	bf00      	nop

70024394 <strncmp>:
70024394:	b4f0      	push	{r4, r5, r6, r7}
70024396:	2a00      	cmp	r2, #0
70024398:	d04b      	beq.n	70024432 <strncmp+0x9e>
7002439a:	ea40 0301 	orr.w	r3, r0, r1
7002439e:	f013 0303 	ands.w	r3, r3, #3
700243a2:	d12d      	bne.n	70024400 <strncmp+0x6c>
700243a4:	2a03      	cmp	r2, #3
700243a6:	d92b      	bls.n	70024400 <strncmp+0x6c>
700243a8:	6804      	ldr	r4, [r0, #0]
700243aa:	680d      	ldr	r5, [r1, #0]
700243ac:	42ac      	cmp	r4, r5
700243ae:	d127      	bne.n	70024400 <strncmp+0x6c>
700243b0:	3a04      	subs	r2, #4
700243b2:	d03e      	beq.n	70024432 <strncmp+0x9e>
700243b4:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
700243b8:	ea25 0404 	bic.w	r4, r5, r4
700243bc:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
700243c0:	d13d      	bne.n	7002443e <strncmp+0xaa>
700243c2:	460c      	mov	r4, r1
700243c4:	4605      	mov	r5, r0
700243c6:	e00e      	b.n	700243e6 <strncmp+0x52>
700243c8:	686b      	ldr	r3, [r5, #4]
700243ca:	4605      	mov	r5, r0
700243cc:	6866      	ldr	r6, [r4, #4]
700243ce:	460c      	mov	r4, r1
700243d0:	f1a3 3701 	sub.w	r7, r3, #16843009	; 0x1010101
700243d4:	42b3      	cmp	r3, r6
700243d6:	ea27 0703 	bic.w	r7, r7, r3
700243da:	d111      	bne.n	70024400 <strncmp+0x6c>
700243dc:	3a04      	subs	r2, #4
700243de:	d028      	beq.n	70024432 <strncmp+0x9e>
700243e0:	f017 3f80 	tst.w	r7, #2155905152	; 0x80808080
700243e4:	d128      	bne.n	70024438 <strncmp+0xa4>
700243e6:	2a03      	cmp	r2, #3
700243e8:	f100 0004 	add.w	r0, r0, #4
700243ec:	f101 0104 	add.w	r1, r1, #4
700243f0:	d8ea      	bhi.n	700243c8 <strncmp+0x34>
700243f2:	1e56      	subs	r6, r2, #1
700243f4:	b92a      	cbnz	r2, 70024402 <strncmp+0x6e>
700243f6:	7928      	ldrb	r0, [r5, #4]
700243f8:	7922      	ldrb	r2, [r4, #4]
700243fa:	1a80      	subs	r0, r0, r2
700243fc:	bcf0      	pop	{r4, r5, r6, r7}
700243fe:	4770      	bx	lr
70024400:	1e56      	subs	r6, r2, #1
70024402:	7803      	ldrb	r3, [r0, #0]
70024404:	780a      	ldrb	r2, [r1, #0]
70024406:	4293      	cmp	r3, r2
70024408:	d11b      	bne.n	70024442 <strncmp+0xae>
7002440a:	b1e6      	cbz	r6, 70024446 <strncmp+0xb2>
7002440c:	b1bb      	cbz	r3, 7002443e <strncmp+0xaa>
7002440e:	3601      	adds	r6, #1
70024410:	1c8b      	adds	r3, r1, #2
70024412:	4604      	mov	r4, r0
70024414:	4431      	add	r1, r6
70024416:	e005      	b.n	70024424 <strncmp+0x90>
70024418:	428b      	cmp	r3, r1
7002441a:	f103 0301 	add.w	r3, r3, #1
7002441e:	d00b      	beq.n	70024438 <strncmp+0xa4>
70024420:	2800      	cmp	r0, #0
70024422:	d0eb      	beq.n	700243fc <strncmp+0x68>
70024424:	f814 0f01 	ldrb.w	r0, [r4, #1]!
70024428:	f813 2c01 	ldrb.w	r2, [r3, #-1]
7002442c:	4290      	cmp	r0, r2
7002442e:	d0f3      	beq.n	70024418 <strncmp+0x84>
70024430:	e7e3      	b.n	700243fa <strncmp+0x66>
70024432:	4610      	mov	r0, r2
70024434:	bcf0      	pop	{r4, r5, r6, r7}
70024436:	4770      	bx	lr
70024438:	2000      	movs	r0, #0
7002443a:	bcf0      	pop	{r4, r5, r6, r7}
7002443c:	4770      	bx	lr
7002443e:	4618      	mov	r0, r3
70024440:	e7dc      	b.n	700243fc <strncmp+0x68>
70024442:	4618      	mov	r0, r3
70024444:	e7d9      	b.n	700243fa <strncmp+0x66>
70024446:	4630      	mov	r0, r6
70024448:	e7d8      	b.n	700243fc <strncmp+0x68>
7002444a:	bf00      	nop

7002444c <strncpy>:
7002444c:	ea40 0301 	orr.w	r3, r0, r1
70024450:	079b      	lsls	r3, r3, #30
70024452:	b470      	push	{r4, r5, r6}
70024454:	d12b      	bne.n	700244ae <strncpy+0x62>
70024456:	2a03      	cmp	r2, #3
70024458:	bf84      	itt	hi
7002445a:	460b      	movhi	r3, r1
7002445c:	4605      	movhi	r5, r0
7002445e:	d926      	bls.n	700244ae <strncpy+0x62>
70024460:	4619      	mov	r1, r3
70024462:	f853 4b04 	ldr.w	r4, [r3], #4
70024466:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
7002446a:	ea26 0604 	bic.w	r6, r6, r4
7002446e:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
70024472:	d105      	bne.n	70024480 <strncpy+0x34>
70024474:	3a04      	subs	r2, #4
70024476:	f845 4b04 	str.w	r4, [r5], #4
7002447a:	2a03      	cmp	r2, #3
7002447c:	4619      	mov	r1, r3
7002447e:	d8ef      	bhi.n	70024460 <strncpy+0x14>
70024480:	b19a      	cbz	r2, 700244aa <strncpy+0x5e>
70024482:	780c      	ldrb	r4, [r1, #0]
70024484:	3a01      	subs	r2, #1
70024486:	1c6b      	adds	r3, r5, #1
70024488:	702c      	strb	r4, [r5, #0]
7002448a:	b13c      	cbz	r4, 7002449c <strncpy+0x50>
7002448c:	b16a      	cbz	r2, 700244aa <strncpy+0x5e>
7002448e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
70024492:	3a01      	subs	r2, #1
70024494:	f803 4b01 	strb.w	r4, [r3], #1
70024498:	2c00      	cmp	r4, #0
7002449a:	d1f7      	bne.n	7002448c <strncpy+0x40>
7002449c:	b12a      	cbz	r2, 700244aa <strncpy+0x5e>
7002449e:	441a      	add	r2, r3
700244a0:	2100      	movs	r1, #0
700244a2:	f803 1b01 	strb.w	r1, [r3], #1
700244a6:	4293      	cmp	r3, r2
700244a8:	d1fb      	bne.n	700244a2 <strncpy+0x56>
700244aa:	bc70      	pop	{r4, r5, r6}
700244ac:	4770      	bx	lr
700244ae:	4605      	mov	r5, r0
700244b0:	e7e6      	b.n	70024480 <strncpy+0x34>
700244b2:	bf00      	nop

700244b4 <_strtol_r>:
700244b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
700244b8:	f249 44dc 	movw	r4, #38108	; 0x94dc
700244bc:	b085      	sub	sp, #20
700244be:	f2c7 0402 	movt	r4, #28674	; 0x7002
700244c2:	468c      	mov	ip, r1
700244c4:	4699      	mov	r9, r3
700244c6:	9003      	str	r0, [sp, #12]
700244c8:	4608      	mov	r0, r1
700244ca:	f8d4 8000 	ldr.w	r8, [r4]
700244ce:	e000      	b.n	700244d2 <_strtol_r+0x1e>
700244d0:	4620      	mov	r0, r4
700244d2:	4604      	mov	r4, r0
700244d4:	f814 5b01 	ldrb.w	r5, [r4], #1
700244d8:	eb08 0305 	add.w	r3, r8, r5
700244dc:	7859      	ldrb	r1, [r3, #1]
700244de:	f001 0108 	and.w	r1, r1, #8
700244e2:	f001 03ff 	and.w	r3, r1, #255	; 0xff
700244e6:	2900      	cmp	r1, #0
700244e8:	d1f2      	bne.n	700244d0 <_strtol_r+0x1c>
700244ea:	2d2d      	cmp	r5, #45	; 0x2d
700244ec:	d076      	beq.n	700245dc <_strtol_r+0x128>
700244ee:	2d2b      	cmp	r5, #43	; 0x2b
700244f0:	bf04      	itt	eq
700244f2:	1c84      	addeq	r4, r0, #2
700244f4:	7845      	ldrbeq	r5, [r0, #1]
700244f6:	f039 0110 	bics.w	r1, r9, #16
700244fa:	d112      	bne.n	70024522 <_strtol_r+0x6e>
700244fc:	f1d9 0101 	rsbs	r1, r9, #1
70024500:	bf38      	it	cc
70024502:	2100      	movcc	r1, #0
70024504:	2d30      	cmp	r5, #48	; 0x30
70024506:	d004      	beq.n	70024512 <_strtol_r+0x5e>
70024508:	b159      	cbz	r1, 70024522 <_strtol_r+0x6e>
7002450a:	f04f 090a 	mov.w	r9, #10
7002450e:	46cb      	mov	fp, r9
70024510:	e008      	b.n	70024524 <_strtol_r+0x70>
70024512:	7820      	ldrb	r0, [r4, #0]
70024514:	f000 00df 	and.w	r0, r0, #223	; 0xdf
70024518:	2858      	cmp	r0, #88	; 0x58
7002451a:	d063      	beq.n	700245e4 <_strtol_r+0x130>
7002451c:	b109      	cbz	r1, 70024522 <_strtol_r+0x6e>
7002451e:	f04f 0908 	mov.w	r9, #8
70024522:	46cb      	mov	fp, r9
70024524:	2b00      	cmp	r3, #0
70024526:	4659      	mov	r1, fp
70024528:	bf0c      	ite	eq
7002452a:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000
7002452e:	f04f 4600 	movne.w	r6, #2147483648	; 0x80000000
70024532:	9200      	str	r2, [sp, #0]
70024534:	9302      	str	r3, [sp, #8]
70024536:	2700      	movs	r7, #0
70024538:	4630      	mov	r0, r6
7002453a:	f8cd c004 	str.w	ip, [sp, #4]
7002453e:	f7fe fead 	bl	7002329c <__aeabi_uidivmod>
70024542:	4630      	mov	r0, r6
70024544:	468a      	mov	sl, r1
70024546:	4659      	mov	r1, fp
70024548:	f7fe fd7a 	bl	70023040 <__aeabi_uidiv>
7002454c:	4639      	mov	r1, r7
7002454e:	9b02      	ldr	r3, [sp, #8]
70024550:	e89d 1004 	ldmia.w	sp, {r2, ip}
70024554:	e00c      	b.n	70024570 <_strtol_r+0xbc>
70024556:	4555      	cmp	r5, sl
70024558:	bfd4      	ite	le
7002455a:	2600      	movle	r6, #0
7002455c:	2601      	movgt	r6, #1
7002455e:	4281      	cmp	r1, r0
70024560:	bf18      	it	ne
70024562:	2600      	movne	r6, #0
70024564:	b9ee      	cbnz	r6, 700245a2 <_strtol_r+0xee>
70024566:	fb0b 5101 	mla	r1, fp, r1, r5
7002456a:	2701      	movs	r7, #1
7002456c:	f814 5b01 	ldrb.w	r5, [r4], #1
70024570:	eb08 0605 	add.w	r6, r8, r5
70024574:	7876      	ldrb	r6, [r6, #1]
70024576:	f016 0f04 	tst.w	r6, #4
7002457a:	bf18      	it	ne
7002457c:	3d30      	subne	r5, #48	; 0x30
7002457e:	d107      	bne.n	70024590 <_strtol_r+0xdc>
70024580:	f016 0603 	ands.w	r6, r6, #3
70024584:	d010      	beq.n	700245a8 <_strtol_r+0xf4>
70024586:	2e01      	cmp	r6, #1
70024588:	bf14      	ite	ne
7002458a:	2657      	movne	r6, #87	; 0x57
7002458c:	2637      	moveq	r6, #55	; 0x37
7002458e:	1bad      	subs	r5, r5, r6
70024590:	45a9      	cmp	r9, r5
70024592:	dd09      	ble.n	700245a8 <_strtol_r+0xf4>
70024594:	4281      	cmp	r1, r0
70024596:	bf94      	ite	ls
70024598:	2600      	movls	r6, #0
7002459a:	2601      	movhi	r6, #1
7002459c:	ea56 77d7 	orrs.w	r7, r6, r7, lsr #31
700245a0:	d0d9      	beq.n	70024556 <_strtol_r+0xa2>
700245a2:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
700245a6:	e7e1      	b.n	7002456c <_strtol_r+0xb8>
700245a8:	1c78      	adds	r0, r7, #1
700245aa:	d008      	beq.n	700245be <_strtol_r+0x10a>
700245ac:	b9a3      	cbnz	r3, 700245d8 <_strtol_r+0x124>
700245ae:	4608      	mov	r0, r1
700245b0:	b112      	cbz	r2, 700245b8 <_strtol_r+0x104>
700245b2:	b97f      	cbnz	r7, 700245d4 <_strtol_r+0x120>
700245b4:	4664      	mov	r4, ip
700245b6:	6014      	str	r4, [r2, #0]
700245b8:	b005      	add	sp, #20
700245ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
700245be:	9903      	ldr	r1, [sp, #12]
700245c0:	2b00      	cmp	r3, #0
700245c2:	bf0c      	ite	eq
700245c4:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
700245c8:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
700245cc:	2322      	movs	r3, #34	; 0x22
700245ce:	600b      	str	r3, [r1, #0]
700245d0:	2a00      	cmp	r2, #0
700245d2:	d0f1      	beq.n	700245b8 <_strtol_r+0x104>
700245d4:	3c01      	subs	r4, #1
700245d6:	e7ee      	b.n	700245b6 <_strtol_r+0x102>
700245d8:	4249      	negs	r1, r1
700245da:	e7e8      	b.n	700245ae <_strtol_r+0xfa>
700245dc:	1c84      	adds	r4, r0, #2
700245de:	7845      	ldrb	r5, [r0, #1]
700245e0:	2301      	movs	r3, #1
700245e2:	e788      	b.n	700244f6 <_strtol_r+0x42>
700245e4:	f04f 0910 	mov.w	r9, #16
700245e8:	7865      	ldrb	r5, [r4, #1]
700245ea:	46cb      	mov	fp, r9
700245ec:	3402      	adds	r4, #2
700245ee:	e799      	b.n	70024524 <_strtol_r+0x70>

700245f0 <strtol>:
700245f0:	b430      	push	{r4, r5}
700245f2:	f249 44d0 	movw	r4, #38096	; 0x94d0
700245f6:	f2c7 0402 	movt	r4, #28674	; 0x7002
700245fa:	460d      	mov	r5, r1
700245fc:	4613      	mov	r3, r2
700245fe:	4601      	mov	r1, r0
70024600:	462a      	mov	r2, r5
70024602:	6820      	ldr	r0, [r4, #0]
70024604:	bc30      	pop	{r4, r5}
70024606:	f7ff bf55 	b.w	700244b4 <_strtol_r>
7002460a:	bf00      	nop

7002460c <tzset>:
7002460c:	f249 43d0 	movw	r3, #38096	; 0x94d0
70024610:	f2c7 0302 	movt	r3, #28674	; 0x7002
70024614:	6818      	ldr	r0, [r3, #0]
70024616:	f000 b801 	b.w	7002461c <_tzset_r>
7002461a:	bf00      	nop

7002461c <_tzset_r>:
7002461c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024620:	b08b      	sub	sp, #44	; 0x2c
70024622:	4606      	mov	r6, r0
70024624:	f000 fa28 	bl	70024a78 <__gettzinfo>
70024628:	f648 3194 	movw	r1, #35732	; 0x8b94
7002462c:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024630:	f64a 3460 	movw	r4, #43872	; 0xab60
70024634:	f2c7 0402 	movt	r4, #28674	; 0x7002
70024638:	4681      	mov	r9, r0
7002463a:	4630      	mov	r0, r6
7002463c:	f000 fa14 	bl	70024a68 <_getenv_r>
70024640:	4605      	mov	r5, r0
70024642:	2800      	cmp	r0, #0
70024644:	f000 8128 	beq.w	70024898 <_tzset_r+0x27c>
70024648:	f001 f9b8 	bl	700259bc <__tz_lock>
7002464c:	6821      	ldr	r1, [r4, #0]
7002464e:	2900      	cmp	r1, #0
70024650:	f000 8141 	beq.w	700248d6 <_tzset_r+0x2ba>
70024654:	4628      	mov	r0, r5
70024656:	f7fe fbd5 	bl	70022e04 <strcmp>
7002465a:	2800      	cmp	r0, #0
7002465c:	f000 8117 	beq.w	7002488e <_tzset_r+0x272>
70024660:	6820      	ldr	r0, [r4, #0]
70024662:	f000 fa0f 	bl	70024a84 <free>
70024666:	4628      	mov	r0, r5
70024668:	f7ff fe64 	bl	70024334 <strlen>
7002466c:	1c41      	adds	r1, r0, #1
7002466e:	4630      	mov	r0, r6
70024670:	f7fa ea52 	blx	7001eb18 <_malloc_r>
70024674:	6020      	str	r0, [r4, #0]
70024676:	b110      	cbz	r0, 7002467e <_tzset_r+0x62>
70024678:	4629      	mov	r1, r5
7002467a:	f000 fb0b 	bl	70024c94 <strcpy>
7002467e:	782b      	ldrb	r3, [r5, #0]
70024680:	ac08      	add	r4, sp, #32
70024682:	f648 31a0 	movw	r1, #35744	; 0x8ba0
70024686:	f64a 3254 	movw	r2, #43860	; 0xab54
7002468a:	2b3a      	cmp	r3, #58	; 0x3a
7002468c:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024690:	bf08      	it	eq
70024692:	3501      	addeq	r5, #1
70024694:	4623      	mov	r3, r4
70024696:	f2c7 0202 	movt	r2, #28674	; 0x7002
7002469a:	4628      	mov	r0, r5
7002469c:	f000 faca 	bl	70024c34 <siscanf>
700246a0:	2800      	cmp	r0, #0
700246a2:	f340 80f4 	ble.w	7002488e <_tzset_r+0x272>
700246a6:	9b08      	ldr	r3, [sp, #32]
700246a8:	eb05 0803 	add.w	r8, r5, r3
700246ac:	5ceb      	ldrb	r3, [r5, r3]
700246ae:	2b2d      	cmp	r3, #45	; 0x2d
700246b0:	bf04      	itt	eq
700246b2:	f108 0801 	addeq.w	r8, r8, #1
700246b6:	f04f 3bff 	moveq.w	fp, #4294967295	; 0xffffffff
700246ba:	d005      	beq.n	700246c8 <_tzset_r+0xac>
700246bc:	2b2b      	cmp	r3, #43	; 0x2b
700246be:	f04f 0b01 	mov.w	fp, #1
700246c2:	bf08      	it	eq
700246c4:	f108 0801 	addeq.w	r8, r8, #1
700246c8:	f10d 0316 	add.w	r3, sp, #22
700246cc:	9401      	str	r4, [sp, #4]
700246ce:	9300      	str	r3, [sp, #0]
700246d0:	aa05      	add	r2, sp, #20
700246d2:	9403      	str	r4, [sp, #12]
700246d4:	af06      	add	r7, sp, #24
700246d6:	f648 31b0 	movw	r1, #35760	; 0x8bb0
700246da:	9702      	str	r7, [sp, #8]
700246dc:	f2c7 0102 	movt	r1, #28674	; 0x7002
700246e0:	4640      	mov	r0, r8
700246e2:	4623      	mov	r3, r4
700246e4:	f04f 0a00 	mov.w	sl, #0
700246e8:	f8ad a016 	strh.w	sl, [sp, #22]
700246ec:	f8ad a018 	strh.w	sl, [sp, #24]
700246f0:	f000 faa0 	bl	70024c34 <siscanf>
700246f4:	4550      	cmp	r0, sl
700246f6:	f340 80ca 	ble.w	7002488e <_tzset_r+0x272>
700246fa:	f8bd 3016 	ldrh.w	r3, [sp, #22]
700246fe:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
70024702:	f8bd 0018 	ldrh.w	r0, [sp, #24]
70024706:	f64a 3648 	movw	r6, #43848	; 0xab48
7002470a:	f8bd 1014 	ldrh.w	r1, [sp, #20]
7002470e:	f2c7 0602 	movt	r6, #28674	; 0x7002
70024712:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
70024716:	9a08      	ldr	r2, [sp, #32]
70024718:	f249 45d4 	movw	r5, #38100	; 0x94d4
7002471c:	f2c7 0502 	movt	r5, #28674	; 0x7002
70024720:	eb00 0383 	add.w	r3, r0, r3, lsl #2
70024724:	4490      	add	r8, r2
70024726:	4632      	mov	r2, r6
70024728:	fb0e 3e01 	mla	lr, lr, r1, r3
7002472c:	4640      	mov	r0, r8
7002472e:	f648 31a0 	movw	r1, #35744	; 0x8ba0
70024732:	4623      	mov	r3, r4
70024734:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024738:	fb0b fb0e 	mul.w	fp, fp, lr
7002473c:	f64a 3e54 	movw	lr, #43860	; 0xab54
70024740:	f2c7 0e02 	movt	lr, #28674	; 0x7002
70024744:	f8c5 e000 	str.w	lr, [r5]
70024748:	f8c9 b020 	str.w	fp, [r9, #32]
7002474c:	f000 fa72 	bl	70024c34 <siscanf>
70024750:	4550      	cmp	r0, sl
70024752:	f340 811f 	ble.w	70024994 <_tzset_r+0x378>
70024756:	9b08      	ldr	r3, [sp, #32]
70024758:	606e      	str	r6, [r5, #4]
7002475a:	eb08 0a03 	add.w	sl, r8, r3
7002475e:	f818 3003 	ldrb.w	r3, [r8, r3]
70024762:	2b2d      	cmp	r3, #45	; 0x2d
70024764:	bf04      	itt	eq
70024766:	f10a 0a01 	addeq.w	sl, sl, #1
7002476a:	f04f 38ff 	moveq.w	r8, #4294967295	; 0xffffffff
7002476e:	d005      	beq.n	7002477c <_tzset_r+0x160>
70024770:	2b2b      	cmp	r3, #43	; 0x2b
70024772:	f04f 0801 	mov.w	r8, #1
70024776:	bf08      	it	eq
70024778:	f10a 0a01 	addeq.w	sl, sl, #1
7002477c:	4623      	mov	r3, r4
7002477e:	f10d 0216 	add.w	r2, sp, #22
70024782:	f648 31b0 	movw	r1, #35760	; 0x8bb0
70024786:	9200      	str	r2, [sp, #0]
70024788:	f2c7 0102 	movt	r1, #28674	; 0x7002
7002478c:	aa05      	add	r2, sp, #20
7002478e:	9401      	str	r4, [sp, #4]
70024790:	4650      	mov	r0, sl
70024792:	9702      	str	r7, [sp, #8]
70024794:	2500      	movs	r5, #0
70024796:	9403      	str	r4, [sp, #12]
70024798:	2600      	movs	r6, #0
7002479a:	f8ad 5014 	strh.w	r5, [sp, #20]
7002479e:	46b3      	mov	fp, r6
700247a0:	f8ad 5016 	strh.w	r5, [sp, #22]
700247a4:	f8ad 5018 	strh.w	r5, [sp, #24]
700247a8:	9508      	str	r5, [sp, #32]
700247aa:	f000 fa43 	bl	70024c34 <siscanf>
700247ae:	42a8      	cmp	r0, r5
700247b0:	9d08      	ldr	r5, [sp, #32]
700247b2:	bfc2      	ittt	gt
700247b4:	f8bd 3016 	ldrhgt.w	r3, [sp, #22]
700247b8:	f44f 6061 	movgt.w	r0, #3600	; 0xe10
700247bc:	f8bd 2018 	ldrhgt.w	r2, [sp, #24]
700247c0:	4455      	add	r5, sl
700247c2:	bfc5      	ittet	gt
700247c4:	f8bd 1014 	ldrhgt.w	r1, [sp, #20]
700247c8:	ebc3 1303 	rsbgt	r3, r3, r3, lsl #4
700247cc:	f8d9 3020 	ldrle.w	r3, [r9, #32]
700247d0:	eb02 0283 	addgt.w	r2, r2, r3, lsl #2
700247d4:	bfd2      	itee	le
700247d6:	f5a3 6361 	suble.w	r3, r3, #3600	; 0xe10
700247da:	fb00 2301 	mlagt	r3, r0, r1, r2
700247de:	fb08 f303 	mulgt.w	r3, r8, r3
700247e2:	46c8      	mov	r8, r9
700247e4:	f8c9 303c 	str.w	r3, [r9, #60]	; 0x3c
700247e8:	f895 a000 	ldrb.w	sl, [r5]
700247ec:	f1ba 0f2c 	cmp.w	sl, #44	; 0x2c
700247f0:	bf04      	itt	eq
700247f2:	f895 a001 	ldrbeq.w	sl, [r5, #1]
700247f6:	3501      	addeq	r5, #1
700247f8:	f1ba 0f4d 	cmp.w	sl, #77	; 0x4d
700247fc:	d06d      	beq.n	700248da <_tzset_r+0x2be>
700247fe:	f1ba 0f4a 	cmp.w	sl, #74	; 0x4a
70024802:	a909      	add	r1, sp, #36	; 0x24
70024804:	bf08      	it	eq
70024806:	3501      	addeq	r5, #1
70024808:	f04f 020a 	mov.w	r2, #10
7002480c:	bf18      	it	ne
7002480e:	f04f 0a44 	movne.w	sl, #68	; 0x44
70024812:	4628      	mov	r0, r5
70024814:	f000 fb3c 	bl	70024e90 <strtoul>
70024818:	9e09      	ldr	r6, [sp, #36]	; 0x24
7002481a:	42ae      	cmp	r6, r5
7002481c:	f8ad 001e 	strh.w	r0, [sp, #30]
70024820:	bf1e      	ittt	ne
70024822:	b280      	uxthne	r0, r0
70024824:	f888 a008 	strbne.w	sl, [r8, #8]
70024828:	f8c8 0014 	strne.w	r0, [r8, #20]
7002482c:	f000 80a2 	beq.w	70024974 <_tzset_r+0x358>
70024830:	2500      	movs	r5, #0
70024832:	f04f 0302 	mov.w	r3, #2
70024836:	f8ad 5016 	strh.w	r5, [sp, #22]
7002483a:	f8ad 3014 	strh.w	r3, [sp, #20]
7002483e:	f8ad 5018 	strh.w	r5, [sp, #24]
70024842:	9508      	str	r5, [sp, #32]
70024844:	7833      	ldrb	r3, [r6, #0]
70024846:	2b2f      	cmp	r3, #47	; 0x2f
70024848:	bf18      	it	ne
7002484a:	f44f 53e1 	movne.w	r3, #7200	; 0x1c20
7002484e:	d072      	beq.n	70024936 <_tzset_r+0x31a>
70024850:	f10b 0b01 	add.w	fp, fp, #1
70024854:	f8c8 3018 	str.w	r3, [r8, #24]
70024858:	f1bb 0f02 	cmp.w	fp, #2
7002485c:	4435      	add	r5, r6
7002485e:	f108 081c 	add.w	r8, r8, #28
70024862:	d1c1      	bne.n	700247e8 <_tzset_r+0x1cc>
70024864:	f8d9 0004 	ldr.w	r0, [r9, #4]
70024868:	f000 f914 	bl	70024a94 <__tzcalc_limits>
7002486c:	f8d9 1020 	ldr.w	r1, [r9, #32]
70024870:	f8d9 003c 	ldr.w	r0, [r9, #60]	; 0x3c
70024874:	f64a 3264 	movw	r2, #43876	; 0xab64
70024878:	f64a 3368 	movw	r3, #43880	; 0xab68
7002487c:	f2c7 0202 	movt	r2, #28674	; 0x7002
70024880:	1a08      	subs	r0, r1, r0
70024882:	f2c7 0302 	movt	r3, #28674	; 0x7002
70024886:	bf18      	it	ne
70024888:	2001      	movne	r0, #1
7002488a:	6019      	str	r1, [r3, #0]
7002488c:	6010      	str	r0, [r2, #0]
7002488e:	f001 f897 	bl	700259c0 <__tz_unlock>
70024892:	b00b      	add	sp, #44	; 0x2c
70024894:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024898:	f001 f890 	bl	700259bc <__tz_lock>
7002489c:	f64a 3268 	movw	r2, #43880	; 0xab68
700248a0:	f64a 3164 	movw	r1, #43876	; 0xab64
700248a4:	f2c7 0202 	movt	r2, #28674	; 0x7002
700248a8:	f2c7 0102 	movt	r1, #28674	; 0x7002
700248ac:	f249 43d4 	movw	r3, #38100	; 0x94d4
700248b0:	f2c7 0302 	movt	r3, #28674	; 0x7002
700248b4:	6820      	ldr	r0, [r4, #0]
700248b6:	6015      	str	r5, [r2, #0]
700248b8:	f648 329c 	movw	r2, #35740	; 0x8b9c
700248bc:	600d      	str	r5, [r1, #0]
700248be:	f2c7 0202 	movt	r2, #28674	; 0x7002
700248c2:	601a      	str	r2, [r3, #0]
700248c4:	605a      	str	r2, [r3, #4]
700248c6:	f000 f8dd 	bl	70024a84 <free>
700248ca:	6025      	str	r5, [r4, #0]
700248cc:	f001 f878 	bl	700259c0 <__tz_unlock>
700248d0:	b00b      	add	sp, #44	; 0x2c
700248d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
700248d6:	4608      	mov	r0, r1
700248d8:	e6c3      	b.n	70024662 <_tzset_r+0x46>
700248da:	aa07      	add	r2, sp, #28
700248dc:	f10d 031e 	add.w	r3, sp, #30
700248e0:	9200      	str	r2, [sp, #0]
700248e2:	f648 31c4 	movw	r1, #35780	; 0x8bc4
700248e6:	9302      	str	r3, [sp, #8]
700248e8:	f2c7 0102 	movt	r1, #28674	; 0x7002
700248ec:	9401      	str	r4, [sp, #4]
700248ee:	4628      	mov	r0, r5
700248f0:	9403      	str	r4, [sp, #12]
700248f2:	f10d 021a 	add.w	r2, sp, #26
700248f6:	4623      	mov	r3, r4
700248f8:	f000 f99c 	bl	70024c34 <siscanf>
700248fc:	2803      	cmp	r0, #3
700248fe:	d1c6      	bne.n	7002488e <_tzset_r+0x272>
70024900:	f8bd 301a 	ldrh.w	r3, [sp, #26]
70024904:	1e5a      	subs	r2, r3, #1
70024906:	b292      	uxth	r2, r2
70024908:	2a0b      	cmp	r2, #11
7002490a:	d8c0      	bhi.n	7002488e <_tzset_r+0x272>
7002490c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
70024910:	1e51      	subs	r1, r2, #1
70024912:	b289      	uxth	r1, r1
70024914:	2904      	cmp	r1, #4
70024916:	d8ba      	bhi.n	7002488e <_tzset_r+0x272>
70024918:	f8bd 101e 	ldrh.w	r1, [sp, #30]
7002491c:	2906      	cmp	r1, #6
7002491e:	d8b6      	bhi.n	7002488e <_tzset_r+0x272>
70024920:	9e08      	ldr	r6, [sp, #32]
70024922:	f888 a008 	strb.w	sl, [r8, #8]
70024926:	f8c8 300c 	str.w	r3, [r8, #12]
7002492a:	442e      	add	r6, r5
7002492c:	f8c8 2010 	str.w	r2, [r8, #16]
70024930:	f8c8 1014 	str.w	r1, [r8, #20]
70024934:	e77c      	b.n	70024830 <_tzset_r+0x214>
70024936:	f10d 0216 	add.w	r2, sp, #22
7002493a:	4623      	mov	r3, r4
7002493c:	9200      	str	r2, [sp, #0]
7002493e:	f648 31d8 	movw	r1, #35800	; 0x8bd8
70024942:	aa05      	add	r2, sp, #20
70024944:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024948:	9401      	str	r4, [sp, #4]
7002494a:	4630      	mov	r0, r6
7002494c:	9702      	str	r7, [sp, #8]
7002494e:	9403      	str	r4, [sp, #12]
70024950:	f000 f970 	bl	70024c34 <siscanf>
70024954:	f8bd 2016 	ldrh.w	r2, [sp, #22]
70024958:	f8bd 0018 	ldrh.w	r0, [sp, #24]
7002495c:	f44f 6361 	mov.w	r3, #3600	; 0xe10
70024960:	f8bd 1014 	ldrh.w	r1, [sp, #20]
70024964:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
70024968:	9d08      	ldr	r5, [sp, #32]
7002496a:	eb00 0282 	add.w	r2, r0, r2, lsl #2
7002496e:	fb03 2301 	mla	r3, r3, r1, r2
70024972:	e76d      	b.n	70024850 <_tzset_r+0x234>
70024974:	f1bb 0f00 	cmp.w	fp, #0
70024978:	d01e      	beq.n	700249b8 <_tzset_r+0x39c>
7002497a:	224d      	movs	r2, #77	; 0x4d
7002497c:	230b      	movs	r3, #11
7002497e:	f889 2024 	strb.w	r2, [r9, #36]	; 0x24
70024982:	2201      	movs	r2, #1
70024984:	f8c9 3028 	str.w	r3, [r9, #40]	; 0x28
70024988:	2300      	movs	r3, #0
7002498a:	f8c9 202c 	str.w	r2, [r9, #44]	; 0x2c
7002498e:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
70024992:	e74d      	b.n	70024830 <_tzset_r+0x214>
70024994:	f8d9 0020 	ldr.w	r0, [r9, #32]
70024998:	f64a 3268 	movw	r2, #43880	; 0xab68
7002499c:	6829      	ldr	r1, [r5, #0]
7002499e:	f2c7 0202 	movt	r2, #28674	; 0x7002
700249a2:	f64a 3364 	movw	r3, #43876	; 0xab64
700249a6:	f2c7 0302 	movt	r3, #28674	; 0x7002
700249aa:	6010      	str	r0, [r2, #0]
700249ac:	f8c3 a000 	str.w	sl, [r3]
700249b0:	6069      	str	r1, [r5, #4]
700249b2:	f001 f805 	bl	700259c0 <__tz_unlock>
700249b6:	e76c      	b.n	70024892 <_tzset_r+0x276>
700249b8:	2303      	movs	r3, #3
700249ba:	2202      	movs	r2, #2
700249bc:	f8c9 300c 	str.w	r3, [r9, #12]
700249c0:	234d      	movs	r3, #77	; 0x4d
700249c2:	f8c9 2010 	str.w	r2, [r9, #16]
700249c6:	f8c9 b014 	str.w	fp, [r9, #20]
700249ca:	f889 3008 	strb.w	r3, [r9, #8]
700249ce:	e72f      	b.n	70024830 <_tzset_r+0x214>

700249d0 <__env_lock>:
700249d0:	4770      	bx	lr
700249d2:	bf00      	nop

700249d4 <__env_unlock>:
700249d4:	4770      	bx	lr
700249d6:	bf00      	nop

700249d8 <__errno>:
700249d8:	f249 43d0 	movw	r3, #38096	; 0x94d0
700249dc:	f2c7 0302 	movt	r3, #28674	; 0x7002
700249e0:	6818      	ldr	r0, [r3, #0]
700249e2:	4770      	bx	lr

700249e4 <_findenv_r>:
700249e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
700249e8:	f249 47e0 	movw	r7, #38112	; 0x94e0
700249ec:	f2c7 0702 	movt	r7, #28674	; 0x7002
700249f0:	460e      	mov	r6, r1
700249f2:	4691      	mov	r9, r2
700249f4:	4680      	mov	r8, r0
700249f6:	f7ff ffeb 	bl	700249d0 <__env_lock>
700249fa:	683c      	ldr	r4, [r7, #0]
700249fc:	b314      	cbz	r4, 70024a44 <_findenv_r+0x60>
700249fe:	7833      	ldrb	r3, [r6, #0]
70024a00:	2b3d      	cmp	r3, #61	; 0x3d
70024a02:	bf18      	it	ne
70024a04:	2b00      	cmpne	r3, #0
70024a06:	bf08      	it	eq
70024a08:	4632      	moveq	r2, r6
70024a0a:	d007      	beq.n	70024a1c <_findenv_r+0x38>
70024a0c:	1c75      	adds	r5, r6, #1
70024a0e:	462a      	mov	r2, r5
70024a10:	f815 3b01 	ldrb.w	r3, [r5], #1
70024a14:	2b3d      	cmp	r3, #61	; 0x3d
70024a16:	bf18      	it	ne
70024a18:	2b00      	cmpne	r3, #0
70024a1a:	d1f8      	bne.n	70024a0e <_findenv_r+0x2a>
70024a1c:	2b3d      	cmp	r3, #61	; 0x3d
70024a1e:	d011      	beq.n	70024a44 <_findenv_r+0x60>
70024a20:	6820      	ldr	r0, [r4, #0]
70024a22:	1b95      	subs	r5, r2, r6
70024a24:	b170      	cbz	r0, 70024a44 <_findenv_r+0x60>
70024a26:	4631      	mov	r1, r6
70024a28:	462a      	mov	r2, r5
70024a2a:	f7ff fcb3 	bl	70024394 <strncmp>
70024a2e:	b928      	cbnz	r0, 70024a3c <_findenv_r+0x58>
70024a30:	6823      	ldr	r3, [r4, #0]
70024a32:	eb03 0a05 	add.w	sl, r3, r5
70024a36:	5d5b      	ldrb	r3, [r3, r5]
70024a38:	2b3d      	cmp	r3, #61	; 0x3d
70024a3a:	d009      	beq.n	70024a50 <_findenv_r+0x6c>
70024a3c:	f854 0f04 	ldr.w	r0, [r4, #4]!
70024a40:	2800      	cmp	r0, #0
70024a42:	d1f0      	bne.n	70024a26 <_findenv_r+0x42>
70024a44:	4640      	mov	r0, r8
70024a46:	f7ff ffc5 	bl	700249d4 <__env_unlock>
70024a4a:	2000      	movs	r0, #0
70024a4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
70024a50:	683b      	ldr	r3, [r7, #0]
70024a52:	4640      	mov	r0, r8
70024a54:	1ae4      	subs	r4, r4, r3
70024a56:	10a4      	asrs	r4, r4, #2
70024a58:	f8c9 4000 	str.w	r4, [r9]
70024a5c:	f7ff ffba 	bl	700249d4 <__env_unlock>
70024a60:	f10a 0001 	add.w	r0, sl, #1
70024a64:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

70024a68 <_getenv_r>:
70024a68:	b500      	push	{lr}
70024a6a:	b083      	sub	sp, #12
70024a6c:	aa01      	add	r2, sp, #4
70024a6e:	f7ff ffb9 	bl	700249e4 <_findenv_r>
70024a72:	b003      	add	sp, #12
70024a74:	f85d fb04 	ldr.w	pc, [sp], #4

70024a78 <__gettzinfo>:
70024a78:	f249 40e4 	movw	r0, #38116	; 0x94e4
70024a7c:	f2c7 0002 	movt	r0, #28674	; 0x7002
70024a80:	4770      	bx	lr
70024a82:	bf00      	nop

70024a84 <free>:
70024a84:	f249 43d0 	movw	r3, #38096	; 0x94d0
70024a88:	f2c7 0302 	movt	r3, #28674	; 0x7002
70024a8c:	4601      	mov	r1, r0
70024a8e:	6818      	ldr	r0, [r3, #0]
70024a90:	f001 ba4a 	b.w	70025f28 <___free_r_from_thumb>

70024a94 <__tzcalc_limits>:
70024a94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024a98:	b085      	sub	sp, #20
70024a9a:	4606      	mov	r6, r0
70024a9c:	f7ff ffec 	bl	70024a78 <__gettzinfo>
70024aa0:	f240 73b1 	movw	r3, #1969	; 0x7b1
70024aa4:	429e      	cmp	r6, r3
70024aa6:	4604      	mov	r4, r0
70024aa8:	bfd8      	it	le
70024aaa:	2000      	movle	r0, #0
70024aac:	f340 80a0 	ble.w	70024bf0 <__tzcalc_limits+0x15c>
70024ab0:	f248 531f 	movw	r3, #34079	; 0x851f
70024ab4:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
70024ab8:	f2a6 716d 	subw	r1, r6, #1901	; 0x76d
70024abc:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
70024ac0:	fb83 0506 	smull	r0, r5, r3, r6
70024ac4:	18b2      	adds	r2, r6, r2
70024ac6:	f46f 60f6 	mvn.w	r0, #1968	; 0x7b0
70024aca:	eb06 0900 	add.w	r9, r6, r0
70024ace:	17f0      	asrs	r0, r6, #31
70024ad0:	f2a6 7ab2 	subw	sl, r6, #1970	; 0x7b2
70024ad4:	fb83 7b02 	smull	r7, fp, r3, r2
70024ad8:	ebc0 18e5 	rsb	r8, r0, r5, asr #7
70024adc:	ebc0 1065 	rsb	r0, r0, r5, asr #5
70024ae0:	9001      	str	r0, [sp, #4]
70024ae2:	fb83 7c01 	smull	r7, ip, r3, r1
70024ae6:	9b01      	ldr	r3, [sp, #4]
70024ae8:	2764      	movs	r7, #100	; 0x64
70024aea:	ea4f 09a9 	mov.w	r9, r9, asr #2
70024aee:	f240 156d 	movw	r5, #365	; 0x16d
70024af2:	f44f 70c8 	mov.w	r0, #400	; 0x190
70024af6:	fb07 6313 	mls	r3, r7, r3, r6
70024afa:	17c9      	asrs	r1, r1, #31
70024afc:	fb05 950a 	mla	r5, r5, sl, r9
70024b00:	17d2      	asrs	r2, r2, #31
70024b02:	fb00 6018 	mls	r0, r0, r8, r6
70024b06:	eba1 116c 	sub.w	r1, r1, ip, asr #5
70024b0a:	4429      	add	r1, r5
70024b0c:	f006 0703 	and.w	r7, r6, #3
70024b10:	9301      	str	r3, [sp, #4]
70024b12:	f648 45f0 	movw	r5, #36080	; 0x8cf0
70024b16:	ebc2 13eb 	rsb	r3, r2, fp, asr #7
70024b1a:	f1d0 0001 	rsbs	r0, r0, #1
70024b1e:	9703      	str	r7, [sp, #12]
70024b20:	f242 4893 	movw	r8, #9363	; 0x2493
70024b24:	f44f 47a3 	mov.w	r7, #20864	; 0x5180
70024b28:	f2c7 0502 	movt	r5, #28674	; 0x7002
70024b2c:	f2c9 2849 	movt	r8, #37449	; 0x9249
70024b30:	f2c0 0701 	movt	r7, #1
70024b34:	eb01 0b03 	add.w	fp, r1, r3
70024b38:	4622      	mov	r2, r4
70024b3a:	f04f 0100 	mov.w	r1, #0
70024b3e:	bf38      	it	cc
70024b40:	2000      	movcc	r0, #0
70024b42:	6066      	str	r6, [r4, #4]
70024b44:	9002      	str	r0, [sp, #8]
70024b46:	7a13      	ldrb	r3, [r2, #8]
70024b48:	2b4a      	cmp	r3, #74	; 0x4a
70024b4a:	d059      	beq.n	70024c00 <__tzcalc_limits+0x16c>
70024b4c:	2b44      	cmp	r3, #68	; 0x44
70024b4e:	d06a      	beq.n	70024c26 <__tzcalc_limits+0x192>
70024b50:	9803      	ldr	r0, [sp, #12]
70024b52:	9b02      	ldr	r3, [sp, #8]
70024b54:	2800      	cmp	r0, #0
70024b56:	d04e      	beq.n	70024bf6 <__tzcalc_limits+0x162>
70024b58:	68d0      	ldr	r0, [r2, #12]
70024b5a:	005e      	lsls	r6, r3, #1
70024b5c:	441e      	add	r6, r3
70024b5e:	2801      	cmp	r0, #1
70024b60:	eb05 1606 	add.w	r6, r5, r6, lsl #4
70024b64:	dd62      	ble.n	70024c2c <__tzcalc_limits+0x198>
70024b66:	ea4f 0980 	mov.w	r9, r0, lsl #2
70024b6a:	f1a6 0a08 	sub.w	sl, r6, #8
70024b6e:	44ca      	add	sl, r9
70024b70:	1f30      	subs	r0, r6, #4
70024b72:	465b      	mov	r3, fp
70024b74:	4694      	mov	ip, r2
70024b76:	f850 2f04 	ldr.w	r2, [r0, #4]!
70024b7a:	4550      	cmp	r0, sl
70024b7c:	4413      	add	r3, r2
70024b7e:	d1fa      	bne.n	70024b76 <__tzcalc_limits+0xe2>
70024b80:	f1a9 0904 	sub.w	r9, r9, #4
70024b84:	4662      	mov	r2, ip
70024b86:	1d18      	adds	r0, r3, #4
70024b88:	9000      	str	r0, [sp, #0]
70024b8a:	f856 9009 	ldr.w	r9, [r6, r9]
70024b8e:	fb88 0a00 	smull	r0, sl, r8, r0
70024b92:	9800      	ldr	r0, [sp, #0]
70024b94:	4482      	add	sl, r0
70024b96:	ea4f 7ce0 	mov.w	ip, r0, asr #31
70024b9a:	ebcc 0caa 	rsb	ip, ip, sl, asr #2
70024b9e:	ebcc 0ccc 	rsb	ip, ip, ip, lsl #3
70024ba2:	ebcc 0c00 	rsb	ip, ip, r0
70024ba6:	6950      	ldr	r0, [r2, #20]
70024ba8:	ebb0 0c0c 	subs.w	ip, r0, ip
70024bac:	6910      	ldr	r0, [r2, #16]
70024bae:	bf48      	it	mi
70024bb0:	f10c 0c07 	addmi.w	ip, ip, #7
70024bb4:	1e46      	subs	r6, r0, #1
70024bb6:	ebc6 06c6 	rsb	r6, r6, r6, lsl #3
70024bba:	44b4      	add	ip, r6
70024bbc:	45cc      	cmp	ip, r9
70024bbe:	db04      	blt.n	70024bca <__tzcalc_limits+0x136>
70024bc0:	4648      	mov	r0, r9
70024bc2:	f1ac 0c07 	sub.w	ip, ip, #7
70024bc6:	4584      	cmp	ip, r0
70024bc8:	dafb      	bge.n	70024bc2 <__tzcalc_limits+0x12e>
70024bca:	4463      	add	r3, ip
70024bcc:	6996      	ldr	r6, [r2, #24]
70024bce:	3101      	adds	r1, #1
70024bd0:	6a10      	ldr	r0, [r2, #32]
70024bd2:	2902      	cmp	r1, #2
70024bd4:	fb07 6603 	mla	r6, r7, r3, r6
70024bd8:	4430      	add	r0, r6
70024bda:	f842 0f1c 	str.w	r0, [r2, #28]!
70024bde:	d1b2      	bne.n	70024b46 <__tzcalc_limits+0xb2>
70024be0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
70024be2:	2001      	movs	r0, #1
70024be4:	69e2      	ldr	r2, [r4, #28]
70024be6:	429a      	cmp	r2, r3
70024be8:	bfac      	ite	ge
70024bea:	2300      	movge	r3, #0
70024bec:	2301      	movlt	r3, #1
70024bee:	6023      	str	r3, [r4, #0]
70024bf0:	b005      	add	sp, #20
70024bf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024bf6:	9e01      	ldr	r6, [sp, #4]
70024bf8:	2e00      	cmp	r6, #0
70024bfa:	bf18      	it	ne
70024bfc:	2301      	movne	r3, #1
70024bfe:	e7ab      	b.n	70024b58 <__tzcalc_limits+0xc4>
70024c00:	6950      	ldr	r0, [r2, #20]
70024c02:	9e03      	ldr	r6, [sp, #12]
70024c04:	eb00 030b 	add.w	r3, r0, fp
70024c08:	b946      	cbnz	r6, 70024c1c <__tzcalc_limits+0x188>
70024c0a:	9e01      	ldr	r6, [sp, #4]
70024c0c:	b136      	cbz	r6, 70024c1c <__tzcalc_limits+0x188>
70024c0e:	283b      	cmp	r0, #59	; 0x3b
70024c10:	bfd4      	ite	le
70024c12:	2000      	movle	r0, #0
70024c14:	2001      	movgt	r0, #1
70024c16:	4403      	add	r3, r0
70024c18:	3b01      	subs	r3, #1
70024c1a:	e7d7      	b.n	70024bcc <__tzcalc_limits+0x138>
70024c1c:	9e02      	ldr	r6, [sp, #8]
70024c1e:	2e00      	cmp	r6, #0
70024c20:	d1f5      	bne.n	70024c0e <__tzcalc_limits+0x17a>
70024c22:	9802      	ldr	r0, [sp, #8]
70024c24:	e7f7      	b.n	70024c16 <__tzcalc_limits+0x182>
70024c26:	6953      	ldr	r3, [r2, #20]
70024c28:	445b      	add	r3, fp
70024c2a:	e7cf      	b.n	70024bcc <__tzcalc_limits+0x138>
70024c2c:	465b      	mov	r3, fp
70024c2e:	f04f 0900 	mov.w	r9, #0
70024c32:	e7a8      	b.n	70024b86 <__tzcalc_limits+0xf2>

70024c34 <siscanf>:
70024c34:	b40e      	push	{r1, r2, r3}
70024c36:	f44f 7201 	mov.w	r2, #516	; 0x204
70024c3a:	b570      	push	{r4, r5, r6, lr}
70024c3c:	b09d      	sub	sp, #116	; 0x74
70024c3e:	ac21      	add	r4, sp, #132	; 0x84
70024c40:	f8ad 2014 	strh.w	r2, [sp, #20]
70024c44:	f854 6b04 	ldr.w	r6, [r4], #4
70024c48:	9002      	str	r0, [sp, #8]
70024c4a:	9006      	str	r0, [sp, #24]
70024c4c:	f7ff fb72 	bl	70024334 <strlen>
70024c50:	f249 41d0 	movw	r1, #38096	; 0x94d0
70024c54:	f2c7 0102 	movt	r1, #28674	; 0x7002
70024c58:	4623      	mov	r3, r4
70024c5a:	4632      	mov	r2, r6
70024c5c:	9401      	str	r4, [sp, #4]
70024c5e:	f644 4491 	movw	r4, #19601	; 0x4c91
70024c62:	f2c7 0402 	movt	r4, #28674	; 0x7002
70024c66:	940a      	str	r4, [sp, #40]	; 0x28
70024c68:	f64f 74ff 	movw	r4, #65535	; 0xffff
70024c6c:	f8ad 4016 	strh.w	r4, [sp, #22]
70024c70:	4605      	mov	r5, r0
70024c72:	9003      	str	r0, [sp, #12]
70024c74:	6808      	ldr	r0, [r1, #0]
70024c76:	a902      	add	r1, sp, #8
70024c78:	9507      	str	r5, [sp, #28]
70024c7a:	2500      	movs	r5, #0
70024c7c:	950e      	str	r5, [sp, #56]	; 0x38
70024c7e:	9513      	str	r5, [sp, #76]	; 0x4c
70024c80:	f000 f9b0 	bl	70024fe4 <__ssvfiscanf_r>
70024c84:	b01d      	add	sp, #116	; 0x74
70024c86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
70024c8a:	b003      	add	sp, #12
70024c8c:	4770      	bx	lr
70024c8e:	bf00      	nop

70024c90 <__seofread>:
70024c90:	2000      	movs	r0, #0
70024c92:	4770      	bx	lr

70024c94 <strcpy>:
70024c94:	ea80 0201 	eor.w	r2, r0, r1
70024c98:	4684      	mov	ip, r0
70024c9a:	f012 0f03 	tst.w	r2, #3
70024c9e:	d14f      	bne.n	70024d40 <strcpy+0xac>
70024ca0:	f011 0f03 	tst.w	r1, #3
70024ca4:	d132      	bne.n	70024d0c <strcpy+0x78>
70024ca6:	f84d 4d04 	str.w	r4, [sp, #-4]!
70024caa:	f011 0f04 	tst.w	r1, #4
70024cae:	f851 3b04 	ldr.w	r3, [r1], #4
70024cb2:	d00b      	beq.n	70024ccc <strcpy+0x38>
70024cb4:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
70024cb8:	439a      	bics	r2, r3
70024cba:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
70024cbe:	bf04      	itt	eq
70024cc0:	f84c 3b04 	streq.w	r3, [ip], #4
70024cc4:	f851 3b04 	ldreq.w	r3, [r1], #4
70024cc8:	d116      	bne.n	70024cf8 <strcpy+0x64>
70024cca:	bf00      	nop
70024ccc:	f851 4b04 	ldr.w	r4, [r1], #4
70024cd0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
70024cd4:	439a      	bics	r2, r3
70024cd6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
70024cda:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
70024cde:	d10b      	bne.n	70024cf8 <strcpy+0x64>
70024ce0:	f84c 3b04 	str.w	r3, [ip], #4
70024ce4:	43a2      	bics	r2, r4
70024ce6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
70024cea:	bf04      	itt	eq
70024cec:	f851 3b04 	ldreq.w	r3, [r1], #4
70024cf0:	f84c 4b04 	streq.w	r4, [ip], #4
70024cf4:	d0ea      	beq.n	70024ccc <strcpy+0x38>
70024cf6:	4623      	mov	r3, r4
70024cf8:	f80c 3b01 	strb.w	r3, [ip], #1
70024cfc:	f013 0fff 	tst.w	r3, #255	; 0xff
70024d00:	ea4f 2333 	mov.w	r3, r3, ror #8
70024d04:	d1f8      	bne.n	70024cf8 <strcpy+0x64>
70024d06:	f85d 4b04 	ldr.w	r4, [sp], #4
70024d0a:	4770      	bx	lr
70024d0c:	f011 0f01 	tst.w	r1, #1
70024d10:	d006      	beq.n	70024d20 <strcpy+0x8c>
70024d12:	f811 2b01 	ldrb.w	r2, [r1], #1
70024d16:	f80c 2b01 	strb.w	r2, [ip], #1
70024d1a:	2a00      	cmp	r2, #0
70024d1c:	bf08      	it	eq
70024d1e:	4770      	bxeq	lr
70024d20:	f011 0f02 	tst.w	r1, #2
70024d24:	d0bf      	beq.n	70024ca6 <strcpy+0x12>
70024d26:	f831 2b02 	ldrh.w	r2, [r1], #2
70024d2a:	f012 0fff 	tst.w	r2, #255	; 0xff
70024d2e:	bf16      	itet	ne
70024d30:	f82c 2b02 	strhne.w	r2, [ip], #2
70024d34:	f88c 2000 	strbeq.w	r2, [ip]
70024d38:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
70024d3c:	d1b3      	bne.n	70024ca6 <strcpy+0x12>
70024d3e:	4770      	bx	lr
70024d40:	f811 2b01 	ldrb.w	r2, [r1], #1
70024d44:	f80c 2b01 	strb.w	r2, [ip], #1
70024d48:	2a00      	cmp	r2, #0
70024d4a:	d1f9      	bne.n	70024d40 <strcpy+0xac>
70024d4c:	4770      	bx	lr
70024d4e:	bf00      	nop

70024d50 <_strtoul_r>:
70024d50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024d54:	f249 44dc 	movw	r4, #38108	; 0x94dc
70024d58:	b085      	sub	sp, #20
70024d5a:	f2c7 0402 	movt	r4, #28674	; 0x7002
70024d5e:	468a      	mov	sl, r1
70024d60:	469b      	mov	fp, r3
70024d62:	9003      	str	r0, [sp, #12]
70024d64:	4608      	mov	r0, r1
70024d66:	f8d4 8000 	ldr.w	r8, [r4]
70024d6a:	e000      	b.n	70024d6e <_strtoul_r+0x1e>
70024d6c:	4620      	mov	r0, r4
70024d6e:	4604      	mov	r4, r0
70024d70:	f814 5b01 	ldrb.w	r5, [r4], #1
70024d74:	eb08 0305 	add.w	r3, r8, r5
70024d78:	785b      	ldrb	r3, [r3, #1]
70024d7a:	f003 0308 	and.w	r3, r3, #8
70024d7e:	f003 06ff 	and.w	r6, r3, #255	; 0xff
70024d82:	2b00      	cmp	r3, #0
70024d84:	d1f2      	bne.n	70024d6c <_strtoul_r+0x1c>
70024d86:	2d2d      	cmp	r5, #45	; 0x2d
70024d88:	d06e      	beq.n	70024e68 <_strtoul_r+0x118>
70024d8a:	2d2b      	cmp	r5, #43	; 0x2b
70024d8c:	4633      	mov	r3, r6
70024d8e:	bf04      	itt	eq
70024d90:	1c84      	addeq	r4, r0, #2
70024d92:	7845      	ldrbeq	r5, [r0, #1]
70024d94:	f03b 0110 	bics.w	r1, fp, #16
70024d98:	d116      	bne.n	70024dc8 <_strtoul_r+0x78>
70024d9a:	f1db 0101 	rsbs	r1, fp, #1
70024d9e:	bf38      	it	cc
70024da0:	2100      	movcc	r1, #0
70024da2:	2d30      	cmp	r5, #48	; 0x30
70024da4:	d009      	beq.n	70024dba <_strtoul_r+0x6a>
70024da6:	b179      	cbz	r1, 70024dc8 <_strtoul_r+0x78>
70024da8:	f04f 0b0a 	mov.w	fp, #10
70024dac:	f649 1999 	movw	r9, #39321	; 0x9999
70024db0:	46dc      	mov	ip, fp
70024db2:	f6c1 1999 	movt	r9, #6553	; 0x1999
70024db6:	2105      	movs	r1, #5
70024db8:	e016      	b.n	70024de8 <_strtoul_r+0x98>
70024dba:	7820      	ldrb	r0, [r4, #0]
70024dbc:	f000 00df 	and.w	r0, r0, #223	; 0xdf
70024dc0:	2858      	cmp	r0, #88	; 0x58
70024dc2:	d055      	beq.n	70024e70 <_strtoul_r+0x120>
70024dc4:	2900      	cmp	r1, #0
70024dc6:	d15c      	bne.n	70024e82 <_strtoul_r+0x132>
70024dc8:	4659      	mov	r1, fp
70024dca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70024dce:	9201      	str	r2, [sp, #4]
70024dd0:	9302      	str	r3, [sp, #8]
70024dd2:	f7fe f935 	bl	70023040 <__aeabi_uidiv>
70024dd6:	4659      	mov	r1, fp
70024dd8:	4681      	mov	r9, r0
70024dda:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70024dde:	f7fe fa5d 	bl	7002329c <__aeabi_uidivmod>
70024de2:	9a01      	ldr	r2, [sp, #4]
70024de4:	9b02      	ldr	r3, [sp, #8]
70024de6:	46dc      	mov	ip, fp
70024de8:	2700      	movs	r7, #0
70024dea:	4638      	mov	r0, r7
70024dec:	e00c      	b.n	70024e08 <_strtoul_r+0xb8>
70024dee:	428d      	cmp	r5, r1
70024df0:	bfd4      	ite	le
70024df2:	2600      	movle	r6, #0
70024df4:	2601      	movgt	r6, #1
70024df6:	4548      	cmp	r0, r9
70024df8:	bf18      	it	ne
70024dfa:	2600      	movne	r6, #0
70024dfc:	b9ee      	cbnz	r6, 70024e3a <_strtoul_r+0xea>
70024dfe:	fb0c 5000 	mla	r0, ip, r0, r5
70024e02:	2701      	movs	r7, #1
70024e04:	f814 5b01 	ldrb.w	r5, [r4], #1
70024e08:	eb08 0605 	add.w	r6, r8, r5
70024e0c:	7876      	ldrb	r6, [r6, #1]
70024e0e:	f016 0f04 	tst.w	r6, #4
70024e12:	bf18      	it	ne
70024e14:	3d30      	subne	r5, #48	; 0x30
70024e16:	d107      	bne.n	70024e28 <_strtoul_r+0xd8>
70024e18:	f016 0603 	ands.w	r6, r6, #3
70024e1c:	d010      	beq.n	70024e40 <_strtoul_r+0xf0>
70024e1e:	2e01      	cmp	r6, #1
70024e20:	bf14      	ite	ne
70024e22:	2657      	movne	r6, #87	; 0x57
70024e24:	2637      	moveq	r6, #55	; 0x37
70024e26:	1bad      	subs	r5, r5, r6
70024e28:	45ab      	cmp	fp, r5
70024e2a:	dd09      	ble.n	70024e40 <_strtoul_r+0xf0>
70024e2c:	4548      	cmp	r0, r9
70024e2e:	bf94      	ite	ls
70024e30:	2600      	movls	r6, #0
70024e32:	2601      	movhi	r6, #1
70024e34:	ea56 77d7 	orrs.w	r7, r6, r7, lsr #31
70024e38:	d0d9      	beq.n	70024dee <_strtoul_r+0x9e>
70024e3a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
70024e3e:	e7e1      	b.n	70024e04 <_strtoul_r+0xb4>
70024e40:	1c79      	adds	r1, r7, #1
70024e42:	d007      	beq.n	70024e54 <_strtoul_r+0x104>
70024e44:	b973      	cbnz	r3, 70024e64 <_strtoul_r+0x114>
70024e46:	b112      	cbz	r2, 70024e4e <_strtoul_r+0xfe>
70024e48:	b957      	cbnz	r7, 70024e60 <_strtoul_r+0x110>
70024e4a:	4654      	mov	r4, sl
70024e4c:	6014      	str	r4, [r2, #0]
70024e4e:	b005      	add	sp, #20
70024e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024e54:	9903      	ldr	r1, [sp, #12]
70024e56:	2322      	movs	r3, #34	; 0x22
70024e58:	4638      	mov	r0, r7
70024e5a:	600b      	str	r3, [r1, #0]
70024e5c:	2a00      	cmp	r2, #0
70024e5e:	d0f6      	beq.n	70024e4e <_strtoul_r+0xfe>
70024e60:	3c01      	subs	r4, #1
70024e62:	e7f3      	b.n	70024e4c <_strtoul_r+0xfc>
70024e64:	4240      	negs	r0, r0
70024e66:	e7ee      	b.n	70024e46 <_strtoul_r+0xf6>
70024e68:	1c84      	adds	r4, r0, #2
70024e6a:	7845      	ldrb	r5, [r0, #1]
70024e6c:	2301      	movs	r3, #1
70024e6e:	e791      	b.n	70024d94 <_strtoul_r+0x44>
70024e70:	f04f 0b10 	mov.w	fp, #16
70024e74:	7865      	ldrb	r5, [r4, #1]
70024e76:	46dc      	mov	ip, fp
70024e78:	3402      	adds	r4, #2
70024e7a:	210f      	movs	r1, #15
70024e7c:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
70024e80:	e7b2      	b.n	70024de8 <_strtoul_r+0x98>
70024e82:	f04f 0b08 	mov.w	fp, #8
70024e86:	2107      	movs	r1, #7
70024e88:	46dc      	mov	ip, fp
70024e8a:	f06f 4960 	mvn.w	r9, #3758096384	; 0xe0000000
70024e8e:	e7ab      	b.n	70024de8 <_strtoul_r+0x98>

70024e90 <strtoul>:
70024e90:	b430      	push	{r4, r5}
70024e92:	f249 44d0 	movw	r4, #38096	; 0x94d0
70024e96:	f2c7 0402 	movt	r4, #28674	; 0x7002
70024e9a:	460d      	mov	r5, r1
70024e9c:	4613      	mov	r3, r2
70024e9e:	4601      	mov	r1, r0
70024ea0:	462a      	mov	r2, r5
70024ea2:	6820      	ldr	r0, [r4, #0]
70024ea4:	bc30      	pop	{r4, r5}
70024ea6:	f7ff bf53 	b.w	70024d50 <_strtoul_r>
70024eaa:	bf00      	nop

70024eac <_sungetc_r>:
70024eac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70024eae:	1c4b      	adds	r3, r1, #1
70024eb0:	4614      	mov	r4, r2
70024eb2:	d019      	beq.n	70024ee8 <_sungetc_r+0x3c>
70024eb4:	8992      	ldrh	r2, [r2, #12]
70024eb6:	b2cd      	uxtb	r5, r1
70024eb8:	6b23      	ldr	r3, [r4, #48]	; 0x30
70024eba:	f022 0220 	bic.w	r2, r2, #32
70024ebe:	81a2      	strh	r2, [r4, #12]
70024ec0:	b1ab      	cbz	r3, 70024eee <_sungetc_r+0x42>
70024ec2:	6862      	ldr	r2, [r4, #4]
70024ec4:	6b63      	ldr	r3, [r4, #52]	; 0x34
70024ec6:	429a      	cmp	r2, r3
70024ec8:	da09      	bge.n	70024ede <_sungetc_r+0x32>
70024eca:	6823      	ldr	r3, [r4, #0]
70024ecc:	4628      	mov	r0, r5
70024ece:	1e5a      	subs	r2, r3, #1
70024ed0:	6022      	str	r2, [r4, #0]
70024ed2:	f803 5c01 	strb.w	r5, [r3, #-1]
70024ed6:	6863      	ldr	r3, [r4, #4]
70024ed8:	3301      	adds	r3, #1
70024eda:	6063      	str	r3, [r4, #4]
70024edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
70024ede:	4621      	mov	r1, r4
70024ee0:	f000 fd70 	bl	700259c4 <__submore>
70024ee4:	2800      	cmp	r0, #0
70024ee6:	d0f0      	beq.n	70024eca <_sungetc_r+0x1e>
70024ee8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70024eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
70024eee:	6923      	ldr	r3, [r4, #16]
70024ef0:	6822      	ldr	r2, [r4, #0]
70024ef2:	b12b      	cbz	r3, 70024f00 <_sungetc_r+0x54>
70024ef4:	4293      	cmp	r3, r2
70024ef6:	d203      	bcs.n	70024f00 <_sungetc_r+0x54>
70024ef8:	f812 0c01 	ldrb.w	r0, [r2, #-1]
70024efc:	42a8      	cmp	r0, r5
70024efe:	d00f      	beq.n	70024f20 <_sungetc_r+0x74>
70024f00:	6861      	ldr	r1, [r4, #4]
70024f02:	4623      	mov	r3, r4
70024f04:	63a2      	str	r2, [r4, #56]	; 0x38
70024f06:	f104 0740 	add.w	r7, r4, #64	; 0x40
70024f0a:	2603      	movs	r6, #3
70024f0c:	2201      	movs	r2, #1
70024f0e:	63e1      	str	r1, [r4, #60]	; 0x3c
70024f10:	4628      	mov	r0, r5
70024f12:	6327      	str	r7, [r4, #48]	; 0x30
70024f14:	6366      	str	r6, [r4, #52]	; 0x34
70024f16:	f803 5f42 	strb.w	r5, [r3, #66]!
70024f1a:	6062      	str	r2, [r4, #4]
70024f1c:	6023      	str	r3, [r4, #0]
70024f1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
70024f20:	6863      	ldr	r3, [r4, #4]
70024f22:	3a01      	subs	r2, #1
70024f24:	6022      	str	r2, [r4, #0]
70024f26:	3301      	adds	r3, #1
70024f28:	6063      	str	r3, [r4, #4]
70024f2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

70024f2c <__ssrefill_r>:
70024f2c:	b510      	push	{r4, lr}
70024f2e:	460c      	mov	r4, r1
70024f30:	6b09      	ldr	r1, [r1, #48]	; 0x30
70024f32:	b169      	cbz	r1, 70024f50 <__ssrefill_r+0x24>
70024f34:	f104 0340 	add.w	r3, r4, #64	; 0x40
70024f38:	4299      	cmp	r1, r3
70024f3a:	d001      	beq.n	70024f40 <__ssrefill_r+0x14>
70024f3c:	f7f9 ee60 	blx	7001ec00 <_free_r>
70024f40:	6be3      	ldr	r3, [r4, #60]	; 0x3c
70024f42:	2000      	movs	r0, #0
70024f44:	6320      	str	r0, [r4, #48]	; 0x30
70024f46:	6063      	str	r3, [r4, #4]
70024f48:	b113      	cbz	r3, 70024f50 <__ssrefill_r+0x24>
70024f4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
70024f4c:	6023      	str	r3, [r4, #0]
70024f4e:	bd10      	pop	{r4, pc}
70024f50:	6923      	ldr	r3, [r4, #16]
70024f52:	2100      	movs	r1, #0
70024f54:	89a2      	ldrh	r2, [r4, #12]
70024f56:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70024f5a:	6061      	str	r1, [r4, #4]
70024f5c:	f042 0220 	orr.w	r2, r2, #32
70024f60:	6023      	str	r3, [r4, #0]
70024f62:	81a2      	strh	r2, [r4, #12]
70024f64:	bd10      	pop	{r4, pc}
70024f66:	bf00      	nop

70024f68 <_sfread_r>:
70024f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024f6c:	b083      	sub	sp, #12
70024f6e:	fb02 f903 	mul.w	r9, r2, r3
70024f72:	9201      	str	r2, [sp, #4]
70024f74:	469a      	mov	sl, r3
70024f76:	4607      	mov	r7, r0
70024f78:	468b      	mov	fp, r1
70024f7a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
70024f7c:	f04f 0800 	mov.w	r8, #0
70024f80:	464e      	mov	r6, r9
70024f82:	f1b9 0f00 	cmp.w	r9, #0
70024f86:	d10e      	bne.n	70024fa6 <_sfread_r+0x3e>
70024f88:	e020      	b.n	70024fcc <_sfread_r+0x64>
70024f8a:	f7fe ff8d 	bl	70023ea8 <memcpy>
70024f8e:	6822      	ldr	r2, [r4, #0]
70024f90:	f8c4 8004 	str.w	r8, [r4, #4]
70024f94:	4638      	mov	r0, r7
70024f96:	442a      	add	r2, r5
70024f98:	4621      	mov	r1, r4
70024f9a:	6022      	str	r2, [r4, #0]
70024f9c:	44ab      	add	fp, r5
70024f9e:	1b76      	subs	r6, r6, r5
70024fa0:	f7ff ffc4 	bl	70024f2c <__ssrefill_r>
70024fa4:	b9b0      	cbnz	r0, 70024fd4 <_sfread_r+0x6c>
70024fa6:	e894 0022 	ldmia.w	r4, {r1, r5}
70024faa:	4658      	mov	r0, fp
70024fac:	42ae      	cmp	r6, r5
70024fae:	462a      	mov	r2, r5
70024fb0:	d8eb      	bhi.n	70024f8a <_sfread_r+0x22>
70024fb2:	4632      	mov	r2, r6
70024fb4:	f7fe ff78 	bl	70023ea8 <memcpy>
70024fb8:	6862      	ldr	r2, [r4, #4]
70024fba:	6823      	ldr	r3, [r4, #0]
70024fbc:	4650      	mov	r0, sl
70024fbe:	1b92      	subs	r2, r2, r6
70024fc0:	6062      	str	r2, [r4, #4]
70024fc2:	4433      	add	r3, r6
70024fc4:	6023      	str	r3, [r4, #0]
70024fc6:	b003      	add	sp, #12
70024fc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024fcc:	4648      	mov	r0, r9
70024fce:	b003      	add	sp, #12
70024fd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70024fd4:	ebc6 0009 	rsb	r0, r6, r9
70024fd8:	9901      	ldr	r1, [sp, #4]
70024fda:	f7fe f831 	bl	70023040 <__aeabi_uidiv>
70024fde:	b003      	add	sp, #12
70024fe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

70024fe4 <__ssvfiscanf_r>:
70024fe4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70024fe8:	460c      	mov	r4, r1
70024fea:	8989      	ldrh	r1, [r1, #12]
70024fec:	b0dd      	sub	sp, #372	; 0x174
70024fee:	4690      	mov	r8, r2
70024ff0:	2600      	movs	r6, #0
70024ff2:	048f      	lsls	r7, r1, #18
70024ff4:	9306      	str	r3, [sp, #24]
70024ff6:	bf5e      	ittt	pl
70024ff8:	f441 5100 	orrpl.w	r1, r1, #8192	; 0x2000
70024ffc:	81a1      	strhpl	r1, [r4, #12]
70024ffe:	6e63      	ldrpl	r3, [r4, #100]	; 0x64
70025000:	f249 47dc 	movw	r7, #38108	; 0x94dc
70025004:	9604      	str	r6, [sp, #16]
70025006:	4635      	mov	r5, r6
70025008:	bf58      	it	pl
7002500a:	f423 5300 	bicpl.w	r3, r3, #8192	; 0x2000
7002500e:	9608      	str	r6, [sp, #32]
70025010:	bf58      	it	pl
70025012:	6663      	strpl	r3, [r4, #100]	; 0x64
70025014:	4683      	mov	fp, r0
70025016:	f818 3b01 	ldrb.w	r3, [r8], #1
7002501a:	f2c7 0702 	movt	r7, #28674	; 0x7002
7002501e:	9609      	str	r6, [sp, #36]	; 0x24
70025020:	f648 5650 	movw	r6, #36176	; 0x8d50
70025024:	f2c7 0602 	movt	r6, #28674	; 0x7002
70025028:	960a      	str	r6, [sp, #40]	; 0x28
7002502a:	930f      	str	r3, [sp, #60]	; 0x3c
7002502c:	f644 5651 	movw	r6, #19793	; 0x4d51
70025030:	f2c7 0602 	movt	r6, #28674	; 0x7002
70025034:	960b      	str	r6, [sp, #44]	; 0x2c
70025036:	b32b      	cbz	r3, 70025084 <__ssvfiscanf_r+0xa0>
70025038:	6839      	ldr	r1, [r7, #0]
7002503a:	18c8      	adds	r0, r1, r3
7002503c:	7840      	ldrb	r0, [r0, #1]
7002503e:	f000 0008 	and.w	r0, r0, #8
70025042:	f000 09ff 	and.w	r9, r0, #255	; 0xff
70025046:	b308      	cbz	r0, 7002508c <__ssvfiscanf_r+0xa8>
70025048:	6863      	ldr	r3, [r4, #4]
7002504a:	e00c      	b.n	70025066 <__ssvfiscanf_r+0x82>
7002504c:	6823      	ldr	r3, [r4, #0]
7002504e:	683a      	ldr	r2, [r7, #0]
70025050:	1c59      	adds	r1, r3, #1
70025052:	781b      	ldrb	r3, [r3, #0]
70025054:	441a      	add	r2, r3
70025056:	7853      	ldrb	r3, [r2, #1]
70025058:	071e      	lsls	r6, r3, #28
7002505a:	d50c      	bpl.n	70025076 <__ssvfiscanf_r+0x92>
7002505c:	6863      	ldr	r3, [r4, #4]
7002505e:	3501      	adds	r5, #1
70025060:	6021      	str	r1, [r4, #0]
70025062:	3b01      	subs	r3, #1
70025064:	6063      	str	r3, [r4, #4]
70025066:	2b00      	cmp	r3, #0
70025068:	dcf0      	bgt.n	7002504c <__ssvfiscanf_r+0x68>
7002506a:	4658      	mov	r0, fp
7002506c:	4621      	mov	r1, r4
7002506e:	f7ff ff5d 	bl	70024f2c <__ssrefill_r>
70025072:	2800      	cmp	r0, #0
70025074:	d0ea      	beq.n	7002504c <__ssvfiscanf_r+0x68>
70025076:	4642      	mov	r2, r8
70025078:	4690      	mov	r8, r2
7002507a:	f818 3b01 	ldrb.w	r3, [r8], #1
7002507e:	930f      	str	r3, [sp, #60]	; 0x3c
70025080:	2b00      	cmp	r3, #0
70025082:	d1d9      	bne.n	70025038 <__ssvfiscanf_r+0x54>
70025084:	9809      	ldr	r0, [sp, #36]	; 0x24
70025086:	b05d      	add	sp, #372	; 0x174
70025088:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
7002508c:	2b25      	cmp	r3, #37	; 0x25
7002508e:	f040 80dc 	bne.w	7002524a <__ssvfiscanf_r+0x266>
70025092:	7853      	ldrb	r3, [r2, #1]
70025094:	464e      	mov	r6, r9
70025096:	f108 0201 	add.w	r2, r8, #1
7002509a:	2b78      	cmp	r3, #120	; 0x78
7002509c:	f200 8238 	bhi.w	70025510 <__ssvfiscanf_r+0x52c>
700250a0:	e8df f013 	tbh	[pc, r3, lsl #1]
700250a4:	023600cc 	.word	0x023600cc
700250a8:	02360236 	.word	0x02360236
700250ac:	02360236 	.word	0x02360236
700250b0:	02360236 	.word	0x02360236
700250b4:	02360236 	.word	0x02360236
700250b8:	02360236 	.word	0x02360236
700250bc:	02360236 	.word	0x02360236
700250c0:	02360236 	.word	0x02360236
700250c4:	02360236 	.word	0x02360236
700250c8:	02360236 	.word	0x02360236
700250cc:	02360236 	.word	0x02360236
700250d0:	02360236 	.word	0x02360236
700250d4:	02360236 	.word	0x02360236
700250d8:	02360236 	.word	0x02360236
700250dc:	02360236 	.word	0x02360236
700250e0:	02360236 	.word	0x02360236
700250e4:	02360236 	.word	0x02360236
700250e8:	02360236 	.word	0x02360236
700250ec:	00d10236 	.word	0x00d10236
700250f0:	02360236 	.word	0x02360236
700250f4:	02360236 	.word	0x02360236
700250f8:	023601d4 	.word	0x023601d4
700250fc:	02360236 	.word	0x02360236
70025100:	02360236 	.word	0x02360236
70025104:	01cb01cb 	.word	0x01cb01cb
70025108:	01cb01cb 	.word	0x01cb01cb
7002510c:	01cb01cb 	.word	0x01cb01cb
70025110:	01cb01cb 	.word	0x01cb01cb
70025114:	01cb01cb 	.word	0x01cb01cb
70025118:	02360236 	.word	0x02360236
7002511c:	02360236 	.word	0x02360236
70025120:	02360236 	.word	0x02360236
70025124:	02360236 	.word	0x02360236
70025128:	02360236 	.word	0x02360236
7002512c:	023601c7 	.word	0x023601c7
70025130:	02360236 	.word	0x02360236
70025134:	02360236 	.word	0x02360236
70025138:	02360236 	.word	0x02360236
7002513c:	023601c1 	.word	0x023601c1
70025140:	01bd0236 	.word	0x01bd0236
70025144:	02360236 	.word	0x02360236
70025148:	02360236 	.word	0x02360236
7002514c:	02360236 	.word	0x02360236
70025150:	02360236 	.word	0x02360236
70025154:	023601b0 	.word	0x023601b0
70025158:	01a50236 	.word	0x01a50236
7002515c:	02360236 	.word	0x02360236
70025160:	02360236 	.word	0x02360236
70025164:	02360236 	.word	0x02360236
70025168:	019f0236 	.word	0x019f0236
7002516c:	02360194 	.word	0x02360194
70025170:	02360236 	.word	0x02360236
70025174:	0183018e 	.word	0x0183018e
70025178:	02360236 	.word	0x02360236
7002517c:	02360174 	.word	0x02360174
70025180:	014b0156 	.word	0x014b0156
70025184:	02360167 	.word	0x02360167
70025188:	013e0236 	.word	0x013e0236
7002518c:	00e60236 	.word	0x00e60236
70025190:	02360236 	.word	0x02360236
70025194:	01b0      	.short	0x01b0
70025196:	2208      	movs	r2, #8
70025198:	2100      	movs	r1, #0
7002519a:	a810      	add	r0, sp, #64	; 0x40
7002519c:	f7fe fed8 	bl	70023f50 <memset>
700251a0:	f019 0110 	ands.w	r1, r9, #16
700251a4:	bf18      	it	ne
700251a6:	f10d 0a3c 	addne.w	sl, sp, #60	; 0x3c
700251aa:	f04f 0900 	mov.w	r9, #0
700251ae:	bf08      	it	eq
700251b0:	9a06      	ldreq	r2, [sp, #24]
700251b2:	9107      	str	r1, [sp, #28]
700251b4:	bf02      	ittt	eq
700251b6:	f8d2 a000 	ldreq.w	sl, [r2]
700251ba:	3204      	addeq	r2, #4
700251bc:	9206      	streq	r2, [sp, #24]
700251be:	6822      	ldr	r2, [r4, #0]
700251c0:	683b      	ldr	r3, [r7, #0]
700251c2:	7812      	ldrb	r2, [r2, #0]
700251c4:	4413      	add	r3, r2
700251c6:	785b      	ldrb	r3, [r3, #1]
700251c8:	0719      	lsls	r1, r3, #28
700251ca:	f100 8354 	bmi.w	70025876 <__ssvfiscanf_r+0x892>
700251ce:	2e00      	cmp	r6, #0
700251d0:	f000 8351 	beq.w	70025876 <__ssvfiscanf_r+0x892>
700251d4:	f000 fc4a 	bl	70025a6c <__locale_mb_cur_max>
700251d8:	4548      	cmp	r0, r9
700251da:	d029      	beq.n	70025230 <__ssvfiscanf_r+0x24c>
700251dc:	6822      	ldr	r2, [r4, #0]
700251de:	a910      	add	r1, sp, #64	; 0x40
700251e0:	6863      	ldr	r3, [r4, #4]
700251e2:	f109 0801 	add.w	r8, r9, #1
700251e6:	4658      	mov	r0, fp
700251e8:	f812 eb01 	ldrb.w	lr, [r2], #1
700251ec:	3b01      	subs	r3, #1
700251ee:	9100      	str	r1, [sp, #0]
700251f0:	4651      	mov	r1, sl
700251f2:	6063      	str	r3, [r4, #4]
700251f4:	4643      	mov	r3, r8
700251f6:	6022      	str	r2, [r4, #0]
700251f8:	aa12      	add	r2, sp, #72	; 0x48
700251fa:	f802 e009 	strb.w	lr, [r2, r9]
700251fe:	f000 fc3b 	bl	70025a78 <_mbrtowc_r>
70025202:	1c43      	adds	r3, r0, #1
70025204:	d014      	beq.n	70025230 <__ssvfiscanf_r+0x24c>
70025206:	2800      	cmp	r0, #0
70025208:	f000 831e 	beq.w	70025848 <__ssvfiscanf_r+0x864>
7002520c:	3002      	adds	r0, #2
7002520e:	bf08      	it	eq
70025210:	46c1      	moveq	r9, r8
70025212:	f040 83d0 	bne.w	700259b6 <__ssvfiscanf_r+0x9d2>
70025216:	6863      	ldr	r3, [r4, #4]
70025218:	2b00      	cmp	r3, #0
7002521a:	dcd0      	bgt.n	700251be <__ssvfiscanf_r+0x1da>
7002521c:	4658      	mov	r0, fp
7002521e:	4621      	mov	r1, r4
70025220:	f7ff fe84 	bl	70024f2c <__ssrefill_r>
70025224:	2800      	cmp	r0, #0
70025226:	d0ca      	beq.n	700251be <__ssvfiscanf_r+0x1da>
70025228:	f1b9 0f00 	cmp.w	r9, #0
7002522c:	f000 8323 	beq.w	70025876 <__ssvfiscanf_r+0x892>
70025230:	9f09      	ldr	r7, [sp, #36]	; 0x24
70025232:	b11f      	cbz	r7, 7002523c <__ssvfiscanf_r+0x258>
70025234:	89a3      	ldrh	r3, [r4, #12]
70025236:	065a      	lsls	r2, r3, #25
70025238:	f57f af24 	bpl.w	70025084 <__ssvfiscanf_r+0xa0>
7002523c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025240:	b05d      	add	sp, #372	; 0x174
70025242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70025246:	4690      	mov	r8, r2
70025248:	9205      	str	r2, [sp, #20]
7002524a:	6863      	ldr	r3, [r4, #4]
7002524c:	2b00      	cmp	r3, #0
7002524e:	f340 8347 	ble.w	700258e0 <__ssvfiscanf_r+0x8fc>
70025252:	6823      	ldr	r3, [r4, #0]
70025254:	f818 2c01 	ldrb.w	r2, [r8, #-1]
70025258:	7819      	ldrb	r1, [r3, #0]
7002525a:	4291      	cmp	r1, r2
7002525c:	f47f af12 	bne.w	70025084 <__ssvfiscanf_r+0xa0>
70025260:	6862      	ldr	r2, [r4, #4]
70025262:	3301      	adds	r3, #1
70025264:	3501      	adds	r5, #1
70025266:	6023      	str	r3, [r4, #0]
70025268:	3a01      	subs	r2, #1
7002526a:	6062      	str	r2, [r4, #4]
7002526c:	4642      	mov	r2, r8
7002526e:	e703      	b.n	70025078 <__ssvfiscanf_r+0x94>
70025270:	f04f 0803 	mov.w	r8, #3
70025274:	9205      	str	r2, [sp, #20]
70025276:	f644 5151 	movw	r1, #19793	; 0x4d51
7002527a:	220a      	movs	r2, #10
7002527c:	f2c7 0102 	movt	r1, #28674	; 0x7002
70025280:	9208      	str	r2, [sp, #32]
70025282:	9104      	str	r1, [sp, #16]
70025284:	6863      	ldr	r3, [r4, #4]
70025286:	2b00      	cmp	r3, #0
70025288:	dd50      	ble.n	7002532c <__ssvfiscanf_r+0x348>
7002528a:	f019 0f40 	tst.w	r9, #64	; 0x40
7002528e:	d036      	beq.n	700252fe <__ssvfiscanf_r+0x31a>
70025290:	f1b8 0f02 	cmp.w	r8, #2
70025294:	f000 8234 	beq.w	70025700 <__ssvfiscanf_r+0x71c>
70025298:	f1b8 0f03 	cmp.w	r8, #3
7002529c:	f000 817c 	beq.w	70025598 <__ssvfiscanf_r+0x5b4>
700252a0:	f1b8 0f01 	cmp.w	r8, #1
700252a4:	f000 8146 	beq.w	70025534 <__ssvfiscanf_r+0x550>
700252a8:	2e00      	cmp	r6, #0
700252aa:	bf08      	it	eq
700252ac:	2601      	moveq	r6, #1
700252ae:	f019 0801 	ands.w	r8, r9, #1
700252b2:	f040 80d1 	bne.w	70025458 <__ssvfiscanf_r+0x474>
700252b6:	f019 0f10 	tst.w	r9, #16
700252ba:	d10a      	bne.n	700252d2 <__ssvfiscanf_r+0x2ee>
700252bc:	e2f7      	b.n	700258ae <__ssvfiscanf_r+0x8ca>
700252be:	6822      	ldr	r2, [r4, #0]
700252c0:	4498      	add	r8, r3
700252c2:	1af6      	subs	r6, r6, r3
700252c4:	4413      	add	r3, r2
700252c6:	6023      	str	r3, [r4, #0]
700252c8:	f7ff fe30 	bl	70024f2c <__ssrefill_r>
700252cc:	2800      	cmp	r0, #0
700252ce:	f040 82e9 	bne.w	700258a4 <__ssvfiscanf_r+0x8c0>
700252d2:	6863      	ldr	r3, [r4, #4]
700252d4:	4658      	mov	r0, fp
700252d6:	4621      	mov	r1, r4
700252d8:	42b3      	cmp	r3, r6
700252da:	dbf0      	blt.n	700252be <__ssvfiscanf_r+0x2da>
700252dc:	6822      	ldr	r2, [r4, #0]
700252de:	44b0      	add	r8, r6
700252e0:	1b9b      	subs	r3, r3, r6
700252e2:	6063      	str	r3, [r4, #4]
700252e4:	4432      	add	r2, r6
700252e6:	6022      	str	r2, [r4, #0]
700252e8:	4445      	add	r5, r8
700252ea:	f8dd 8014 	ldr.w	r8, [sp, #20]
700252ee:	4642      	mov	r2, r8
700252f0:	e6c2      	b.n	70025078 <__ssvfiscanf_r+0x94>
700252f2:	4658      	mov	r0, fp
700252f4:	4621      	mov	r1, r4
700252f6:	f7ff fe19 	bl	70024f2c <__ssrefill_r>
700252fa:	2800      	cmp	r0, #0
700252fc:	d198      	bne.n	70025230 <__ssvfiscanf_r+0x24c>
700252fe:	6839      	ldr	r1, [r7, #0]
70025300:	6823      	ldr	r3, [r4, #0]
70025302:	e000      	b.n	70025306 <__ssvfiscanf_r+0x322>
70025304:	6023      	str	r3, [r4, #0]
70025306:	781a      	ldrb	r2, [r3, #0]
70025308:	3301      	adds	r3, #1
7002530a:	440a      	add	r2, r1
7002530c:	7852      	ldrb	r2, [r2, #1]
7002530e:	0710      	lsls	r0, r2, #28
70025310:	d5be      	bpl.n	70025290 <__ssvfiscanf_r+0x2ac>
70025312:	6862      	ldr	r2, [r4, #4]
70025314:	3501      	adds	r5, #1
70025316:	3a01      	subs	r2, #1
70025318:	6062      	str	r2, [r4, #4]
7002531a:	2a00      	cmp	r2, #0
7002531c:	dcf2      	bgt.n	70025304 <__ssvfiscanf_r+0x320>
7002531e:	e7e8      	b.n	700252f2 <__ssvfiscanf_r+0x30e>
70025320:	6863      	ldr	r3, [r4, #4]
70025322:	f04f 0802 	mov.w	r8, #2
70025326:	9205      	str	r2, [sp, #20]
70025328:	2b00      	cmp	r3, #0
7002532a:	dcae      	bgt.n	7002528a <__ssvfiscanf_r+0x2a6>
7002532c:	4658      	mov	r0, fp
7002532e:	4621      	mov	r1, r4
70025330:	f7ff fdfc 	bl	70024f2c <__ssrefill_r>
70025334:	2800      	cmp	r0, #0
70025336:	d0a8      	beq.n	7002528a <__ssvfiscanf_r+0x2a6>
70025338:	e77a      	b.n	70025230 <__ssvfiscanf_r+0x24c>
7002533a:	9205      	str	r2, [sp, #20]
7002533c:	f644 5351 	movw	r3, #19793	; 0x4d51
70025340:	2008      	movs	r0, #8
70025342:	f2c7 0302 	movt	r3, #28674	; 0x7002
70025346:	9008      	str	r0, [sp, #32]
70025348:	9304      	str	r3, [sp, #16]
7002534a:	f04f 0803 	mov.w	r8, #3
7002534e:	e799      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
70025350:	f019 0f10 	tst.w	r9, #16
70025354:	9205      	str	r2, [sp, #20]
70025356:	f040 80d7 	bne.w	70025508 <__ssvfiscanf_r+0x524>
7002535a:	f019 0f04 	tst.w	r9, #4
7002535e:	f000 82dc 	beq.w	7002591a <__ssvfiscanf_r+0x936>
70025362:	9e06      	ldr	r6, [sp, #24]
70025364:	4690      	mov	r8, r2
70025366:	3604      	adds	r6, #4
70025368:	f856 3c04 	ldr.w	r3, [r6, #-4]
7002536c:	9606      	str	r6, [sp, #24]
7002536e:	801d      	strh	r5, [r3, #0]
70025370:	e681      	b.n	70025076 <__ssvfiscanf_r+0x92>
70025372:	9205      	str	r2, [sp, #20]
70025374:	f644 5151 	movw	r1, #19793	; 0x4d51
70025378:	2210      	movs	r2, #16
7002537a:	f2c7 0102 	movt	r1, #28674	; 0x7002
7002537e:	f449 7908 	orr.w	r9, r9, #544	; 0x220
70025382:	9208      	str	r2, [sp, #32]
70025384:	9104      	str	r1, [sp, #16]
70025386:	f04f 0803 	mov.w	r8, #3
7002538a:	e77b      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
7002538c:	f898 3001 	ldrb.w	r3, [r8, #1]
70025390:	2b6c      	cmp	r3, #108	; 0x6c
70025392:	bf0b      	itete	eq
70025394:	f049 0902 	orreq.w	r9, r9, #2
70025398:	f049 0901 	orrne.w	r9, r9, #1
7002539c:	f898 3002 	ldrbeq.w	r3, [r8, #2]
700253a0:	4690      	movne	r8, r2
700253a2:	bf08      	it	eq
700253a4:	f108 0802 	addeq.w	r8, r8, #2
700253a8:	e675      	b.n	70025096 <__ssvfiscanf_r+0xb2>
700253aa:	9205      	str	r2, [sp, #20]
700253ac:	2300      	movs	r3, #0
700253ae:	f244 42b5 	movw	r2, #17589	; 0x44b5
700253b2:	9308      	str	r3, [sp, #32]
700253b4:	f2c7 0202 	movt	r2, #28674	; 0x7002
700253b8:	f04f 0803 	mov.w	r8, #3
700253bc:	9204      	str	r2, [sp, #16]
700253be:	e761      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
700253c0:	f898 3001 	ldrb.w	r3, [r8, #1]
700253c4:	f049 0904 	orr.w	r9, r9, #4
700253c8:	4690      	mov	r8, r2
700253ca:	e664      	b.n	70025096 <__ssvfiscanf_r+0xb2>
700253cc:	9205      	str	r2, [sp, #20]
700253ce:	f244 41b5 	movw	r1, #17589	; 0x44b5
700253d2:	220a      	movs	r2, #10
700253d4:	f2c7 0102 	movt	r1, #28674	; 0x7002
700253d8:	9208      	str	r2, [sp, #32]
700253da:	9104      	str	r1, [sp, #16]
700253dc:	f04f 0803 	mov.w	r8, #3
700253e0:	e750      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
700253e2:	9205      	str	r2, [sp, #20]
700253e4:	f049 0940 	orr.w	r9, r9, #64	; 0x40
700253e8:	f04f 0800 	mov.w	r8, #0
700253ec:	e74a      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
700253ee:	4611      	mov	r1, r2
700253f0:	a81c      	add	r0, sp, #112	; 0x70
700253f2:	9205      	str	r2, [sp, #20]
700253f4:	f000 fb88 	bl	70025b08 <__sccl>
700253f8:	f049 0940 	orr.w	r9, r9, #64	; 0x40
700253fc:	f04f 0801 	mov.w	r8, #1
70025400:	9005      	str	r0, [sp, #20]
70025402:	e73f      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
70025404:	f644 5351 	movw	r3, #19793	; 0x4d51
70025408:	2010      	movs	r0, #16
7002540a:	f2c7 0302 	movt	r3, #28674	; 0x7002
7002540e:	9205      	str	r2, [sp, #20]
70025410:	f449 7900 	orr.w	r9, r9, #512	; 0x200
70025414:	9008      	str	r0, [sp, #32]
70025416:	9304      	str	r3, [sp, #16]
70025418:	f04f 0803 	mov.w	r8, #3
7002541c:	e732      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
7002541e:	9205      	str	r2, [sp, #20]
70025420:	f049 0901 	orr.w	r9, r9, #1
70025424:	e78a      	b.n	7002533c <__ssvfiscanf_r+0x358>
70025426:	f898 3001 	ldrb.w	r3, [r8, #1]
7002542a:	f049 0902 	orr.w	r9, r9, #2
7002542e:	4690      	mov	r8, r2
70025430:	e631      	b.n	70025096 <__ssvfiscanf_r+0xb2>
70025432:	9205      	str	r2, [sp, #20]
70025434:	f049 0901 	orr.w	r9, r9, #1
70025438:	e7c9      	b.n	700253ce <__ssvfiscanf_r+0x3ea>
7002543a:	eb06 0686 	add.w	r6, r6, r6, lsl #2
7002543e:	eb03 0646 	add.w	r6, r3, r6, lsl #1
70025442:	f898 3001 	ldrb.w	r3, [r8, #1]
70025446:	3e30      	subs	r6, #48	; 0x30
70025448:	4690      	mov	r8, r2
7002544a:	e624      	b.n	70025096 <__ssvfiscanf_r+0xb2>
7002544c:	f898 3001 	ldrb.w	r3, [r8, #1]
70025450:	f049 0910 	orr.w	r9, r9, #16
70025454:	4690      	mov	r8, r2
70025456:	e61e      	b.n	70025096 <__ssvfiscanf_r+0xb2>
70025458:	2208      	movs	r2, #8
7002545a:	a810      	add	r0, sp, #64	; 0x40
7002545c:	2100      	movs	r1, #0
7002545e:	f04f 0800 	mov.w	r8, #0
70025462:	f7fe fd75 	bl	70023f50 <memset>
70025466:	f019 0210 	ands.w	r2, r9, #16
7002546a:	920c      	str	r2, [sp, #48]	; 0x30
7002546c:	f10d 0948 	add.w	r9, sp, #72	; 0x48
70025470:	bf0c      	ite	eq
70025472:	9b06      	ldreq	r3, [sp, #24]
70025474:	f04f 0a00 	movne.w	sl, #0
70025478:	970d      	str	r7, [sp, #52]	; 0x34
7002547a:	462f      	mov	r7, r5
7002547c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
7002547e:	f8cd b01c 	str.w	fp, [sp, #28]
70025482:	bf02      	ittt	eq
70025484:	f8d3 a000 	ldreq.w	sl, [r3]
70025488:	3304      	addeq	r3, #4
7002548a:	9306      	streq	r3, [sp, #24]
7002548c:	f000 faee 	bl	70025a6c <__locale_mb_cur_max>
70025490:	4540      	cmp	r0, r8
70025492:	f43f aecd 	beq.w	70025230 <__ssvfiscanf_r+0x24c>
70025496:	6821      	ldr	r1, [r4, #0]
70025498:	f108 0b01 	add.w	fp, r8, #1
7002549c:	6863      	ldr	r3, [r4, #4]
7002549e:	aa10      	add	r2, sp, #64	; 0x40
700254a0:	9807      	ldr	r0, [sp, #28]
700254a2:	f811 eb01 	ldrb.w	lr, [r1], #1
700254a6:	3b01      	subs	r3, #1
700254a8:	9200      	str	r2, [sp, #0]
700254aa:	464a      	mov	r2, r9
700254ac:	6063      	str	r3, [r4, #4]
700254ae:	465b      	mov	r3, fp
700254b0:	6021      	str	r1, [r4, #0]
700254b2:	4651      	mov	r1, sl
700254b4:	f809 e008 	strb.w	lr, [r9, r8]
700254b8:	f000 fade 	bl	70025a78 <_mbrtowc_r>
700254bc:	1c42      	adds	r2, r0, #1
700254be:	f43f aeb7 	beq.w	70025230 <__ssvfiscanf_r+0x24c>
700254c2:	2800      	cmp	r0, #0
700254c4:	f040 81ba 	bne.w	7002583c <__ssvfiscanf_r+0x858>
700254c8:	b90d      	cbnz	r5, 700254ce <__ssvfiscanf_r+0x4ea>
700254ca:	f8ca 5000 	str.w	r5, [sl]
700254ce:	445f      	add	r7, fp
700254d0:	3e01      	subs	r6, #1
700254d2:	f04f 0800 	mov.w	r8, #0
700254d6:	b915      	cbnz	r5, 700254de <__ssvfiscanf_r+0x4fa>
700254d8:	f10a 0a04 	add.w	sl, sl, #4
700254dc:	46a8      	mov	r8, r5
700254de:	6863      	ldr	r3, [r4, #4]
700254e0:	2b00      	cmp	r3, #0
700254e2:	dc06      	bgt.n	700254f2 <__ssvfiscanf_r+0x50e>
700254e4:	9807      	ldr	r0, [sp, #28]
700254e6:	4621      	mov	r1, r4
700254e8:	f7ff fd20 	bl	70024f2c <__ssrefill_r>
700254ec:	2800      	cmp	r0, #0
700254ee:	f040 824b 	bne.w	70025988 <__ssvfiscanf_r+0x9a4>
700254f2:	2e00      	cmp	r6, #0
700254f4:	d1ca      	bne.n	7002548c <__ssvfiscanf_r+0x4a8>
700254f6:	463d      	mov	r5, r7
700254f8:	f8dd b01c 	ldr.w	fp, [sp, #28]
700254fc:	9f0d      	ldr	r7, [sp, #52]	; 0x34
700254fe:	9e0c      	ldr	r6, [sp, #48]	; 0x30
70025500:	b916      	cbnz	r6, 70025508 <__ssvfiscanf_r+0x524>
70025502:	9e09      	ldr	r6, [sp, #36]	; 0x24
70025504:	3601      	adds	r6, #1
70025506:	9609      	str	r6, [sp, #36]	; 0x24
70025508:	f8dd 8014 	ldr.w	r8, [sp, #20]
7002550c:	4642      	mov	r2, r8
7002550e:	e5b3      	b.n	70025078 <__ssvfiscanf_r+0x94>
70025510:	440b      	add	r3, r1
70025512:	9205      	str	r2, [sp, #20]
70025514:	785b      	ldrb	r3, [r3, #1]
70025516:	f003 0303 	and.w	r3, r3, #3
7002551a:	2b01      	cmp	r3, #1
7002551c:	f000 81f1 	beq.w	70025902 <__ssvfiscanf_r+0x91e>
70025520:	f244 40b5 	movw	r0, #17589	; 0x44b5
70025524:	210a      	movs	r1, #10
70025526:	f2c7 0002 	movt	r0, #28674	; 0x7002
7002552a:	9108      	str	r1, [sp, #32]
7002552c:	9004      	str	r0, [sp, #16]
7002552e:	f04f 0803 	mov.w	r8, #3
70025532:	e6a7      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
70025534:	2e00      	cmp	r6, #0
70025536:	bf08      	it	eq
70025538:	f04f 36ff 	moveq.w	r6, #4294967295	; 0xffffffff
7002553c:	f019 0f10 	tst.w	r9, #16
70025540:	f000 8137 	beq.w	700257b2 <__ssvfiscanf_r+0x7ce>
70025544:	6823      	ldr	r3, [r4, #0]
70025546:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
7002554a:	f04f 0800 	mov.w	r8, #0
7002554e:	781a      	ldrb	r2, [r3, #0]
70025550:	3301      	adds	r3, #1
70025552:	f81a 2002 	ldrb.w	r2, [sl, r2]
70025556:	b1d2      	cbz	r2, 7002558e <__ssvfiscanf_r+0x5aa>
70025558:	f108 0801 	add.w	r8, r8, #1
7002555c:	6862      	ldr	r2, [r4, #4]
7002555e:	4546      	cmp	r6, r8
70025560:	6023      	str	r3, [r4, #0]
70025562:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
70025566:	6062      	str	r2, [r4, #4]
70025568:	f43f aebe 	beq.w	700252e8 <__ssvfiscanf_r+0x304>
7002556c:	2a00      	cmp	r2, #0
7002556e:	dcee      	bgt.n	7002554e <__ssvfiscanf_r+0x56a>
70025570:	4658      	mov	r0, fp
70025572:	4621      	mov	r1, r4
70025574:	f7ff fcda 	bl	70024f2c <__ssrefill_r>
70025578:	2800      	cmp	r0, #0
7002557a:	f47f aeb5 	bne.w	700252e8 <__ssvfiscanf_r+0x304>
7002557e:	6823      	ldr	r3, [r4, #0]
70025580:	3301      	adds	r3, #1
70025582:	f813 2c01 	ldrb.w	r2, [r3, #-1]
70025586:	f81a 2002 	ldrb.w	r2, [sl, r2]
7002558a:	2a00      	cmp	r2, #0
7002558c:	d1e4      	bne.n	70025558 <__ssvfiscanf_r+0x574>
7002558e:	f1b8 0f00 	cmp.w	r8, #0
70025592:	f47f aea9 	bne.w	700252e8 <__ssvfiscanf_r+0x304>
70025596:	e575      	b.n	70025084 <__ssvfiscanf_r+0xa0>
70025598:	1e73      	subs	r3, r6, #1
7002559a:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
7002559e:	2b26      	cmp	r3, #38	; 0x26
700255a0:	f449 6958 	orr.w	r9, r9, #3456	; 0xd80
700255a4:	bf88      	it	hi
700255a6:	f1a6 0327 	subhi.w	r3, r6, #39	; 0x27
700255aa:	46d0      	mov	r8, sl
700255ac:	bf98      	it	ls
700255ae:	2300      	movls	r3, #0
700255b0:	930c      	str	r3, [sp, #48]	; 0x30
700255b2:	462b      	mov	r3, r5
700255b4:	9d08      	ldr	r5, [sp, #32]
700255b6:	bf88      	it	hi
700255b8:	2627      	movhi	r6, #39	; 0x27
700255ba:	46bc      	mov	ip, r7
700255bc:	2000      	movs	r0, #0
700255be:	9007      	str	r0, [sp, #28]
700255c0:	6820      	ldr	r0, [r4, #0]
700255c2:	7801      	ldrb	r1, [r0, #0]
700255c4:	f1a1 022b 	sub.w	r2, r1, #43	; 0x2b
700255c8:	2a4d      	cmp	r2, #77	; 0x4d
700255ca:	d83f      	bhi.n	7002564c <__ssvfiscanf_r+0x668>
700255cc:	e8df f002 	tbb	[pc, r2]
700255d0:	3e923e92 	.word	0x3e923e92
700255d4:	6262683e 	.word	0x6262683e
700255d8:	62626262 	.word	0x62626262
700255dc:	3e5c5c62 	.word	0x3e5c5c62
700255e0:	3e3e3e3e 	.word	0x3e3e3e3e
700255e4:	57573e3e 	.word	0x57573e3e
700255e8:	57575757 	.word	0x57575757
700255ec:	3e3e3e3e 	.word	0x3e3e3e3e
700255f0:	3e3e3e3e 	.word	0x3e3e3e3e
700255f4:	3e3e3e3e 	.word	0x3e3e3e3e
700255f8:	3e3e3e3e 	.word	0x3e3e3e3e
700255fc:	3e3e273e 	.word	0x3e3e273e
70025600:	3e3e3e3e 	.word	0x3e3e3e3e
70025604:	57573e3e 	.word	0x57573e3e
70025608:	57575757 	.word	0x57575757
7002560c:	3e3e3e3e 	.word	0x3e3e3e3e
70025610:	3e3e3e3e 	.word	0x3e3e3e3e
70025614:	3e3e3e3e 	.word	0x3e3e3e3e
70025618:	3e3e3e3e 	.word	0x3e3e3e3e
7002561c:	273e      	.short	0x273e
7002561e:	f409 62c0 	and.w	r2, r9, #1536	; 0x600
70025622:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
70025626:	d111      	bne.n	7002564c <__ssvfiscanf_r+0x668>
70025628:	f429 7900 	bic.w	r9, r9, #512	; 0x200
7002562c:	2510      	movs	r5, #16
7002562e:	f449 69a0 	orr.w	r9, r9, #1280	; 0x500
70025632:	6862      	ldr	r2, [r4, #4]
70025634:	f108 0801 	add.w	r8, r8, #1
70025638:	f808 1c01 	strb.w	r1, [r8, #-1]
7002563c:	3a01      	subs	r2, #1
7002563e:	6062      	str	r2, [r4, #4]
70025640:	2a00      	cmp	r2, #0
70025642:	dd4a      	ble.n	700256da <__ssvfiscanf_r+0x6f6>
70025644:	3001      	adds	r0, #1
70025646:	6020      	str	r0, [r4, #0]
70025648:	3e01      	subs	r6, #1
7002564a:	d1b9      	bne.n	700255c0 <__ssvfiscanf_r+0x5dc>
7002564c:	f419 7f80 	tst.w	r9, #256	; 0x100
70025650:	9508      	str	r5, [sp, #32]
70025652:	4667      	mov	r7, ip
70025654:	461d      	mov	r5, r3
70025656:	d005      	beq.n	70025664 <__ssvfiscanf_r+0x680>
70025658:	45d0      	cmp	r8, sl
7002565a:	f200 8149 	bhi.w	700258f0 <__ssvfiscanf_r+0x90c>
7002565e:	45d0      	cmp	r8, sl
70025660:	f43f ad10 	beq.w	70025084 <__ssvfiscanf_r+0xa0>
70025664:	f019 0610 	ands.w	r6, r9, #16
70025668:	f000 80d3 	beq.w	70025812 <__ssvfiscanf_r+0x82e>
7002566c:	ebca 0a08 	rsb	sl, sl, r8
70025670:	9b07      	ldr	r3, [sp, #28]
70025672:	f8dd 8014 	ldr.w	r8, [sp, #20]
70025676:	4453      	add	r3, sl
70025678:	441d      	add	r5, r3
7002567a:	4642      	mov	r2, r8
7002567c:	e4fc      	b.n	70025078 <__ssvfiscanf_r+0x94>
7002567e:	2d0a      	cmp	r5, #10
70025680:	dde4      	ble.n	7002564c <__ssvfiscanf_r+0x668>
70025682:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
70025686:	e7d4      	b.n	70025632 <__ssvfiscanf_r+0x64e>
70025688:	9f0a      	ldr	r7, [sp, #40]	; 0x28
7002568a:	f937 5015 	ldrsh.w	r5, [r7, r5, lsl #1]
7002568e:	2d08      	cmp	r5, #8
70025690:	dcf7      	bgt.n	70025682 <__ssvfiscanf_r+0x69e>
70025692:	e7db      	b.n	7002564c <__ssvfiscanf_r+0x668>
70025694:	9f0a      	ldr	r7, [sp, #40]	; 0x28
70025696:	f429 6938 	bic.w	r9, r9, #2944	; 0xb80
7002569a:	f937 5015 	ldrsh.w	r5, [r7, r5, lsl #1]
7002569e:	e7c8      	b.n	70025632 <__ssvfiscanf_r+0x64e>
700256a0:	f419 6f00 	tst.w	r9, #2048	; 0x800
700256a4:	d0c5      	beq.n	70025632 <__ssvfiscanf_r+0x64e>
700256a6:	b915      	cbnz	r5, 700256ae <__ssvfiscanf_r+0x6ca>
700256a8:	f449 7900 	orr.w	r9, r9, #512	; 0x200
700256ac:	2508      	movs	r5, #8
700256ae:	f419 6f80 	tst.w	r9, #1024	; 0x400
700256b2:	bf18      	it	ne
700256b4:	f429 69b0 	bicne.w	r9, r9, #1408	; 0x580
700256b8:	d1bb      	bne.n	70025632 <__ssvfiscanf_r+0x64e>
700256ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
700256bc:	f429 7960 	bic.w	r9, r9, #896	; 0x380
700256c0:	b112      	cbz	r2, 700256c8 <__ssvfiscanf_r+0x6e4>
700256c2:	3601      	adds	r6, #1
700256c4:	3a01      	subs	r2, #1
700256c6:	920c      	str	r2, [sp, #48]	; 0x30
700256c8:	6862      	ldr	r2, [r4, #4]
700256ca:	9f07      	ldr	r7, [sp, #28]
700256cc:	3a01      	subs	r2, #1
700256ce:	6062      	str	r2, [r4, #4]
700256d0:	2a00      	cmp	r2, #0
700256d2:	f107 0701 	add.w	r7, r7, #1
700256d6:	9707      	str	r7, [sp, #28]
700256d8:	dcb4      	bgt.n	70025644 <__ssvfiscanf_r+0x660>
700256da:	4658      	mov	r0, fp
700256dc:	4621      	mov	r1, r4
700256de:	9303      	str	r3, [sp, #12]
700256e0:	f8cd c008 	str.w	ip, [sp, #8]
700256e4:	f7ff fc22 	bl	70024f2c <__ssrefill_r>
700256e8:	9b03      	ldr	r3, [sp, #12]
700256ea:	f8dd c008 	ldr.w	ip, [sp, #8]
700256ee:	2800      	cmp	r0, #0
700256f0:	d0aa      	beq.n	70025648 <__ssvfiscanf_r+0x664>
700256f2:	e7ab      	b.n	7002564c <__ssvfiscanf_r+0x668>
700256f4:	f019 0f80 	tst.w	r9, #128	; 0x80
700256f8:	d0a8      	beq.n	7002564c <__ssvfiscanf_r+0x668>
700256fa:	f029 0980 	bic.w	r9, r9, #128	; 0x80
700256fe:	e798      	b.n	70025632 <__ssvfiscanf_r+0x64e>
70025700:	2e00      	cmp	r6, #0
70025702:	bf08      	it	eq
70025704:	f04f 36ff 	moveq.w	r6, #4294967295	; 0xffffffff
70025708:	f019 0801 	ands.w	r8, r9, #1
7002570c:	f47f ad43 	bne.w	70025196 <__ssvfiscanf_r+0x1b2>
70025710:	f019 0f10 	tst.w	r9, #16
70025714:	d137      	bne.n	70025786 <__ssvfiscanf_r+0x7a2>
70025716:	9806      	ldr	r0, [sp, #24]
70025718:	f100 0a04 	add.w	sl, r0, #4
7002571c:	f8d0 8000 	ldr.w	r8, [r0]
70025720:	46c1      	mov	r9, r8
70025722:	6823      	ldr	r3, [r4, #0]
70025724:	683a      	ldr	r2, [r7, #0]
70025726:	1c59      	adds	r1, r3, #1
70025728:	7818      	ldrb	r0, [r3, #0]
7002572a:	4402      	add	r2, r0
7002572c:	7852      	ldrb	r2, [r2, #1]
7002572e:	0710      	lsls	r0, r2, #28
70025730:	d412      	bmi.n	70025758 <__ssvfiscanf_r+0x774>
70025732:	6862      	ldr	r2, [r4, #4]
70025734:	3e01      	subs	r6, #1
70025736:	6021      	str	r1, [r4, #0]
70025738:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
7002573c:	6062      	str	r2, [r4, #4]
7002573e:	781b      	ldrb	r3, [r3, #0]
70025740:	f809 3b01 	strb.w	r3, [r9], #1
70025744:	d008      	beq.n	70025758 <__ssvfiscanf_r+0x774>
70025746:	6863      	ldr	r3, [r4, #4]
70025748:	2b00      	cmp	r3, #0
7002574a:	dcea      	bgt.n	70025722 <__ssvfiscanf_r+0x73e>
7002574c:	4658      	mov	r0, fp
7002574e:	4621      	mov	r1, r4
70025750:	f7ff fbec 	bl	70024f2c <__ssrefill_r>
70025754:	2800      	cmp	r0, #0
70025756:	d0e4      	beq.n	70025722 <__ssvfiscanf_r+0x73e>
70025758:	ebc8 0809 	rsb	r8, r8, r9
7002575c:	9e09      	ldr	r6, [sp, #36]	; 0x24
7002575e:	4445      	add	r5, r8
70025760:	f8dd 8014 	ldr.w	r8, [sp, #20]
70025764:	f04f 0100 	mov.w	r1, #0
70025768:	3601      	adds	r6, #1
7002576a:	f889 1000 	strb.w	r1, [r9]
7002576e:	9609      	str	r6, [sp, #36]	; 0x24
70025770:	4642      	mov	r2, r8
70025772:	f8cd a018 	str.w	sl, [sp, #24]
70025776:	e47f      	b.n	70025078 <__ssvfiscanf_r+0x94>
70025778:	4658      	mov	r0, fp
7002577a:	4621      	mov	r1, r4
7002577c:	f7ff fbd6 	bl	70024f2c <__ssrefill_r>
70025780:	2800      	cmp	r0, #0
70025782:	f47f adb1 	bne.w	700252e8 <__ssvfiscanf_r+0x304>
70025786:	6839      	ldr	r1, [r7, #0]
70025788:	6823      	ldr	r3, [r4, #0]
7002578a:	781a      	ldrb	r2, [r3, #0]
7002578c:	3301      	adds	r3, #1
7002578e:	440a      	add	r2, r1
70025790:	7852      	ldrb	r2, [r2, #1]
70025792:	0712      	lsls	r2, r2, #28
70025794:	f53f ada8 	bmi.w	700252e8 <__ssvfiscanf_r+0x304>
70025798:	f108 0801 	add.w	r8, r8, #1
7002579c:	6862      	ldr	r2, [r4, #4]
7002579e:	4546      	cmp	r6, r8
700257a0:	6023      	str	r3, [r4, #0]
700257a2:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
700257a6:	6062      	str	r2, [r4, #4]
700257a8:	f43f ad9e 	beq.w	700252e8 <__ssvfiscanf_r+0x304>
700257ac:	2a00      	cmp	r2, #0
700257ae:	dcec      	bgt.n	7002578a <__ssvfiscanf_r+0x7a6>
700257b0:	e7e2      	b.n	70025778 <__ssvfiscanf_r+0x794>
700257b2:	9906      	ldr	r1, [sp, #24]
700257b4:	f10d 0a70 	add.w	sl, sp, #112	; 0x70
700257b8:	1d0a      	adds	r2, r1, #4
700257ba:	9206      	str	r2, [sp, #24]
700257bc:	f8d1 8000 	ldr.w	r8, [r1]
700257c0:	46c1      	mov	r9, r8
700257c2:	6823      	ldr	r3, [r4, #0]
700257c4:	1c59      	adds	r1, r3, #1
700257c6:	781a      	ldrb	r2, [r3, #0]
700257c8:	f81a 2002 	ldrb.w	r2, [sl, r2]
700257cc:	b1aa      	cbz	r2, 700257fa <__ssvfiscanf_r+0x816>
700257ce:	6862      	ldr	r2, [r4, #4]
700257d0:	3e01      	subs	r6, #1
700257d2:	6021      	str	r1, [r4, #0]
700257d4:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
700257d8:	6062      	str	r2, [r4, #4]
700257da:	781b      	ldrb	r3, [r3, #0]
700257dc:	f809 3b01 	strb.w	r3, [r9], #1
700257e0:	d00b      	beq.n	700257fa <__ssvfiscanf_r+0x816>
700257e2:	6863      	ldr	r3, [r4, #4]
700257e4:	2b00      	cmp	r3, #0
700257e6:	dcec      	bgt.n	700257c2 <__ssvfiscanf_r+0x7de>
700257e8:	4658      	mov	r0, fp
700257ea:	4621      	mov	r1, r4
700257ec:	f7ff fb9e 	bl	70024f2c <__ssrefill_r>
700257f0:	2800      	cmp	r0, #0
700257f2:	d0e6      	beq.n	700257c2 <__ssvfiscanf_r+0x7de>
700257f4:	45c8      	cmp	r8, r9
700257f6:	f43f ad1b 	beq.w	70025230 <__ssvfiscanf_r+0x24c>
700257fa:	ebb9 0808 	subs.w	r8, r9, r8
700257fe:	f43f ac41 	beq.w	70025084 <__ssvfiscanf_r+0xa0>
70025802:	9e09      	ldr	r6, [sp, #36]	; 0x24
70025804:	f04f 0000 	mov.w	r0, #0
70025808:	f889 0000 	strb.w	r0, [r9]
7002580c:	3601      	adds	r6, #1
7002580e:	9609      	str	r6, [sp, #36]	; 0x24
70025810:	e56a      	b.n	700252e8 <__ssvfiscanf_r+0x304>
70025812:	4632      	mov	r2, r6
70025814:	f888 6000 	strb.w	r6, [r8]
70025818:	4658      	mov	r0, fp
7002581a:	4651      	mov	r1, sl
7002581c:	9b08      	ldr	r3, [sp, #32]
7002581e:	9e04      	ldr	r6, [sp, #16]
70025820:	47b0      	blx	r6
70025822:	f019 0f20 	tst.w	r9, #32
70025826:	d033      	beq.n	70025890 <__ssvfiscanf_r+0x8ac>
70025828:	9e06      	ldr	r6, [sp, #24]
7002582a:	3604      	adds	r6, #4
7002582c:	f856 3c04 	ldr.w	r3, [r6, #-4]
70025830:	9606      	str	r6, [sp, #24]
70025832:	6018      	str	r0, [r3, #0]
70025834:	9e09      	ldr	r6, [sp, #36]	; 0x24
70025836:	3601      	adds	r6, #1
70025838:	9609      	str	r6, [sp, #36]	; 0x24
7002583a:	e717      	b.n	7002566c <__ssvfiscanf_r+0x688>
7002583c:	3002      	adds	r0, #2
7002583e:	bf08      	it	eq
70025840:	46d8      	moveq	r8, fp
70025842:	f43f ae4c 	beq.w	700254de <__ssvfiscanf_r+0x4fa>
70025846:	e642      	b.n	700254ce <__ssvfiscanf_r+0x4ea>
70025848:	f8ca 0000 	str.w	r0, [sl]
7002584c:	f000 f8f8 	bl	70025a40 <iswspace>
70025850:	2800      	cmp	r0, #0
70025852:	f000 80a2 	beq.w	7002599a <__ssvfiscanf_r+0x9b6>
70025856:	f1b8 0f00 	cmp.w	r8, #0
7002585a:	d00c      	beq.n	70025876 <__ssvfiscanf_r+0x892>
7002585c:	ae12      	add	r6, sp, #72	; 0x48
7002585e:	4446      	add	r6, r8
70025860:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
70025864:	4658      	mov	r0, fp
70025866:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
7002586a:	4622      	mov	r2, r4
7002586c:	f7ff fb1e 	bl	70024eac <_sungetc_r>
70025870:	f1b8 0f00 	cmp.w	r8, #0
70025874:	d1f4      	bne.n	70025860 <__ssvfiscanf_r+0x87c>
70025876:	9e07      	ldr	r6, [sp, #28]
70025878:	2e00      	cmp	r6, #0
7002587a:	f47f ae45 	bne.w	70025508 <__ssvfiscanf_r+0x524>
7002587e:	9e09      	ldr	r6, [sp, #36]	; 0x24
70025880:	f8dd 8014 	ldr.w	r8, [sp, #20]
70025884:	3601      	adds	r6, #1
70025886:	9609      	str	r6, [sp, #36]	; 0x24
70025888:	9e07      	ldr	r6, [sp, #28]
7002588a:	f8ca 6000 	str.w	r6, [sl]
7002588e:	e63d      	b.n	7002550c <__ssvfiscanf_r+0x528>
70025890:	f019 0f04 	tst.w	r9, #4
70025894:	d05e      	beq.n	70025954 <__ssvfiscanf_r+0x970>
70025896:	9e06      	ldr	r6, [sp, #24]
70025898:	3604      	adds	r6, #4
7002589a:	f856 3c04 	ldr.w	r3, [r6, #-4]
7002589e:	9606      	str	r6, [sp, #24]
700258a0:	8018      	strh	r0, [r3, #0]
700258a2:	e7c7      	b.n	70025834 <__ssvfiscanf_r+0x850>
700258a4:	f1b8 0f00 	cmp.w	r8, #0
700258a8:	f47f ad1e 	bne.w	700252e8 <__ssvfiscanf_r+0x304>
700258ac:	e4c0      	b.n	70025230 <__ssvfiscanf_r+0x24c>
700258ae:	f8dd e018 	ldr.w	lr, [sp, #24]
700258b2:	4633      	mov	r3, r6
700258b4:	4658      	mov	r0, fp
700258b6:	2201      	movs	r2, #1
700258b8:	f10e 0604 	add.w	r6, lr, #4
700258bc:	f8de 1000 	ldr.w	r1, [lr]
700258c0:	9400      	str	r4, [sp, #0]
700258c2:	f7ff fb51 	bl	70024f68 <_sfread_r>
700258c6:	2800      	cmp	r0, #0
700258c8:	f43f acb2 	beq.w	70025230 <__ssvfiscanf_r+0x24c>
700258cc:	f8dd 8014 	ldr.w	r8, [sp, #20]
700258d0:	4405      	add	r5, r0
700258d2:	9809      	ldr	r0, [sp, #36]	; 0x24
700258d4:	9606      	str	r6, [sp, #24]
700258d6:	3001      	adds	r0, #1
700258d8:	4642      	mov	r2, r8
700258da:	9009      	str	r0, [sp, #36]	; 0x24
700258dc:	f7ff bbcc 	b.w	70025078 <__ssvfiscanf_r+0x94>
700258e0:	4658      	mov	r0, fp
700258e2:	4621      	mov	r1, r4
700258e4:	f7ff fb22 	bl	70024f2c <__ssrefill_r>
700258e8:	2800      	cmp	r0, #0
700258ea:	f43f acb2 	beq.w	70025252 <__ssvfiscanf_r+0x26e>
700258ee:	e49f      	b.n	70025230 <__ssvfiscanf_r+0x24c>
700258f0:	f818 1c01 	ldrb.w	r1, [r8, #-1]
700258f4:	4658      	mov	r0, fp
700258f6:	4622      	mov	r2, r4
700258f8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
700258fc:	f7ff fad6 	bl	70024eac <_sungetc_r>
70025900:	e6ad      	b.n	7002565e <__ssvfiscanf_r+0x67a>
70025902:	f244 40b5 	movw	r0, #17589	; 0x44b5
70025906:	210a      	movs	r1, #10
70025908:	f2c7 0002 	movt	r0, #28674	; 0x7002
7002590c:	f049 0901 	orr.w	r9, r9, #1
70025910:	9108      	str	r1, [sp, #32]
70025912:	f04f 0803 	mov.w	r8, #3
70025916:	9004      	str	r0, [sp, #16]
70025918:	e4b4      	b.n	70025284 <__ssvfiscanf_r+0x2a0>
7002591a:	f019 0f01 	tst.w	r9, #1
7002591e:	d10f      	bne.n	70025940 <__ssvfiscanf_r+0x95c>
70025920:	f019 0f02 	tst.w	r9, #2
70025924:	d00c      	beq.n	70025940 <__ssvfiscanf_r+0x95c>
70025926:	9e06      	ldr	r6, [sp, #24]
70025928:	462a      	mov	r2, r5
7002592a:	17eb      	asrs	r3, r5, #31
7002592c:	f8dd 8014 	ldr.w	r8, [sp, #20]
70025930:	3604      	adds	r6, #4
70025932:	f856 1c04 	ldr.w	r1, [r6, #-4]
70025936:	9606      	str	r6, [sp, #24]
70025938:	e9c1 2300 	strd	r2, r3, [r1]
7002593c:	f7ff bb9b 	b.w	70025076 <__ssvfiscanf_r+0x92>
70025940:	9e06      	ldr	r6, [sp, #24]
70025942:	f8dd 8014 	ldr.w	r8, [sp, #20]
70025946:	3604      	adds	r6, #4
70025948:	f856 3c04 	ldr.w	r3, [r6, #-4]
7002594c:	9606      	str	r6, [sp, #24]
7002594e:	601d      	str	r5, [r3, #0]
70025950:	f7ff bb91 	b.w	70025076 <__ssvfiscanf_r+0x92>
70025954:	f019 0201 	ands.w	r2, r9, #1
70025958:	f47f af66 	bne.w	70025828 <__ssvfiscanf_r+0x844>
7002595c:	f019 0f02 	tst.w	r9, #2
70025960:	f43f af62 	beq.w	70025828 <__ssvfiscanf_r+0x844>
70025964:	9e04      	ldr	r6, [sp, #16]
70025966:	4658      	mov	r0, fp
70025968:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
7002596c:	4651      	mov	r1, sl
7002596e:	9b08      	ldr	r3, [sp, #32]
70025970:	4576      	cmp	r6, lr
70025972:	d01d      	beq.n	700259b0 <__ssvfiscanf_r+0x9cc>
70025974:	f000 f908 	bl	70025b88 <_strtoll_r>
70025978:	9e06      	ldr	r6, [sp, #24]
7002597a:	3604      	adds	r6, #4
7002597c:	f856 3c04 	ldr.w	r3, [r6, #-4]
70025980:	9606      	str	r6, [sp, #24]
70025982:	e9c3 0100 	strd	r0, r1, [r3]
70025986:	e755      	b.n	70025834 <__ssvfiscanf_r+0x850>
70025988:	463d      	mov	r5, r7
7002598a:	f8dd b01c 	ldr.w	fp, [sp, #28]
7002598e:	9f0d      	ldr	r7, [sp, #52]	; 0x34
70025990:	f1b8 0f00 	cmp.w	r8, #0
70025994:	f43f adb3 	beq.w	700254fe <__ssvfiscanf_r+0x51a>
70025998:	e44a      	b.n	70025230 <__ssvfiscanf_r+0x24c>
7002599a:	9b07      	ldr	r3, [sp, #28]
7002599c:	4445      	add	r5, r8
7002599e:	3e01      	subs	r6, #1
700259a0:	4681      	mov	r9, r0
700259a2:	2b00      	cmp	r3, #0
700259a4:	f47f ac37 	bne.w	70025216 <__ssvfiscanf_r+0x232>
700259a8:	f10a 0a04 	add.w	sl, sl, #4
700259ac:	4699      	mov	r9, r3
700259ae:	e432      	b.n	70025216 <__ssvfiscanf_r+0x232>
700259b0:	f000 f9c4 	bl	70025d3c <_strtoull_r>
700259b4:	e7e0      	b.n	70025978 <__ssvfiscanf_r+0x994>
700259b6:	f8da 0000 	ldr.w	r0, [sl]
700259ba:	e747      	b.n	7002584c <__ssvfiscanf_r+0x868>

700259bc <__tz_lock>:
700259bc:	4770      	bx	lr
700259be:	bf00      	nop

700259c0 <__tz_unlock>:
700259c0:	4770      	bx	lr
700259c2:	bf00      	nop

700259c4 <__submore>:
700259c4:	f101 0340 	add.w	r3, r1, #64	; 0x40
700259c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
700259cc:	460c      	mov	r4, r1
700259ce:	6b09      	ldr	r1, [r1, #48]	; 0x30
700259d0:	4299      	cmp	r1, r3
700259d2:	d014      	beq.n	700259fe <__submore+0x3a>
700259d4:	6b66      	ldr	r6, [r4, #52]	; 0x34
700259d6:	0077      	lsls	r7, r6, #1
700259d8:	463a      	mov	r2, r7
700259da:	f7f9 e8c2 	blx	7001eb60 <_realloc_r>
700259de:	4605      	mov	r5, r0
700259e0:	b348      	cbz	r0, 70025a36 <__submore+0x72>
700259e2:	eb00 0806 	add.w	r8, r0, r6
700259e6:	4601      	mov	r1, r0
700259e8:	4632      	mov	r2, r6
700259ea:	4640      	mov	r0, r8
700259ec:	f7fe fa5c 	bl	70023ea8 <memcpy>
700259f0:	2000      	movs	r0, #0
700259f2:	f8c4 8000 	str.w	r8, [r4]
700259f6:	6325      	str	r5, [r4, #48]	; 0x30
700259f8:	6367      	str	r7, [r4, #52]	; 0x34
700259fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
700259fe:	f44f 6180 	mov.w	r1, #1024	; 0x400
70025a02:	f7f9 e88a 	blx	7001eb18 <_malloc_r>
70025a06:	4603      	mov	r3, r0
70025a08:	b1a8      	cbz	r0, 70025a36 <__submore+0x72>
70025a0a:	f894 1042 	ldrb.w	r1, [r4, #66]	; 0x42
70025a0e:	f44f 6080 	mov.w	r0, #1024	; 0x400
70025a12:	6323      	str	r3, [r4, #48]	; 0x30
70025a14:	f203 32fd 	addw	r2, r3, #1021	; 0x3fd
70025a18:	6360      	str	r0, [r4, #52]	; 0x34
70025a1a:	2000      	movs	r0, #0
70025a1c:	f883 13ff 	strb.w	r1, [r3, #1023]	; 0x3ff
70025a20:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
70025a24:	f883 13fe 	strb.w	r1, [r3, #1022]	; 0x3fe
70025a28:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
70025a2c:	f883 13fd 	strb.w	r1, [r3, #1021]	; 0x3fd
70025a30:	6022      	str	r2, [r4, #0]
70025a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
70025a36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025a3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
70025a3e:	bf00      	nop

70025a40 <iswspace>:
70025a40:	28ff      	cmp	r0, #255	; 0xff
70025a42:	bf9f      	itttt	ls
70025a44:	f249 43dc 	movwls	r3, #38108	; 0x94dc
70025a48:	f2c7 0302 	movtls	r3, #28674	; 0x7002
70025a4c:	681b      	ldrls	r3, [r3, #0]
70025a4e:	18c0      	addls	r0, r0, r3
70025a50:	bf9d      	ittte	ls
70025a52:	7840      	ldrbls	r0, [r0, #1]
70025a54:	f000 0008 	andls.w	r0, r0, #8
70025a58:	b2c0      	uxtbls	r0, r0
70025a5a:	2000      	movhi	r0, #0
70025a5c:	4770      	bx	lr
70025a5e:	bf00      	nop

70025a60 <__locale_charset>:
70025a60:	f249 5024 	movw	r0, #38180	; 0x9524
70025a64:	f2c7 0002 	movt	r0, #28674	; 0x7002
70025a68:	4770      	bx	lr
70025a6a:	bf00      	nop

70025a6c <__locale_mb_cur_max>:
70025a6c:	f249 5344 	movw	r3, #38212	; 0x9544
70025a70:	f2c7 0302 	movt	r3, #28674	; 0x7002
70025a74:	6818      	ldr	r0, [r3, #0]
70025a76:	4770      	bx	lr

70025a78 <_mbrtowc_r>:
70025a78:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
70025a7c:	b083      	sub	sp, #12
70025a7e:	4606      	mov	r6, r0
70025a80:	4689      	mov	r9, r1
70025a82:	4698      	mov	r8, r3
70025a84:	4615      	mov	r5, r2
70025a86:	9f0a      	ldr	r7, [sp, #40]	; 0x28
70025a88:	b1b2      	cbz	r2, 70025ab8 <_mbrtowc_r+0x40>
70025a8a:	f249 5448 	movw	r4, #38216	; 0x9548
70025a8e:	f2c7 0402 	movt	r4, #28674	; 0x7002
70025a92:	6824      	ldr	r4, [r4, #0]
70025a94:	f7ff ffe4 	bl	70025a60 <__locale_charset>
70025a98:	9701      	str	r7, [sp, #4]
70025a9a:	4649      	mov	r1, r9
70025a9c:	462a      	mov	r2, r5
70025a9e:	4643      	mov	r3, r8
70025aa0:	9000      	str	r0, [sp, #0]
70025aa2:	4630      	mov	r0, r6
70025aa4:	47a0      	blx	r4
70025aa6:	1c43      	adds	r3, r0, #1
70025aa8:	bf01      	itttt	eq
70025aaa:	2200      	moveq	r2, #0
70025aac:	238a      	moveq	r3, #138	; 0x8a
70025aae:	603a      	streq	r2, [r7, #0]
70025ab0:	6033      	streq	r3, [r6, #0]
70025ab2:	b003      	add	sp, #12
70025ab4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
70025ab8:	f249 5348 	movw	r3, #38216	; 0x9548
70025abc:	f2c7 0302 	movt	r3, #28674	; 0x7002
70025ac0:	681c      	ldr	r4, [r3, #0]
70025ac2:	f7ff ffcd 	bl	70025a60 <__locale_charset>
70025ac6:	9701      	str	r7, [sp, #4]
70025ac8:	4629      	mov	r1, r5
70025aca:	f648 5274 	movw	r2, #36212	; 0x8d74
70025ace:	2301      	movs	r3, #1
70025ad0:	f2c7 0202 	movt	r2, #28674	; 0x7002
70025ad4:	9000      	str	r0, [sp, #0]
70025ad6:	4630      	mov	r0, r6
70025ad8:	47a0      	blx	r4
70025ada:	e7e4      	b.n	70025aa6 <_mbrtowc_r+0x2e>

70025adc <__ascii_mbtowc>:
70025adc:	b082      	sub	sp, #8
70025ade:	b149      	cbz	r1, 70025af4 <__ascii_mbtowc+0x18>
70025ae0:	b15a      	cbz	r2, 70025afa <__ascii_mbtowc+0x1e>
70025ae2:	b16b      	cbz	r3, 70025b00 <__ascii_mbtowc+0x24>
70025ae4:	7813      	ldrb	r3, [r2, #0]
70025ae6:	600b      	str	r3, [r1, #0]
70025ae8:	7810      	ldrb	r0, [r2, #0]
70025aea:	3000      	adds	r0, #0
70025aec:	bf18      	it	ne
70025aee:	2001      	movne	r0, #1
70025af0:	b002      	add	sp, #8
70025af2:	4770      	bx	lr
70025af4:	a901      	add	r1, sp, #4
70025af6:	2a00      	cmp	r2, #0
70025af8:	d1f3      	bne.n	70025ae2 <__ascii_mbtowc+0x6>
70025afa:	4610      	mov	r0, r2
70025afc:	b002      	add	sp, #8
70025afe:	4770      	bx	lr
70025b00:	f06f 0001 	mvn.w	r0, #1
70025b04:	e7f4      	b.n	70025af0 <__ascii_mbtowc+0x14>
70025b06:	bf00      	nop

70025b08 <__sccl>:
70025b08:	b4f0      	push	{r4, r5, r6, r7}
70025b0a:	2300      	movs	r3, #0
70025b0c:	780c      	ldrb	r4, [r1, #0]
70025b0e:	2c5e      	cmp	r4, #94	; 0x5e
70025b10:	bf15      	itete	ne
70025b12:	1c4d      	addne	r5, r1, #1
70025b14:	1c8d      	addeq	r5, r1, #2
70025b16:	2200      	movne	r2, #0
70025b18:	2201      	moveq	r2, #1
70025b1a:	bf08      	it	eq
70025b1c:	784c      	ldrbeq	r4, [r1, #1]
70025b1e:	4611      	mov	r1, r2
70025b20:	54c2      	strb	r2, [r0, r3]
70025b22:	3301      	adds	r3, #1
70025b24:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
70025b28:	d1fa      	bne.n	70025b20 <__sccl+0x18>
70025b2a:	f081 0201 	eor.w	r2, r1, #1
70025b2e:	b174      	cbz	r4, 70025b4e <__sccl+0x46>
70025b30:	1c6e      	adds	r6, r5, #1
70025b32:	5502      	strb	r2, [r0, r4]
70025b34:	f816 3c01 	ldrb.w	r3, [r6, #-1]
70025b38:	2b2d      	cmp	r3, #45	; 0x2d
70025b3a:	d00e      	beq.n	70025b5a <__sccl+0x52>
70025b3c:	2b5d      	cmp	r3, #93	; 0x5d
70025b3e:	d009      	beq.n	70025b54 <__sccl+0x4c>
70025b40:	b113      	cbz	r3, 70025b48 <__sccl+0x40>
70025b42:	461c      	mov	r4, r3
70025b44:	4635      	mov	r5, r6
70025b46:	e7f3      	b.n	70025b30 <__sccl+0x28>
70025b48:	4628      	mov	r0, r5
70025b4a:	bcf0      	pop	{r4, r5, r6, r7}
70025b4c:	4770      	bx	lr
70025b4e:	1e68      	subs	r0, r5, #1
70025b50:	bcf0      	pop	{r4, r5, r6, r7}
70025b52:	4770      	bx	lr
70025b54:	4630      	mov	r0, r6
70025b56:	bcf0      	pop	{r4, r5, r6, r7}
70025b58:	4770      	bx	lr
70025b5a:	7869      	ldrb	r1, [r5, #1]
70025b5c:	f1b1 0c5d 	subs.w	ip, r1, #93	; 0x5d
70025b60:	f1dc 0700 	rsbs	r7, ip, #0
70025b64:	eb57 070c 	adcs.w	r7, r7, ip
70025b68:	42a1      	cmp	r1, r4
70025b6a:	bfb8      	it	lt
70025b6c:	f047 0701 	orrlt.w	r7, r7, #1
70025b70:	2f00      	cmp	r7, #0
70025b72:	d1e6      	bne.n	70025b42 <__sccl+0x3a>
70025b74:	3502      	adds	r5, #2
70025b76:	1903      	adds	r3, r0, r4
70025b78:	3401      	adds	r4, #1
70025b7a:	f803 2f01 	strb.w	r2, [r3, #1]!
70025b7e:	42a1      	cmp	r1, r4
70025b80:	dcfa      	bgt.n	70025b78 <__sccl+0x70>
70025b82:	3602      	adds	r6, #2
70025b84:	e7d6      	b.n	70025b34 <__sccl+0x2c>
70025b86:	bf00      	nop

70025b88 <_strtoll_r>:
70025b88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70025b8c:	f249 44dc 	movw	r4, #38108	; 0x94dc
70025b90:	b087      	sub	sp, #28
70025b92:	f2c7 0402 	movt	r4, #28674	; 0x7002
70025b96:	4699      	mov	r9, r3
70025b98:	9202      	str	r2, [sp, #8]
70025b9a:	460a      	mov	r2, r1
70025b9c:	9104      	str	r1, [sp, #16]
70025b9e:	9005      	str	r0, [sp, #20]
70025ba0:	f8d4 8000 	ldr.w	r8, [r4]
70025ba4:	e000      	b.n	70025ba8 <_strtoll_r+0x20>
70025ba6:	4632      	mov	r2, r6
70025ba8:	4616      	mov	r6, r2
70025baa:	f816 7b01 	ldrb.w	r7, [r6], #1
70025bae:	eb08 0307 	add.w	r3, r8, r7
70025bb2:	785b      	ldrb	r3, [r3, #1]
70025bb4:	f003 0308 	and.w	r3, r3, #8
70025bb8:	f003 0cff 	and.w	ip, r3, #255	; 0xff
70025bbc:	2b00      	cmp	r3, #0
70025bbe:	d1f2      	bne.n	70025ba6 <_strtoll_r+0x1e>
70025bc0:	2f2d      	cmp	r7, #45	; 0x2d
70025bc2:	f000 8095 	beq.w	70025cf0 <_strtoll_r+0x168>
70025bc6:	2f2b      	cmp	r7, #43	; 0x2b
70025bc8:	f8cd c00c 	str.w	ip, [sp, #12]
70025bcc:	bf04      	itt	eq
70025bce:	1c96      	addeq	r6, r2, #2
70025bd0:	7857      	ldrbeq	r7, [r2, #1]
70025bd2:	f039 0310 	bics.w	r3, r9, #16
70025bd6:	d116      	bne.n	70025c06 <_strtoll_r+0x7e>
70025bd8:	f1d9 0301 	rsbs	r3, r9, #1
70025bdc:	bf38      	it	cc
70025bde:	2300      	movcc	r3, #0
70025be0:	2f30      	cmp	r7, #48	; 0x30
70025be2:	d007      	beq.n	70025bf4 <_strtoll_r+0x6c>
70025be4:	b17b      	cbz	r3, 70025c06 <_strtoll_r+0x7e>
70025be6:	f04f 0a0a 	mov.w	sl, #10
70025bea:	f04f 0b00 	mov.w	fp, #0
70025bee:	f04f 090a 	mov.w	r9, #10
70025bf2:	e00b      	b.n	70025c0c <_strtoll_r+0x84>
70025bf4:	7832      	ldrb	r2, [r6, #0]
70025bf6:	f002 02df 	and.w	r2, r2, #223	; 0xdf
70025bfa:	2a58      	cmp	r2, #88	; 0x58
70025bfc:	f000 808d 	beq.w	70025d1a <_strtoll_r+0x192>
70025c00:	2b00      	cmp	r3, #0
70025c02:	f040 8093 	bne.w	70025d2c <_strtoll_r+0x1a4>
70025c06:	ea4f 7be9 	mov.w	fp, r9, asr #31
70025c0a:	46ca      	mov	sl, r9
70025c0c:	9a03      	ldr	r2, [sp, #12]
70025c0e:	2400      	movs	r4, #0
70025c10:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
70025c14:	b91a      	cbnz	r2, 70025c1e <_strtoll_r+0x96>
70025c16:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
70025c1a:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
70025c1e:	4620      	mov	r0, r4
70025c20:	4629      	mov	r1, r5
70025c22:	4652      	mov	r2, sl
70025c24:	465b      	mov	r3, fp
70025c26:	f7fd fca1 	bl	7002356c <__aeabi_uldivmod>
70025c2a:	4620      	mov	r0, r4
70025c2c:	4629      	mov	r1, r5
70025c2e:	465b      	mov	r3, fp
70025c30:	2400      	movs	r4, #0
70025c32:	2500      	movs	r5, #0
70025c34:	4694      	mov	ip, r2
70025c36:	4652      	mov	r2, sl
70025c38:	f8cd c004 	str.w	ip, [sp, #4]
70025c3c:	f7fd fc96 	bl	7002356c <__aeabi_uldivmod>
70025c40:	2300      	movs	r3, #0
70025c42:	f8dd c004 	ldr.w	ip, [sp, #4]
70025c46:	e018      	b.n	70025c7a <_strtoll_r+0xf2>
70025c48:	428d      	cmp	r5, r1
70025c4a:	bf08      	it	eq
70025c4c:	4284      	cmpeq	r4, r0
70025c4e:	bf14      	ite	ne
70025c50:	2300      	movne	r3, #0
70025c52:	2301      	moveq	r3, #1
70025c54:	4567      	cmp	r7, ip
70025c56:	bfd4      	ite	le
70025c58:	2300      	movle	r3, #0
70025c5a:	f003 0301 	andgt.w	r3, r3, #1
70025c5e:	bb3b      	cbnz	r3, 70025cb0 <_strtoll_r+0x128>
70025c60:	fb04 f20b 	mul.w	r2, r4, fp
70025c64:	2301      	movs	r3, #1
70025c66:	fb0a 2205 	mla	r2, sl, r5, r2
70025c6a:	fba4 450a 	umull	r4, r5, r4, sl
70025c6e:	4415      	add	r5, r2
70025c70:	19e4      	adds	r4, r4, r7
70025c72:	eb45 75e7 	adc.w	r5, r5, r7, asr #31
70025c76:	f816 7b01 	ldrb.w	r7, [r6], #1
70025c7a:	eb08 0207 	add.w	r2, r8, r7
70025c7e:	7852      	ldrb	r2, [r2, #1]
70025c80:	f012 0f04 	tst.w	r2, #4
70025c84:	bf18      	it	ne
70025c86:	3f30      	subne	r7, #48	; 0x30
70025c88:	d107      	bne.n	70025c9a <_strtoll_r+0x112>
70025c8a:	f012 0203 	ands.w	r2, r2, #3
70025c8e:	d012      	beq.n	70025cb6 <_strtoll_r+0x12e>
70025c90:	2a01      	cmp	r2, #1
70025c92:	bf14      	ite	ne
70025c94:	2257      	movne	r2, #87	; 0x57
70025c96:	2237      	moveq	r2, #55	; 0x37
70025c98:	1abf      	subs	r7, r7, r2
70025c9a:	45b9      	cmp	r9, r7
70025c9c:	dd0b      	ble.n	70025cb6 <_strtoll_r+0x12e>
70025c9e:	42a9      	cmp	r1, r5
70025ca0:	bf08      	it	eq
70025ca2:	42a0      	cmpeq	r0, r4
70025ca4:	bf2c      	ite	cs
70025ca6:	2200      	movcs	r2, #0
70025ca8:	2201      	movcc	r2, #1
70025caa:	ea52 73d3 	orrs.w	r3, r2, r3, lsr #31
70025cae:	d0cb      	beq.n	70025c48 <_strtoll_r+0xc0>
70025cb0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
70025cb4:	e7df      	b.n	70025c76 <_strtoll_r+0xee>
70025cb6:	1c5a      	adds	r2, r3, #1
70025cb8:	d01f      	beq.n	70025cfa <_strtoll_r+0x172>
70025cba:	9a03      	ldr	r2, [sp, #12]
70025cbc:	b9a2      	cbnz	r2, 70025ce8 <_strtoll_r+0x160>
70025cbe:	9a02      	ldr	r2, [sp, #8]
70025cc0:	4620      	mov	r0, r4
70025cc2:	4629      	mov	r1, r5
70025cc4:	b12a      	cbz	r2, 70025cd2 <_strtoll_r+0x14a>
70025cc6:	b13b      	cbz	r3, 70025cd8 <_strtoll_r+0x150>
70025cc8:	4620      	mov	r0, r4
70025cca:	4629      	mov	r1, r5
70025ccc:	9b02      	ldr	r3, [sp, #8]
70025cce:	3e01      	subs	r6, #1
70025cd0:	601e      	str	r6, [r3, #0]
70025cd2:	b007      	add	sp, #28
70025cd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70025cd8:	9e04      	ldr	r6, [sp, #16]
70025cda:	4620      	mov	r0, r4
70025cdc:	9b02      	ldr	r3, [sp, #8]
70025cde:	4629      	mov	r1, r5
70025ce0:	601e      	str	r6, [r3, #0]
70025ce2:	b007      	add	sp, #28
70025ce4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70025ce8:	4264      	negs	r4, r4
70025cea:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
70025cee:	e7e6      	b.n	70025cbe <_strtoll_r+0x136>
70025cf0:	1c96      	adds	r6, r2, #2
70025cf2:	7857      	ldrb	r7, [r2, #1]
70025cf4:	2201      	movs	r2, #1
70025cf6:	9203      	str	r2, [sp, #12]
70025cf8:	e76b      	b.n	70025bd2 <_strtoll_r+0x4a>
70025cfa:	9b03      	ldr	r3, [sp, #12]
70025cfc:	2000      	movs	r0, #0
70025cfe:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
70025d02:	b91b      	cbnz	r3, 70025d0c <_strtoll_r+0x184>
70025d04:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025d08:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
70025d0c:	9a05      	ldr	r2, [sp, #20]
70025d0e:	2322      	movs	r3, #34	; 0x22
70025d10:	6013      	str	r3, [r2, #0]
70025d12:	9b02      	ldr	r3, [sp, #8]
70025d14:	2b00      	cmp	r3, #0
70025d16:	d1d9      	bne.n	70025ccc <_strtoll_r+0x144>
70025d18:	e7db      	b.n	70025cd2 <_strtoll_r+0x14a>
70025d1a:	7877      	ldrb	r7, [r6, #1]
70025d1c:	f04f 0a10 	mov.w	sl, #16
70025d20:	f04f 0b00 	mov.w	fp, #0
70025d24:	3602      	adds	r6, #2
70025d26:	f04f 0910 	mov.w	r9, #16
70025d2a:	e76f      	b.n	70025c0c <_strtoll_r+0x84>
70025d2c:	f04f 0a08 	mov.w	sl, #8
70025d30:	f04f 0b00 	mov.w	fp, #0
70025d34:	f04f 0908 	mov.w	r9, #8
70025d38:	e768      	b.n	70025c0c <_strtoll_r+0x84>
70025d3a:	bf00      	nop

70025d3c <_strtoull_r>:
70025d3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
70025d40:	f249 44dc 	movw	r4, #38108	; 0x94dc
70025d44:	b087      	sub	sp, #28
70025d46:	f2c7 0402 	movt	r4, #28674	; 0x7002
70025d4a:	4691      	mov	r9, r2
70025d4c:	468b      	mov	fp, r1
70025d4e:	9005      	str	r0, [sp, #20]
70025d50:	4698      	mov	r8, r3
70025d52:	6827      	ldr	r7, [r4, #0]
70025d54:	460a      	mov	r2, r1
70025d56:	e000      	b.n	70025d5a <_strtoull_r+0x1e>
70025d58:	4632      	mov	r2, r6
70025d5a:	4616      	mov	r6, r2
70025d5c:	f816 ab01 	ldrb.w	sl, [r6], #1
70025d60:	eb07 030a 	add.w	r3, r7, sl
70025d64:	785b      	ldrb	r3, [r3, #1]
70025d66:	f003 0308 	and.w	r3, r3, #8
70025d6a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
70025d6e:	2b00      	cmp	r3, #0
70025d70:	d1f2      	bne.n	70025d58 <_strtoull_r+0x1c>
70025d72:	f1ba 0f2d 	cmp.w	sl, #45	; 0x2d
70025d76:	f000 80a3 	beq.w	70025ec0 <_strtoull_r+0x184>
70025d7a:	f1ba 0f2b 	cmp.w	sl, #43	; 0x2b
70025d7e:	9104      	str	r1, [sp, #16]
70025d80:	bf04      	itt	eq
70025d82:	1c96      	addeq	r6, r2, #2
70025d84:	f892 a001 	ldrbeq.w	sl, [r2, #1]
70025d88:	f038 0110 	bics.w	r1, r8, #16
70025d8c:	d118      	bne.n	70025dc0 <_strtoull_r+0x84>
70025d8e:	f1d8 0301 	rsbs	r3, r8, #1
70025d92:	bf38      	it	cc
70025d94:	2300      	movcc	r3, #0
70025d96:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
70025d9a:	f000 8097 	beq.w	70025ecc <_strtoull_r+0x190>
70025d9e:	2b00      	cmp	r3, #0
70025da0:	f000 80b5 	beq.w	70025f0e <_strtoull_r+0x1d2>
70025da4:	f649 1599 	movw	r5, #39321	; 0x9999
70025da8:	200a      	movs	r0, #10
70025daa:	2100      	movs	r1, #0
70025dac:	2205      	movs	r2, #5
70025dae:	f04f 3499 	mov.w	r4, #2576980377	; 0x99999999
70025db2:	f6c1 1599 	movt	r5, #6553	; 0x1999
70025db6:	e9cd 0102 	strd	r0, r1, [sp, #8]
70025dba:	f04f 080a 	mov.w	r8, #10
70025dbe:	e016      	b.n	70025dee <_strtoull_r+0xb2>
70025dc0:	4640      	mov	r0, r8
70025dc2:	ea4f 71e8 	mov.w	r1, r8, asr #31
70025dc6:	e9cd 0102 	strd	r0, r1, [sp, #8]
70025dca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025dce:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
70025dd2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
70025dd6:	f7fd fbc9 	bl	7002356c <__aeabi_uldivmod>
70025dda:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
70025dde:	4604      	mov	r4, r0
70025de0:	460d      	mov	r5, r1
70025de2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025de6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
70025dea:	f7fd fbbf 	bl	7002356c <__aeabi_uldivmod>
70025dee:	2000      	movs	r0, #0
70025df0:	2100      	movs	r1, #0
70025df2:	2300      	movs	r3, #0
70025df4:	f8cd 9004 	str.w	r9, [sp, #4]
70025df8:	e01c      	b.n	70025e34 <_strtoull_r+0xf8>
70025dfa:	42a9      	cmp	r1, r5
70025dfc:	bf08      	it	eq
70025dfe:	42a0      	cmpeq	r0, r4
70025e00:	bf14      	ite	ne
70025e02:	2300      	movne	r3, #0
70025e04:	2301      	moveq	r3, #1
70025e06:	4592      	cmp	sl, r2
70025e08:	bfd4      	ite	le
70025e0a:	2300      	movle	r3, #0
70025e0c:	f003 0301 	andgt.w	r3, r3, #1
70025e10:	bb9b      	cbnz	r3, 70025e7a <_strtoull_r+0x13e>
70025e12:	9b03      	ldr	r3, [sp, #12]
70025e14:	f8dd 9008 	ldr.w	r9, [sp, #8]
70025e18:	fb00 fc03 	mul.w	ip, r0, r3
70025e1c:	2301      	movs	r3, #1
70025e1e:	fb09 cc01 	mla	ip, r9, r1, ip
70025e22:	fba0 0109 	umull	r0, r1, r0, r9
70025e26:	4461      	add	r1, ip
70025e28:	eb10 000a 	adds.w	r0, r0, sl
70025e2c:	eb41 71ea 	adc.w	r1, r1, sl, asr #31
70025e30:	f816 ab01 	ldrb.w	sl, [r6], #1
70025e34:	eb07 0c0a 	add.w	ip, r7, sl
70025e38:	f89c c001 	ldrb.w	ip, [ip, #1]
70025e3c:	f01c 0f04 	tst.w	ip, #4
70025e40:	bf18      	it	ne
70025e42:	f1aa 0a30 	subne.w	sl, sl, #48	; 0x30
70025e46:	d10b      	bne.n	70025e60 <_strtoull_r+0x124>
70025e48:	f01c 0c03 	ands.w	ip, ip, #3
70025e4c:	d018      	beq.n	70025e80 <_strtoull_r+0x144>
70025e4e:	f1bc 0f01 	cmp.w	ip, #1
70025e52:	bf14      	ite	ne
70025e54:	f04f 0c57 	movne.w	ip, #87	; 0x57
70025e58:	f04f 0c37 	moveq.w	ip, #55	; 0x37
70025e5c:	ebcc 0a0a 	rsb	sl, ip, sl
70025e60:	45d0      	cmp	r8, sl
70025e62:	dd0d      	ble.n	70025e80 <_strtoull_r+0x144>
70025e64:	428d      	cmp	r5, r1
70025e66:	bf08      	it	eq
70025e68:	4284      	cmpeq	r4, r0
70025e6a:	bf2c      	ite	cs
70025e6c:	f04f 0c00 	movcs.w	ip, #0
70025e70:	f04f 0c01 	movcc.w	ip, #1
70025e74:	ea5c 73d3 	orrs.w	r3, ip, r3, lsr #31
70025e78:	d0bf      	beq.n	70025dfa <_strtoull_r+0xbe>
70025e7a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
70025e7e:	e7d7      	b.n	70025e30 <_strtoull_r+0xf4>
70025e80:	1c5a      	adds	r2, r3, #1
70025e82:	f8dd 9004 	ldr.w	r9, [sp, #4]
70025e86:	d00b      	beq.n	70025ea0 <_strtoull_r+0x164>
70025e88:	9a04      	ldr	r2, [sp, #16]
70025e8a:	b9aa      	cbnz	r2, 70025eb8 <_strtoull_r+0x17c>
70025e8c:	f1b9 0f00 	cmp.w	r9, #0
70025e90:	d003      	beq.n	70025e9a <_strtoull_r+0x15e>
70025e92:	b97b      	cbnz	r3, 70025eb4 <_strtoull_r+0x178>
70025e94:	465e      	mov	r6, fp
70025e96:	f8c9 6000 	str.w	r6, [r9]
70025e9a:	b007      	add	sp, #28
70025e9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70025ea0:	9805      	ldr	r0, [sp, #20]
70025ea2:	2322      	movs	r3, #34	; 0x22
70025ea4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
70025ea8:	6003      	str	r3, [r0, #0]
70025eaa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025eae:	f1b9 0f00 	cmp.w	r9, #0
70025eb2:	d0f2      	beq.n	70025e9a <_strtoull_r+0x15e>
70025eb4:	3e01      	subs	r6, #1
70025eb6:	e7ee      	b.n	70025e96 <_strtoull_r+0x15a>
70025eb8:	4240      	negs	r0, r0
70025eba:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
70025ebe:	e7e5      	b.n	70025e8c <_strtoull_r+0x150>
70025ec0:	2001      	movs	r0, #1
70025ec2:	1c96      	adds	r6, r2, #2
70025ec4:	f892 a001 	ldrb.w	sl, [r2, #1]
70025ec8:	9004      	str	r0, [sp, #16]
70025eca:	e75d      	b.n	70025d88 <_strtoull_r+0x4c>
70025ecc:	7832      	ldrb	r2, [r6, #0]
70025ece:	f002 02df 	and.w	r2, r2, #223	; 0xdf
70025ed2:	2a58      	cmp	r2, #88	; 0x58
70025ed4:	d00c      	beq.n	70025ef0 <_strtoull_r+0x1b4>
70025ed6:	b1d3      	cbz	r3, 70025f0e <_strtoull_r+0x1d2>
70025ed8:	2208      	movs	r2, #8
70025eda:	2300      	movs	r3, #0
70025edc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
70025ee0:	e9cd 2302 	strd	r2, r3, [sp, #8]
70025ee4:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000
70025ee8:	2207      	movs	r2, #7
70025eea:	f04f 0808 	mov.w	r8, #8
70025eee:	e77e      	b.n	70025dee <_strtoull_r+0xb2>
70025ef0:	f896 a001 	ldrb.w	sl, [r6, #1]
70025ef4:	2010      	movs	r0, #16
70025ef6:	2100      	movs	r1, #0
70025ef8:	220f      	movs	r2, #15
70025efa:	3602      	adds	r6, #2
70025efc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
70025f00:	f06f 4570 	mvn.w	r5, #4026531840	; 0xf0000000
70025f04:	e9cd 0102 	strd	r0, r1, [sp, #8]
70025f08:	f04f 0810 	mov.w	r8, #16
70025f0c:	e76f      	b.n	70025dee <_strtoull_r+0xb2>
70025f0e:	4642      	mov	r2, r8
70025f10:	ea4f 73e8 	mov.w	r3, r8, asr #31
70025f14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
70025f18:	e9cd 2302 	strd	r2, r3, [sp, #8]
70025f1c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
70025f20:	e759      	b.n	70025dd6 <_strtoull_r+0x9a>
70025f22:	bf00      	nop
70025f24:	0000      	movs	r0, r0
	...

70025f28 <___free_r_from_thumb>:
70025f28:	4778      	bx	pc
70025f2a:	46c0      	nop			; (mov r8, r8)
70025f2c:	eaffe333 	b	7001ec00 <_free_r>

70025f30 <__fsym_list_mem>:
70025f30:	70026ab0 70026abc 70009070              .j.p.j.pp..p

70025f3c <__fsym_gic>:
70025f3c:	70026ff8 70026ffc 7000cd88              .o.p.o.p...p

70025f48 <__fsym_hello>:
70025f48:	700273e4 700273ec 7000fc8c              .s.p.s.p...p

70025f54 <__fsym_version>:
70025f54:	700273fc 70027404 7000fcac              .s.p.t.p...p

70025f60 <__fsym___cmd_version>:
70025f60:	70027428 70027438 7000fcac              (t.p8t.p...p

70025f6c <__fsym_list_thread>:
70025f6c:	70027554 70027560 7000fe74              Tu.p`u.pt..p

70025f78 <__fsym___cmd_list_thread>:
70025f78:	7002756c 70027580 7000fe74              lu.p.u.pt..p

70025f84 <__fsym_list_sem>:
70025f84:	70027600 7002760c 70010044              .v.p.v.pD..p

70025f90 <__fsym___cmd_list_sem>:
70025f90:	70027628 70027638 70010044              (v.p8v.pD..p

70025f9c <__fsym_list_event>:
70025f9c:	700276c8 700276d4 70010168              .v.p.v.ph..p

70025fa8 <__fsym___cmd_list_event>:
70025fa8:	700276ec 70027700 70010168              .v.p.w.ph..p

70025fb4 <__fsym_list_mutex>:
70025fb4:	70027780 7002778c 7001024c              .w.p.w.pL..p

70025fc0 <__fsym___cmd_list_mutex>:
70025fc0:	700277a4 700277b8 7001024c              .w.p.w.pL..p

70025fcc <__fsym_list_mailbox>:
70025fcc:	70027848 70027858 700103b8              Hx.pXx.p...p

70025fd8 <__fsym___cmd_list_mailbox>:
70025fd8:	70027870 70027884 700103b8              px.p.x.p...p

70025fe4 <__fsym_list_msgqueue>:
70025fe4:	70027904 70027914 70010504              .y.p.y.p...p

70025ff0 <__fsym___cmd_list_msgqueue>:
70025ff0:	70027934 70027948 70010504              4y.pHy.p...p

70025ffc <__fsym_list_mempool>:
70025ffc:	700279f8 70027a08 70010644              .y.p.z.pD..p

70026008 <__fsym___cmd_list_mempool>:
70026008:	70027a24 70027a38 70010644              $z.p8z.pD..p

70026014 <__fsym_list_timer>:
70026014:	70027af4 70027b00 70010744              .z.p.{.pD..p

70026020 <__fsym___cmd_list_timer>:
70026020:	70027b18 70027b2c 70010744              .{.p,{.pD..p

7002602c <__fsym_list_device>:
7002602c:	70027d08 70027d14 70010854              .}.p.}.pT..p

70026038 <__fsym___cmd_list_device>:
70026038:	70027d2c 70027d40 70010854              ,}.p@}.pT..p

70026044 <__fsym_list>:
70026044:	70027d9c 70027da4 70010874              .}.p.}.pt..p

70026050 <__fsym___cmd_ps>:
70026050:	70027e0c 70027e18 70010fc8              .~.p.~.p...p

7002605c <__fsym___cmd_time>:
7002605c:	70027e34 70027e40 70010ff0              4~.p@~.p...p

70026068 <__fsym___cmd_free>:
70026068:	70027e5c 70027e68 70011018              \~.ph~.p...p

70026074 <__fsym___cmd_exit>:
70026074:	70027e90 70027e9c 70011064              .~.p.~.pd..p

70026080 <__fsym_msh>:
70026080:	70027ebc 70027ec0 7001109c              .~.p.~.p...p

7002608c <__fsym___cmd_help>:
7002608c:	70027f08 70027f14 700110c8              ...p...p...p

70026098 <__fsym_log_level>:
70026098:	7002869c 700286a8 7001f19c              ...p...p...p

700260a4 <__fsym_log_trace>:
700260a4:	700286f8 70028704 7001f864              ...p...pd..p

700260b0 <__fsym_log_flush>:
700260b0:	70028710 7002871c 7001fb28              ...p...p(..p

700260bc <__fsym_log_device>:
700260bc:	70028754 70028760 7001fe44              T..p`..pD..p

700260c8 <__fsymtab_end>:
700260c8:	70027de8 	.word	0x70027de8
700260cc:	70027df0 	.word	0x70027df0
700260d0:	00000009 	.word	0x00000009
700260d4:	7002aa1c 	.word	0x7002aa1c

700260d8 <__rt_init_rti_start>:
700260d8:	700007e0                                ...p

700260dc <__rt_init_rt_hw_timer_init>:
700260dc:	70000168                                h..p

700260e0 <__rt_init_rt_hw_uart_init>:
700260e0:	700005d8                                ...p

700260e4 <__rt_init_rti_board_end>:
700260e4:	700007fc                                ...p

700260e8 <__rt_init_finsh_system_init>:
700260e8:	7000fac8                                ...p

700260ec <__rt_init_libc_system_init>:
700260ec:	7001e63c                                <..p

700260f0 <__rt_init_rti_end>:
700260f0:	70000818                                ...p
